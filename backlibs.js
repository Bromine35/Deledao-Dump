/*
 MIT LICENSE
 Copyright (c) 2007 Monsur Hossain (http://monsur.hossa.in)

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */

// Avoid polluting the global namespace if we're using a module loader
(function () {

  /**
   * Creates a new DLDCache object.
   * @param {number} maxSize The maximum size of the cache (or -1 for no max).
   * @param {boolean} debug Whether to log events to the console.log.
   * @constructor
   */
  function DLDCache(maxSize, debug, storage) {
    this.maxSize_ = maxSize || -1;
    this.debug_ = debug || false;
    this.storage_ = storage || new DLDCache.BasicCacheStorage();

    this.fillFactor_ = .75;

    this.stats_ = {};
    this.stats_['hits'] = 0;
    this.stats_['misses'] = 0;
    this.log_('Initialized cache with size ' + maxSize);
  }

  /**
   * An easier way to refer to the priority of a cache item
   * @enum {number}
   */
  DLDCache.Priority = {
    'LOW': 1,
    'NORMAL': 2,
    'HIGH': 4
  };

  /**
   * Basic in memory cache storage backend.
   * @constructor
   */
  DLDCache.BasicCacheStorage = function () {
    this.items_ = {};
    this.count_ = 0;
  }
  DLDCache.BasicCacheStorage.prototype.get = function (key) {
    return this.items_[key];
  }
  DLDCache.BasicCacheStorage.prototype.set = function (key, value) {
    if (typeof this.get(key) === "undefined")
      this.count_++;
    this.items_[key] = value;
  }
  DLDCache.BasicCacheStorage.prototype.size = function (key, value) {
    return this.count_;
  }
  DLDCache.BasicCacheStorage.prototype.remove = function (key) {
    var item = this.get(key);
    if (typeof item !== "undefined")
      this.count_--;
    delete this.items_[key];
    return item;
  }
  DLDCache.BasicCacheStorage.prototype.keys = function () {
    var ret = [],
      p;
    for (p in this.items_) ret.push(p);
    return ret;
  }

  /**
   * Local Storage based persistant cache storage backend.
   * If a size of -1 is used, it will purge itself when localStorage
   * is filled. This is 5MB on Chrome/Safari.
   * WARNING: The amortized cost of this cache is very low, however,
   * when a the cache fills up all of localStorage, and a purge is required, it can
   * take a few seconds to fetch all the keys and values in storage.
   * Since localStorage doesn't have namespacing, this means that even if this
   * individual cache is small, it can take this time if there are lots of other
   * other keys in localStorage.
   *
   * @param {string} namespace A string to namespace the items in localStorage. Defaults to 'default'.
   * @constructor
   */
  DLDCache.LocalStorageCacheStorage = function (namespace, ls) {
    this.prefix_ = 'cache-storage.' + (namespace || 'default') + '.';
    // Regexp String Escaping from http://simonwillison.net/2006/Jan/20/escape/#p-6
    var escapedPrefix = this.prefix_.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    this.regexp_ = new RegExp('^' + escapedPrefix);
    this.ls = ls || window.localStorage;
  }
  DLDCache.LocalStorageCacheStorage.prototype.get = function (key) {
    var item = this.ls[this.prefix_ + key];
    if (item) return JSON.parse(item);
    return null;
  }
  DLDCache.LocalStorageCacheStorage.prototype.set = function (key, value) {
    this.ls[this.prefix_ + key] = JSON.stringify(value);
  }
  DLDCache.LocalStorageCacheStorage.prototype.size = function (key, value) {
    return this.ls.length;
  }
  DLDCache.LocalStorageCacheStorage.prototype.remove = function (key) {
    var item = this.get(key);
    delete this.ls[this.prefix_ + key];
    return item;
  }
  DLDCache.LocalStorageCacheStorage.prototype.keys = function () {
    var ret = [],
      p;
    for (let i = 0; i < this.ls.length; i++) {
      p = this.ls.key(i);
      if (p.match(this.regexp_)) ret.push(p.replace(this.prefix_, ''));
    };
    return ret;
  }

  /**
   * Retrieves an item from the cache.
   * @param {string} key The key to retrieve.
   * @return {Object} The item, or null if it doesn't exist.
   */
  DLDCache.prototype.getItem = function (key) {

    // retrieve the item from the cache
    var item = this.storage_.get(key);

    if (item != null) {
      if (!this.isExpired_(item)) {
        // if the item is not expired
        // update its last accessed date
        item.lastAccessed = new Date().getTime();
      } else {
        // if the item is expired, remove it from the cache
        this.removeItem(key);
        item = null;
      }
    }

    // return the item value (if it exists), or null
    var returnVal = item ? item.value : null;
    if (returnVal) {
      this.stats_['hits']++;
      this.log_('Cache HIT for key ' + key)
    } else {
      this.stats_['misses']++;
      this.log_('Cache MISS for key ' + key)
    }
    return returnVal;
  };


  DLDCache._CacheItem = function (k, v, o) {
    if (!k) {
      throw new Error("key cannot be null or empty");
    }
    this.key = k;
    this.value = v;
    o = o || {};
    if (o.expirationAbsolute) {
      o.expirationAbsolute = o.expirationAbsolute.getTime();
    }
    if (!o.priority) {
      o.priority = DLDCache.Priority.NORMAL;
    }
    this.options = o;
    this.lastAccessed = new Date().getTime();
  };


  /**
   * Sets an item in the cache.
   * @param {string} key The key to refer to the item.
   * @param {Object} value The item to cache.
   * @param {Object} options an optional object which controls various caching
   *    options:
   *      expirationAbsolute: the datetime when the item should expire
   *      expirationSliding: an integer representing the seconds since
   *                         the last cache access after which the item
   *                         should expire
   *      priority: How important it is to leave this item in the cache.
   *                You can use the values Cache.Priority.LOW, .NORMAL, or
   *                .HIGH, or you can just use an integer.  Note that
   *                placing a priority on an item does not guarantee
   *                it will remain in cache.  It can still be purged if
   *                an expiration is hit, or if the cache is full.
   *      callback: A function that gets called when the item is purged
   *                from cache.  The key and value of the removed item
   *                are passed as parameters to the callback function.
   */
  DLDCache.prototype.setItem = function (key, value, options) {

    // add a new cache item to the cache
    if (this.storage_.get(key) != null) {
      this.removeItem(key);
    }
    this.addItem_(new DLDCache._CacheItem(key, value, options));
    this.log_("Setting key " + key);

    // if the cache is full, purge it
    if ((this.maxSize_ > 0) && (this.size() > this.maxSize_)) {
      var that = this;
      setTimeout(function () {
        that.purge_.call(that);
      }, 0);
    }
  };


  /**
   * Removes all items from the cache.
   */
  DLDCache.prototype.clear = function () {
    // loop through each item in the cache and remove it
    var keys = this.storage_.keys()
    for (var i = 0; i < keys.length; i++) {
      this.removeItem(keys[i]);
    }
    this.log_('Cache cleared');
  };


  /**
   * @return {Object} The hits and misses on the cache.
   */
  DLDCache.prototype.getStats = function () {
    return this.stats_;
  };


  /**
   * @return {string} Returns an HTML string representation of the cache.
   */
  DLDCache.prototype.toHtmlString = function () {
    var returnStr = this.size() + " item(s) in cache<br /><ul>";
    var keys = this.storage_.keys()
    for (var i = 0; i < keys.length; i++) {
      var item = this.storage_.get(keys[i]);
      returnStr = returnStr + "<li>" + item.key.toString() + " = " +
        item.value.toString() + "</li>";
    }
    returnStr = returnStr + "</ul>";
    return returnStr;
  };


  /**
   * Allows it to resize the Cache capacity if needed.
   * @param    {integer} newMaxSize the new max amount of stored entries within the Cache
   */
  DLDCache.prototype.resize = function (newMaxSize) {
    this.log_('Resizing Cache from ' + this.maxSize_ + ' to ' + newMaxSize);
    // Set new size before purging so we know how many items to purge
    var oldMaxSize = this.maxSize_
    this.maxSize_ = newMaxSize;

    if (newMaxSize > 0 && (oldMaxSize < 0 || newMaxSize < oldMaxSize)) {
      if (this.size() > newMaxSize) {
        // Cache needs to be purged as it does contain too much entries for the new size
        this.purge_();
      } // else if cache isn't filled up to the new limit nothing is to do
    }
    // else if newMaxSize >= maxSize nothing to do
    this.log_('Resizing done');
  }

  /**
   * Removes expired items from the cache.
   */
  DLDCache.prototype.purge_ = function () {
    var tmparray = new Array();
    var purgeSize = Math.round(this.maxSize_ * this.fillFactor_);
    if (this.maxSize_ < 0)
      purgeSize = this.size() * this.fillFactor_;
    // loop through the cache, expire items that should be expired
    // otherwise, add the item to an array
    var keys = this.storage_.keys();
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var item = this.storage_.get(key);
      if (this.isExpired_(item)) {
        this.removeItem(key);
      } else {
        tmparray.push(item);
      }
    }

    if (tmparray.length > purgeSize) {
      // sort this array based on cache priority and the last accessed date
      tmparray = tmparray.sort(function (a, b) {
        if (a.options.priority != b.options.priority) {
          return b.options.priority - a.options.priority;
        } else {
          return b.lastAccessed - a.lastAccessed;
        }
      });
      // remove items from the end of the array
      while (tmparray.length > purgeSize) {
        var ritem = tmparray.pop();
        this.removeItem(ritem.key);
      }
    }
    this.log_('Purged cached');
  };


  /**
   * Add an item to the cache.
   * @param {Object} item The cache item to add.
   * @private
   */
  DLDCache.prototype.addItem_ = function (item, attemptedAlready) {
    //var cache = this;
    try {
      this.storage_.set(item.key, item);
    } catch (err) {
      if (attemptedAlready) {
        this.log_('Failed setting again, giving up: ' + err.toString());
        throw (err);
      }
      this.log_('Error adding item, purging and trying again: ' + err.toString());
      this.purge_();
      this.addItem_(item, true);
    }
  };


  /**
   * Remove an item from the cache, call the callback function (if it exists).
   * @param {String} key The key of the item to remove
   */
  DLDCache.prototype.removeItem = function (key) {
    var item = this.storage_.remove(key);
    this.log_("removed key " + key);

    // if there is a callback function, call it at the end of execution
    if (item && item.options && item.options.callback) {
      setTimeout(function () {
        item.options.callback.call(null, item.key, item.value);
      }, 0);
    }
    return item ? item.value : null;
  };

  /**
   * Scan through each item in the cache and remove that item if it passes the
   * supplied test.
   * @param {Function} test   A test to determine if the given item should be removed.
   *                            The item will be removed if test(key, value) returns true.
   */
  DLDCache.prototype.removeWhere = function (test) {
    // Get a copy of the keys array - it won't be modified when we remove items from storage
    var keys = this.storage_.keys();
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var item = this.storage_.get(key);
      if (test(key, item.value) === true) {
        this.removeItem(key);
      }
    }
  };

  DLDCache.prototype.size = function () {
    return this.storage_.size();
  }


  /**
   * @param {Object} item A cache item.
   * @return {boolean} True if the item is expired
   * @private
   */
  DLDCache.prototype.isExpired_ = function (item) {
    var now = new Date().getTime();
    var expired = false;
    if (item.options.expirationAbsolute &&
      (item.options.expirationAbsolute < now)) {
      // if the absolute expiration has passed, expire the item
      expired = true;
    }
    if (!expired && item.options.expirationSliding) {
      // if the sliding expiration has passed, expire the item
      var lastAccess =
        item.lastAccessed + (item.options.expirationSliding * 1000);
      if (lastAccess < now) {
        expired = true;
      }
    }
    return expired;
  };


  /**
   * Logs a message to the console.log if debug is set to true.
   * @param {string} msg The message to log.
   * @private
   */
  DLDCache.prototype.log_ = function (msg) {
    if (this.debug_) {
      console.log(msg);
    }
  };

  // Establish the root object, `window` in the browser, or `global` on the server.
  window.DLDCache = DLDCache;
  /*
    var root = this;

    if (typeof module !== "undefined" && module.exports) {
        module.exports = DLDCache;
    } else if (typeof define == "function" && define.amd) {
        define(function () {
            return DLDCache;
        });
    } else {
        root.DLDCache = DLDCache;
    }
*/
  /*  
    if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = DLDCache;
    else if ("function" == typeof define && define.amd)
        define([], DLDCache);
    else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).dldc = DLDCache
    }
*/
})();
! function (a) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = a() : "function" == typeof define && define.amd ? define([], a) : ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).psl = a()
}(function () {
  return function e(s, n, t) {
    function m(o, a) {
      if (!n[o]) {
        if (!s[o]) {
          var i = "function" == typeof require && require;
          if (!a && i) return i(o, !0);
          if (u) return u(o, !0);
          throw (a = new Error("Cannot find module '" + o + "'")).code = "MODULE_NOT_FOUND", a
        }
        i = n[o] = {
          exports: {}
        }, s[o][0].call(i.exports, function (a) {
          return m(s[o][1][a] || a)
        }, i, i.exports, e, s, n, t)
      }
      return n[o].exports
    }
    for (var u = "function" == typeof require && require, a = 0; a < t.length; a++) m(t[a]);
    return m
  }({
    1: [function (a, o, i) {
      o.exports = ["ac", "com.ac", "edu.ac", "gov.ac", "net.ac", "mil.ac", "org.ac", "ad", "nom.ad", "ae", "co.ae", "net.ae", "org.ae", "sch.ae", "ac.ae", "gov.ae", "mil.ae", "aero", "accident-investigation.aero", "accident-prevention.aero", "aerobatic.aero", "aeroclub.aero", "aerodrome.aero", "agents.aero", "aircraft.aero", "airline.aero", "airport.aero", "air-surveillance.aero", "airtraffic.aero", "air-traffic-control.aero", "ambulance.aero", "amusement.aero", "association.aero", "author.aero", "ballooning.aero", "broker.aero", "caa.aero", "cargo.aero", "catering.aero", "certification.aero", "championship.aero", "charter.aero", "civilaviation.aero", "club.aero", "conference.aero", "consultant.aero", "consulting.aero", "control.aero", "council.aero", "crew.aero", "design.aero", "dgca.aero", "educator.aero", "emergency.aero", "engine.aero", "engineer.aero", "entertainment.aero", "equipment.aero", "exchange.aero", "express.aero", "federation.aero", "flight.aero", "fuel.aero", "gliding.aero", "government.aero", "groundhandling.aero", "group.aero", "hanggliding.aero", "homebuilt.aero", "insurance.aero", "journal.aero", "journalist.aero", "leasing.aero", "logistics.aero", "magazine.aero", "maintenance.aero", "media.aero", "microlight.aero", "modelling.aero", "navigation.aero", "parachuting.aero", "paragliding.aero", "passenger-association.aero", "pilot.aero", "press.aero", "production.aero", "recreation.aero", "repbody.aero", "res.aero", "research.aero", "rotorcraft.aero", "safety.aero", "scientist.aero", "services.aero", "show.aero", "skydiving.aero", "software.aero", "student.aero", "trader.aero", "trading.aero", "trainer.aero", "union.aero", "workinggroup.aero", "works.aero", "af", "gov.af", "com.af", "org.af", "net.af", "edu.af", "ag", "com.ag", "org.ag", "net.ag", "co.ag", "nom.ag", "ai", "off.ai", "com.ai", "net.ai", "org.ai", "al", "com.al", "edu.al", "gov.al", "mil.al", "net.al", "org.al", "am", "co.am", "com.am", "commune.am", "net.am", "org.am", "ao", "ed.ao", "gv.ao", "og.ao", "co.ao", "pb.ao", "it.ao", "aq", "ar", "bet.ar", "com.ar", "coop.ar", "edu.ar", "gob.ar", "gov.ar", "int.ar", "mil.ar", "musica.ar", "mutual.ar", "net.ar", "org.ar", "senasa.ar", "tur.ar", "arpa", "e164.arpa", "in-addr.arpa", "ip6.arpa", "iris.arpa", "uri.arpa", "urn.arpa", "as", "gov.as", "asia", "at", "ac.at", "co.at", "gv.at", "or.at", "sth.ac.at", "au", "com.au", "net.au", "org.au", "edu.au", "gov.au", "asn.au", "id.au", "info.au", "conf.au", "oz.au", "act.au", "nsw.au", "nt.au", "qld.au", "sa.au", "tas.au", "vic.au", "wa.au", "act.edu.au", "catholic.edu.au", "nsw.edu.au", "nt.edu.au", "qld.edu.au", "sa.edu.au", "tas.edu.au", "vic.edu.au", "wa.edu.au", "qld.gov.au", "sa.gov.au", "tas.gov.au", "vic.gov.au", "wa.gov.au", "schools.nsw.edu.au", "aw", "com.aw", "ax", "az", "com.az", "net.az", "int.az", "gov.az", "org.az", "edu.az", "info.az", "pp.az", "mil.az", "name.az", "pro.az", "biz.az", "ba", "com.ba", "edu.ba", "gov.ba", "mil.ba", "net.ba", "org.ba", "bb", "biz.bb", "co.bb", "com.bb", "edu.bb", "gov.bb", "info.bb", "net.bb", "org.bb", "store.bb", "tv.bb", "*.bd", "be", "ac.be", "bf", "gov.bf", "bg", "a.bg", "b.bg", "c.bg", "d.bg", "e.bg", "f.bg", "g.bg", "h.bg", "i.bg", "j.bg", "k.bg", "l.bg", "m.bg", "n.bg", "o.bg", "p.bg", "q.bg", "r.bg", "s.bg", "t.bg", "u.bg", "v.bg", "w.bg", "x.bg", "y.bg", "z.bg", "0.bg", "1.bg", "2.bg", "3.bg", "4.bg", "5.bg", "6.bg", "7.bg", "8.bg", "9.bg", "bh", "com.bh", "edu.bh", "net.bh", "org.bh", "gov.bh", "bi", "co.bi", "com.bi", "edu.bi", "or.bi", "org.bi", "biz", "bj", "asso.bj", "barreau.bj", "gouv.bj", "bm", "com.bm", "edu.bm", "gov.bm", "net.bm", "org.bm", "bn", "com.bn", "edu.bn", "gov.bn", "net.bn", "org.bn", "bo", "com.bo", "edu.bo", "gob.bo", "int.bo", "org.bo", "net.bo", "mil.bo", "tv.bo", "web.bo", "academia.bo", "agro.bo", "arte.bo", "blog.bo", "bolivia.bo", "ciencia.bo", "cooperativa.bo", "democracia.bo", "deporte.bo", "ecologia.bo", "economia.bo", "empresa.bo", "indigena.bo", "industria.bo", "info.bo", "medicina.bo", "movimiento.bo", "musica.bo", "natural.bo", "nombre.bo", "noticias.bo", "patria.bo", "politica.bo", "profesional.bo", "plurinacional.bo", "pueblo.bo", "revista.bo", "salud.bo", "tecnologia.bo", "tksat.bo", "transporte.bo", "wiki.bo", "br", "9guacu.br", "abc.br", "adm.br", "adv.br", "agr.br", "aju.br", "am.br", "anani.br", "aparecida.br", "app.br", "arq.br", "art.br", "ato.br", "b.br", "barueri.br", "belem.br", "bhz.br", "bib.br", "bio.br", "blog.br", "bmd.br", "boavista.br", "bsb.br", "campinagrande.br", "campinas.br", "caxias.br", "cim.br", "cng.br", "cnt.br", "com.br", "contagem.br", "coop.br", "coz.br", "cri.br", "cuiaba.br", "curitiba.br", "def.br", "des.br", "det.br", "dev.br", "ecn.br", "eco.br", "edu.br", "emp.br", "enf.br", "eng.br", "esp.br", "etc.br", "eti.br", "far.br", "feira.br", "flog.br", "floripa.br", "fm.br", "fnd.br", "fortal.br", "fot.br", "foz.br", "fst.br", "g12.br", "geo.br", "ggf.br", "goiania.br", "gov.br", "ac.gov.br", "al.gov.br", "am.gov.br", "ap.gov.br", "ba.gov.br", "ce.gov.br", "df.gov.br", "es.gov.br", "go.gov.br", "ma.gov.br", "mg.gov.br", "ms.gov.br", "mt.gov.br", "pa.gov.br", "pb.gov.br", "pe.gov.br", "pi.gov.br", "pr.gov.br", "rj.gov.br", "rn.gov.br", "ro.gov.br", "rr.gov.br", "rs.gov.br", "sc.gov.br", "se.gov.br", "sp.gov.br", "to.gov.br", "gru.br", "imb.br", "ind.br", "inf.br", "jab.br", "jampa.br", "jdf.br", "joinville.br", "jor.br", "jus.br", "leg.br", "lel.br", "log.br", "londrina.br", "macapa.br", "maceio.br", "manaus.br", "maringa.br", "mat.br", "med.br", "mil.br", "morena.br", "mp.br", "mus.br", "natal.br", "net.br", "niteroi.br", "*.nom.br", "not.br", "ntr.br", "odo.br", "ong.br", "org.br", "osasco.br", "palmas.br", "poa.br", "ppg.br", "pro.br", "psc.br", "psi.br", "pvh.br", "qsl.br", "radio.br", "rec.br", "recife.br", "rep.br", "ribeirao.br", "rio.br", "riobranco.br", "riopreto.br", "salvador.br", "sampa.br", "santamaria.br", "santoandre.br", "saobernardo.br", "saogonca.br", "seg.br", "sjc.br", "slg.br", "slz.br", "sorocaba.br", "srv.br", "taxi.br", "tc.br", "tec.br", "teo.br", "the.br", "tmp.br", "trd.br", "tur.br", "tv.br", "udi.br", "vet.br", "vix.br", "vlog.br", "wiki.br", "zlg.br", "bs", "com.bs", "net.bs", "org.bs", "edu.bs", "gov.bs", "bt", "com.bt", "edu.bt", "gov.bt", "net.bt", "org.bt", "bv", "bw", "co.bw", "org.bw", "by", "gov.by", "mil.by", "com.by", "of.by", "bz", "com.bz", "net.bz", "org.bz", "edu.bz", "gov.bz", "ca", "ab.ca", "bc.ca", "mb.ca", "nb.ca", "nf.ca", "nl.ca", "ns.ca", "nt.ca", "nu.ca", "on.ca", "pe.ca", "qc.ca", "sk.ca", "yk.ca", "gc.ca", "cat", "cc", "cd", "gov.cd", "cf", "cg", "ch", "ci", "org.ci", "or.ci", "com.ci", "co.ci", "edu.ci", "ed.ci", "ac.ci", "net.ci", "go.ci", "asso.ci", "aéroport.ci", "int.ci", "presse.ci", "md.ci", "gouv.ci", "*.ck", "!www.ck", "cl", "co.cl", "gob.cl", "gov.cl", "mil.cl", "cm", "co.cm", "com.cm", "gov.cm", "net.cm", "cn", "ac.cn", "com.cn", "edu.cn", "gov.cn", "net.cn", "org.cn", "mil.cn", "公司.cn", "网络.cn", "網絡.cn", "ah.cn", "bj.cn", "cq.cn", "fj.cn", "gd.cn", "gs.cn", "gz.cn", "gx.cn", "ha.cn", "hb.cn", "he.cn", "hi.cn", "hl.cn", "hn.cn", "jl.cn", "js.cn", "jx.cn", "ln.cn", "nm.cn", "nx.cn", "qh.cn", "sc.cn", "sd.cn", "sh.cn", "sn.cn", "sx.cn", "tj.cn", "xj.cn", "xz.cn", "yn.cn", "zj.cn", "hk.cn", "mo.cn", "tw.cn", "co", "arts.co", "com.co", "edu.co", "firm.co", "gov.co", "info.co", "int.co", "mil.co", "net.co", "nom.co", "org.co", "rec.co", "web.co", "com", "coop", "cr", "ac.cr", "co.cr", "ed.cr", "fi.cr", "go.cr", "or.cr", "sa.cr", "cu", "com.cu", "edu.cu", "org.cu", "net.cu", "gov.cu", "inf.cu", "cv", "com.cv", "edu.cv", "int.cv", "nome.cv", "org.cv", "cw", "com.cw", "edu.cw", "net.cw", "org.cw", "cx", "gov.cx", "cy", "ac.cy", "biz.cy", "com.cy", "ekloges.cy", "gov.cy", "ltd.cy", "mil.cy", "net.cy", "org.cy", "press.cy", "pro.cy", "tm.cy", "cz", "de", "dj", "dk", "dm", "com.dm", "net.dm", "org.dm", "edu.dm", "gov.dm", "do", "art.do", "com.do", "edu.do", "gob.do", "gov.do", "mil.do", "net.do", "org.do", "sld.do", "web.do", "dz", "art.dz", "asso.dz", "com.dz", "edu.dz", "gov.dz", "org.dz", "net.dz", "pol.dz", "soc.dz", "tm.dz", "ec", "com.ec", "info.ec", "net.ec", "fin.ec", "k12.ec", "med.ec", "pro.ec", "org.ec", "edu.ec", "gov.ec", "gob.ec", "mil.ec", "edu", "ee", "edu.ee", "gov.ee", "riik.ee", "lib.ee", "med.ee", "com.ee", "pri.ee", "aip.ee", "org.ee", "fie.ee", "eg", "com.eg", "edu.eg", "eun.eg", "gov.eg", "mil.eg", "name.eg", "net.eg", "org.eg", "sci.eg", "*.er", "es", "com.es", "nom.es", "org.es", "gob.es", "edu.es", "et", "com.et", "gov.et", "org.et", "edu.et", "biz.et", "name.et", "info.et", "net.et", "eu", "fi", "aland.fi", "fj", "ac.fj", "biz.fj", "com.fj", "gov.fj", "info.fj", "mil.fj", "name.fj", "net.fj", "org.fj", "pro.fj", "*.fk", "com.fm", "edu.fm", "net.fm", "org.fm", "fm", "fo", "fr", "asso.fr", "com.fr", "gouv.fr", "nom.fr", "prd.fr", "tm.fr", "aeroport.fr", "avocat.fr", "avoues.fr", "cci.fr", "chambagri.fr", "chirurgiens-dentistes.fr", "experts-comptables.fr", "geometre-expert.fr", "greta.fr", "huissier-justice.fr", "medecin.fr", "notaires.fr", "pharmacien.fr", "port.fr", "veterinaire.fr", "ga", "gb", "edu.gd", "gov.gd", "gd", "ge", "com.ge", "edu.ge", "gov.ge", "org.ge", "mil.ge", "net.ge", "pvt.ge", "gf", "gg", "co.gg", "net.gg", "org.gg", "gh", "com.gh", "edu.gh", "gov.gh", "org.gh", "mil.gh", "gi", "com.gi", "ltd.gi", "gov.gi", "mod.gi", "edu.gi", "org.gi", "gl", "co.gl", "com.gl", "edu.gl", "net.gl", "org.gl", "gm", "gn", "ac.gn", "com.gn", "edu.gn", "gov.gn", "org.gn", "net.gn", "gov", "gp", "com.gp", "net.gp", "mobi.gp", "edu.gp", "org.gp", "asso.gp", "gq", "gr", "com.gr", "edu.gr", "net.gr", "org.gr", "gov.gr", "gs", "gt", "com.gt", "edu.gt", "gob.gt", "ind.gt", "mil.gt", "net.gt", "org.gt", "gu", "com.gu", "edu.gu", "gov.gu", "guam.gu", "info.gu", "net.gu", "org.gu", "web.gu", "gw", "gy", "co.gy", "com.gy", "edu.gy", "gov.gy", "net.gy", "org.gy", "hk", "com.hk", "edu.hk", "gov.hk", "idv.hk", "net.hk", "org.hk", "公司.hk", "教育.hk", "敎育.hk", "政府.hk", "個人.hk", "个��.hk", "箇人.hk", "網络.hk", "网络.hk", "组織.hk", "網絡.hk", "网絡.hk", "组织.hk", "組織.hk", "組织.hk", "hm", "hn", "com.hn", "edu.hn", "org.hn", "net.hn", "mil.hn", "gob.hn", "hr", "iz.hr", "from.hr", "name.hr", "com.hr", "ht", "com.ht", "shop.ht", "firm.ht", "info.ht", "adult.ht", "net.ht", "pro.ht", "org.ht", "med.ht", "art.ht", "coop.ht", "pol.ht", "asso.ht", "edu.ht", "rel.ht", "gouv.ht", "perso.ht", "hu", "co.hu", "info.hu", "org.hu", "priv.hu", "sport.hu", "tm.hu", "2000.hu", "agrar.hu", "bolt.hu", "casino.hu", "city.hu", "erotica.hu", "erotika.hu", "film.hu", "forum.hu", "games.hu", "hotel.hu", "ingatlan.hu", "jogasz.hu", "konyvelo.hu", "lakas.hu", "media.hu", "news.hu", "reklam.hu", "sex.hu", "shop.hu", "suli.hu", "szex.hu", "tozsde.hu", "utazas.hu", "video.hu", "id", "ac.id", "biz.id", "co.id", "desa.id", "go.id", "mil.id", "my.id", "net.id", "or.id", "ponpes.id", "sch.id", "web.id", "ie", "gov.ie", "il", "ac.il", "co.il", "gov.il", "idf.il", "k12.il", "muni.il", "net.il", "org.il", "im", "ac.im", "co.im", "com.im", "ltd.co.im", "net.im", "org.im", "plc.co.im", "tt.im", "tv.im", "in", "co.in", "firm.in", "net.in", "org.in", "gen.in", "ind.in", "nic.in", "ac.in", "edu.in", "res.in", "gov.in", "mil.in", "info", "int", "eu.int", "io", "com.io", "iq", "gov.iq", "edu.iq", "mil.iq", "com.iq", "org.iq", "net.iq", "ir", "ac.ir", "co.ir", "gov.ir", "id.ir", "net.ir", "org.ir", "sch.ir", "ایران.ir", "ايران.ir", "is", "net.is", "com.is", "edu.is", "gov.is", "org.is", "int.is", "it", "gov.it", "edu.it", "abr.it", "abruzzo.it", "aosta-valley.it", "aostavalley.it", "bas.it", "basilicata.it", "cal.it", "calabria.it", "cam.it", "campania.it", "emilia-romagna.it", "emiliaromagna.it", "emr.it", "friuli-v-giulia.it", "friuli-ve-giulia.it", "friuli-vegiulia.it", "friuli-venezia-giulia.it", "friuli-veneziagiulia.it", "friuli-vgiulia.it", "friuliv-giulia.it", "friulive-giulia.it", "friulivegiulia.it", "friulivenezia-giulia.it", "friuliveneziagiulia.it", "friulivgiulia.it", "fvg.it", "laz.it", "lazio.it", "lig.it", "liguria.it", "lom.it", "lombardia.it", "lombardy.it", "lucania.it", "mar.it", "marche.it", "mol.it", "molise.it", "piedmont.it", "piemonte.it", "pmn.it", "pug.it", "puglia.it", "sar.it", "sardegna.it", "sardinia.it", "sic.it", "sicilia.it", "sicily.it", "taa.it", "tos.it", "toscana.it", "trentin-sud-tirol.it", "trentin-süd-tirol.it", "trentin-sudtirol.it", "trentin-südtirol.it", "trentin-sued-tirol.it", "trentin-suedtirol.it", "trentino-a-adige.it", "trentino-aadige.it", "trentino-alto-adige.it", "trentino-altoadige.it", "trentino-s-tirol.it", "trentino-stirol.it", "trentino-sud-tirol.it", "trentino-süd-tirol.it", "trentino-sudtirol.it", "trentino-südtirol.it", "trentino-sued-tirol.it", "trentino-suedtirol.it", "trentino.it", "trentinoa-adige.it", "trentinoaadige.it", "trentinoalto-adige.it", "trentinoaltoadige.it", "trentinos-tirol.it", "trentinostirol.it", "trentinosud-tirol.it", "trentinosüd-tirol.it", "trentinosudtirol.it", "trentinosüdtirol.it", "trentinosued-tirol.it", "trentinosuedtirol.it", "trentinsud-tirol.it", "trentinsüd-tirol.it", "trentinsudtirol.it", "trentinsüdtirol.it", "trentinsued-tirol.it", "trentinsuedtirol.it", "tuscany.it", "umb.it", "umbria.it", "val-d-aosta.it", "val-daosta.it", "vald-aosta.it", "valdaosta.it", "valle-aosta.it", "valle-d-aosta.it", "valle-daosta.it", "valleaosta.it", "valled-aosta.it", "valledaosta.it", "vallee-aoste.it", "vallée-aoste.it", "vallee-d-aoste.it", "vallée-d-aoste.it", "valleeaoste.it", "valléeaoste.it", "valleedaoste.it", "valléedaoste.it", "vao.it", "vda.it", "ven.it", "veneto.it", "ag.it", "agrigento.it", "al.it", "alessandria.it", "alto-adige.it", "altoadige.it", "an.it", "ancona.it", "andria-barletta-trani.it", "andria-trani-barletta.it", "andriabarlettatrani.it", "andriatranibarletta.it", "ao.it", "aosta.it", "aoste.it", "ap.it", "aq.it", "aquila.it", "ar.it", "arezzo.it", "ascoli-piceno.it", "ascolipiceno.it", "asti.it", "at.it", "av.it", "avellino.it", "ba.it", "balsan-sudtirol.it", "balsan-südtirol.it", "balsan-suedtirol.it", "balsan.it", "bari.it", "barletta-trani-andria.it", "barlettatraniandria.it", "belluno.it", "benevento.it", "bergamo.it", "bg.it", "bi.it", "biella.it", "bl.it", "bn.it", "bo.it", "bologna.it", "bolzano-altoadige.it", "bolzano.it", "bozen-sudtirol.it", "bozen-südtirol.it", "bozen-suedtirol.it", "bozen.it", "br.it", "brescia.it", "brindisi.it", "bs.it", "bt.it", "bulsan-sudtirol.it", "bulsan-südtirol.it", "bulsan-suedtirol.it", "bulsan.it", "bz.it", "ca.it", "cagliari.it", "caltanissetta.it", "campidano-medio.it", "campidanomedio.it", "campobasso.it", "carbonia-iglesias.it", "carboniaiglesias.it", "carrara-massa.it", "carraramassa.it", "caserta.it", "catania.it", "catanzaro.it", "cb.it", "ce.it", "cesena-forli.it", "cesena-forlì.it", "cesenaforli.it", "cesenaforlì.it", "ch.it", "chieti.it", "ci.it", "cl.it", "cn.it", "co.it", "como.it", "cosenza.it", "cr.it", "cremona.it", "crotone.it", "cs.it", "ct.it", "cuneo.it", "cz.it", "dell-ogliastra.it", "dellogliastra.it", "en.it", "enna.it", "fc.it", "fe.it", "fermo.it", "ferrara.it", "fg.it", "fi.it", "firenze.it", "florence.it", "fm.it", "foggia.it", "forli-cesena.it", "forlì-cesena.it", "forlicesena.it", "forlìcesena.it", "fr.it", "frosinone.it", "ge.it", "genoa.it", "genova.it", "go.it", "gorizia.it", "gr.it", "grosseto.it", "iglesias-carbonia.it", "iglesiascarbonia.it", "im.it", "imperia.it", "is.it", "isernia.it", "kr.it", "la-spezia.it", "laquila.it", "laspezia.it", "latina.it", "lc.it", "le.it", "lecce.it", "lecco.it", "li.it", "livorno.it", "lo.it", "lodi.it", "lt.it", "lu.it", "lucca.it", "macerata.it", "mantova.it", "massa-carrara.it", "massacarrara.it", "matera.it", "mb.it", "mc.it", "me.it", "medio-campidano.it", "mediocampidano.it", "messina.it", "mi.it", "milan.it", "milano.it", "mn.it", "mo.it", "modena.it", "monza-brianza.it", "monza-e-della-brianza.it", "monza.it", "monzabrianza.it", "monzaebrianza.it", "monzaedellabrianza.it", "ms.it", "mt.it", "na.it", "naples.it", "napoli.it", "no.it", "novara.it", "nu.it", "nuoro.it", "og.it", "ogliastra.it", "olbia-tempio.it", "olbiatempio.it", "or.it", "oristano.it", "ot.it", "pa.it", "padova.it", "padua.it", "palermo.it", "parma.it", "pavia.it", "pc.it", "pd.it", "pe.it", "perugia.it", "pesaro-urbino.it", "pesarourbino.it", "pescara.it", "pg.it", "pi.it", "piacenza.it", "pisa.it", "pistoia.it", "pn.it", "po.it", "pordenone.it", "potenza.it", "pr.it", "prato.it", "pt.it", "pu.it", "pv.it", "pz.it", "ra.it", "ragusa.it", "ravenna.it", "rc.it", "re.it", "reggio-calabria.it", "reggio-emilia.it", "reggiocalabria.it", "reggioemilia.it", "rg.it", "ri.it", "rieti.it", "rimini.it", "rm.it", "rn.it", "ro.it", "roma.it", "rome.it", "rovigo.it", "sa.it", "salerno.it", "sassari.it", "savona.it", "si.it", "siena.it", "siracusa.it", "so.it", "sondrio.it", "sp.it", "sr.it", "ss.it", "suedtirol.it", "südtirol.it", "sv.it", "ta.it", "taranto.it", "te.it", "tempio-olbia.it", "tempioolbia.it", "teramo.it", "terni.it", "tn.it", "to.it", "torino.it", "tp.it", "tr.it", "trani-andria-barletta.it", "trani-barletta-andria.it", "traniandriabarletta.it", "tranibarlettaandria.it", "trapani.it", "trento.it", "treviso.it", "trieste.it", "ts.it", "turin.it", "tv.it", "ud.it", "udine.it", "urbino-pesaro.it", "urbinopesaro.it", "va.it", "varese.it", "vb.it", "vc.it", "ve.it", "venezia.it", "venice.it", "verbania.it", "vercelli.it", "verona.it", "vi.it", "vibo-valentia.it", "vibovalentia.it", "vicenza.it", "viterbo.it", "vr.it", "vs.it", "vt.it", "vv.it", "je", "co.je", "net.je", "org.je", "*.jm", "jo", "com.jo", "org.jo", "net.jo", "edu.jo", "sch.jo", "gov.jo", "mil.jo", "name.jo", "jobs", "jp", "ac.jp", "ad.jp", "co.jp", "ed.jp", "go.jp", "gr.jp", "lg.jp", "ne.jp", "or.jp", "aichi.jp", "akita.jp", "aomori.jp", "chiba.jp", "ehime.jp", "fukui.jp", "fukuoka.jp", "fukushima.jp", "gifu.jp", "gunma.jp", "hiroshima.jp", "hokkaido.jp", "hyogo.jp", "ibaraki.jp", "ishikawa.jp", "iwate.jp", "kagawa.jp", "kagoshima.jp", "kanagawa.jp", "kochi.jp", "kumamoto.jp", "kyoto.jp", "mie.jp", "miyagi.jp", "miyazaki.jp", "nagano.jp", "nagasaki.jp", "nara.jp", "niigata.jp", "oita.jp", "okayama.jp", "okinawa.jp", "osaka.jp", "saga.jp", "saitama.jp", "shiga.jp", "shimane.jp", "shizuoka.jp", "tochigi.jp", "tokushima.jp", "tokyo.jp", "tottori.jp", "toyama.jp", "wakayama.jp", "yamagata.jp", "yamaguchi.jp", "yamanashi.jp", "栃木.jp", "愛知.jp", "愛媛.jp", "兵庫.jp", "熊本.jp", "茨城.jp", "北海道.jp", "千葉.jp", "和歌山.jp", "長崎.jp", "長野.jp", "新潟.jp", "青森.jp", "静岡.jp", "東京.jp", "石川.jp", "埼玉.jp", "三重.jp", "京都.jp", "佐賀.jp", "大分.jp", "大阪.jp", "奈良.jp", "宮城.jp", "宮崎.jp", "富山.jp", "山口.jp", "山形.jp", "山梨.jp", "岩手.jp", "岐阜.jp", "岡山.jp", "島根.jp", "広島.jp", "徳島.jp", "沖縄.jp", "滋賀.jp", "神奈川.jp", "福井.jp", "福岡.jp", "福島.jp", "秋田.jp", "群馬.jp", "香川.jp", "高知.jp", "鳥取.jp", "鹿児島.jp", "*.kawasaki.jp", "*.kitakyushu.jp", "*.kobe.jp", "*.nagoya.jp", "*.sapporo.jp", "*.sendai.jp", "*.yokohama.jp", "!city.kawasaki.jp", "!city.kitakyushu.jp", "!city.kobe.jp", "!city.nagoya.jp", "!city.sapporo.jp", "!city.sendai.jp", "!city.yokohama.jp", "aisai.aichi.jp", "ama.aichi.jp", "anjo.aichi.jp", "asuke.aichi.jp", "chiryu.aichi.jp", "chita.aichi.jp", "fuso.aichi.jp", "gamagori.aichi.jp", "handa.aichi.jp", "hazu.aichi.jp", "hekinan.aichi.jp", "higashiura.aichi.jp", "ichinomiya.aichi.jp", "inazawa.aichi.jp", "inuyama.aichi.jp", "isshiki.aichi.jp", "iwakura.aichi.jp", "kanie.aichi.jp", "kariya.aichi.jp", "kasugai.aichi.jp", "kira.aichi.jp", "kiyosu.aichi.jp", "komaki.aichi.jp", "konan.aichi.jp", "kota.aichi.jp", "mihama.aichi.jp", "miyoshi.aichi.jp", "nishio.aichi.jp", "nisshin.aichi.jp", "obu.aichi.jp", "oguchi.aichi.jp", "oharu.aichi.jp", "okazaki.aichi.jp", "owariasahi.aichi.jp", "seto.aichi.jp", "shikatsu.aichi.jp", "shinshiro.aichi.jp", "shitara.aichi.jp", "tahara.aichi.jp", "takahama.aichi.jp", "tobishima.aichi.jp", "toei.aichi.jp", "togo.aichi.jp", "tokai.aichi.jp", "tokoname.aichi.jp", "toyoake.aichi.jp", "toyohashi.aichi.jp", "toyokawa.aichi.jp", "toyone.aichi.jp", "toyota.aichi.jp", "tsushima.aichi.jp", "yatomi.aichi.jp", "akita.akita.jp", "daisen.akita.jp", "fujisato.akita.jp", "gojome.akita.jp", "hachirogata.akita.jp", "happou.akita.jp", "higashinaruse.akita.jp", "honjo.akita.jp", "honjyo.akita.jp", "ikawa.akita.jp", "kamikoani.akita.jp", "kamioka.akita.jp", "katagami.akita.jp", "kazuno.akita.jp", "kitaakita.akita.jp", "kosaka.akita.jp", "kyowa.akita.jp", "misato.akita.jp", "mitane.akita.jp", "moriyoshi.akita.jp", "nikaho.akita.jp", "noshiro.akita.jp", "odate.akita.jp", "oga.akita.jp", "ogata.akita.jp", "semboku.akita.jp", "yokote.akita.jp", "yurihonjo.akita.jp", "aomori.aomori.jp", "gonohe.aomori.jp", "hachinohe.aomori.jp", "hashikami.aomori.jp", "hiranai.aomori.jp", "hirosaki.aomori.jp", "itayanagi.aomori.jp", "kuroishi.aomori.jp", "misawa.aomori.jp", "mutsu.aomori.jp", "nakadomari.aomori.jp", "noheji.aomori.jp", "oirase.aomori.jp", "owani.aomori.jp", "rokunohe.aomori.jp", "sannohe.aomori.jp", "shichinohe.aomori.jp", "shingo.aomori.jp", "takko.aomori.jp", "towada.aomori.jp", "tsugaru.aomori.jp", "tsuruta.aomori.jp", "abiko.chiba.jp", "asahi.chiba.jp", "chonan.chiba.jp", "chosei.chiba.jp", "choshi.chiba.jp", "chuo.chiba.jp", "funabashi.chiba.jp", "futtsu.chiba.jp", "hanamigawa.chiba.jp", "ichihara.chiba.jp", "ichikawa.chiba.jp", "ichinomiya.chiba.jp", "inzai.chiba.jp", "isumi.chiba.jp", "kamagaya.chiba.jp", "kamogawa.chiba.jp", "kashiwa.chiba.jp", "katori.chiba.jp", "katsuura.chiba.jp", "kimitsu.chiba.jp", "kisarazu.chiba.jp", "kozaki.chiba.jp", "kujukuri.chiba.jp", "kyonan.chiba.jp", "matsudo.chiba.jp", "midori.chiba.jp", "mihama.chiba.jp", "minamiboso.chiba.jp", "mobara.chiba.jp", "mutsuzawa.chiba.jp", "nagara.chiba.jp", "nagareyama.chiba.jp", "narashino.chiba.jp", "narita.chiba.jp", "noda.chiba.jp", "oamishirasato.chiba.jp", "omigawa.chiba.jp", "onjuku.chiba.jp", "otaki.chiba.jp", "sakae.chiba.jp", "sakura.chiba.jp", "shimofusa.chiba.jp", "shirako.chiba.jp", "shiroi.chiba.jp", "shisui.chiba.jp", "sodegaura.chiba.jp", "sosa.chiba.jp", "tako.chiba.jp", "tateyama.chiba.jp", "togane.chiba.jp", "tohnosho.chiba.jp", "tomisato.chiba.jp", "urayasu.chiba.jp", "yachimata.chiba.jp", "yachiyo.chiba.jp", "yokaichiba.chiba.jp", "yokoshibahikari.chiba.jp", "yotsukaido.chiba.jp", "ainan.ehime.jp", "honai.ehime.jp", "ikata.ehime.jp", "imabari.ehime.jp", "iyo.ehime.jp", "kamijima.ehime.jp", "kihoku.ehime.jp", "kumakogen.ehime.jp", "masaki.ehime.jp", "matsuno.ehime.jp", "matsuyama.ehime.jp", "namikata.ehime.jp", "niihama.ehime.jp", "ozu.ehime.jp", "saijo.ehime.jp", "seiyo.ehime.jp", "shikokuchuo.ehime.jp", "tobe.ehime.jp", "toon.ehime.jp", "uchiko.ehime.jp", "uwajima.ehime.jp", "yawatahama.ehime.jp", "echizen.fukui.jp", "eiheiji.fukui.jp", "fukui.fukui.jp", "ikeda.fukui.jp", "katsuyama.fukui.jp", "mihama.fukui.jp", "minamiechizen.fukui.jp", "obama.fukui.jp", "ohi.fukui.jp", "ono.fukui.jp", "sabae.fukui.jp", "sakai.fukui.jp", "takahama.fukui.jp", "tsuruga.fukui.jp", "wakasa.fukui.jp", "ashiya.fukuoka.jp", "buzen.fukuoka.jp", "chikugo.fukuoka.jp", "chikuho.fukuoka.jp", "chikujo.fukuoka.jp", "chikushino.fukuoka.jp", "chikuzen.fukuoka.jp", "chuo.fukuoka.jp", "dazaifu.fukuoka.jp", "fukuchi.fukuoka.jp", "hakata.fukuoka.jp", "higashi.fukuoka.jp", "hirokawa.fukuoka.jp", "hisayama.fukuoka.jp", "iizuka.fukuoka.jp", "inatsuki.fukuoka.jp", "kaho.fukuoka.jp", "kasuga.fukuoka.jp", "kasuya.fukuoka.jp", "kawara.fukuoka.jp", "keisen.fukuoka.jp", "koga.fukuoka.jp", "kurate.fukuoka.jp", "kurogi.fukuoka.jp", "kurume.fukuoka.jp", "minami.fukuoka.jp", "miyako.fukuoka.jp", "miyama.fukuoka.jp", "miyawaka.fukuoka.jp", "mizumaki.fukuoka.jp", "munakata.fukuoka.jp", "nakagawa.fukuoka.jp", "nakama.fukuoka.jp", "nishi.fukuoka.jp", "nogata.fukuoka.jp", "ogori.fukuoka.jp", "okagaki.fukuoka.jp", "okawa.fukuoka.jp", "oki.fukuoka.jp", "omuta.fukuoka.jp", "onga.fukuoka.jp", "onojo.fukuoka.jp", "oto.fukuoka.jp", "saigawa.fukuoka.jp", "sasaguri.fukuoka.jp", "shingu.fukuoka.jp", "shinyoshitomi.fukuoka.jp", "shonai.fukuoka.jp", "soeda.fukuoka.jp", "sue.fukuoka.jp", "tachiarai.fukuoka.jp", "tagawa.fukuoka.jp", "takata.fukuoka.jp", "toho.fukuoka.jp", "toyotsu.fukuoka.jp", "tsuiki.fukuoka.jp", "ukiha.fukuoka.jp", "umi.fukuoka.jp", "usui.fukuoka.jp", "yamada.fukuoka.jp", "yame.fukuoka.jp", "yanagawa.fukuoka.jp", "yukuhashi.fukuoka.jp", "aizubange.fukushima.jp", "aizumisato.fukushima.jp", "aizuwakamatsu.fukushima.jp", "asakawa.fukushima.jp", "bandai.fukushima.jp", "date.fukushima.jp", "fukushima.fukushima.jp", "furudono.fukushima.jp", "futaba.fukushima.jp", "hanawa.fukushima.jp", "higashi.fukushima.jp", "hirata.fukushima.jp", "hirono.fukushima.jp", "iitate.fukushima.jp", "inawashiro.fukushima.jp", "ishikawa.fukushima.jp", "iwaki.fukushima.jp", "izumizaki.fukushima.jp", "kagamiishi.fukushima.jp", "kaneyama.fukushima.jp", "kawamata.fukushima.jp", "kitakata.fukushima.jp", "kitashiobara.fukushima.jp", "koori.fukushima.jp", "koriyama.fukushima.jp", "kunimi.fukushima.jp", "miharu.fukushima.jp", "mishima.fukushima.jp", "namie.fukushima.jp", "nango.fukushima.jp", "nishiaizu.fukushima.jp", "nishigo.fukushima.jp", "okuma.fukushima.jp", "omotego.fukushima.jp", "ono.fukushima.jp", "otama.fukushima.jp", "samegawa.fukushima.jp", "shimogo.fukushima.jp", "shirakawa.fukushima.jp", "showa.fukushima.jp", "soma.fukushima.jp", "sukagawa.fukushima.jp", "taishin.fukushima.jp", "tamakawa.fukushima.jp", "tanagura.fukushima.jp", "tenei.fukushima.jp", "yabuki.fukushima.jp", "yamato.fukushima.jp", "yamatsuri.fukushima.jp", "yanaizu.fukushima.jp", "yugawa.fukushima.jp", "anpachi.gifu.jp", "ena.gifu.jp", "gifu.gifu.jp", "ginan.gifu.jp", "godo.gifu.jp", "gujo.gifu.jp", "hashima.gifu.jp", "hichiso.gifu.jp", "hida.gifu.jp", "higashishirakawa.gifu.jp", "ibigawa.gifu.jp", "ikeda.gifu.jp", "kakamigahara.gifu.jp", "kani.gifu.jp", "kasahara.gifu.jp", "kasamatsu.gifu.jp", "kawaue.gifu.jp", "kitagata.gifu.jp", "mino.gifu.jp", "minokamo.gifu.jp", "mitake.gifu.jp", "mizunami.gifu.jp", "motosu.gifu.jp", "nakatsugawa.gifu.jp", "ogaki.gifu.jp", "sakahogi.gifu.jp", "seki.gifu.jp", "sekigahara.gifu.jp", "shirakawa.gifu.jp", "tajimi.gifu.jp", "takayama.gifu.jp", "tarui.gifu.jp", "toki.gifu.jp", "tomika.gifu.jp", "wanouchi.gifu.jp", "yamagata.gifu.jp", "yaotsu.gifu.jp", "yoro.gifu.jp", "annaka.gunma.jp", "chiyoda.gunma.jp", "fujioka.gunma.jp", "higashiagatsuma.gunma.jp", "isesaki.gunma.jp", "itakura.gunma.jp", "kanna.gunma.jp", "kanra.gunma.jp", "katashina.gunma.jp", "kawaba.gunma.jp", "kiryu.gunma.jp", "kusatsu.gunma.jp", "maebashi.gunma.jp", "meiwa.gunma.jp", "midori.gunma.jp", "minakami.gunma.jp", "naganohara.gunma.jp", "nakanojo.gunma.jp", "nanmoku.gunma.jp", "numata.gunma.jp", "oizumi.gunma.jp", "ora.gunma.jp", "ota.gunma.jp", "shibukawa.gunma.jp", "shimonita.gunma.jp", "shinto.gunma.jp", "showa.gunma.jp", "takasaki.gunma.jp", "takayama.gunma.jp", "tamamura.gunma.jp", "tatebayashi.gunma.jp", "tomioka.gunma.jp", "tsukiyono.gunma.jp", "tsumagoi.gunma.jp", "ueno.gunma.jp", "yoshioka.gunma.jp", "asaminami.hiroshima.jp", "daiwa.hiroshima.jp", "etajima.hiroshima.jp", "fuchu.hiroshima.jp", "fukuyama.hiroshima.jp", "hatsukaichi.hiroshima.jp", "higashihiroshima.hiroshima.jp", "hongo.hiroshima.jp", "jinsekikogen.hiroshima.jp", "kaita.hiroshima.jp", "kui.hiroshima.jp", "kumano.hiroshima.jp", "kure.hiroshima.jp", "mihara.hiroshima.jp", "miyoshi.hiroshima.jp", "naka.hiroshima.jp", "onomichi.hiroshima.jp", "osakikamijima.hiroshima.jp", "otake.hiroshima.jp", "saka.hiroshima.jp", "sera.hiroshima.jp", "seranishi.hiroshima.jp", "shinichi.hiroshima.jp", "shobara.hiroshima.jp", "takehara.hiroshima.jp", "abashiri.hokkaido.jp", "abira.hokkaido.jp", "aibetsu.hokkaido.jp", "akabira.hokkaido.jp", "akkeshi.hokkaido.jp", "asahikawa.hokkaido.jp", "ashibetsu.hokkaido.jp", "ashoro.hokkaido.jp", "assabu.hokkaido.jp", "atsuma.hokkaido.jp", "bibai.hokkaido.jp", "biei.hokkaido.jp", "bifuka.hokkaido.jp", "bihoro.hokkaido.jp", "biratori.hokkaido.jp", "chippubetsu.hokkaido.jp", "chitose.hokkaido.jp", "date.hokkaido.jp", "ebetsu.hokkaido.jp", "embetsu.hokkaido.jp", "eniwa.hokkaido.jp", "erimo.hokkaido.jp", "esan.hokkaido.jp", "esashi.hokkaido.jp", "fukagawa.hokkaido.jp", "fukushima.hokkaido.jp", "furano.hokkaido.jp", "furubira.hokkaido.jp", "haboro.hokkaido.jp", "hakodate.hokkaido.jp", "hamatonbetsu.hokkaido.jp", "hidaka.hokkaido.jp", "higashikagura.hokkaido.jp", "higashikawa.hokkaido.jp", "hiroo.hokkaido.jp", "hokuryu.hokkaido.jp", "hokuto.hokkaido.jp", "honbetsu.hokkaido.jp", "horokanai.hokkaido.jp", "horonobe.hokkaido.jp", "ikeda.hokkaido.jp", "imakane.hokkaido.jp", "ishikari.hokkaido.jp", "iwamizawa.hokkaido.jp", "iwanai.hokkaido.jp", "kamifurano.hokkaido.jp", "kamikawa.hokkaido.jp", "kamishihoro.hokkaido.jp", "kamisunagawa.hokkaido.jp", "kamoenai.hokkaido.jp", "kayabe.hokkaido.jp", "kembuchi.hokkaido.jp", "kikonai.hokkaido.jp", "kimobetsu.hokkaido.jp", "kitahiroshima.hokkaido.jp", "kitami.hokkaido.jp", "kiyosato.hokkaido.jp", "koshimizu.hokkaido.jp", "kunneppu.hokkaido.jp", "kuriyama.hokkaido.jp", "kuromatsunai.hokkaido.jp", "kushiro.hokkaido.jp", "kutchan.hokkaido.jp", "kyowa.hokkaido.jp", "mashike.hokkaido.jp", "matsumae.hokkaido.jp", "mikasa.hokkaido.jp", "minamifurano.hokkaido.jp", "mombetsu.hokkaido.jp", "moseushi.hokkaido.jp", "mukawa.hokkaido.jp", "muroran.hokkaido.jp", "naie.hokkaido.jp", "nakagawa.hokkaido.jp", "nakasatsunai.hokkaido.jp", "nakatombetsu.hokkaido.jp", "nanae.hokkaido.jp", "nanporo.hokkaido.jp", "nayoro.hokkaido.jp", "nemuro.hokkaido.jp", "niikappu.hokkaido.jp", "niki.hokkaido.jp", "nishiokoppe.hokkaido.jp", "noboribetsu.hokkaido.jp", "numata.hokkaido.jp", "obihiro.hokkaido.jp", "obira.hokkaido.jp", "oketo.hokkaido.jp", "okoppe.hokkaido.jp", "otaru.hokkaido.jp", "otobe.hokkaido.jp", "otofuke.hokkaido.jp", "otoineppu.hokkaido.jp", "oumu.hokkaido.jp", "ozora.hokkaido.jp", "pippu.hokkaido.jp", "rankoshi.hokkaido.jp", "rebun.hokkaido.jp", "rikubetsu.hokkaido.jp", "rishiri.hokkaido.jp", "rishirifuji.hokkaido.jp", "saroma.hokkaido.jp", "sarufutsu.hokkaido.jp", "shakotan.hokkaido.jp", "shari.hokkaido.jp", "shibecha.hokkaido.jp", "shibetsu.hokkaido.jp", "shikabe.hokkaido.jp", "shikaoi.hokkaido.jp", "shimamaki.hokkaido.jp", "shimizu.hokkaido.jp", "shimokawa.hokkaido.jp", "shinshinotsu.hokkaido.jp", "shintoku.hokkaido.jp", "shiranuka.hokkaido.jp", "shiraoi.hokkaido.jp", "shiriuchi.hokkaido.jp", "sobetsu.hokkaido.jp", "sunagawa.hokkaido.jp", "taiki.hokkaido.jp", "takasu.hokkaido.jp", "takikawa.hokkaido.jp", "takinoue.hokkaido.jp", "teshikaga.hokkaido.jp", "tobetsu.hokkaido.jp", "tohma.hokkaido.jp", "tomakomai.hokkaido.jp", "tomari.hokkaido.jp", "toya.hokkaido.jp", "toyako.hokkaido.jp", "toyotomi.hokkaido.jp", "toyoura.hokkaido.jp", "tsubetsu.hokkaido.jp", "tsukigata.hokkaido.jp", "urakawa.hokkaido.jp", "urausu.hokkaido.jp", "uryu.hokkaido.jp", "utashinai.hokkaido.jp", "wakkanai.hokkaido.jp", "wassamu.hokkaido.jp", "yakumo.hokkaido.jp", "yoichi.hokkaido.jp", "aioi.hyogo.jp", "akashi.hyogo.jp", "ako.hyogo.jp", "amagasaki.hyogo.jp", "aogaki.hyogo.jp", "asago.hyogo.jp", "ashiya.hyogo.jp", "awaji.hyogo.jp", "fukusaki.hyogo.jp", "goshiki.hyogo.jp", "harima.hyogo.jp", "himeji.hyogo.jp", "ichikawa.hyogo.jp", "inagawa.hyogo.jp", "itami.hyogo.jp", "kakogawa.hyogo.jp", "kamigori.hyogo.jp", "kamikawa.hyogo.jp", "kasai.hyogo.jp", "kasuga.hyogo.jp", "kawanishi.hyogo.jp", "miki.hyogo.jp", "minamiawaji.hyogo.jp", "nishinomiya.hyogo.jp", "nishiwaki.hyogo.jp", "ono.hyogo.jp", "sanda.hyogo.jp", "sannan.hyogo.jp", "sasayama.hyogo.jp", "sayo.hyogo.jp", "shingu.hyogo.jp", "shinonsen.hyogo.jp", "shiso.hyogo.jp", "sumoto.hyogo.jp", "taishi.hyogo.jp", "taka.hyogo.jp", "takarazuka.hyogo.jp", "takasago.hyogo.jp", "takino.hyogo.jp", "tamba.hyogo.jp", "tatsuno.hyogo.jp", "toyooka.hyogo.jp", "yabu.hyogo.jp", "yashiro.hyogo.jp", "yoka.hyogo.jp", "yokawa.hyogo.jp", "ami.ibaraki.jp", "asahi.ibaraki.jp", "bando.ibaraki.jp", "chikusei.ibaraki.jp", "daigo.ibaraki.jp", "fujishiro.ibaraki.jp", "hitachi.ibaraki.jp", "hitachinaka.ibaraki.jp", "hitachiomiya.ibaraki.jp", "hitachiota.ibaraki.jp", "ibaraki.ibaraki.jp", "ina.ibaraki.jp", "inashiki.ibaraki.jp", "itako.ibaraki.jp", "iwama.ibaraki.jp", "joso.ibaraki.jp", "kamisu.ibaraki.jp", "kasama.ibaraki.jp", "kashima.ibaraki.jp", "kasumigaura.ibaraki.jp", "koga.ibaraki.jp", "miho.ibaraki.jp", "mito.ibaraki.jp", "moriya.ibaraki.jp", "naka.ibaraki.jp", "namegata.ibaraki.jp", "oarai.ibaraki.jp", "ogawa.ibaraki.jp", "omitama.ibaraki.jp", "ryugasaki.ibaraki.jp", "sakai.ibaraki.jp", "sakuragawa.ibaraki.jp", "shimodate.ibaraki.jp", "shimotsuma.ibaraki.jp", "shirosato.ibaraki.jp", "sowa.ibaraki.jp", "suifu.ibaraki.jp", "takahagi.ibaraki.jp", "tamatsukuri.ibaraki.jp", "tokai.ibaraki.jp", "tomobe.ibaraki.jp", "tone.ibaraki.jp", "toride.ibaraki.jp", "tsuchiura.ibaraki.jp", "tsukuba.ibaraki.jp", "uchihara.ibaraki.jp", "ushiku.ibaraki.jp", "yachiyo.ibaraki.jp", "yamagata.ibaraki.jp", "yawara.ibaraki.jp", "yuki.ibaraki.jp", "anamizu.ishikawa.jp", "hakui.ishikawa.jp", "hakusan.ishikawa.jp", "kaga.ishikawa.jp", "kahoku.ishikawa.jp", "kanazawa.ishikawa.jp", "kawakita.ishikawa.jp", "komatsu.ishikawa.jp", "nakanoto.ishikawa.jp", "nanao.ishikawa.jp", "nomi.ishikawa.jp", "nonoichi.ishikawa.jp", "noto.ishikawa.jp", "shika.ishikawa.jp", "suzu.ishikawa.jp", "tsubata.ishikawa.jp", "tsurugi.ishikawa.jp", "uchinada.ishikawa.jp", "wajima.ishikawa.jp", "fudai.iwate.jp", "fujisawa.iwate.jp", "hanamaki.iwate.jp", "hiraizumi.iwate.jp", "hirono.iwate.jp", "ichinohe.iwate.jp", "ichinoseki.iwate.jp", "iwaizumi.iwate.jp", "iwate.iwate.jp", "joboji.iwate.jp", "kamaishi.iwate.jp", "kanegasaki.iwate.jp", "karumai.iwate.jp", "kawai.iwate.jp", "kitakami.iwate.jp", "kuji.iwate.jp", "kunohe.iwate.jp", "kuzumaki.iwate.jp", "miyako.iwate.jp", "mizusawa.iwate.jp", "morioka.iwate.jp", "ninohe.iwate.jp", "noda.iwate.jp", "ofunato.iwate.jp", "oshu.iwate.jp", "otsuchi.iwate.jp", "rikuzentakata.iwate.jp", "shiwa.iwate.jp", "shizukuishi.iwate.jp", "sumita.iwate.jp", "tanohata.iwate.jp", "tono.iwate.jp", "yahaba.iwate.jp", "yamada.iwate.jp", "ayagawa.kagawa.jp", "higashikagawa.kagawa.jp", "kanonji.kagawa.jp", "kotohira.kagawa.jp", "manno.kagawa.jp", "marugame.kagawa.jp", "mitoyo.kagawa.jp", "naoshima.kagawa.jp", "sanuki.kagawa.jp", "tadotsu.kagawa.jp", "takamatsu.kagawa.jp", "tonosho.kagawa.jp", "uchinomi.kagawa.jp", "utazu.kagawa.jp", "zentsuji.kagawa.jp", "akune.kagoshima.jp", "amami.kagoshima.jp", "hioki.kagoshima.jp", "isa.kagoshima.jp", "isen.kagoshima.jp", "izumi.kagoshima.jp", "kagoshima.kagoshima.jp", "kanoya.kagoshima.jp", "kawanabe.kagoshima.jp", "kinko.kagoshima.jp", "kouyama.kagoshima.jp", "makurazaki.kagoshima.jp", "matsumoto.kagoshima.jp", "minamitane.kagoshima.jp", "nakatane.kagoshima.jp", "nishinoomote.kagoshima.jp", "satsumasendai.kagoshima.jp", "soo.kagoshima.jp", "tarumizu.kagoshima.jp", "yusui.kagoshima.jp", "aikawa.kanagawa.jp", "atsugi.kanagawa.jp", "ayase.kanagawa.jp", "chigasaki.kanagawa.jp", "ebina.kanagawa.jp", "fujisawa.kanagawa.jp", "hadano.kanagawa.jp", "hakone.kanagawa.jp", "hiratsuka.kanagawa.jp", "isehara.kanagawa.jp", "kaisei.kanagawa.jp", "kamakura.kanagawa.jp", "kiyokawa.kanagawa.jp", "matsuda.kanagawa.jp", "minamiashigara.kanagawa.jp", "miura.kanagawa.jp", "nakai.kanagawa.jp", "ninomiya.kanagawa.jp", "odawara.kanagawa.jp", "oi.kanagawa.jp", "oiso.kanagawa.jp", "sagamihara.kanagawa.jp", "samukawa.kanagawa.jp", "tsukui.kanagawa.jp", "yamakita.kanagawa.jp", "yamato.kanagawa.jp", "yokosuka.kanagawa.jp", "yugawara.kanagawa.jp", "zama.kanagawa.jp", "zushi.kanagawa.jp", "aki.kochi.jp", "geisei.kochi.jp", "hidaka.kochi.jp", "higashitsuno.kochi.jp", "ino.kochi.jp", "kagami.kochi.jp", "kami.kochi.jp", "kitagawa.kochi.jp", "kochi.kochi.jp", "mihara.kochi.jp", "motoyama.kochi.jp", "muroto.kochi.jp", "nahari.kochi.jp", "nakamura.kochi.jp", "nankoku.kochi.jp", "nishitosa.kochi.jp", "niyodogawa.kochi.jp", "ochi.kochi.jp", "okawa.kochi.jp", "otoyo.kochi.jp", "otsuki.kochi.jp", "sakawa.kochi.jp", "sukumo.kochi.jp", "susaki.kochi.jp", "tosa.kochi.jp", "tosashimizu.kochi.jp", "toyo.kochi.jp", "tsuno.kochi.jp", "umaji.kochi.jp", "yasuda.kochi.jp", "yusuhara.kochi.jp", "amakusa.kumamoto.jp", "arao.kumamoto.jp", "aso.kumamoto.jp", "choyo.kumamoto.jp", "gyokuto.kumamoto.jp", "kamiamakusa.kumamoto.jp", "kikuchi.kumamoto.jp", "kumamoto.kumamoto.jp", "mashiki.kumamoto.jp", "mifune.kumamoto.jp", "minamata.kumamoto.jp", "minamioguni.kumamoto.jp", "nagasu.kumamoto.jp", "nishihara.kumamoto.jp", "oguni.kumamoto.jp", "ozu.kumamoto.jp", "sumoto.kumamoto.jp", "takamori.kumamoto.jp", "uki.kumamoto.jp", "uto.kumamoto.jp", "yamaga.kumamoto.jp", "yamato.kumamoto.jp", "yatsushiro.kumamoto.jp", "ayabe.kyoto.jp", "fukuchiyama.kyoto.jp", "higashiyama.kyoto.jp", "ide.kyoto.jp", "ine.kyoto.jp", "joyo.kyoto.jp", "kameoka.kyoto.jp", "kamo.kyoto.jp", "kita.kyoto.jp", "kizu.kyoto.jp", "kumiyama.kyoto.jp", "kyotamba.kyoto.jp", "kyotanabe.kyoto.jp", "kyotango.kyoto.jp", "maizuru.kyoto.jp", "minami.kyoto.jp", "minamiyamashiro.kyoto.jp", "miyazu.kyoto.jp", "muko.kyoto.jp", "nagaokakyo.kyoto.jp", "nakagyo.kyoto.jp", "nantan.kyoto.jp", "oyamazaki.kyoto.jp", "sakyo.kyoto.jp", "seika.kyoto.jp", "tanabe.kyoto.jp", "uji.kyoto.jp", "ujitawara.kyoto.jp", "wazuka.kyoto.jp", "yamashina.kyoto.jp", "yawata.kyoto.jp", "asahi.mie.jp", "inabe.mie.jp", "ise.mie.jp", "kameyama.mie.jp", "kawagoe.mie.jp", "kiho.mie.jp", "kisosaki.mie.jp", "kiwa.mie.jp", "komono.mie.jp", "kumano.mie.jp", "kuwana.mie.jp", "matsusaka.mie.jp", "meiwa.mie.jp", "mihama.mie.jp", "minamiise.mie.jp", "misugi.mie.jp", "miyama.mie.jp", "nabari.mie.jp", "shima.mie.jp", "suzuka.mie.jp", "tado.mie.jp", "taiki.mie.jp", "taki.mie.jp", "tamaki.mie.jp", "toba.mie.jp", "tsu.mie.jp", "udono.mie.jp", "ureshino.mie.jp", "watarai.mie.jp", "yokkaichi.mie.jp", "furukawa.miyagi.jp", "higashimatsushima.miyagi.jp", "ishinomaki.miyagi.jp", "iwanuma.miyagi.jp", "kakuda.miyagi.jp", "kami.miyagi.jp", "kawasaki.miyagi.jp", "marumori.miyagi.jp", "matsushima.miyagi.jp", "minamisanriku.miyagi.jp", "misato.miyagi.jp", "murata.miyagi.jp", "natori.miyagi.jp", "ogawara.miyagi.jp", "ohira.miyagi.jp", "onagawa.miyagi.jp", "osaki.miyagi.jp", "rifu.miyagi.jp", "semine.miyagi.jp", "shibata.miyagi.jp", "shichikashuku.miyagi.jp", "shikama.miyagi.jp", "shiogama.miyagi.jp", "shiroishi.miyagi.jp", "tagajo.miyagi.jp", "taiwa.miyagi.jp", "tome.miyagi.jp", "tomiya.miyagi.jp", "wakuya.miyagi.jp", "watari.miyagi.jp", "yamamoto.miyagi.jp", "zao.miyagi.jp", "aya.miyazaki.jp", "ebino.miyazaki.jp", "gokase.miyazaki.jp", "hyuga.miyazaki.jp", "kadogawa.miyazaki.jp", "kawaminami.miyazaki.jp", "kijo.miyazaki.jp", "kitagawa.miyazaki.jp", "kitakata.miyazaki.jp", "kitaura.miyazaki.jp", "kobayashi.miyazaki.jp", "kunitomi.miyazaki.jp", "kushima.miyazaki.jp", "mimata.miyazaki.jp", "miyakonojo.miyazaki.jp", "miyazaki.miyazaki.jp", "morotsuka.miyazaki.jp", "nichinan.miyazaki.jp", "nishimera.miyazaki.jp", "nobeoka.miyazaki.jp", "saito.miyazaki.jp", "shiiba.miyazaki.jp", "shintomi.miyazaki.jp", "takaharu.miyazaki.jp", "takanabe.miyazaki.jp", "takazaki.miyazaki.jp", "tsuno.miyazaki.jp", "achi.nagano.jp", "agematsu.nagano.jp", "anan.nagano.jp", "aoki.nagano.jp", "asahi.nagano.jp", "azumino.nagano.jp", "chikuhoku.nagano.jp", "chikuma.nagano.jp", "chino.nagano.jp", "fujimi.nagano.jp", "hakuba.nagano.jp", "hara.nagano.jp", "hiraya.nagano.jp", "iida.nagano.jp", "iijima.nagano.jp", "iiyama.nagano.jp", "iizuna.nagano.jp", "ikeda.nagano.jp", "ikusaka.nagano.jp", "ina.nagano.jp", "karuizawa.nagano.jp", "kawakami.nagano.jp", "kiso.nagano.jp", "kisofukushima.nagano.jp", "kitaaiki.nagano.jp", "komagane.nagano.jp", "komoro.nagano.jp", "matsukawa.nagano.jp", "matsumoto.nagano.jp", "miasa.nagano.jp", "minamiaiki.nagano.jp", "minamimaki.nagano.jp", "minamiminowa.nagano.jp", "minowa.nagano.jp", "miyada.nagano.jp", "miyota.nagano.jp", "mochizuki.nagano.jp", "nagano.nagano.jp", "nagawa.nagano.jp", "nagiso.nagano.jp", "nakagawa.nagano.jp", "nakano.nagano.jp", "nozawaonsen.nagano.jp", "obuse.nagano.jp", "ogawa.nagano.jp", "okaya.nagano.jp", "omachi.nagano.jp", "omi.nagano.jp", "ookuwa.nagano.jp", "ooshika.nagano.jp", "otaki.nagano.jp", "otari.nagano.jp", "sakae.nagano.jp", "sakaki.nagano.jp", "saku.nagano.jp", "sakuho.nagano.jp", "shimosuwa.nagano.jp", "shinanomachi.nagano.jp", "shiojiri.nagano.jp", "suwa.nagano.jp", "suzaka.nagano.jp", "takagi.nagano.jp", "takamori.nagano.jp", "takayama.nagano.jp", "tateshina.nagano.jp", "tatsuno.nagano.jp", "togakushi.nagano.jp", "togura.nagano.jp", "tomi.nagano.jp", "ueda.nagano.jp", "wada.nagano.jp", "yamagata.nagano.jp", "yamanouchi.nagano.jp", "yasaka.nagano.jp", "yasuoka.nagano.jp", "chijiwa.nagasaki.jp", "futsu.nagasaki.jp", "goto.nagasaki.jp", "hasami.nagasaki.jp", "hirado.nagasaki.jp", "iki.nagasaki.jp", "isahaya.nagasaki.jp", "kawatana.nagasaki.jp", "kuchinotsu.nagasaki.jp", "matsuura.nagasaki.jp", "nagasaki.nagasaki.jp", "obama.nagasaki.jp", "omura.nagasaki.jp", "oseto.nagasaki.jp", "saikai.nagasaki.jp", "sasebo.nagasaki.jp", "seihi.nagasaki.jp", "shimabara.nagasaki.jp", "shinkamigoto.nagasaki.jp", "togitsu.nagasaki.jp", "tsushima.nagasaki.jp", "unzen.nagasaki.jp", "ando.nara.jp", "gose.nara.jp", "heguri.nara.jp", "higashiyoshino.nara.jp", "ikaruga.nara.jp", "ikoma.nara.jp", "kamikitayama.nara.jp", "kanmaki.nara.jp", "kashiba.nara.jp", "kashihara.nara.jp", "katsuragi.nara.jp", "kawai.nara.jp", "kawakami.nara.jp", "kawanishi.nara.jp", "koryo.nara.jp", "kurotaki.nara.jp", "mitsue.nara.jp", "miyake.nara.jp", "nara.nara.jp", "nosegawa.nara.jp", "oji.nara.jp", "ouda.nara.jp", "oyodo.nara.jp", "sakurai.nara.jp", "sango.nara.jp", "shimoichi.nara.jp", "shimokitayama.nara.jp", "shinjo.nara.jp", "soni.nara.jp", "takatori.nara.jp", "tawaramoto.nara.jp", "tenkawa.nara.jp", "tenri.nara.jp", "uda.nara.jp", "yamatokoriyama.nara.jp", "yamatotakada.nara.jp", "yamazoe.nara.jp", "yoshino.nara.jp", "aga.niigata.jp", "agano.niigata.jp", "gosen.niigata.jp", "itoigawa.niigata.jp", "izumozaki.niigata.jp", "joetsu.niigata.jp", "kamo.niigata.jp", "kariwa.niigata.jp", "kashiwazaki.niigata.jp", "minamiuonuma.niigata.jp", "mitsuke.niigata.jp", "muika.niigata.jp", "murakami.niigata.jp", "myoko.niigata.jp", "nagaoka.niigata.jp", "niigata.niigata.jp", "ojiya.niigata.jp", "omi.niigata.jp", "sado.niigata.jp", "sanjo.niigata.jp", "seiro.niigata.jp", "seirou.niigata.jp", "sekikawa.niigata.jp", "shibata.niigata.jp", "tagami.niigata.jp", "tainai.niigata.jp", "tochio.niigata.jp", "tokamachi.niigata.jp", "tsubame.niigata.jp", "tsunan.niigata.jp", "uonuma.niigata.jp", "yahiko.niigata.jp", "yoita.niigata.jp", "yuzawa.niigata.jp", "beppu.oita.jp", "bungoono.oita.jp", "bungotakada.oita.jp", "hasama.oita.jp", "hiji.oita.jp", "himeshima.oita.jp", "hita.oita.jp", "kamitsue.oita.jp", "kokonoe.oita.jp", "kuju.oita.jp", "kunisaki.oita.jp", "kusu.oita.jp", "oita.oita.jp", "saiki.oita.jp", "taketa.oita.jp", "tsukumi.oita.jp", "usa.oita.jp", "usuki.oita.jp", "yufu.oita.jp", "akaiwa.okayama.jp", "asakuchi.okayama.jp", "bizen.okayama.jp", "hayashima.okayama.jp", "ibara.okayama.jp", "kagamino.okayama.jp", "kasaoka.okayama.jp", "kibichuo.okayama.jp", "kumenan.okayama.jp", "kurashiki.okayama.jp", "maniwa.okayama.jp", "misaki.okayama.jp", "nagi.okayama.jp", "niimi.okayama.jp", "nishiawakura.okayama.jp", "okayama.okayama.jp", "satosho.okayama.jp", "setouchi.okayama.jp", "shinjo.okayama.jp", "shoo.okayama.jp", "soja.okayama.jp", "takahashi.okayama.jp", "tamano.okayama.jp", "tsuyama.okayama.jp", "wake.okayama.jp", "yakage.okayama.jp", "aguni.okinawa.jp", "ginowan.okinawa.jp", "ginoza.okinawa.jp", "gushikami.okinawa.jp", "haebaru.okinawa.jp", "higashi.okinawa.jp", "hirara.okinawa.jp", "iheya.okinawa.jp", "ishigaki.okinawa.jp", "ishikawa.okinawa.jp", "itoman.okinawa.jp", "izena.okinawa.jp", "kadena.okinawa.jp", "kin.okinawa.jp", "kitadaito.okinawa.jp", "kitanakagusuku.okinawa.jp", "kumejima.okinawa.jp", "kunigami.okinawa.jp", "minamidaito.okinawa.jp", "motobu.okinawa.jp", "nago.okinawa.jp", "naha.okinawa.jp", "nakagusuku.okinawa.jp", "nakijin.okinawa.jp", "nanjo.okinawa.jp", "nishihara.okinawa.jp", "ogimi.okinawa.jp", "okinawa.okinawa.jp", "onna.okinawa.jp", "shimoji.okinawa.jp", "taketomi.okinawa.jp", "tarama.okinawa.jp", "tokashiki.okinawa.jp", "tomigusuku.okinawa.jp", "tonaki.okinawa.jp", "urasoe.okinawa.jp", "uruma.okinawa.jp", "yaese.okinawa.jp", "yomitan.okinawa.jp", "yonabaru.okinawa.jp", "yonaguni.okinawa.jp", "zamami.okinawa.jp", "abeno.osaka.jp", "chihayaakasaka.osaka.jp", "chuo.osaka.jp", "daito.osaka.jp", "fujiidera.osaka.jp", "habikino.osaka.jp", "hannan.osaka.jp", "higashiosaka.osaka.jp", "higashisumiyoshi.osaka.jp", "higashiyodogawa.osaka.jp", "hirakata.osaka.jp", "ibaraki.osaka.jp", "ikeda.osaka.jp", "izumi.osaka.jp", "izumiotsu.osaka.jp", "izumisano.osaka.jp", "kadoma.osaka.jp", "kaizuka.osaka.jp", "kanan.osaka.jp", "kashiwara.osaka.jp", "katano.osaka.jp", "kawachinagano.osaka.jp", "kishiwada.osaka.jp", "kita.osaka.jp", "kumatori.osaka.jp", "matsubara.osaka.jp", "minato.osaka.jp", "minoh.osaka.jp", "misaki.osaka.jp", "moriguchi.osaka.jp", "neyagawa.osaka.jp", "nishi.osaka.jp", "nose.osaka.jp", "osakasayama.osaka.jp", "sakai.osaka.jp", "sayama.osaka.jp", "sennan.osaka.jp", "settsu.osaka.jp", "shijonawate.osaka.jp", "shimamoto.osaka.jp", "suita.osaka.jp", "tadaoka.osaka.jp", "taishi.osaka.jp", "tajiri.osaka.jp", "takaishi.osaka.jp", "takatsuki.osaka.jp", "tondabayashi.osaka.jp", "toyonaka.osaka.jp", "toyono.osaka.jp", "yao.osaka.jp", "ariake.saga.jp", "arita.saga.jp", "fukudomi.saga.jp", "genkai.saga.jp", "hamatama.saga.jp", "hizen.saga.jp", "imari.saga.jp", "kamimine.saga.jp", "kanzaki.saga.jp", "karatsu.saga.jp", "kashima.saga.jp", "kitagata.saga.jp", "kitahata.saga.jp", "kiyama.saga.jp", "kouhoku.saga.jp", "kyuragi.saga.jp", "nishiarita.saga.jp", "ogi.saga.jp", "omachi.saga.jp", "ouchi.saga.jp", "saga.saga.jp", "shiroishi.saga.jp", "taku.saga.jp", "tara.saga.jp", "tosu.saga.jp", "yoshinogari.saga.jp", "arakawa.saitama.jp", "asaka.saitama.jp", "chichibu.saitama.jp", "fujimi.saitama.jp", "fujimino.saitama.jp", "fukaya.saitama.jp", "hanno.saitama.jp", "hanyu.saitama.jp", "hasuda.saitama.jp", "hatogaya.saitama.jp", "hatoyama.saitama.jp", "hidaka.saitama.jp", "higashichichibu.saitama.jp", "higashimatsuyama.saitama.jp", "honjo.saitama.jp", "ina.saitama.jp", "iruma.saitama.jp", "iwatsuki.saitama.jp", "kamiizumi.saitama.jp", "kamikawa.saitama.jp", "kamisato.saitama.jp", "kasukabe.saitama.jp", "kawagoe.saitama.jp", "kawaguchi.saitama.jp", "kawajima.saitama.jp", "kazo.saitama.jp", "kitamoto.saitama.jp", "koshigaya.saitama.jp", "kounosu.saitama.jp", "kuki.saitama.jp", "kumagaya.saitama.jp", "matsubushi.saitama.jp", "minano.saitama.jp", "misato.saitama.jp", "miyashiro.saitama.jp", "miyoshi.saitama.jp", "moroyama.saitama.jp", "nagatoro.saitama.jp", "namegawa.saitama.jp", "niiza.saitama.jp", "ogano.saitama.jp", "ogawa.saitama.jp", "ogose.saitama.jp", "okegawa.saitama.jp", "omiya.saitama.jp", "otaki.saitama.jp", "ranzan.saitama.jp", "ryokami.saitama.jp", "saitama.saitama.jp", "sakado.saitama.jp", "satte.saitama.jp", "sayama.saitama.jp", "shiki.saitama.jp", "shiraoka.saitama.jp", "soka.saitama.jp", "sugito.saitama.jp", "toda.saitama.jp", "tokigawa.saitama.jp", "tokorozawa.saitama.jp", "tsurugashima.saitama.jp", "urawa.saitama.jp", "warabi.saitama.jp", "yashio.saitama.jp", "yokoze.saitama.jp", "yono.saitama.jp", "yorii.saitama.jp", "yoshida.saitama.jp", "yoshikawa.saitama.jp", "yoshimi.saitama.jp", "aisho.shiga.jp", "gamo.shiga.jp", "higashiomi.shiga.jp", "hikone.shiga.jp", "koka.shiga.jp", "konan.shiga.jp", "kosei.shiga.jp", "koto.shiga.jp", "kusatsu.shiga.jp", "maibara.shiga.jp", "moriyama.shiga.jp", "nagahama.shiga.jp", "nishiazai.shiga.jp", "notogawa.shiga.jp", "omihachiman.shiga.jp", "otsu.shiga.jp", "ritto.shiga.jp", "ryuoh.shiga.jp", "takashima.shiga.jp", "takatsuki.shiga.jp", "torahime.shiga.jp", "toyosato.shiga.jp", "yasu.shiga.jp", "akagi.shimane.jp", "ama.shimane.jp", "gotsu.shimane.jp", "hamada.shimane.jp", "higashiizumo.shimane.jp", "hikawa.shimane.jp", "hikimi.shimane.jp", "izumo.shimane.jp", "kakinoki.shimane.jp", "masuda.shimane.jp", "matsue.shimane.jp", "misato.shimane.jp", "nishinoshima.shimane.jp", "ohda.shimane.jp", "okinoshima.shimane.jp", "okuizumo.shimane.jp", "shimane.shimane.jp", "tamayu.shimane.jp", "tsuwano.shimane.jp", "unnan.shimane.jp", "yakumo.shimane.jp", "yasugi.shimane.jp", "yatsuka.shimane.jp", "arai.shizuoka.jp", "atami.shizuoka.jp", "fuji.shizuoka.jp", "fujieda.shizuoka.jp", "fujikawa.shizuoka.jp", "fujinomiya.shizuoka.jp", "fukuroi.shizuoka.jp", "gotemba.shizuoka.jp", "haibara.shizuoka.jp", "hamamatsu.shizuoka.jp", "higashiizu.shizuoka.jp", "ito.shizuoka.jp", "iwata.shizuoka.jp", "izu.shizuoka.jp", "izunokuni.shizuoka.jp", "kakegawa.shizuoka.jp", "kannami.shizuoka.jp", "kawanehon.shizuoka.jp", "kawazu.shizuoka.jp", "kikugawa.shizuoka.jp", "kosai.shizuoka.jp", "makinohara.shizuoka.jp", "matsuzaki.shizuoka.jp", "minamiizu.shizuoka.jp", "mishima.shizuoka.jp", "morimachi.shizuoka.jp", "nishiizu.shizuoka.jp", "numazu.shizuoka.jp", "omaezaki.shizuoka.jp", "shimada.shizuoka.jp", "shimizu.shizuoka.jp", "shimoda.shizuoka.jp", "shizuoka.shizuoka.jp", "susono.shizuoka.jp", "yaizu.shizuoka.jp", "yoshida.shizuoka.jp", "ashikaga.tochigi.jp", "bato.tochigi.jp", "haga.tochigi.jp", "ichikai.tochigi.jp", "iwafune.tochigi.jp", "kaminokawa.tochigi.jp", "kanuma.tochigi.jp", "karasuyama.tochigi.jp", "kuroiso.tochigi.jp", "mashiko.tochigi.jp", "mibu.tochigi.jp", "moka.tochigi.jp", "motegi.tochigi.jp", "nasu.tochigi.jp", "nasushiobara.tochigi.jp", "nikko.tochigi.jp", "nishikata.tochigi.jp", "nogi.tochigi.jp", "ohira.tochigi.jp", "ohtawara.tochigi.jp", "oyama.tochigi.jp", "sakura.tochigi.jp", "sano.tochigi.jp", "shimotsuke.tochigi.jp", "shioya.tochigi.jp", "takanezawa.tochigi.jp", "tochigi.tochigi.jp", "tsuga.tochigi.jp", "ujiie.tochigi.jp", "utsunomiya.tochigi.jp", "yaita.tochigi.jp", "aizumi.tokushima.jp", "anan.tokushima.jp", "ichiba.tokushima.jp", "itano.tokushima.jp", "kainan.tokushima.jp", "komatsushima.tokushima.jp", "matsushige.tokushima.jp", "mima.tokushima.jp", "minami.tokushima.jp", "miyoshi.tokushima.jp", "mugi.tokushima.jp", "nakagawa.tokushima.jp", "naruto.tokushima.jp", "sanagochi.tokushima.jp", "shishikui.tokushima.jp", "tokushima.tokushima.jp", "wajiki.tokushima.jp", "adachi.tokyo.jp", "akiruno.tokyo.jp", "akishima.tokyo.jp", "aogashima.tokyo.jp", "arakawa.tokyo.jp", "bunkyo.tokyo.jp", "chiyoda.tokyo.jp", "chofu.tokyo.jp", "chuo.tokyo.jp", "edogawa.tokyo.jp", "fuchu.tokyo.jp", "fussa.tokyo.jp", "hachijo.tokyo.jp", "hachioji.tokyo.jp", "hamura.tokyo.jp", "higashikurume.tokyo.jp", "higashimurayama.tokyo.jp", "higashiyamato.tokyo.jp", "hino.tokyo.jp", "hinode.tokyo.jp", "hinohara.tokyo.jp", "inagi.tokyo.jp", "itabashi.tokyo.jp", "katsushika.tokyo.jp", "kita.tokyo.jp", "kiyose.tokyo.jp", "kodaira.tokyo.jp", "koganei.tokyo.jp", "kokubunji.tokyo.jp", "komae.tokyo.jp", "koto.tokyo.jp", "kouzushima.tokyo.jp", "kunitachi.tokyo.jp", "machida.tokyo.jp", "meguro.tokyo.jp", "minato.tokyo.jp", "mitaka.tokyo.jp", "mizuho.tokyo.jp", "musashimurayama.tokyo.jp", "musashino.tokyo.jp", "nakano.tokyo.jp", "nerima.tokyo.jp", "ogasawara.tokyo.jp", "okutama.tokyo.jp", "ome.tokyo.jp", "oshima.tokyo.jp", "ota.tokyo.jp", "setagaya.tokyo.jp", "shibuya.tokyo.jp", "shinagawa.tokyo.jp", "shinjuku.tokyo.jp", "suginami.tokyo.jp", "sumida.tokyo.jp", "tachikawa.tokyo.jp", "taito.tokyo.jp", "tama.tokyo.jp", "toshima.tokyo.jp", "chizu.tottori.jp", "hino.tottori.jp", "kawahara.tottori.jp", "koge.tottori.jp", "kotoura.tottori.jp", "misasa.tottori.jp", "nanbu.tottori.jp", "nichinan.tottori.jp", "sakaiminato.tottori.jp", "tottori.tottori.jp", "wakasa.tottori.jp", "yazu.tottori.jp", "yonago.tottori.jp", "asahi.toyama.jp", "fuchu.toyama.jp", "fukumitsu.toyama.jp", "funahashi.toyama.jp", "himi.toyama.jp", "imizu.toyama.jp", "inami.toyama.jp", "johana.toyama.jp", "kamiichi.toyama.jp", "kurobe.toyama.jp", "nakaniikawa.toyama.jp", "namerikawa.toyama.jp", "nanto.toyama.jp", "nyuzen.toyama.jp", "oyabe.toyama.jp", "taira.toyama.jp", "takaoka.toyama.jp", "tateyama.toyama.jp", "toga.toyama.jp", "tonami.toyama.jp", "toyama.toyama.jp", "unazuki.toyama.jp", "uozu.toyama.jp", "yamada.toyama.jp", "arida.wakayama.jp", "aridagawa.wakayama.jp", "gobo.wakayama.jp", "hashimoto.wakayama.jp", "hidaka.wakayama.jp", "hirogawa.wakayama.jp", "inami.wakayama.jp", "iwade.wakayama.jp", "kainan.wakayama.jp", "kamitonda.wakayama.jp", "katsuragi.wakayama.jp", "kimino.wakayama.jp", "kinokawa.wakayama.jp", "kitayama.wakayama.jp", "koya.wakayama.jp", "koza.wakayama.jp", "kozagawa.wakayama.jp", "kudoyama.wakayama.jp", "kushimoto.wakayama.jp", "mihama.wakayama.jp", "misato.wakayama.jp", "nachikatsuura.wakayama.jp", "shingu.wakayama.jp", "shirahama.wakayama.jp", "taiji.wakayama.jp", "tanabe.wakayama.jp", "wakayama.wakayama.jp", "yuasa.wakayama.jp", "yura.wakayama.jp", "asahi.yamagata.jp", "funagata.yamagata.jp", "higashine.yamagata.jp", "iide.yamagata.jp", "kahoku.yamagata.jp", "kaminoyama.yamagata.jp", "kaneyama.yamagata.jp", "kawanishi.yamagata.jp", "mamurogawa.yamagata.jp", "mikawa.yamagata.jp", "murayama.yamagata.jp", "nagai.yamagata.jp", "nakayama.yamagata.jp", "nanyo.yamagata.jp", "nishikawa.yamagata.jp", "obanazawa.yamagata.jp", "oe.yamagata.jp", "oguni.yamagata.jp", "ohkura.yamagata.jp", "oishida.yamagata.jp", "sagae.yamagata.jp", "sakata.yamagata.jp", "sakegawa.yamagata.jp", "shinjo.yamagata.jp", "shirataka.yamagata.jp", "shonai.yamagata.jp", "takahata.yamagata.jp", "tendo.yamagata.jp", "tozawa.yamagata.jp", "tsuruoka.yamagata.jp", "yamagata.yamagata.jp", "yamanobe.yamagata.jp", "yonezawa.yamagata.jp", "yuza.yamagata.jp", "abu.yamaguchi.jp", "hagi.yamaguchi.jp", "hikari.yamaguchi.jp", "hofu.yamaguchi.jp", "iwakuni.yamaguchi.jp", "kudamatsu.yamaguchi.jp", "mitou.yamaguchi.jp", "nagato.yamaguchi.jp", "oshima.yamaguchi.jp", "shimonoseki.yamaguchi.jp", "shunan.yamaguchi.jp", "tabuse.yamaguchi.jp", "tokuyama.yamaguchi.jp", "toyota.yamaguchi.jp", "ube.yamaguchi.jp", "yuu.yamaguchi.jp", "chuo.yamanashi.jp", "doshi.yamanashi.jp", "fuefuki.yamanashi.jp", "fujikawa.yamanashi.jp", "fujikawaguchiko.yamanashi.jp", "fujiyoshida.yamanashi.jp", "hayakawa.yamanashi.jp", "hokuto.yamanashi.jp", "ichikawamisato.yamanashi.jp", "kai.yamanashi.jp", "kofu.yamanashi.jp", "koshu.yamanashi.jp", "kosuge.yamanashi.jp", "minami-alps.yamanashi.jp", "minobu.yamanashi.jp", "nakamichi.yamanashi.jp", "nanbu.yamanashi.jp", "narusawa.yamanashi.jp", "nirasaki.yamanashi.jp", "nishikatsura.yamanashi.jp", "oshino.yamanashi.jp", "otsuki.yamanashi.jp", "showa.yamanashi.jp", "tabayama.yamanashi.jp", "tsuru.yamanashi.jp", "uenohara.yamanashi.jp", "yamanakako.yamanashi.jp", "yamanashi.yamanashi.jp", "ke", "ac.ke", "co.ke", "go.ke", "info.ke", "me.ke", "mobi.ke", "ne.ke", "or.ke", "sc.ke", "kg", "org.kg", "net.kg", "com.kg", "edu.kg", "gov.kg", "mil.kg", "*.kh", "ki", "edu.ki", "biz.ki", "net.ki", "org.ki", "gov.ki", "info.ki", "com.ki", "km", "org.km", "nom.km", "gov.km", "prd.km", "tm.km", "edu.km", "mil.km", "ass.km", "com.km", "coop.km", "asso.km", "presse.km", "medecin.km", "notaires.km", "pharmaciens.km", "veterinaire.km", "gouv.km", "kn", "net.kn", "org.kn", "edu.kn", "gov.kn", "kp", "com.kp", "edu.kp", "gov.kp", "org.kp", "rep.kp", "tra.kp", "kr", "ac.kr", "co.kr", "es.kr", "go.kr", "hs.kr", "kg.kr", "mil.kr", "ms.kr", "ne.kr", "or.kr", "pe.kr", "re.kr", "sc.kr", "busan.kr", "chungbuk.kr", "chungnam.kr", "daegu.kr", "daejeon.kr", "gangwon.kr", "gwangju.kr", "gyeongbuk.kr", "gyeonggi.kr", "gyeongnam.kr", "incheon.kr", "jeju.kr", "jeonbuk.kr", "jeonnam.kr", "seoul.kr", "ulsan.kr", "kw", "com.kw", "edu.kw", "emb.kw", "gov.kw", "ind.kw", "net.kw", "org.kw", "ky", "com.ky", "edu.ky", "net.ky", "org.ky", "kz", "org.kz", "edu.kz", "net.kz", "gov.kz", "mil.kz", "com.kz", "la", "int.la", "net.la", "info.la", "edu.la", "gov.la", "per.la", "com.la", "org.la", "lb", "com.lb", "edu.lb", "gov.lb", "net.lb", "org.lb", "lc", "com.lc", "net.lc", "co.lc", "org.lc", "edu.lc", "gov.lc", "li", "lk", "gov.lk", "sch.lk", "net.lk", "int.lk", "com.lk", "org.lk", "edu.lk", "ngo.lk", "soc.lk", "web.lk", "ltd.lk", "assn.lk", "grp.lk", "hotel.lk", "ac.lk", "lr", "com.lr", "edu.lr", "gov.lr", "org.lr", "net.lr", "ls", "ac.ls", "biz.ls", "co.ls", "edu.ls", "gov.ls", "info.ls", "net.ls", "org.ls", "sc.ls", "lt", "gov.lt", "lu", "lv", "com.lv", "edu.lv", "gov.lv", "org.lv", "mil.lv", "id.lv", "net.lv", "asn.lv", "conf.lv", "ly", "com.ly", "net.ly", "gov.ly", "plc.ly", "edu.ly", "sch.ly", "med.ly", "org.ly", "id.ly", "ma", "co.ma", "net.ma", "gov.ma", "org.ma", "ac.ma", "press.ma", "mc", "tm.mc", "asso.mc", "md", "me", "co.me", "net.me", "org.me", "edu.me", "ac.me", "gov.me", "its.me", "priv.me", "mg", "org.mg", "nom.mg", "gov.mg", "prd.mg", "tm.mg", "edu.mg", "mil.mg", "com.mg", "co.mg", "mh", "mil", "mk", "com.mk", "org.mk", "net.mk", "edu.mk", "gov.mk", "inf.mk", "name.mk", "ml", "com.ml", "edu.ml", "gouv.ml", "gov.ml", "net.ml", "org.ml", "presse.ml", "*.mm", "mn", "gov.mn", "edu.mn", "org.mn", "mo", "com.mo", "net.mo", "org.mo", "edu.mo", "gov.mo", "mobi", "mp", "mq", "mr", "gov.mr", "ms", "com.ms", "edu.ms", "gov.ms", "net.ms", "org.ms", "mt", "com.mt", "edu.mt", "net.mt", "org.mt", "mu", "com.mu", "net.mu", "org.mu", "gov.mu", "ac.mu", "co.mu", "or.mu", "museum", "academy.museum", "agriculture.museum", "air.museum", "airguard.museum", "alabama.museum", "alaska.museum", "amber.museum", "ambulance.museum", "american.museum", "americana.museum", "americanantiques.museum", "americanart.museum", "amsterdam.museum", "and.museum", "annefrank.museum", "anthro.museum", "anthropology.museum", "antiques.museum", "aquarium.museum", "arboretum.museum", "archaeological.museum", "archaeology.museum", "architecture.museum", "art.museum", "artanddesign.museum", "artcenter.museum", "artdeco.museum", "arteducation.museum", "artgallery.museum", "arts.museum", "artsandcrafts.museum", "asmatart.museum", "assassination.museum", "assisi.museum", "association.museum", "astronomy.museum", "atlanta.museum", "austin.museum", "australia.museum", "automotive.museum", "aviation.museum", "axis.museum", "badajoz.museum", "baghdad.museum", "bahn.museum", "bale.museum", "baltimore.museum", "barcelona.museum", "baseball.museum", "basel.museum", "baths.museum", "bauern.museum", "beauxarts.museum", "beeldengeluid.museum", "bellevue.museum", "bergbau.museum", "berkeley.museum", "berlin.museum", "bern.museum", "bible.museum", "bilbao.museum", "bill.museum", "birdart.museum", "birthplace.museum", "bonn.museum", "boston.museum", "botanical.museum", "botanicalgarden.museum", "botanicgarden.museum", "botany.museum", "brandywinevalley.museum", "brasil.museum", "bristol.museum", "british.museum", "britishcolumbia.museum", "broadcast.museum", "brunel.museum", "brussel.museum", "brussels.museum", "bruxelles.museum", "building.museum", "burghof.museum", "bus.museum", "bushey.museum", "cadaques.museum", "california.museum", "cambridge.museum", "can.museum", "canada.museum", "capebreton.museum", "carrier.museum", "cartoonart.museum", "casadelamoneda.museum", "castle.museum", "castres.museum", "celtic.museum", "center.museum", "chattanooga.museum", "cheltenham.museum", "chesapeakebay.museum", "chicago.museum", "children.museum", "childrens.museum", "childrensgarden.museum", "chiropractic.museum", "chocolate.museum", "christiansburg.museum", "cincinnati.museum", "cinema.museum", "circus.museum", "civilisation.museum", "civilization.museum", "civilwar.museum", "clinton.museum", "clock.museum", "coal.museum", "coastaldefence.museum", "cody.museum", "coldwar.museum", "collection.museum", "colonialwilliamsburg.museum", "coloradoplateau.museum", "columbia.museum", "columbus.museum", "communication.museum", "communications.museum", "community.museum", "computer.museum", "computerhistory.museum", "comunicações.museum", "contemporary.museum", "contemporaryart.museum", "convent.museum", "copenhagen.museum", "corporation.museum", "correios-e-telecomunicações.museum", "corvette.museum", "costume.museum", "countryestate.museum", "county.museum", "crafts.museum", "cranbrook.museum", "creation.museum", "cultural.museum", "culturalcenter.museum", "culture.museum", "cyber.museum", "cymru.museum", "dali.museum", "dallas.museum", "database.museum", "ddr.museum", "decorativearts.museum", "delaware.museum", "delmenhorst.museum", "denmark.museum", "depot.museum", "design.museum", "detroit.museum", "dinosaur.museum", "discovery.museum", "dolls.museum", "donostia.museum", "durham.museum", "eastafrica.museum", "eastcoast.museum", "education.museum", "educational.museum", "egyptian.museum", "eisenbahn.museum", "elburg.museum", "elvendrell.museum", "embroidery.museum", "encyclopedic.museum", "england.museum", "entomology.museum", "environment.museum", "environmentalconservation.museum", "epilepsy.museum", "essex.museum", "estate.museum", "ethnology.museum", "exeter.museum", "exhibition.museum", "family.museum", "farm.museum", "farmequipment.museum", "farmers.museum", "farmstead.museum", "field.museum", "figueres.museum", "filatelia.museum", "film.museum", "fineart.museum", "finearts.museum", "finland.museum", "flanders.museum", "florida.museum", "force.museum", "fortmissoula.museum", "fortworth.museum", "foundation.museum", "francaise.museum", "frankfurt.museum", "franziskaner.museum", "freemasonry.museum", "freiburg.museum", "fribourg.museum", "frog.museum", "fundacio.museum", "furniture.museum", "gallery.museum", "garden.museum", "gateway.museum", "geelvinck.museum", "gemological.museum", "geology.museum", "georgia.museum", "giessen.museum", "glas.museum", "glass.museum", "gorge.museum", "grandrapids.museum", "graz.museum", "guernsey.museum", "halloffame.museum", "hamburg.museum", "handson.museum", "harvestcelebration.museum", "hawaii.museum", "health.museum", "heimatunduhren.museum", "hellas.museum", "helsinki.museum", "hembygdsforbund.museum", "heritage.museum", "histoire.museum", "historical.museum", "historicalsociety.museum", "historichouses.museum", "historisch.museum", "historisches.museum", "history.museum", "historyofscience.museum", "horology.museum", "house.museum", "humanities.museum", "illustration.museum", "imageandsound.museum", "indian.museum", "indiana.museum", "indianapolis.museum", "indianmarket.museum", "intelligence.museum", "interactive.museum", "iraq.museum", "iron.museum", "isleofman.museum", "jamison.museum", "jefferson.museum", "jerusalem.museum", "jewelry.museum", "jewish.museum", "jewishart.museum", "jfk.museum", "journalism.museum", "judaica.museum", "judygarland.museum", "juedisches.museum", "juif.museum", "karate.museum", "karikatur.museum", "kids.museum", "koebenhavn.museum", "koeln.museum", "kunst.museum", "kunstsammlung.museum", "kunstunddesign.museum", "labor.museum", "labour.museum", "lajolla.museum", "lancashire.museum", "landes.museum", "lans.museum", "läns.museum", "larsson.museum", "lewismiller.museum", "lincoln.museum", "linz.museum", "living.museum", "livinghistory.museum", "localhistory.museum", "london.museum", "losangeles.museum", "louvre.museum", "loyalist.museum", "lucerne.museum", "luxembourg.museum", "luzern.museum", "mad.museum", "madrid.museum", "mallorca.museum", "manchester.museum", "mansion.museum", "mansions.museum", "manx.museum", "marburg.museum", "maritime.museum", "maritimo.museum", "maryland.museum", "marylhurst.museum", "media.museum", "medical.museum", "medizinhistorisches.museum", "meeres.museum", "memorial.museum", "mesaverde.museum", "michigan.museum", "midatlantic.museum", "military.museum", "mill.museum", "miners.museum", "mining.museum", "minnesota.museum", "missile.museum", "missoula.museum", "modern.museum", "moma.museum", "money.museum", "monmouth.museum", "monticello.museum", "montreal.museum", "moscow.museum", "motorcycle.museum", "muenchen.museum", "muenster.museum", "mulhouse.museum", "muncie.museum", "museet.museum", "museumcenter.museum", "museumvereniging.museum", "music.museum", "national.museum", "nationalfirearms.museum", "nationalheritage.museum", "nativeamerican.museum", "naturalhistory.museum", "naturalhistorymuseum.museum", "naturalsciences.museum", "nature.museum", "naturhistorisches.museum", "natuurwetenschappen.museum", "naumburg.museum", "naval.museum", "nebraska.museum", "neues.museum", "newhampshire.museum", "newjersey.museum", "newmexico.museum", "newport.museum", "newspaper.museum", "newyork.museum", "niepce.museum", "norfolk.museum", "north.museum", "nrw.museum", "nyc.museum", "nyny.museum", "oceanographic.museum", "oceanographique.museum", "omaha.museum", "online.museum", "ontario.museum", "openair.museum", "oregon.museum", "oregontrail.museum", "otago.museum", "oxford.museum", "pacific.museum", "paderborn.museum", "palace.museum", "paleo.museum", "palmsprings.museum", "panama.museum", "paris.museum", "pasadena.museum", "pharmacy.museum", "philadelphia.museum", "philadelphiaarea.museum", "philately.museum", "phoenix.museum", "photography.museum", "pilots.museum", "pittsburgh.museum", "planetarium.museum", "plantation.museum", "plants.museum", "plaza.museum", "portal.museum", "portland.museum", "portlligat.museum", "posts-and-telecommunications.museum", "preservation.museum", "presidio.museum", "press.museum", "project.museum", "public.museum", "pubol.museum", "quebec.museum", "railroad.museum", "railway.museum", "research.museum", "resistance.museum", "riodejaneiro.museum", "rochester.museum", "rockart.museum", "roma.museum", "russia.museum", "saintlouis.museum", "salem.museum", "salvadordali.museum", "salzburg.museum", "sandiego.museum", "sanfrancisco.museum", "santabarbara.museum", "santacruz.museum", "santafe.museum", "saskatchewan.museum", "satx.museum", "savannahga.museum", "schlesisches.museum", "schoenbrunn.museum", "schokoladen.museum", "school.museum", "schweiz.museum", "science.museum", "scienceandhistory.museum", "scienceandindustry.museum", "sciencecenter.museum", "sciencecenters.museum", "science-fiction.museum", "sciencehistory.museum", "sciences.museum", "sciencesnaturelles.museum", "scotland.museum", "seaport.museum", "settlement.museum", "settlers.museum", "shell.museum", "sherbrooke.museum", "sibenik.museum", "silk.museum", "ski.museum", "skole.museum", "society.museum", "sologne.museum", "soundandvision.museum", "southcarolina.museum", "southwest.museum", "space.museum", "spy.museum", "square.museum", "stadt.museum", "stalbans.museum", "starnberg.museum", "state.museum", "stateofdelaware.museum", "station.museum", "steam.museum", "steiermark.museum", "stjohn.museum", "stockholm.museum", "stpetersburg.museum", "stuttgart.museum", "suisse.museum", "surgeonshall.museum", "surrey.museum", "svizzera.museum", "sweden.museum", "sydney.museum", "tank.museum", "tcm.museum", "technology.museum", "telekommunikation.museum", "television.museum", "texas.museum", "textile.museum", "theater.museum", "time.museum", "timekeeping.museum", "topology.museum", "torino.museum", "touch.museum", "town.museum", "transport.museum", "tree.museum", "trolley.museum", "trust.museum", "trustee.museum", "uhren.museum", "ulm.museum", "undersea.museum", "university.museum", "usa.museum", "usantiques.museum", "usarts.museum", "uscountryestate.museum", "usculture.museum", "usdecorativearts.museum", "usgarden.museum", "ushistory.museum", "ushuaia.museum", "uslivinghistory.museum", "utah.museum", "uvic.museum", "valley.museum", "vantaa.museum", "versailles.museum", "viking.museum", "village.museum", "virginia.museum", "virtual.museum", "virtuel.museum", "vlaanderen.museum", "volkenkunde.museum", "wales.museum", "wallonie.museum", "war.museum", "washingtondc.museum", "watchandclock.museum", "watch-and-clock.museum", "western.museum", "westfalen.museum", "whaling.museum", "wildlife.museum", "williamsburg.museum", "windmill.museum", "workshop.museum", "york.museum", "yorkshire.museum", "yosemite.museum", "youth.museum", "zoological.museum", "zoology.museum", "ירושלים.museum", "иком.museum", "mv", "aero.mv", "biz.mv", "com.mv", "coop.mv", "edu.mv", "gov.mv", "info.mv", "int.mv", "mil.mv", "museum.mv", "name.mv", "net.mv", "org.mv", "pro.mv", "mw", "ac.mw", "biz.mw", "co.mw", "com.mw", "coop.mw", "edu.mw", "gov.mw", "int.mw", "museum.mw", "net.mw", "org.mw", "mx", "com.mx", "org.mx", "gob.mx", "edu.mx", "net.mx", "my", "biz.my", "com.my", "edu.my", "gov.my", "mil.my", "name.my", "net.my", "org.my", "mz", "ac.mz", "adv.mz", "co.mz", "edu.mz", "gov.mz", "mil.mz", "net.mz", "org.mz", "na", "info.na", "pro.na", "name.na", "school.na", "or.na", "dr.na", "us.na", "mx.na", "ca.na", "in.na", "cc.na", "tv.na", "ws.na", "mobi.na", "co.na", "com.na", "org.na", "name", "nc", "asso.nc", "nom.nc", "ne", "net", "nf", "com.nf", "net.nf", "per.nf", "rec.nf", "web.nf", "arts.nf", "firm.nf", "info.nf", "other.nf", "store.nf", "ng", "com.ng", "edu.ng", "gov.ng", "i.ng", "mil.ng", "mobi.ng", "name.ng", "net.ng", "org.ng", "sch.ng", "ni", "ac.ni", "biz.ni", "co.ni", "com.ni", "edu.ni", "gob.ni", "in.ni", "info.ni", "int.ni", "mil.ni", "net.ni", "nom.ni", "org.ni", "web.ni", "nl", "no", "fhs.no", "vgs.no", "fylkesbibl.no", "folkebibl.no", "museum.no", "idrett.no", "priv.no", "mil.no", "stat.no", "dep.no", "kommune.no", "herad.no", "aa.no", "ah.no", "bu.no", "fm.no", "hl.no", "hm.no", "jan-mayen.no", "mr.no", "nl.no", "nt.no", "of.no", "ol.no", "oslo.no", "rl.no", "sf.no", "st.no", "svalbard.no", "tm.no", "tr.no", "va.no", "vf.no", "gs.aa.no", "gs.ah.no", "gs.bu.no", "gs.fm.no", "gs.hl.no", "gs.hm.no", "gs.jan-mayen.no", "gs.mr.no", "gs.nl.no", "gs.nt.no", "gs.of.no", "gs.ol.no", "gs.oslo.no", "gs.rl.no", "gs.sf.no", "gs.st.no", "gs.svalbard.no", "gs.tm.no", "gs.tr.no", "gs.va.no", "gs.vf.no", "akrehamn.no", "åkrehamn.no", "algard.no", "ålgård.no", "arna.no", "brumunddal.no", "bryne.no", "bronnoysund.no", "brønnøysund.no", "drobak.no", "drøbak.no", "egersund.no", "fetsund.no", "floro.no", "florø.no", "fredrikstad.no", "hokksund.no", "honefoss.no", "hønefoss.no", "jessheim.no", "jorpeland.no", "jørpeland.no", "kirkenes.no", "kopervik.no", "krokstadelva.no", "langevag.no", "langevåg.no", "leirvik.no", "mjondalen.no", "mjøndalen.no", "mo-i-rana.no", "mosjoen.no", "mosjøen.no", "nesoddtangen.no", "orkanger.no", "osoyro.no", "osøyro.no", "raholt.no", "råholt.no", "sandnessjoen.no", "sandnessjøen.no", "skedsmokorset.no", "slattum.no", "spjelkavik.no", "stathelle.no", "stavern.no", "stjordalshalsen.no", "stjørdalshalsen.no", "tananger.no", "tranby.no", "vossevangen.no", "afjord.no", "åfjord.no", "agdenes.no", "al.no", "ål.no", "alesund.no", "ålesund.no", "alstahaug.no", "alta.no", "áltá.no", "alaheadju.no", "álaheadju.no", "alvdal.no", "amli.no", "åmli.no", "amot.no", "åmot.no", "andebu.no", "andoy.no", "andøy.no", "andasuolo.no", "ardal.no", "årdal.no", "aremark.no", "arendal.no", "ås.no", "aseral.no", "åseral.no", "asker.no", "askim.no", "askvoll.no", "askoy.no", "askøy.no", "asnes.no", "åsnes.no", "audnedaln.no", "aukra.no", "aure.no", "aurland.no", "aurskog-holand.no", "aurskog-høland.no", "austevoll.no", "austrheim.no", "averoy.no", "averøy.no", "balestrand.no", "ballangen.no", "balat.no", "bálát.no", "balsfjord.no", "bahccavuotna.no", "báhccavuotna.no", "bamble.no", "bardu.no", "beardu.no", "beiarn.no", "bajddar.no", "bájddar.no", "baidar.no", "báidár.no", "berg.no", "bergen.no", "berlevag.no", "berlevåg.no", "bearalvahki.no", "bearalváhki.no", "bindal.no", "birkenes.no", "bjarkoy.no", "bjarkøy.no", "bjerkreim.no", "bjugn.no", "bodo.no", "bodø.no", "badaddja.no", "bådåddjå.no", "budejju.no", "bokn.no", "bremanger.no", "bronnoy.no", "brønnøy.no", "bygland.no", "bykle.no", "barum.no", "bærum.no", "bo.telemark.no", "bø.telemark.no", "bo.nordland.no", "bø.nordland.no", "bievat.no", "bievát.no", "bomlo.no", "bømlo.no", "batsfjord.no", "båtsfjord.no", "bahcavuotna.no", "báhcavuotna.no", "dovre.no", "drammen.no", "drangedal.no", "dyroy.no", "dyrøy.no", "donna.no", "dønna.no", "eid.no", "eidfjord.no", "eidsberg.no", "eidskog.no", "eidsvoll.no", "eigersund.no", "elverum.no", "enebakk.no", "engerdal.no", "etne.no", "etnedal.no", "evenes.no", "evenassi.no", "evenášši.no", "evje-og-hornnes.no", "farsund.no", "fauske.no", "fuossko.no", "fuoisku.no", "fedje.no", "fet.no", "finnoy.no", "finnøy.no", "fitjar.no", "fjaler.no", "fjell.no", "flakstad.no", "flatanger.no", "flekkefjord.no", "flesberg.no", "flora.no", "fla.no", "flå.no", "folldal.no", "forsand.no", "fosnes.no", "frei.no", "frogn.no", "froland.no", "frosta.no", "frana.no", "fræna.no", "froya.no", "frøya.no", "fusa.no", "fyresdal.no", "forde.no", "førde.no", "gamvik.no", "gangaviika.no", "gáŋgaviika.no", "gaular.no", "gausdal.no", "gildeskal.no", "gildeskål.no", "giske.no", "gjemnes.no", "gjerdrum.no", "gjerstad.no", "gjesdal.no", "gjovik.no", "gjøvik.no", "gloppen.no", "gol.no", "gran.no", "grane.no", "granvin.no", "gratangen.no", "grimstad.no", "grong.no", "kraanghke.no", "kråanghke.no", "grue.no", "gulen.no", "hadsel.no", "halden.no", "halsa.no", "hamar.no", "hamaroy.no", "habmer.no", "hábmer.no", "hapmir.no", "hápmir.no", "hammerfest.no", "hammarfeasta.no", "hámmárfeasta.no", "haram.no", "hareid.no", "harstad.no", "hasvik.no", "aknoluokta.no", "ákŋoluokta.no", "hattfjelldal.no", "aarborte.no", "haugesund.no", "hemne.no", "hemnes.no", "hemsedal.no", "heroy.more-og-romsdal.no", "herøy.møre-og-romsdal.no", "heroy.nordland.no", "herøy.nordland.no", "hitra.no", "hjartdal.no", "hjelmeland.no", "hobol.no", "hobøl.no", "hof.no", "hol.no", "hole.no", "holmestrand.no", "holtalen.no", "holtålen.no", "hornindal.no", "horten.no", "hurdal.no", "hurum.no", "hvaler.no", "hyllestad.no", "hagebostad.no", "hægebostad.no", "hoyanger.no", "høyanger.no", "hoylandet.no", "høylandet.no", "ha.no", "hå.no", "ibestad.no", "inderoy.no", "inderøy.no", "iveland.no", "jevnaker.no", "jondal.no", "jolster.no", "jølster.no", "karasjok.no", "karasjohka.no", "kárášjohka.no", "karlsoy.no", "galsa.no", "gálsá.no", "karmoy.no", "karmøy.no", "kautokeino.no", "guovdageaidnu.no", "klepp.no", "klabu.no", "klæbu.no", "kongsberg.no", "kongsvinger.no", "kragero.no", "kragerø.no", "kristiansand.no", "kristiansund.no", "krodsherad.no", "krødsherad.no", "kvalsund.no", "rahkkeravju.no", "ráhkkerávju.no", "kvam.no", "kvinesdal.no", "kvinnherad.no", "kviteseid.no", "kvitsoy.no", "kvitsøy.no", "kvafjord.no", "kvæfjord.no", "giehtavuoatna.no", "kvanangen.no", "kvænangen.no", "navuotna.no", "návuotna.no", "kafjord.no", "kåfjord.no", "gaivuotna.no", "gáivuotna.no", "larvik.no", "lavangen.no", "lavagis.no", "loabat.no", "loabát.no", "lebesby.no", "davvesiida.no", "leikanger.no", "leirfjord.no", "leka.no", "leksvik.no", "lenvik.no", "leangaviika.no", "leaŋgaviika.no", "lesja.no", "levanger.no", "lier.no", "lierne.no", "lillehammer.no", "lillesand.no", "lindesnes.no", "lindas.no", "lindås.no", "lom.no", "loppa.no", "lahppi.no", "láhppi.no", "lund.no", "lunner.no", "luroy.no", "lurøy.no", "luster.no", "lyngdal.no", "lyngen.no", "ivgu.no", "lardal.no", "lerdal.no", "lærdal.no", "lodingen.no", "lødingen.no", "lorenskog.no", "lørenskog.no", "loten.no", "løten.no", "malvik.no", "masoy.no", "måsøy.no", "muosat.no", "muosát.no", "mandal.no", "marker.no", "marnardal.no", "masfjorden.no", "meland.no", "meldal.no", "melhus.no", "meloy.no", "meløy.no", "meraker.no", "meråker.no", "moareke.no", "moåreke.no", "midsund.no", "midtre-gauldal.no", "modalen.no", "modum.no", "molde.no", "moskenes.no", "moss.no", "mosvik.no", "malselv.no", "målselv.no", "malatvuopmi.no", "málatvuopmi.no", "namdalseid.no", "aejrie.no", "namsos.no", "namsskogan.no", "naamesjevuemie.no", "nååmesjevuemie.no", "laakesvuemie.no", "nannestad.no", "narvik.no", "narviika.no", "naustdal.no", "nedre-eiker.no", "nes.akershus.no", "nes.buskerud.no", "nesna.no", "nesodden.no", "nesseby.no", "unjarga.no", "unjárga.no", "nesset.no", "nissedal.no", "nittedal.no", "nord-aurdal.no", "nord-fron.no", "nord-odal.no", "norddal.no", "nordkapp.no", "davvenjarga.no", "davvenjárga.no", "nordre-land.no", "nordreisa.no", "raisa.no", "ráisa.no", "nore-og-uvdal.no", "notodden.no", "naroy.no", "nærøy.no", "notteroy.no", "nøtterøy.no", "odda.no", "oksnes.no", "øksnes.no", "oppdal.no", "oppegard.no", "oppegård.no", "orkdal.no", "orland.no", "ørland.no", "orskog.no", "ørskog.no", "orsta.no", "ørsta.no", "os.hedmark.no", "os.hordaland.no", "osen.no", "osteroy.no", "osterøy.no", "ostre-toten.no", "østre-toten.no", "overhalla.no", "ovre-eiker.no", "øvre-eiker.no", "oyer.no", "øyer.no", "oygarden.no", "øygarden.no", "oystre-slidre.no", "øystre-slidre.no", "porsanger.no", "porsangu.no", "porsáŋgu.no", "porsgrunn.no", "radoy.no", "radøy.no", "rakkestad.no", "rana.no", "ruovat.no", "randaberg.no", "rauma.no", "rendalen.no", "rennebu.no", "rennesoy.no", "rennesøy.no", "rindal.no", "ringebu.no", "ringerike.no", "ringsaker.no", "rissa.no", "risor.no", "risør.no", "roan.no", "rollag.no", "rygge.no", "ralingen.no", "rælingen.no", "rodoy.no", "rødøy.no", "romskog.no", "rømskog.no", "roros.no", "røros.no", "rost.no", "røst.no", "royken.no", "røyken.no", "royrvik.no", "røyrvik.no", "rade.no", "råde.no", "salangen.no", "siellak.no", "saltdal.no", "salat.no", "sálát.no", "sálat.no", "samnanger.no", "sande.more-og-romsdal.no", "sande.møre-og-romsdal.no", "sande.vestfold.no", "sandefjord.no", "sandnes.no", "sandoy.no", "sandøy.no", "sarpsborg.no", "sauda.no", "sauherad.no", "sel.no", "selbu.no", "selje.no", "seljord.no", "sigdal.no", "siljan.no", "sirdal.no", "skaun.no", "skedsmo.no", "ski.no", "skien.no", "skiptvet.no", "skjervoy.no", "skjervøy.no", "skierva.no", "skiervá.no", "skjak.no", "skjåk.no", "skodje.no", "skanland.no", "skånland.no", "skanit.no", "skánit.no", "smola.no", "smøla.no", "snillfjord.no", "snasa.no", "snåsa.no", "snoasa.no", "snaase.no", "snåase.no", "sogndal.no", "sokndal.no", "sola.no", "solund.no", "songdalen.no", "sortland.no", "spydeberg.no", "stange.no", "stavanger.no", "steigen.no", "steinkjer.no", "stjordal.no", "stjørdal.no", "stokke.no", "stor-elvdal.no", "stord.no", "stordal.no", "storfjord.no", "omasvuotna.no", "strand.no", "stranda.no", "stryn.no", "sula.no", "suldal.no", "sund.no", "sunndal.no", "surnadal.no", "sveio.no", "svelvik.no", "sykkylven.no", "sogne.no", "søgne.no", "somna.no", "sømna.no", "sondre-land.no", "søndre-land.no", "sor-aurdal.no", "sør-aurdal.no", "sor-fron.no", "sør-fron.no", "sor-odal.no", "sør-odal.no", "sor-varanger.no", "sør-varanger.no", "matta-varjjat.no", "mátta-várjjat.no", "sorfold.no", "sørfold.no", "sorreisa.no", "sørreisa.no", "sorum.no", "sørum.no", "tana.no", "deatnu.no", "time.no", "tingvoll.no", "tinn.no", "tjeldsund.no", "dielddanuorri.no", "tjome.no", "tjøme.no", "tokke.no", "tolga.no", "torsken.no", "tranoy.no", "tranøy.no", "tromso.no", "tromsø.no", "tromsa.no", "romsa.no", "trondheim.no", "troandin.no", "trysil.no", "trana.no", "træna.no", "trogstad.no", "trøgstad.no", "tvedestrand.no", "tydal.no", "tynset.no", "tysfjord.no", "divtasvuodna.no", "divttasvuotna.no", "tysnes.no", "tysvar.no", "tysvær.no", "tonsberg.no", "tønsberg.no", "ullensaker.no", "ullensvang.no", "ulvik.no", "utsira.no", "vadso.no", "vadsø.no", "cahcesuolo.no", "čáhcesuolo.no", "vaksdal.no", "valle.no", "vang.no", "vanylven.no", "vardo.no", "vardø.no", "varggat.no", "várggát.no", "vefsn.no", "vaapste.no", "vega.no", "vegarshei.no", "vegårshei.no", "vennesla.no", "verdal.no", "verran.no", "vestby.no", "vestnes.no", "vestre-slidre.no", "vestre-toten.no", "vestvagoy.no", "vestvågøy.no", "vevelstad.no", "vik.no", "vikna.no", "vindafjord.no", "volda.no", "voss.no", "varoy.no", "værøy.no", "vagan.no", "vågan.no", "voagat.no", "vagsoy.no", "vågsøy.no", "vaga.no", "vågå.no", "valer.ostfold.no", "våler.østfold.no", "valer.hedmark.no", "våler.hedmark.no", "*.np", "nr", "biz.nr", "info.nr", "gov.nr", "edu.nr", "org.nr", "net.nr", "com.nr", "nu", "nz", "ac.nz", "co.nz", "cri.nz", "geek.nz", "gen.nz", "govt.nz", "health.nz", "iwi.nz", "kiwi.nz", "maori.nz", "mil.nz", "māori.nz", "net.nz", "org.nz", "parliament.nz", "school.nz", "om", "co.om", "com.om", "edu.om", "gov.om", "med.om", "museum.om", "net.om", "org.om", "pro.om", "onion", "org", "pa", "ac.pa", "gob.pa", "com.pa", "org.pa", "sld.pa", "edu.pa", "net.pa", "ing.pa", "abo.pa", "med.pa", "nom.pa", "pe", "edu.pe", "gob.pe", "nom.pe", "mil.pe", "org.pe", "com.pe", "net.pe", "pf", "com.pf", "org.pf", "edu.pf", "*.pg", "ph", "com.ph", "net.ph", "org.ph", "gov.ph", "edu.ph", "ngo.ph", "mil.ph", "i.ph", "pk", "com.pk", "net.pk", "edu.pk", "org.pk", "fam.pk", "biz.pk", "web.pk", "gov.pk", "gob.pk", "gok.pk", "gon.pk", "gop.pk", "gos.pk", "info.pk", "pl", "com.pl", "net.pl", "org.pl", "aid.pl", "agro.pl", "atm.pl", "auto.pl", "biz.pl", "edu.pl", "gmina.pl", "gsm.pl", "info.pl", "mail.pl", "miasta.pl", "media.pl", "mil.pl", "nieruchomosci.pl", "nom.pl", "pc.pl", "powiat.pl", "priv.pl", "realestate.pl", "rel.pl", "sex.pl", "shop.pl", "sklep.pl", "sos.pl", "szkola.pl", "targi.pl", "tm.pl", "tourism.pl", "travel.pl", "turystyka.pl", "gov.pl", "ap.gov.pl", "ic.gov.pl", "is.gov.pl", "us.gov.pl", "kmpsp.gov.pl", "kppsp.gov.pl", "kwpsp.gov.pl", "psp.gov.pl", "wskr.gov.pl", "kwp.gov.pl", "mw.gov.pl", "ug.gov.pl", "um.gov.pl", "umig.gov.pl", "ugim.gov.pl", "upow.gov.pl", "uw.gov.pl", "starostwo.gov.pl", "pa.gov.pl", "po.gov.pl", "psse.gov.pl", "pup.gov.pl", "rzgw.gov.pl", "sa.gov.pl", "so.gov.pl", "sr.gov.pl", "wsa.gov.pl", "sko.gov.pl", "uzs.gov.pl", "wiih.gov.pl", "winb.gov.pl", "pinb.gov.pl", "wios.gov.pl", "witd.gov.pl", "wzmiuw.gov.pl", "piw.gov.pl", "wiw.gov.pl", "griw.gov.pl", "wif.gov.pl", "oum.gov.pl", "sdn.gov.pl", "zp.gov.pl", "uppo.gov.pl", "mup.gov.pl", "wuoz.gov.pl", "konsulat.gov.pl", "oirm.gov.pl", "augustow.pl", "babia-gora.pl", "bedzin.pl", "beskidy.pl", "bialowieza.pl", "bialystok.pl", "bielawa.pl", "bieszczady.pl", "boleslawiec.pl", "bydgoszcz.pl", "bytom.pl", "cieszyn.pl", "czeladz.pl", "czest.pl", "dlugoleka.pl", "elblag.pl", "elk.pl", "glogow.pl", "gniezno.pl", "gorlice.pl", "grajewo.pl", "ilawa.pl", "jaworzno.pl", "jelenia-gora.pl", "jgora.pl", "kalisz.pl", "kazimierz-dolny.pl", "karpacz.pl", "kartuzy.pl", "kaszuby.pl", "katowice.pl", "kepno.pl", "ketrzyn.pl", "klodzko.pl", "kobierzyce.pl", "kolobrzeg.pl", "konin.pl", "konskowola.pl", "kutno.pl", "lapy.pl", "lebork.pl", "legnica.pl", "lezajsk.pl", "limanowa.pl", "lomza.pl", "lowicz.pl", "lubin.pl", "lukow.pl", "malbork.pl", "malopolska.pl", "mazowsze.pl", "mazury.pl", "mielec.pl", "mielno.pl", "mragowo.pl", "naklo.pl", "nowaruda.pl", "nysa.pl", "olawa.pl", "olecko.pl", "olkusz.pl", "olsztyn.pl", "opoczno.pl", "opole.pl", "ostroda.pl", "ostroleka.pl", "ostrowiec.pl", "ostrowwlkp.pl", "pila.pl", "pisz.pl", "podhale.pl", "podlasie.pl", "polkowice.pl", "pomorze.pl", "pomorskie.pl", "prochowice.pl", "pruszkow.pl", "przeworsk.pl", "pulawy.pl", "radom.pl", "rawa-maz.pl", "rybnik.pl", "rzeszow.pl", "sanok.pl", "sejny.pl", "slask.pl", "slupsk.pl", "sosnowiec.pl", "stalowa-wola.pl", "skoczow.pl", "starachowice.pl", "stargard.pl", "suwalki.pl", "swidnica.pl", "swiebodzin.pl", "swinoujscie.pl", "szczecin.pl", "szczytno.pl", "tarnobrzeg.pl", "tgory.pl", "turek.pl", "tychy.pl", "ustka.pl", "walbrzych.pl", "warmia.pl", "warszawa.pl", "waw.pl", "wegrow.pl", "wielun.pl", "wlocl.pl", "wloclawek.pl", "wodzislaw.pl", "wolomin.pl", "wroclaw.pl", "zachpomor.pl", "zagan.pl", "zarow.pl", "zgora.pl", "zgorzelec.pl", "pm", "pn", "gov.pn", "co.pn", "org.pn", "edu.pn", "net.pn", "post", "pr", "com.pr", "net.pr", "org.pr", "gov.pr", "edu.pr", "isla.pr", "pro.pr", "biz.pr", "info.pr", "name.pr", "est.pr", "prof.pr", "ac.pr", "pro", "aaa.pro", "aca.pro", "acct.pro", "avocat.pro", "bar.pro", "cpa.pro", "eng.pro", "jur.pro", "law.pro", "med.pro", "recht.pro", "ps", "edu.ps", "gov.ps", "sec.ps", "plo.ps", "com.ps", "org.ps", "net.ps", "pt", "net.pt", "gov.pt", "org.pt", "edu.pt", "int.pt", "publ.pt", "com.pt", "nome.pt", "pw", "co.pw", "ne.pw", "or.pw", "ed.pw", "go.pw", "belau.pw", "py", "com.py", "coop.py", "edu.py", "gov.py", "mil.py", "net.py", "org.py", "qa", "com.qa", "edu.qa", "gov.qa", "mil.qa", "name.qa", "net.qa", "org.qa", "sch.qa", "re", "asso.re", "com.re", "nom.re", "ro", "arts.ro", "com.ro", "firm.ro", "info.ro", "nom.ro", "nt.ro", "org.ro", "rec.ro", "store.ro", "tm.ro", "www.ro", "rs", "ac.rs", "co.rs", "edu.rs", "gov.rs", "in.rs", "org.rs", "ru", "rw", "ac.rw", "co.rw", "coop.rw", "gov.rw", "mil.rw", "net.rw", "org.rw", "sa", "com.sa", "net.sa", "org.sa", "gov.sa", "med.sa", "pub.sa", "edu.sa", "sch.sa", "sb", "com.sb", "edu.sb", "gov.sb", "net.sb", "org.sb", "sc", "com.sc", "gov.sc", "net.sc", "org.sc", "edu.sc", "sd", "com.sd", "net.sd", "org.sd", "edu.sd", "med.sd", "tv.sd", "gov.sd", "info.sd", "se", "a.se", "ac.se", "b.se", "bd.se", "brand.se", "c.se", "d.se", "e.se", "f.se", "fh.se", "fhsk.se", "fhv.se", "g.se", "h.se", "i.se", "k.se", "komforb.se", "kommunalforbund.se", "komvux.se", "l.se", "lanbib.se", "m.se", "n.se", "naturbruksgymn.se", "o.se", "org.se", "p.se", "parti.se", "pp.se", "press.se", "r.se", "s.se", "t.se", "tm.se", "u.se", "w.se", "x.se", "y.se", "z.se", "sg", "com.sg", "net.sg", "org.sg", "gov.sg", "edu.sg", "per.sg", "sh", "com.sh", "net.sh", "gov.sh", "org.sh", "mil.sh", "si", "sj", "sk", "sl", "com.sl", "net.sl", "edu.sl", "gov.sl", "org.sl", "sm", "sn", "art.sn", "com.sn", "edu.sn", "gouv.sn", "org.sn", "perso.sn", "univ.sn", "so", "com.so", "edu.so", "gov.so", "me.so", "net.so", "org.so", "sr", "ss", "biz.ss", "com.ss", "edu.ss", "gov.ss", "me.ss", "net.ss", "org.ss", "sch.ss", "st", "co.st", "com.st", "consulado.st", "edu.st", "embaixada.st", "mil.st", "net.st", "org.st", "principe.st", "saotome.st", "store.st", "su", "sv", "com.sv", "edu.sv", "gob.sv", "org.sv", "red.sv", "sx", "gov.sx", "sy", "edu.sy", "gov.sy", "net.sy", "mil.sy", "com.sy", "org.sy", "sz", "co.sz", "ac.sz", "org.sz", "tc", "td", "tel", "tf", "tg", "th", "ac.th", "co.th", "go.th", "in.th", "mi.th", "net.th", "or.th", "tj", "ac.tj", "biz.tj", "co.tj", "com.tj", "edu.tj", "go.tj", "gov.tj", "int.tj", "mil.tj", "name.tj", "net.tj", "nic.tj", "org.tj", "test.tj", "web.tj", "tk", "tl", "gov.tl", "tm", "com.tm", "co.tm", "org.tm", "net.tm", "nom.tm", "gov.tm", "mil.tm", "edu.tm", "tn", "com.tn", "ens.tn", "fin.tn", "gov.tn", "ind.tn", "info.tn", "intl.tn", "mincom.tn", "nat.tn", "net.tn", "org.tn", "perso.tn", "tourism.tn", "to", "com.to", "gov.to", "net.to", "org.to", "edu.to", "mil.to", "tr", "av.tr", "bbs.tr", "bel.tr", "biz.tr", "com.tr", "dr.tr", "edu.tr", "gen.tr", "gov.tr", "info.tr", "mil.tr", "k12.tr", "kep.tr", "name.tr", "net.tr", "org.tr", "pol.tr", "tel.tr", "tsk.tr", "tv.tr", "web.tr", "nc.tr", "gov.nc.tr", "tt", "co.tt", "com.tt", "org.tt", "net.tt", "biz.tt", "info.tt", "pro.tt", "int.tt", "coop.tt", "jobs.tt", "mobi.tt", "travel.tt", "museum.tt", "aero.tt", "name.tt", "gov.tt", "edu.tt", "tv", "tw", "edu.tw", "gov.tw", "mil.tw", "com.tw", "net.tw", "org.tw", "idv.tw", "game.tw", "ebiz.tw", "club.tw", "網路.tw", "組織.tw", "商業.tw", "tz", "ac.tz", "co.tz", "go.tz", "hotel.tz", "info.tz", "me.tz", "mil.tz", "mobi.tz", "ne.tz", "or.tz", "sc.tz", "tv.tz", "ua", "com.ua", "edu.ua", "gov.ua", "in.ua", "net.ua", "org.ua", "cherkassy.ua", "cherkasy.ua", "chernigov.ua", "chernihiv.ua", "chernivtsi.ua", "chernovtsy.ua", "ck.ua", "cn.ua", "cr.ua", "crimea.ua", "cv.ua", "dn.ua", "dnepropetrovsk.ua", "dnipropetrovsk.ua", "donetsk.ua", "dp.ua", "if.ua", "ivano-frankivsk.ua", "kh.ua", "kharkiv.ua", "kharkov.ua", "kherson.ua", "khmelnitskiy.ua", "khmelnytskyi.ua", "kiev.ua", "kirovograd.ua", "km.ua", "kr.ua", "krym.ua", "ks.ua", "kv.ua", "kyiv.ua", "lg.ua", "lt.ua", "lugansk.ua", "lutsk.ua", "lv.ua", "lviv.ua", "mk.ua", "mykolaiv.ua", "nikolaev.ua", "od.ua", "odesa.ua", "odessa.ua", "pl.ua", "poltava.ua", "rivne.ua", "rovno.ua", "rv.ua", "sb.ua", "sebastopol.ua", "sevastopol.ua", "sm.ua", "sumy.ua", "te.ua", "ternopil.ua", "uz.ua", "uzhgorod.ua", "vinnica.ua", "vinnytsia.ua", "vn.ua", "volyn.ua", "yalta.ua", "zaporizhzhe.ua", "zaporizhzhia.ua", "zhitomir.ua", "zhytomyr.ua", "zp.ua", "zt.ua", "ug", "co.ug", "or.ug", "ac.ug", "sc.ug", "go.ug", "ne.ug", "com.ug", "org.ug", "uk", "ac.uk", "co.uk", "gov.uk", "ltd.uk", "me.uk", "net.uk", "nhs.uk", "org.uk", "plc.uk", "police.uk", "*.sch.uk", "us", "dni.us", "fed.us", "isa.us", "kids.us", "nsn.us", "ak.us", "al.us", "ar.us", "as.us", "az.us", "ca.us", "co.us", "ct.us", "dc.us", "de.us", "fl.us", "ga.us", "gu.us", "hi.us", "ia.us", "id.us", "il.us", "in.us", "ks.us", "ky.us", "la.us", "ma.us", "md.us", "me.us", "mi.us", "mn.us", "mo.us", "ms.us", "mt.us", "nc.us", "nd.us", "ne.us", "nh.us", "nj.us", "nm.us", "nv.us", "ny.us", "oh.us", "ok.us", "or.us", "pa.us", "pr.us", "ri.us", "sc.us", "sd.us", "tn.us", "tx.us", "ut.us", "vi.us", "vt.us", "va.us", "wa.us", "wi.us", "wv.us", "wy.us", "k12.ak.us", "k12.al.us", "k12.ar.us", "k12.as.us", "k12.az.us", "k12.ca.us", "k12.co.us", "k12.ct.us", "k12.dc.us", "k12.de.us", "k12.fl.us", "k12.ga.us", "k12.gu.us", "k12.ia.us", "k12.id.us", "k12.il.us", "k12.in.us", "k12.ks.us", "k12.ky.us", "k12.la.us", "k12.ma.us", "k12.md.us", "k12.me.us", "k12.mi.us", "k12.mn.us", "k12.mo.us", "k12.ms.us", "k12.mt.us", "k12.nc.us", "k12.ne.us", "k12.nh.us", "k12.nj.us", "k12.nm.us", "k12.nv.us", "k12.ny.us", "k12.oh.us", "k12.ok.us", "k12.or.us", "k12.pa.us", "k12.pr.us", "k12.sc.us", "k12.tn.us", "k12.tx.us", "k12.ut.us", "k12.vi.us", "k12.vt.us", "k12.va.us", "k12.wa.us", "k12.wi.us", "k12.wy.us", "cc.ak.us", "cc.al.us", "cc.ar.us", "cc.as.us", "cc.az.us", "cc.ca.us", "cc.co.us", "cc.ct.us", "cc.dc.us", "cc.de.us", "cc.fl.us", "cc.ga.us", "cc.gu.us", "cc.hi.us", "cc.ia.us", "cc.id.us", "cc.il.us", "cc.in.us", "cc.ks.us", "cc.ky.us", "cc.la.us", "cc.ma.us", "cc.md.us", "cc.me.us", "cc.mi.us", "cc.mn.us", "cc.mo.us", "cc.ms.us", "cc.mt.us", "cc.nc.us", "cc.nd.us", "cc.ne.us", "cc.nh.us", "cc.nj.us", "cc.nm.us", "cc.nv.us", "cc.ny.us", "cc.oh.us", "cc.ok.us", "cc.or.us", "cc.pa.us", "cc.pr.us", "cc.ri.us", "cc.sc.us", "cc.sd.us", "cc.tn.us", "cc.tx.us", "cc.ut.us", "cc.vi.us", "cc.vt.us", "cc.va.us", "cc.wa.us", "cc.wi.us", "cc.wv.us", "cc.wy.us", "lib.ak.us", "lib.al.us", "lib.ar.us", "lib.as.us", "lib.az.us", "lib.ca.us", "lib.co.us", "lib.ct.us", "lib.dc.us", "lib.fl.us", "lib.ga.us", "lib.gu.us", "lib.hi.us", "lib.ia.us", "lib.id.us", "lib.il.us", "lib.in.us", "lib.ks.us", "lib.ky.us", "lib.la.us", "lib.ma.us", "lib.md.us", "lib.me.us", "lib.mi.us", "lib.mn.us", "lib.mo.us", "lib.ms.us", "lib.mt.us", "lib.nc.us", "lib.nd.us", "lib.ne.us", "lib.nh.us", "lib.nj.us", "lib.nm.us", "lib.nv.us", "lib.ny.us", "lib.oh.us", "lib.ok.us", "lib.or.us", "lib.pa.us", "lib.pr.us", "lib.ri.us", "lib.sc.us", "lib.sd.us", "lib.tn.us", "lib.tx.us", "lib.ut.us", "lib.vi.us", "lib.vt.us", "lib.va.us", "lib.wa.us", "lib.wi.us", "lib.wy.us", "pvt.k12.ma.us", "chtr.k12.ma.us", "paroch.k12.ma.us", "ann-arbor.mi.us", "cog.mi.us", "dst.mi.us", "eaton.mi.us", "gen.mi.us", "mus.mi.us", "tec.mi.us", "washtenaw.mi.us", "uy", "com.uy", "edu.uy", "gub.uy", "mil.uy", "net.uy", "org.uy", "uz", "co.uz", "com.uz", "net.uz", "org.uz", "va", "vc", "com.vc", "net.vc", "org.vc", "gov.vc", "mil.vc", "edu.vc", "ve", "arts.ve", "bib.ve", "co.ve", "com.ve", "e12.ve", "edu.ve", "firm.ve", "gob.ve", "gov.ve", "info.ve", "int.ve", "mil.ve", "net.ve", "nom.ve", "org.ve", "rar.ve", "rec.ve", "store.ve", "tec.ve", "web.ve", "vg", "vi", "co.vi", "com.vi", "k12.vi", "net.vi", "org.vi", "vn", "com.vn", "net.vn", "org.vn", "edu.vn", "gov.vn", "int.vn", "ac.vn", "biz.vn", "info.vn", "name.vn", "pro.vn", "health.vn", "vu", "com.vu", "edu.vu", "net.vu", "org.vu", "wf", "ws", "com.ws", "net.ws", "org.ws", "gov.ws", "edu.ws", "yt", "امارات", "հայ", "বাংলা", "бг", "البحرين", "бел", "中国", "中國", "الجزائر", "مصر", "ею", "ευ", "موريتانيا", "გე", "ελ", "香港", "公司.香港", "教育.香港", "政府.香港", "個人.香港", "網絡.香港", "組織.香港", "ಭಾರತ", "ଭାରତ", "ভাৰত", "भारतम्", "भारोत", "ڀارت", "ഭാരതം", "भारत", "بارت", "بھارت", "భారత్", "ભારત", "ਭਾਰਤ", "ভারত", "இந்தியா", "ایران", "ايران", "عراق", "الاردن", "한국", "қаз", "ລາວ", "ලංකා", "இலங்கை", "المغرب", "мкд", "мон", "澳門", "澳门", "مليسيا", "عمان", "پاکستان", "پاكستان", "فلسطين", "срб", "пр.срб", "орг.срб", "обр.срб", "од.срб", "упр.срб", "ак.срб", "рф", "قطر", "السعودية", "السعودیة", "السعودیۃ", "السعوديه", "سودان", "新加坡", "சிங்கப்பூர்", "سورية", "سوريا", "ไทย", "ศึกษา.ไทย", "ธุรกิจ.ไทย", "รัฐบาล.ไทย", "ทหาร.ไทย", "เน็ต.ไทย", "องค์กร.ไทย", "تونس", "台灣", "台湾", "臺灣", "укр", "اليمن", "xxx", "ye", "com.ye", "edu.ye", "gov.ye", "net.ye", "mil.ye", "org.ye", "ac.za", "agric.za", "alt.za", "co.za", "edu.za", "gov.za", "grondar.za", "law.za", "mil.za", "net.za", "ngo.za", "nic.za", "nis.za", "nom.za", "org.za", "school.za", "tm.za", "web.za", "zm", "ac.zm", "biz.zm", "co.zm", "com.zm", "edu.zm", "gov.zm", "info.zm", "mil.zm", "net.zm", "org.zm", "sch.zm", "zw", "ac.zw", "co.zw", "gov.zw", "mil.zw", "org.zw", "aaa", "aarp", "abarth", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "academy", "accenture", "accountant", "accountants", "aco", "actor", "adac", "ads", "adult", "aeg", "aetna", "afl", "africa", "agakhan", "agency", "aig", "airbus", "airforce", "airtel", "akdn", "alfaromeo", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "aol", "apartments", "app", "apple", "aquarelle", "arab", "aramco", "archi", "army", "art", "arte", "asda", "associates", "athleta", "attorney", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "avianca", "aws", "axa", "azure", "baby", "baidu", "banamex", "bananarepublic", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bbc", "bbt", "bbva", "bcg", "bcn", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bharti", "bible", "bid", "bike", "bing", "bingo", "bio", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bms", "bmw", "bnpparibas", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "bugatti", "build", "builders", "business", "buy", "buzz", "bzh", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "cancerresearch", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "catering", "catholic", "cba", "cbn", "cbre", "cbs", "center", "ceo", "cern", "cfa", "cfd", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "cityeats", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "coach", "codes", "coffee", "college", "cologne", "comcast", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cookingchannel", "cool", "corsica", "country", "coupon", "coupons", "courses", "cpa", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "cuisinella", "cymru", "cyou", "dabur", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dnp", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "dunlop", "dupont", "durban", "dvag", "dvr", "earth", "eat", "eco", "edeka", "education", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "ericsson", "erni", "esq", "estate", "etisalat", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fiat", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "flickr", "flights", "flir", "florist", "flowers", "fly", "foo", "food", "foodnetwork", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "free", "fresenius", "frl", "frogans", "frontdoor", "frontier", "ftr", "fujitsu", "fun", "fund", "furniture", "futbol", "fyi", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gbiz", "gdn", "gea", "gent", "genting", "george", "ggee", "gift", "gifts", "gives", "giving", "glass", "gle", "global", "globo", "gmail", "gmbh", "gmo", "gmx", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "guardian", "gucci", "guge", "guide", "guitars", "guru", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hgtv", "hiphop", "hisamitsu", "hitachi", "hiv", "hkt", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hoteles", "hotels", "hotmail", "house", "how", "hsbc", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "ieee", "ifm", "ikano", "imamat", "imdb", "immo", "immobilien", "inc", "industries", "infiniti", "ing", "ink", "institute", "insurance", "insure", "international", "intuit", "investments", "ipiranga", "irish", "ismaili", "ist", "istanbul", "itau", "itv", "jaguar", "java", "jcb", "jeep", "jetzt", "jewelry", "jio", "jll", "jmp", "jnj", "joburg", "jot", "joy", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kia", "kids", "kim", "kinder", "kindle", "kitchen", "kiwi", "koeln", "komatsu", "kosher", "kpmg", "kpn", "krd", "kred", "kuokgroup", "kyoto", "lacaixa", "lamborghini", "lamer", "lancaster", "lancia", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "linde", "link", "lipsy", "live", "living", "llc", "llp", "loan", "loans", "locker", "locus", "loft", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "ltd", "ltda", "lundbeck", "luxe", "luxury", "macys", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "maserati", "mattel", "mba", "mckinsey", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merckmsd", "miami", "microsoft", "mini", "mint", "mit", "mitsubishi", "mlb", "mls", "mma", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "msd", "mtn", "mtr", "music", "mutual", "nab", "nagoya", "natura", "navy", "nba", "nec", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nfl", "ngo", "nhk", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nokia", "northwesternmutual", "norton", "now", "nowruz", "nowtv", "nra", "nrw", "ntt", "nyc", "obi", "observer", "office", "okinawa", "olayan", "olayangroup", "oldnavy", "ollo", "omega", "one", "ong", "onl", "online", "ooo", "open", "oracle", "orange", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "passagens", "pay", "pccw", "pet", "pfizer", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "place", "play", "playstation", "plumbing", "plus", "pnc", "pohl", "poker", "politie", "porn", "pramerica", "praxi", "press", "prime", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "pub", "pwc", "qpon", "quebec", "quest", "racing", "radio", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "rocher", "rocks", "rodeo", "rogers", "room", "rsvp", "rugby", "ruhr", "run", "rwe", "ryukyu", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sbi", "sbs", "sca", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scot", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "ses", "seven", "sew", "sex", "sexy", "sfr", "shangrila", "sharp", "shaw", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "showtime", "silk", "sina", "singles", "site", "ski", "skin", "sky", "skype", "sling", "smart", "smile", "sncf", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "srl", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "swatch", "swiss", "sydney", "systems", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tci", "tdk", "team", "tech", "technology", "temasek", "tennis", "teva", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tiffany", "tips", "tires", "tirol", "tjmaxx", "tjx", "tkmaxx", "tmall", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "trade", "trading", "training", "travel", "travelchannel", "travelers", "travelersinsurance", "trust", "trv", "tube", "tui", "tunes", "tushu", "tvs", "ubank", "ubs", "unicom", "university", "uno", "uol", "ups", "vacations", "vana", "vanguard", "vegas", "ventures", "verisign", "versicherung", "vet", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vodka", "volkswagen", "volvo", "vote", "voting", "voto", "voyage", "vuelos", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wedding", "weibo", "weir", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "wtc", "wtf", "xbox", "xerox", "xfinity", "xihuan", "xin", "कॉम", "セール", "佛山", "慈善", "集团", "在线", "点看", "คอม", "八卦", "موقع", "公益", "公司", "香格里拉", "网站", "移动", "我爱你", "москва", "католик", "онлайн", "сайт", "联通", "קום", "时尚", "微博", "淡马锡", "ファッション", "орг", "नेट", "ストア", "アマゾン", "삼성", "商标", "商店", "商城", "дети", "ポイント", "新闻", "家電", "كوم", "中文网", "中信", "娱乐", "谷歌", "電訊盈科", "购物", "クラウド", "通販", "网店", "संगठन", "餐厅", "网络", "ком", "亚马逊", "诺基亚", "食品", "飞利浦", "手机", "ارامكو", "العليان", "اتصالات", "بازار", "ابوظبي", "كاثوليك", "همراه", "닷컴", "政府", "شبكة", "بيتك", "عرب", "机构", "组织机构", "健康", "招聘", "рус", "大拿", "みんな", "グーグル", "世界", "書籍", "网址", "닷넷", "コム", "天主教", "游戏", "vermögensberater", "vermögensberatung", "企业", "信息", "嘉里大酒店", "嘉里", "广东", "政务", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "yodobashi", "yoga", "yokohama", "you", "youtube", "yun", "zappos", "zara", "zero", "zip", "zone", "zuerich", "cc.ua", "inf.ua", "ltd.ua", "611.to", "graphox.us", "*.devcdnaccesso.com", "adobeaemcloud.com", "*.dev.adobeaemcloud.com", "hlx.live", "adobeaemcloud.net", "hlx.page", "hlx3.page", "beep.pl", "airkitapps.com", "airkitapps-au.com", "airkitapps.eu", "aivencloud.com", "barsy.ca", "*.compute.estate", "*.alces.network", "kasserver.com", "altervista.org", "alwaysdata.net", "cloudfront.net", "*.compute.amazonaws.com", "*.compute-1.amazonaws.com", "*.compute.amazonaws.com.cn", "us-east-1.amazonaws.com", "cn-north-1.eb.amazonaws.com.cn", "cn-northwest-1.eb.amazonaws.com.cn", "elasticbeanstalk.com", "ap-northeast-1.elasticbeanstalk.com", "ap-northeast-2.elasticbeanstalk.com", "ap-northeast-3.elasticbeanstalk.com", "ap-south-1.elasticbeanstalk.com", "ap-southeast-1.elasticbeanstalk.com", "ap-southeast-2.elasticbeanstalk.com", "ca-central-1.elasticbeanstalk.com", "eu-central-1.elasticbeanstalk.com", "eu-west-1.elasticbeanstalk.com", "eu-west-2.elasticbeanstalk.com", "eu-west-3.elasticbeanstalk.com", "sa-east-1.elasticbeanstalk.com", "us-east-1.elasticbeanstalk.com", "us-east-2.elasticbeanstalk.com", "us-gov-west-1.elasticbeanstalk.com", "us-west-1.elasticbeanstalk.com", "us-west-2.elasticbeanstalk.com", "*.elb.amazonaws.com", "*.elb.amazonaws.com.cn", "awsglobalaccelerator.com", "s3.amazonaws.com", "s3-ap-northeast-1.amazonaws.com", "s3-ap-northeast-2.amazonaws.com", "s3-ap-south-1.amazonaws.com", "s3-ap-southeast-1.amazonaws.com", "s3-ap-southeast-2.amazonaws.com", "s3-ca-central-1.amazonaws.com", "s3-eu-central-1.amazonaws.com", "s3-eu-west-1.amazonaws.com", "s3-eu-west-2.amazonaws.com", "s3-eu-west-3.amazonaws.com", "s3-external-1.amazonaws.com", "s3-fips-us-gov-west-1.amazonaws.com", "s3-sa-east-1.amazonaws.com", "s3-us-gov-west-1.amazonaws.com", "s3-us-east-2.amazonaws.com", "s3-us-west-1.amazonaws.com", "s3-us-west-2.amazonaws.com", "s3.ap-northeast-2.amazonaws.com", "s3.ap-south-1.amazonaws.com", "s3.cn-north-1.amazonaws.com.cn", "s3.ca-central-1.amazonaws.com", "s3.eu-central-1.amazonaws.com", "s3.eu-west-2.amazonaws.com", "s3.eu-west-3.amazonaws.com", "s3.us-east-2.amazonaws.com", "s3.dualstack.ap-northeast-1.amazonaws.com", "s3.dualstack.ap-northeast-2.amazonaws.com", "s3.dualstack.ap-south-1.amazonaws.com", "s3.dualstack.ap-southeast-1.amazonaws.com", "s3.dualstack.ap-southeast-2.amazonaws.com", "s3.dualstack.ca-central-1.amazonaws.com", "s3.dualstack.eu-central-1.amazonaws.com", "s3.dualstack.eu-west-1.amazonaws.com", "s3.dualstack.eu-west-2.amazonaws.com", "s3.dualstack.eu-west-3.amazonaws.com", "s3.dualstack.sa-east-1.amazonaws.com", "s3.dualstack.us-east-1.amazonaws.com", "s3.dualstack.us-east-2.amazonaws.com", "s3-website-us-east-1.amazonaws.com", "s3-website-us-west-1.amazonaws.com", "s3-website-us-west-2.amazonaws.com", "s3-website-ap-northeast-1.amazonaws.com", "s3-website-ap-southeast-1.amazonaws.com", "s3-website-ap-southeast-2.amazonaws.com", "s3-website-eu-west-1.amazonaws.com", "s3-website-sa-east-1.amazonaws.com", "s3-website.ap-northeast-2.amazonaws.com", "s3-website.ap-south-1.amazonaws.com", "s3-website.ca-central-1.amazonaws.com", "s3-website.eu-central-1.amazonaws.com", "s3-website.eu-west-2.amazonaws.com", "s3-website.eu-west-3.amazonaws.com", "s3-website.us-east-2.amazonaws.com", "t3l3p0rt.net", "tele.amune.org", "apigee.io", "siiites.com", "appspacehosted.com", "appspaceusercontent.com", "appudo.net", "on-aptible.com", "user.aseinet.ne.jp", "gv.vc", "d.gv.vc", "user.party.eus", "pimienta.org", "poivron.org", "potager.org", "sweetpepper.org", "myasustor.com", "cdn.prod.atlassian-dev.net", "translated.page", "myfritz.net", "onavstack.net", "*.awdev.ca", "*.advisor.ws", "ecommerce-shop.pl", "b-data.io", "backplaneapp.io", "balena-devices.com", "rs.ba", "*.banzai.cloud", "app.banzaicloud.io", "*.backyards.banzaicloud.io", "base.ec", "official.ec", "buyshop.jp", "fashionstore.jp", "handcrafted.jp", "kawaiishop.jp", "supersale.jp", "theshop.jp", "shopselect.net", "base.shop", "*.beget.app", "betainabox.com", "bnr.la", "bitbucket.io", "blackbaudcdn.net", "of.je", "bluebite.io", "boomla.net", "boutir.com", "boxfuse.io", "square7.ch", "bplaced.com", "bplaced.de", "square7.de", "bplaced.net", "square7.net", "shop.brendly.rs", "browsersafetymark.io", "uk0.bigv.io", "dh.bytemark.co.uk", "vm.bytemark.co.uk", "cafjs.com", "mycd.eu", "drr.ac", "uwu.ai", "carrd.co", "crd.co", "ju.mp", "ae.org", "br.com", "cn.com", "com.de", "com.se", "de.com", "eu.com", "gb.net", "hu.net", "jp.net", "jpn.com", "mex.com", "ru.com", "sa.com", "se.net", "uk.com", "uk.net", "us.com", "za.bz", "za.com", "ar.com", "hu.com", "kr.com", "no.com", "qc.com", "uy.com", "africa.com", "gr.com", "in.net", "web.in", "us.org", "co.com", "aus.basketball", "nz.basketball", "radio.am", "radio.fm", "c.la", "certmgr.org", "cx.ua", "discourse.group", "discourse.team", "cleverapps.io", "clerk.app", "clerkstage.app", "*.lcl.dev", "*.lclstage.dev", "*.stg.dev", "*.stgstage.dev", "clickrising.net", "c66.me", "cloud66.ws", "cloud66.zone", "jdevcloud.com", "wpdevcloud.com", "cloudaccess.host", "freesite.host", "cloudaccess.net", "cloudcontrolled.com", "cloudcontrolapp.com", "*.cloudera.site", "pages.dev", "trycloudflare.com", "workers.dev", "wnext.app", "co.ca", "*.otap.co", "co.cz", "c.cdn77.org", "cdn77-ssl.net", "r.cdn77.net", "rsc.cdn77.org", "ssl.origin.cdn77-secure.org", "cloudns.asia", "cloudns.biz", "cloudns.club", "cloudns.cc", "cloudns.eu", "cloudns.in", "cloudns.info", "cloudns.org", "cloudns.pro", "cloudns.pw", "cloudns.us", "cnpy.gdn", "codeberg.page", "co.nl", "co.no", "webhosting.be", "hosting-cluster.nl", "ac.ru", "edu.ru", "gov.ru", "int.ru", "mil.ru", "test.ru", "dyn.cosidns.de", "dynamisches-dns.de", "dnsupdater.de", "internet-dns.de", "l-o-g-i-n.de", "dynamic-dns.info", "feste-ip.net", "knx-server.net", "static-access.net", "realm.cz", "*.cryptonomic.net", "cupcake.is", "curv.dev", "*.customer-oci.com", "*.oci.customer-oci.com", "*.ocp.customer-oci.com", "*.ocs.customer-oci.com", "cyon.link", "cyon.site", "fnwk.site", "folionetwork.site", "platform0.app", "daplie.me", "localhost.daplie.me", "dattolocal.com", "dattorelay.com", "dattoweb.com", "mydatto.com", "dattolocal.net", "mydatto.net", "biz.dk", "co.dk", "firm.dk", "reg.dk", "store.dk", "dyndns.dappnode.io", "*.dapps.earth", "*.bzz.dapps.earth", "builtwithdark.com", "demo.datadetect.com", "instance.datadetect.com", "edgestack.me", "ddns5.com", "debian.net", "deno.dev", "deno-staging.dev", "dedyn.io", "deta.app", "deta.dev", "*.rss.my.id", "*.diher.solutions", "discordsays.com", "discordsez.com", "jozi.biz", "dnshome.de", "online.th", "shop.th", "drayddns.com", "shoparena.pl", "dreamhosters.com", "mydrobo.com", "drud.io", "drud.us", "duckdns.org", "bip.sh", "bitbridge.net", "dy.fi", "tunk.org", "dyndns-at-home.com", "dyndns-at-work.com", "dyndns-blog.com", "dyndns-free.com", "dyndns-home.com", "dyndns-ip.com", "dyndns-mail.com", "dyndns-office.com", "dyndns-pics.com", "dyndns-remote.com", "dyndns-server.com", "dyndns-web.com", "dyndns-wiki.com", "dyndns-work.com", "dyndns.biz", "dyndns.info", "dyndns.org", "dyndns.tv", "at-band-camp.net", "ath.cx", "barrel-of-knowledge.info", "barrell-of-knowledge.info", "better-than.tv", "blogdns.com", "blogdns.net", "blogdns.org", "blogsite.org", "boldlygoingnowhere.org", "broke-it.net", "buyshouses.net", "cechire.com", "dnsalias.com", "dnsalias.net", "dnsalias.org", "dnsdojo.com", "dnsdojo.net", "dnsdojo.org", "does-it.net", "doesntexist.com", "doesntexist.org", "dontexist.com", "dontexist.net", "dontexist.org", "doomdns.com", "doomdns.org", "dvrdns.org", "dyn-o-saur.com", "dynalias.com", "dynalias.net", "dynalias.org", "dynathome.net", "dyndns.ws", "endofinternet.net", "endofinternet.org", "endoftheinternet.org", "est-a-la-maison.com", "est-a-la-masion.com", "est-le-patron.com", "est-mon-blogueur.com", "for-better.biz", "for-more.biz", "for-our.info", "for-some.biz", "for-the.biz", "forgot.her.name", "forgot.his.name", "from-ak.com", "from-al.com", "from-ar.com", "from-az.net", "from-ca.com", "from-co.net", "from-ct.com", "from-dc.com", "from-de.com", "from-fl.com", "from-ga.com", "from-hi.com", "from-ia.com", "from-id.com", "from-il.com", "from-in.com", "from-ks.com", "from-ky.com", "from-la.net", "from-ma.com", "from-md.com", "from-me.org", "from-mi.com", "from-mn.com", "from-mo.com", "from-ms.com", "from-mt.com", "from-nc.com", "from-nd.com", "from-ne.com", "from-nh.com", "from-nj.com", "from-nm.com", "from-nv.com", "from-ny.net", "from-oh.com", "from-ok.com", "from-or.com", "from-pa.com", "from-pr.com", "from-ri.com", "from-sc.com", "from-sd.com", "from-tn.com", "from-tx.com", "from-ut.com", "from-va.com", "from-vt.com", "from-wa.com", "from-wi.com", "from-wv.com", "from-wy.com", "ftpaccess.cc", "fuettertdasnetz.de", "game-host.org", "game-server.cc", "getmyip.com", "gets-it.net", "go.dyndns.org", "gotdns.com", "gotdns.org", "groks-the.info", "groks-this.info", "ham-radio-op.net", "here-for-more.info", "hobby-site.com", "hobby-site.org", "home.dyndns.org", "homedns.org", "homeftp.net", "homeftp.org", "homeip.net", "homelinux.com", "homelinux.net", "homelinux.org", "homeunix.com", "homeunix.net", "homeunix.org", "iamallama.com", "in-the-band.net", "is-a-anarchist.com", "is-a-blogger.com", "is-a-bookkeeper.com", "is-a-bruinsfan.org", "is-a-bulls-fan.com", "is-a-candidate.org", "is-a-caterer.com", "is-a-celticsfan.org", "is-a-chef.com", "is-a-chef.net", "is-a-chef.org", "is-a-conservative.com", "is-a-cpa.com", "is-a-cubicle-slave.com", "is-a-democrat.com", "is-a-designer.com", "is-a-doctor.com", "is-a-financialadvisor.com", "is-a-geek.com", "is-a-geek.net", "is-a-geek.org", "is-a-green.com", "is-a-guru.com", "is-a-hard-worker.com", "is-a-hunter.com", "is-a-knight.org", "is-a-landscaper.com", "is-a-lawyer.com", "is-a-liberal.com", "is-a-libertarian.com", "is-a-linux-user.org", "is-a-llama.com", "is-a-musician.com", "is-a-nascarfan.com", "is-a-nurse.com", "is-a-painter.com", "is-a-patsfan.org", "is-a-personaltrainer.com", "is-a-photographer.com", "is-a-player.com", "is-a-republican.com", "is-a-rockstar.com", "is-a-socialist.com", "is-a-soxfan.org", "is-a-student.com", "is-a-teacher.com", "is-a-techie.com", "is-a-therapist.com", "is-an-accountant.com", "is-an-actor.com", "is-an-actress.com", "is-an-anarchist.com", "is-an-artist.com", "is-an-engineer.com", "is-an-entertainer.com", "is-by.us", "is-certified.com", "is-found.org", "is-gone.com", "is-into-anime.com", "is-into-cars.com", "is-into-cartoons.com", "is-into-games.com", "is-leet.com", "is-lost.org", "is-not-certified.com", "is-saved.org", "is-slick.com", "is-uberleet.com", "is-very-bad.org", "is-very-evil.org", "is-very-good.org", "is-very-nice.org", "is-very-sweet.org", "is-with-theband.com", "isa-geek.com", "isa-geek.net", "isa-geek.org", "isa-hockeynut.com", "issmarterthanyou.com", "isteingeek.de", "istmein.de", "kicks-ass.net", "kicks-ass.org", "knowsitall.info", "land-4-sale.us", "lebtimnetz.de", "leitungsen.de", "likes-pie.com", "likescandy.com", "merseine.nu", "mine.nu", "misconfused.org", "mypets.ws", "myphotos.cc", "neat-url.com", "office-on-the.net", "on-the-web.tv", "podzone.net", "podzone.org", "readmyblog.org", "saves-the-whales.com", "scrapper-site.net", "scrapping.cc", "selfip.biz", "selfip.com", "selfip.info", "selfip.net", "selfip.org", "sells-for-less.com", "sells-for-u.com", "sells-it.net", "sellsyourhome.org", "servebbs.com", "servebbs.net", "servebbs.org", "serveftp.net", "serveftp.org", "servegame.org", "shacknet.nu", "simple-url.com", "space-to-rent.com", "stuff-4-sale.org", "stuff-4-sale.us", "teaches-yoga.com", "thruhere.net", "traeumtgerade.de", "webhop.biz", "webhop.info", "webhop.net", "webhop.org", "worse-than.tv", "writesthisblog.com", "ddnss.de", "dyn.ddnss.de", "dyndns.ddnss.de", "dyndns1.de", "dyn-ip24.de", "home-webserver.de", "dyn.home-webserver.de", "myhome-server.de", "ddnss.org", "definima.net", "definima.io", "ondigitalocean.app", "*.digitaloceanspaces.com", "bci.dnstrace.pro", "ddnsfree.com", "ddnsgeek.com", "giize.com", "gleeze.com", "kozow.com", "loseyourip.com", "ooguy.com", "theworkpc.com", "casacam.net", "dynu.net", "accesscam.org", "camdvr.org", "freeddns.org", "mywire.org", "webredirect.org", "myddns.rocks", "blogsite.xyz", "dynv6.net", "e4.cz", "eero.online", "eero-stage.online", "elementor.cloud", "elementor.cool", "en-root.fr", "mytuleap.com", "tuleap-partners.com", "encr.app", "encoreapi.com", "onred.one", "staging.onred.one", "eu.encoway.cloud", "eu.org", "al.eu.org", "asso.eu.org", "at.eu.org", "au.eu.org", "be.eu.org", "bg.eu.org", "ca.eu.org", "cd.eu.org", "ch.eu.org", "cn.eu.org", "cy.eu.org", "cz.eu.org", "de.eu.org", "dk.eu.org", "edu.eu.org", "ee.eu.org", "es.eu.org", "fi.eu.org", "fr.eu.org", "gr.eu.org", "hr.eu.org", "hu.eu.org", "ie.eu.org", "il.eu.org", "in.eu.org", "int.eu.org", "is.eu.org", "it.eu.org", "jp.eu.org", "kr.eu.org", "lt.eu.org", "lu.eu.org", "lv.eu.org", "mc.eu.org", "me.eu.org", "mk.eu.org", "mt.eu.org", "my.eu.org", "net.eu.org", "ng.eu.org", "nl.eu.org", "no.eu.org", "nz.eu.org", "paris.eu.org", "pl.eu.org", "pt.eu.org", "q-a.eu.org", "ro.eu.org", "ru.eu.org", "se.eu.org", "si.eu.org", "sk.eu.org", "tr.eu.org", "uk.eu.org", "us.eu.org", "eurodir.ru", "eu-1.evennode.com", "eu-2.evennode.com", "eu-3.evennode.com", "eu-4.evennode.com", "us-1.evennode.com", "us-2.evennode.com", "us-3.evennode.com", "us-4.evennode.com", "twmail.cc", "twmail.net", "twmail.org", "mymailer.com.tw", "url.tw", "onfabrica.com", "apps.fbsbx.com", "ru.net", "adygeya.ru", "bashkiria.ru", "bir.ru", "cbg.ru", "com.ru", "dagestan.ru", "grozny.ru", "kalmykia.ru", "kustanai.ru", "marine.ru", "mordovia.ru", "msk.ru", "mytis.ru", "nalchik.ru", "nov.ru", "pyatigorsk.ru", "spb.ru", "vladikavkaz.ru", "vladimir.ru", "abkhazia.su", "adygeya.su", "aktyubinsk.su", "arkhangelsk.su", "armenia.su", "ashgabad.su", "azerbaijan.su", "balashov.su", "bashkiria.su", "bryansk.su", "bukhara.su", "chimkent.su", "dagestan.su", "east-kazakhstan.su", "exnet.su", "georgia.su", "grozny.su", "ivanovo.su", "jambyl.su", "kalmykia.su", "kaluga.su", "karacol.su", "karaganda.su", "karelia.su", "khakassia.su", "krasnodar.su", "kurgan.su", "kustanai.su", "lenug.su", "mangyshlak.su", "mordovia.su", "msk.su", "murmansk.su", "nalchik.su", "navoi.su", "north-kazakhstan.su", "nov.su", "obninsk.su", "penza.su", "pokrovsk.su", "sochi.su", "spb.su", "tashkent.su", "termez.su", "togliatti.su", "troitsk.su", "tselinograd.su", "tula.su", "tuva.su", "vladikavkaz.su", "vladimir.su", "vologda.su", "channelsdvr.net", "u.channelsdvr.net", "edgecompute.app", "fastly-terrarium.com", "fastlylb.net", "map.fastlylb.net", "freetls.fastly.net", "map.fastly.net", "a.prod.fastly.net", "global.prod.fastly.net", "a.ssl.fastly.net", "b.ssl.fastly.net", "global.ssl.fastly.net", "fastvps-server.com", "fastvps.host", "myfast.host", "fastvps.site", "myfast.space", "fedorainfracloud.org", "fedorapeople.org", "cloud.fedoraproject.org", "app.os.fedoraproject.org", "app.os.stg.fedoraproject.org", "conn.uk", "copro.uk", "hosp.uk", "mydobiss.com", "fh-muenster.io", "filegear.me", "filegear-au.me", "filegear-de.me", "filegear-gb.me", "filegear-ie.me", "filegear-jp.me", "filegear-sg.me", "firebaseapp.com", "fireweb.app", "flap.id", "onflashdrive.app", "fldrv.com", "fly.dev", "edgeapp.net", "shw.io", "flynnhosting.net", "forgeblocks.com", "id.forgerock.io", "framer.app", "framercanvas.com", "*.frusky.de", "ravpage.co.il", "0e.vc", "freebox-os.com", "freeboxos.com", "fbx-os.fr", "fbxos.fr", "freebox-os.fr", "freeboxos.fr", "freedesktop.org", "freemyip.com", "wien.funkfeuer.at", "*.futurecms.at", "*.ex.futurecms.at", "*.in.futurecms.at", "futurehosting.at", "futuremailing.at", "*.ex.ortsinfo.at", "*.kunden.ortsinfo.at", "*.statics.cloud", "independent-commission.uk", "independent-inquest.uk", "independent-inquiry.uk", "independent-panel.uk", "independent-review.uk", "public-inquiry.uk", "royal-commission.uk", "campaign.gov.uk", "service.gov.uk", "api.gov.uk", "gehirn.ne.jp", "usercontent.jp", "gentapps.com", "gentlentapis.com", "lab.ms", "cdn-edges.net", "ghost.io", "gsj.bz", "githubusercontent.com", "githubpreview.dev", "github.io", "gitlab.io", "gitapp.si", "gitpage.si", "glitch.me", "nog.community", "co.ro", "shop.ro", "lolipop.io", "angry.jp", "babyblue.jp", "babymilk.jp", "backdrop.jp", "bambina.jp", "bitter.jp", "blush.jp", "boo.jp", "boy.jp", "boyfriend.jp", "but.jp", "candypop.jp", "capoo.jp", "catfood.jp", "cheap.jp", "chicappa.jp", "chillout.jp", "chips.jp", "chowder.jp", "chu.jp", "ciao.jp", "cocotte.jp", "coolblog.jp", "cranky.jp", "cutegirl.jp", "daa.jp", "deca.jp", "deci.jp", "digick.jp", "egoism.jp", "fakefur.jp", "fem.jp", "flier.jp", "floppy.jp", "fool.jp", "frenchkiss.jp", "girlfriend.jp", "girly.jp", "gloomy.jp", "gonna.jp", "greater.jp", "hacca.jp", "heavy.jp", "her.jp", "hiho.jp", "hippy.jp", "holy.jp", "hungry.jp", "icurus.jp", "itigo.jp", "jellybean.jp", "kikirara.jp", "kill.jp", "kilo.jp", "kuron.jp", "littlestar.jp", "lolipopmc.jp", "lolitapunk.jp", "lomo.jp", "lovepop.jp", "lovesick.jp", "main.jp", "mods.jp", "mond.jp", "mongolian.jp", "moo.jp", "namaste.jp", "nikita.jp", "nobushi.jp", "noor.jp", "oops.jp", "parallel.jp", "parasite.jp", "pecori.jp", "peewee.jp", "penne.jp", "pepper.jp", "perma.jp", "pigboat.jp", "pinoko.jp", "punyu.jp", "pupu.jp", "pussycat.jp", "pya.jp", "raindrop.jp", "readymade.jp", "sadist.jp", "schoolbus.jp", "secret.jp", "staba.jp", "stripper.jp", "sub.jp", "sunnyday.jp", "thick.jp", "tonkotsu.jp", "under.jp", "upper.jp", "velvet.jp", "verse.jp", "versus.jp", "vivian.jp", "watson.jp", "weblike.jp", "whitesnow.jp", "zombie.jp", "heteml.net", "cloudapps.digital", "london.cloudapps.digital", "pymnt.uk", "homeoffice.gov.uk", "ro.im", "goip.de", "run.app", "a.run.app", "web.app", "*.0emm.com", "appspot.com", "*.r.appspot.com", "codespot.com", "googleapis.com", "googlecode.com", "pagespeedmobilizer.com", "publishproxy.com", "withgoogle.com", "withyoutube.com", "*.gateway.dev", "cloud.goog", "translate.goog", "*.usercontent.goog", "cloudfunctions.net", "blogspot.ae", "blogspot.al", "blogspot.am", "blogspot.ba", "blogspot.be", "blogspot.bg", "blogspot.bj", "blogspot.ca", "blogspot.cf", "blogspot.ch", "blogspot.cl", "blogspot.co.at", "blogspot.co.id", "blogspot.co.il", "blogspot.co.ke", "blogspot.co.nz", "blogspot.co.uk", "blogspot.co.za", "blogspot.com", "blogspot.com.ar", "blogspot.com.au", "blogspot.com.br", "blogspot.com.by", "blogspot.com.co", "blogspot.com.cy", "blogspot.com.ee", "blogspot.com.eg", "blogspot.com.es", "blogspot.com.mt", "blogspot.com.ng", "blogspot.com.tr", "blogspot.com.uy", "blogspot.cv", "blogspot.cz", "blogspot.de", "blogspot.dk", "blogspot.fi", "blogspot.fr", "blogspot.gr", "blogspot.hk", "blogspot.hr", "blogspot.hu", "blogspot.ie", "blogspot.in", "blogspot.is", "blogspot.it", "blogspot.jp", "blogspot.kr", "blogspot.li", "blogspot.lt", "blogspot.lu", "blogspot.md", "blogspot.mk", "blogspot.mr", "blogspot.mx", "blogspot.my", "blogspot.nl", "blogspot.no", "blogspot.pe", "blogspot.pt", "blogspot.qa", "blogspot.re", "blogspot.ro", "blogspot.rs", "blogspot.ru", "blogspot.se", "blogspot.sg", "blogspot.si", "blogspot.sk", "blogspot.sn", "blogspot.td", "blogspot.tw", "blogspot.ug", "blogspot.vn", "goupile.fr", "gov.nl", "awsmppl.com", "günstigbestellen.de", "günstigliefern.de", "fin.ci", "free.hr", "caa.li", "ua.rs", "conf.se", "hs.zone", "hs.run", "hashbang.sh", "hasura.app", "hasura-app.io", "pages.it.hs-heilbronn.de", "hepforge.org", "herokuapp.com", "herokussl.com", "ravendb.cloud", "myravendb.com", "ravendb.community", "ravendb.me", "development.run", "ravendb.run", "homesklep.pl", "secaas.hk", "hoplix.shop", "orx.biz", "biz.gl", "col.ng", "firm.ng", "gen.ng", "ltd.ng", "ngo.ng", "edu.scot", "sch.so", "hostyhosting.io", "häkkinen.fi", "*.moonscale.io", "moonscale.net", "iki.fi", "ibxos.it", "iliadboxos.it", "impertrixcdn.com", "impertrix.com", "smushcdn.com", "wphostedmail.com", "wpmucdn.com", "tempurl.host", "wpmudev.host", "dyn-berlin.de", "in-berlin.de", "in-brb.de", "in-butter.de", "in-dsl.de", "in-dsl.net", "in-dsl.org", "in-vpn.de", "in-vpn.net", "in-vpn.org", "biz.at", "info.at", "info.cx", "ac.leg.br", "al.leg.br", "am.leg.br", "ap.leg.br", "ba.leg.br", "ce.leg.br", "df.leg.br", "es.leg.br", "go.leg.br", "ma.leg.br", "mg.leg.br", "ms.leg.br", "mt.leg.br", "pa.leg.br", "pb.leg.br", "pe.leg.br", "pi.leg.br", "pr.leg.br", "rj.leg.br", "rn.leg.br", "ro.leg.br", "rr.leg.br", "rs.leg.br", "sc.leg.br", "se.leg.br", "sp.leg.br", "to.leg.br", "pixolino.com", "na4u.ru", "iopsys.se", "ipifony.net", "iservschule.de", "mein-iserv.de", "schulplattform.de", "schulserver.de", "test-iserv.de", "iserv.dev", "iobb.net", "mel.cloudlets.com.au", "cloud.interhostsolutions.be", "users.scale.virtualcloud.com.br", "mycloud.by", "alp1.ae.flow.ch", "appengine.flow.ch", "es-1.axarnet.cloud", "diadem.cloud", "vip.jelastic.cloud", "jele.cloud", "it1.eur.aruba.jenv-aruba.cloud", "it1.jenv-aruba.cloud", "keliweb.cloud", "cs.keliweb.cloud", "oxa.cloud", "tn.oxa.cloud", "uk.oxa.cloud", "primetel.cloud", "uk.primetel.cloud", "ca.reclaim.cloud", "uk.reclaim.cloud", "us.reclaim.cloud", "ch.trendhosting.cloud", "de.trendhosting.cloud", "jele.club", "amscompute.com", "clicketcloud.com", "dopaas.com", "hidora.com", "paas.hosted-by-previder.com", "rag-cloud.hosteur.com", "rag-cloud-ch.hosteur.com", "jcloud.ik-server.com", "jcloud-ver-jpc.ik-server.com", "demo.jelastic.com", "kilatiron.com", "paas.massivegrid.com", "jed.wafaicloud.com", "lon.wafaicloud.com", "ryd.wafaicloud.com", "j.scaleforce.com.cy", "jelastic.dogado.eu", "fi.cloudplatform.fi", "demo.datacenter.fi", "paas.datacenter.fi", "jele.host", "mircloud.host", "paas.beebyte.io", "sekd1.beebyteapp.io", "jele.io", "cloud-fr1.unispace.io", "jc.neen.it", "cloud.jelastic.open.tim.it", "jcloud.kz", "upaas.kazteleport.kz", "cloudjiffy.net", "fra1-de.cloudjiffy.net", "west1-us.cloudjiffy.net", "jls-sto1.elastx.net", "jls-sto2.elastx.net", "jls-sto3.elastx.net", "faststacks.net", "fr-1.paas.massivegrid.net", "lon-1.paas.massivegrid.net", "lon-2.paas.massivegrid.net", "ny-1.paas.massivegrid.net", "ny-2.paas.massivegrid.net", "sg-1.paas.massivegrid.net", "jelastic.saveincloud.net", "nordeste-idc.saveincloud.net", "j.scaleforce.net", "jelastic.tsukaeru.net", "sdscloud.pl", "unicloud.pl", "mircloud.ru", "jelastic.regruhosting.ru", "enscaled.sg", "jele.site", "jelastic.team", "orangecloud.tn", "j.layershift.co.uk", "phx.enscaled.us", "mircloud.us", "myjino.ru", "*.hosting.myjino.ru", "*.landing.myjino.ru", "*.spectrum.myjino.ru", "*.vps.myjino.ru", "jotelulu.cloud", "*.triton.zone", "*.cns.joyent.com", "js.org", "kaas.gg", "khplay.nl", "ktistory.com", "kapsi.fi", "keymachine.de", "kinghost.net", "uni5.net", "knightpoint.systems", "koobin.events", "oya.to", "kuleuven.cloud", "ezproxy.kuleuven.be", "co.krd", "edu.krd", "krellian.net", "webthings.io", "git-repos.de", "lcube-server.de", "svn-repos.de", "leadpages.co", "lpages.co", "lpusercontent.com", "lelux.site", "co.business", "co.education", "co.events", "co.financial", "co.network", "co.place", "co.technology", "app.lmpm.com", "linkyard.cloud", "linkyard-cloud.ch", "members.linode.com", "*.nodebalancer.linode.com", "*.linodeobjects.com", "ip.linodeusercontent.com", "we.bs", "*.user.localcert.dev", "localzone.xyz", "loginline.app", "loginline.dev", "loginline.io", "loginline.services", "loginline.site", "servers.run", "lohmus.me", "krasnik.pl", "leczna.pl", "lubartow.pl", "lublin.pl", "poniatowa.pl", "swidnik.pl", "glug.org.uk", "lug.org.uk", "lugs.org.uk", "barsy.bg", "barsy.co.uk", "barsyonline.co.uk", "barsycenter.com", "barsyonline.com", "barsy.club", "barsy.de", "barsy.eu", "barsy.in", "barsy.info", "barsy.io", "barsy.me", "barsy.menu", "barsy.mobi", "barsy.net", "barsy.online", "barsy.org", "barsy.pro", "barsy.pub", "barsy.ro", "barsy.shop", "barsy.site", "barsy.support", "barsy.uk", "*.magentosite.cloud", "mayfirst.info", "mayfirst.org", "hb.cldmail.ru", "cn.vu", "mazeplay.com", "mcpe.me", "mcdir.me", "mcdir.ru", "mcpre.ru", "vps.mcdir.ru", "mediatech.by", "mediatech.dev", "hra.health", "miniserver.com", "memset.net", "messerli.app", "*.cloud.metacentrum.cz", "custom.metacentrum.cz", "flt.cloud.muni.cz", "usr.cloud.muni.cz", "meteorapp.com", "eu.meteorapp.com", "co.pl", "*.azurecontainer.io", "azurewebsites.net", "azure-mobile.net", "cloudapp.net", "azurestaticapps.net", "1.azurestaticapps.net", "centralus.azurestaticapps.net", "eastasia.azurestaticapps.net", "eastus2.azurestaticapps.net", "westeurope.azurestaticapps.net", "westus2.azurestaticapps.net", "csx.cc", "mintere.site", "forte.id", "mozilla-iot.org", "bmoattachments.org", "net.ru", "org.ru", "pp.ru", "hostedpi.com", "customer.mythic-beasts.com", "caracal.mythic-beasts.com", "fentiger.mythic-beasts.com", "lynx.mythic-beasts.com", "ocelot.mythic-beasts.com", "oncilla.mythic-beasts.com", "onza.mythic-beasts.com", "sphinx.mythic-beasts.com", "vs.mythic-beasts.com", "x.mythic-beasts.com", "yali.mythic-beasts.com", "cust.retrosnub.co.uk", "ui.nabu.casa", "pony.club", "of.fashion", "in.london", "of.london", "from.marketing", "with.marketing", "for.men", "repair.men", "and.mom", "for.mom", "for.one", "under.one", "for.sale", "that.win", "from.work", "to.work", "cloud.nospamproxy.com", "netlify.app", "4u.com", "ngrok.io", "nh-serv.co.uk", "nfshost.com", "*.developer.app", "noop.app", "*.northflank.app", "*.build.run", "*.code.run", "*.database.run", "*.migration.run", "noticeable.news", "dnsking.ch", "mypi.co", "n4t.co", "001www.com", "ddnslive.com", "myiphost.com", "forumz.info", "16-b.it", "32-b.it", "64-b.it", "soundcast.me", "tcp4.me", "dnsup.net", "hicam.net", "now-dns.net", "ownip.net", "vpndns.net", "dynserv.org", "now-dns.org", "x443.pw", "now-dns.top", "ntdll.top", "freeddns.us", "crafting.xyz", "zapto.xyz", "nsupdate.info", "nerdpol.ovh", "blogsyte.com", "brasilia.me", "cable-modem.org", "ciscofreak.com", "collegefan.org", "couchpotatofries.org", "damnserver.com", "ddns.me", "ditchyourip.com", "dnsfor.me", "dnsiskinky.com", "dvrcam.info", "dynns.com", "eating-organic.net", "fantasyleague.cc", "geekgalaxy.com", "golffan.us", "health-carereform.com", "homesecuritymac.com", "homesecuritypc.com", "hopto.me", "ilovecollege.info", "loginto.me", "mlbfan.org", "mmafan.biz", "myactivedirectory.com", "mydissent.net", "myeffect.net", "mymediapc.net", "mypsx.net", "mysecuritycamera.com", "mysecuritycamera.net", "mysecuritycamera.org", "net-freaks.com", "nflfan.org", "nhlfan.net", "no-ip.ca", "no-ip.co.uk", "no-ip.net", "noip.us", "onthewifi.com", "pgafan.net", "point2this.com", "pointto.us", "privatizehealthinsurance.net", "quicksytes.com", "read-books.org", "securitytactics.com", "serveexchange.com", "servehumour.com", "servep2p.com", "servesarcasm.com", "stufftoread.com", "ufcfan.org", "unusualperson.com", "workisboring.com", "3utilities.com", "bounceme.net", "ddns.net", "ddnsking.com", "gotdns.ch", "hopto.org", "myftp.biz", "myftp.org", "myvnc.com", "no-ip.biz", "no-ip.info", "no-ip.org", "noip.me", "redirectme.net", "servebeer.com", "serveblog.net", "servecounterstrike.com", "serveftp.com", "servegame.com", "servehalflife.com", "servehttp.com", "serveirc.com", "serveminecraft.net", "servemp3.com", "servepics.com", "servequake.com", "sytes.net", "webhop.me", "zapto.org", "stage.nodeart.io", "pcloud.host", "nyc.mn", "static.observableusercontent.com", "cya.gg", "omg.lol", "cloudycluster.net", "omniwe.site", "service.one", "nid.io", "opensocial.site", "opencraft.hosting", "orsites.com", "operaunite.com", "tech.orange", "authgear-staging.com", "authgearapps.com", "skygearapp.com", "outsystemscloud.com", "*.webpaas.ovh.net", "*.hosting.ovh.net", "ownprovider.com", "own.pm", "*.owo.codes", "ox.rs", "oy.lc", "pgfog.com", "pagefrontapp.com", "pagexl.com", "*.paywhirl.com", "bar0.net", "bar1.net", "bar2.net", "rdv.to", "art.pl", "gliwice.pl", "krakow.pl", "poznan.pl", "wroc.pl", "zakopane.pl", "pantheonsite.io", "gotpantheon.com", "mypep.link", "perspecta.cloud", "lk3.ru", "on-web.fr", "bc.platform.sh", "ent.platform.sh", "eu.platform.sh", "us.platform.sh", "*.platformsh.site", "*.tst.site", "platter-app.com", "platter-app.dev", "platterp.us", "pdns.page", "plesk.page", "pleskns.com", "dyn53.io", "onporter.run", "co.bn", "postman-echo.com", "pstmn.io", "mock.pstmn.io", "httpbin.org", "prequalifyme.today", "xen.prgmr.com", "priv.at", "prvcy.page", "*.dweb.link", "protonet.io", "chirurgiens-dentistes-en-france.fr", "byen.site", "pubtls.org", "pythonanywhere.com", "eu.pythonanywhere.com", "qoto.io", "qualifioapp.com", "qbuser.com", "cloudsite.builders", "instances.spawn.cc", "instantcloud.cn", "ras.ru", "qa2.com", "qcx.io", "*.sys.qcx.io", "dev-myqnapcloud.com", "alpha-myqnapcloud.com", "myqnapcloud.com", "*.quipelements.com", "vapor.cloud", "vaporcloud.io", "rackmaze.com", "rackmaze.net", "g.vbrplsbx.io", "*.on-k3s.io", "*.on-rancher.cloud", "*.on-rio.io", "readthedocs.io", "rhcloud.com", "app.render.com", "onrender.com", "repl.co", "id.repl.co", "repl.run", "resindevice.io", "devices.resinstaging.io", "hzc.io", "wellbeingzone.eu", "wellbeingzone.co.uk", "adimo.co.uk", "itcouldbewor.se", "git-pages.rit.edu", "rocky.page", "биз.рус", "ком.рус", "крым.рус", "мир.рус", "мск.рус", "орг.рус", "самара.рус", "сочи.рус", "спб.рус", "я.рус", "*.builder.code.com", "*.dev-builder.code.com", "*.stg-builder.code.com", "sandcats.io", "logoip.de", "logoip.com", "fr-par-1.baremetal.scw.cloud", "fr-par-2.baremetal.scw.cloud", "nl-ams-1.baremetal.scw.cloud", "fnc.fr-par.scw.cloud", "functions.fnc.fr-par.scw.cloud", "k8s.fr-par.scw.cloud", "nodes.k8s.fr-par.scw.cloud", "s3.fr-par.scw.cloud", "s3-website.fr-par.scw.cloud", "whm.fr-par.scw.cloud", "priv.instances.scw.cloud", "pub.instances.scw.cloud", "k8s.scw.cloud", "k8s.nl-ams.scw.cloud", "nodes.k8s.nl-ams.scw.cloud", "s3.nl-ams.scw.cloud", "s3-website.nl-ams.scw.cloud", "whm.nl-ams.scw.cloud", "k8s.pl-waw.scw.cloud", "nodes.k8s.pl-waw.scw.cloud", "s3.pl-waw.scw.cloud", "s3-website.pl-waw.scw.cloud", "scalebook.scw.cloud", "smartlabeling.scw.cloud", "dedibox.fr", "schokokeks.net", "gov.scot", "service.gov.scot", "scrysec.com", "firewall-gateway.com", "firewall-gateway.de", "my-gateway.de", "my-router.de", "spdns.de", "spdns.eu", "firewall-gateway.net", "my-firewall.org", "myfirewall.org", "spdns.org", "seidat.net", "sellfy.store", "senseering.net", "minisite.ms", "magnet.page", "biz.ua", "co.ua", "pp.ua", "shiftcrypto.dev", "shiftcrypto.io", "shiftedit.io", "myshopblocks.com", "myshopify.com", "shopitsite.com", "shopware.store", "mo-siemens.io", "1kapp.com", "appchizi.com", "applinzi.com", "sinaapp.com", "vipsinaapp.com", "siteleaf.net", "bounty-full.com", "alpha.bounty-full.com", "beta.bounty-full.com", "small-web.org", "vp4.me", "try-snowplow.com", "srht.site", "stackhero-network.com", "musician.io", "novecore.site", "static.land", "dev.static.land", "sites.static.land", "storebase.store", "vps-host.net", "atl.jelastic.vps-host.net", "njs.jelastic.vps-host.net", "ric.jelastic.vps-host.net", "playstation-cloud.com", "apps.lair.io", "*.stolos.io", "spacekit.io", "customer.speedpartner.de", "myspreadshop.at", "myspreadshop.com.au", "myspreadshop.be", "myspreadshop.ca", "myspreadshop.ch", "myspreadshop.com", "myspreadshop.de", "myspreadshop.dk", "myspreadshop.es", "myspreadshop.fi", "myspreadshop.fr", "myspreadshop.ie", "myspreadshop.it", "myspreadshop.net", "myspreadshop.nl", "myspreadshop.no", "myspreadshop.pl", "myspreadshop.se", "myspreadshop.co.uk", "api.stdlib.com", "storj.farm", "utwente.io", "soc.srcf.net", "user.srcf.net", "temp-dns.com", "supabase.co", "supabase.in", "supabase.net", "su.paba.se", "*.s5y.io", "*.sensiosite.cloud", "syncloud.it", "dscloud.biz", "direct.quickconnect.cn", "dsmynas.com", "familyds.com", "diskstation.me", "dscloud.me", "i234.me", "myds.me", "synology.me", "dscloud.mobi", "dsmynas.net", "familyds.net", "dsmynas.org", "familyds.org", "vpnplus.to", "direct.quickconnect.to", "tabitorder.co.il", "taifun-dns.de", "beta.tailscale.net", "ts.net", "gda.pl", "gdansk.pl", "gdynia.pl", "med.pl", "sopot.pl", "site.tb-hosting.com", "edugit.io", "s3.teckids.org", "telebit.app", "telebit.io", "*.telebit.xyz", "gwiddle.co.uk", "*.firenet.ch", "*.svc.firenet.ch", "reservd.com", "thingdustdata.com", "cust.dev.thingdust.io", "cust.disrec.thingdust.io", "cust.prod.thingdust.io", "cust.testing.thingdust.io", "reservd.dev.thingdust.io", "reservd.disrec.thingdust.io", "reservd.testing.thingdust.io", "tickets.io", "arvo.network", "azimuth.network", "tlon.network", "torproject.net", "pages.torproject.net", "bloxcms.com", "townnews-staging.com", "tbits.me", "12hp.at", "2ix.at", "4lima.at", "lima-city.at", "12hp.ch", "2ix.ch", "4lima.ch", "lima-city.ch", "trafficplex.cloud", "de.cool", "12hp.de", "2ix.de", "4lima.de", "lima-city.de", "1337.pictures", "clan.rip", "lima-city.rocks", "webspace.rocks", "lima.zone", "*.transurl.be", "*.transurl.eu", "*.transurl.nl", "site.transip.me", "tuxfamily.org", "dd-dns.de", "diskstation.eu", "diskstation.org", "dray-dns.de", "draydns.de", "dyn-vpn.de", "dynvpn.de", "mein-vigor.de", "my-vigor.de", "my-wan.de", "syno-ds.de", "synology-diskstation.de", "synology-ds.de", "typedream.app", "pro.typeform.com", "uber.space", "*.uberspace.de", "hk.com", "hk.org", "ltd.hk", "inc.hk", "name.pm", "sch.tf", "biz.wf", "sch.wf", "org.yt", "virtualuser.de", "virtual-user.de", "upli.io", "urown.cloud", "dnsupdate.info", "lib.de.us", "2038.io", "vercel.app", "vercel.dev", "now.sh", "router.management", "v-info.info", "voorloper.cloud", "neko.am", "nyaa.am", "be.ax", "cat.ax", "es.ax", "eu.ax", "gg.ax", "mc.ax", "us.ax", "xy.ax", "nl.ci", "xx.gl", "app.gp", "blog.gt", "de.gt", "to.gt", "be.gy", "cc.hn", "blog.kg", "io.kg", "jp.kg", "tv.kg", "uk.kg", "us.kg", "de.ls", "at.md", "de.md", "jp.md", "to.md", "indie.porn", "vxl.sh", "ch.tc", "me.tc", "we.tc", "nyan.to", "at.vg", "blog.vu", "dev.vu", "me.vu", "v.ua", "*.vultrobjects.com", "wafflecell.com", "*.webhare.dev", "reserve-online.net", "reserve-online.com", "bookonline.app", "hotelwithflight.com", "wedeploy.io", "wedeploy.me", "wedeploy.sh", "remotewd.com", "pages.wiardweb.com", "wmflabs.org", "toolforge.org", "wmcloud.org", "panel.gg", "daemon.panel.gg", "messwithdns.com", "woltlab-demo.com", "myforum.community", "community-pro.de", "diskussionsbereich.de", "community-pro.net", "meinforum.net", "affinitylottery.org.uk", "raffleentry.org.uk", "weeklylottery.org.uk", "wpenginepowered.com", "js.wpenginepowered.com", "wixsite.com", "editorx.io", "half.host", "xnbay.com", "u2.xnbay.com", "u2-local.xnbay.com", "cistron.nl", "demon.nl", "xs4all.space", "yandexcloud.net", "storage.yandexcloud.net", "website.yandexcloud.net", "official.academy", "yolasite.com", "ybo.faith", "yombo.me", "homelink.one", "ybo.party", "ybo.review", "ybo.science", "ybo.trade", "ynh.fr", "nohost.me", "noho.st", "za.net", "za.org", "bss.design", "basicserver.io", "virtualserver.io", "enterprisecloud.nu"]
    }, {}],
    2: [function (a, o, t) {
      "use strict";
      var m = a("punycode"),
        u = {};
      u.rules = a("./data/rules.json").map(function (a) {
        return {
          rule: a,
          suffix: a.replace(/^(\*\.|\!)/, ""),
          punySuffix: -1,
          wildcard: "*" === a.charAt(0),
          exception: "!" === a.charAt(0)
        }
      }), u.endsWith = function (a, o) {
        return -1 !== a.indexOf(o, a.length - o.length)
      }, u.findRule = function (a) {
        var i = m.toASCII(a);
        return u.rules.reduce(function (a, o) {
          return -1 === o.punySuffix && (o.punySuffix = m.toASCII(o.suffix)), u.endsWith(i, "." + o.punySuffix) || i === o.punySuffix ? o : a
        }, null)
      }, t.errorCodes = {
        DOMAIN_TOO_SHORT: "Domain name too short.",
        DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
        LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
        LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
        LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
        LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
        LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
      }, u.validate = function (a) {
        a = m.toASCII(a);
        if (a.length < 1) return "DOMAIN_TOO_SHORT";
        if (255 < a.length) return "DOMAIN_TOO_LONG";
        for (var o, i = a.split("."), e = 0; e < i.length; ++e) {
          if (!(o = i[e]).length) return "LABEL_TOO_SHORT";
          if (63 < o.length) return "LABEL_TOO_LONG";
          if ("-" === o.charAt(0)) return "LABEL_STARTS_WITH_DASH";
          if ("-" === o.charAt(o.length - 1)) return "LABEL_ENDS_WITH_DASH";
          if (!/^[a-z0-9\-]+$/.test(o)) return "LABEL_INVALID_CHARS"
        }
      }, t.parse = function (a) {
        if ("string" != typeof a) throw new TypeError("Domain name must be a string.");
        var o = a.slice(0).toLowerCase(),
          i = ("." === o.charAt(o.length - 1) && (o = o.slice(0, o.length - 1)), u.validate(o));
        if (i) return {
          input: a,
          error: {
            message: t.errorCodes[i],
            code: i
          }
        };
        var e = {
            input: a,
            tld: null,
            sld: null,
            domain: null,
            subdomain: null,
            listed: !1
          },
          i = o.split(".");
        if ("local" === i[i.length - 1]) return e;

        function s() {
          return /xn--/.test(o) && (e.domain && (e.domain = m.toASCII(e.domain)), e.subdomain && (e.subdomain = m.toASCII(e.subdomain))), e
        }
        a = u.findRule(o);
        if (!a) return i.length < 2 ? e : (e.tld = i.pop(), e.sld = i.pop(), e.domain = [e.sld, e.tld].join("."), i.length && (e.subdomain = i.pop()), s());
        e.listed = !0;
        var n = a.suffix.split("."),
          i = i.slice(0, i.length - n.length);
        return a.exception && i.push(n.shift()), e.tld = n.join("."), i.length && (a.wildcard && (n.unshift(i.pop()), e.tld = n.join(".")), i.length && (e.sld = i.pop(), e.domain = [e.sld, e.tld].join("."), i.length && (e.subdomain = i.join(".")))), s()
      }, t.get = function (a) {
        return a && t.parse(a).domain || null
      }, t.isValid = function (a) {
        a = t.parse(a);
        return Boolean(a.domain && a.listed)
      }
    }, {
      "./data/rules.json": 1,
      punycode: 3
    }],
    3: [function (a, _, L) {
      ! function (O) {
        ! function () {
          var a = this,
            o = "object" == typeof L && L && !L.nodeType && L,
            i = "object" == typeof _ && _ && !_.nodeType && _,
            e = "object" == typeof O && O;
          e.global !== e && e.window !== e && e.self !== e || (a = e);
          var s, n, d = 2147483647,
            j = 36,
            b = 26,
            t = 38,
            m = 700,
            u = /^xn--/,
            r = /[^\x20-\x7E]/,
            p = /[\x2E\u3002\uFF0E\uFF61]/g,
            c = {
              overflow: "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input"
            },
            l = j - 1,
            y = Math.floor,
            f = String.fromCharCode;

          function v(a) {
            throw new RangeError(c[a])
          }

          function k(a, o) {
            for (var i = a.length, e = []; i--;) e[i] = o(a[i]);
            return e
          }

          function g(a, o) {
            var i = a.split("@"),
              e = "",
              i = (1 < i.length && (e = i[0] + "@", a = i[1]), (a = a.replace(p, ".")).split("."));
            return e + k(i, o).join(".")
          }

          function w(a) {
            for (var o, i, e = [], s = 0, n = a.length; s < n;) 55296 <= (o = a.charCodeAt(s++)) && o <= 56319 && s < n ? 56320 == (64512 & (i = a.charCodeAt(s++))) ? e.push(((1023 & o) << 10) + (1023 & i) + 65536) : (e.push(o), s--) : e.push(o);
            return e
          }

          function h(a) {
            return k(a, function (a) {
              var o = "";
              return 65535 < a && (o += f((a -= 65536) >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), o += f(a)
            }).join("")
          }

          function z(a, o) {
            return a + 22 + 75 * (a < 26) - ((0 != o) << 5)
          }

          function x(a, o, i) {
            var e = 0;
            for (a = i ? y(a / m) : a >> 1, a += y(a / o); l * b >> 1 < a; e += j) a = y(a / l);
            return y(e + (l + 1) * a / (a + t))
          }

          function q(a) {
            var o, i, e, s, n, t, m, u = [],
              r = a.length,
              p = 0,
              c = 128,
              l = 72,
              k = a.lastIndexOf("-");
            for (k < 0 && (k = 0), i = 0; i < k; ++i) 128 <= a.charCodeAt(i) && v("not-basic"), u.push(a.charCodeAt(i));
            for (e = 0 < k ? k + 1 : 0; e < r;) {
              for (s = p, n = 1, t = j; r <= e && v("invalid-input"), m = a.charCodeAt(e++), (j <= (m = m - 48 < 10 ? m - 22 : m - 65 < 26 ? m - 65 : m - 97 < 26 ? m - 97 : j) || m > y((d - p) / n)) && v("overflow"), p += m * n, !(m < (m = t <= l ? 1 : l + b <= t ? b : t - l)); t += j) n > y(d / (m = j - m)) && v("overflow"), n *= m;
              l = x(p - s, o = u.length + 1, 0 == s), y(p / o) > d - c && v("overflow"), c += y(p / o), p %= o, u.splice(p++, 0, c)
            }
            return h(u)
          }

          function A(a) {
            for (var o, i, e, s, n, t, m, u, r, p, c = [], l = (a = w(a)).length, k = 128, g = 72, h = o = 0; h < l; ++h)(m = a[h]) < 128 && c.push(f(m));
            for (i = e = c.length, e && c.push("-"); i < l;) {
              for (s = d, h = 0; h < l; ++h) k <= (m = a[h]) && m < s && (s = m);
              for (s - k > y((d - o) / (u = i + 1)) && v("overflow"), o += (s - k) * u, k = s, h = 0; h < l; ++h)
                if ((m = a[h]) < k && ++o > d && v("overflow"), m == k) {
                  for (n = o, t = j; !(n < (r = t <= g ? 1 : g + b <= t ? b : t - g)); t += j) c.push(f(z(r + (p = n - r) % (r = j - r), 0))), n = y(p / r);
                  c.push(f(z(n, 0))), g = x(o, u, i == e), o = 0, ++i
                }++ o, ++k
            }
            return c.join("")
          }
          if (s = {
              version: "1.4.1",
              ucs2: {
                decode: w,
                encode: h
              },
              decode: q,
              encode: A,
              toASCII: function (a) {
                return g(a, function (a) {
                  return r.test(a) ? "xn--" + A(a) : a
                })
              },
              toUnicode: function (a) {
                return g(a, function (a) {
                  return u.test(a) ? q(a.slice(4).toLowerCase()) : a
                })
              }
            }, o && i)
            if (_.exports == o) i.exports = s;
            else
              for (n in s) s.hasOwnProperty(n) && (o[n] = s[n]);
          else a.punycode = s
        }.call(this)
      }.call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}]
  }, {}, [2])(2)
});
! function (t) {
  if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
  else if ("function" == typeof define && define.amd) define([], t);
  else {
    ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).pako = t()
  }
}(function () {
  return function t(e, a, i) {
    function n(s, o) {
      if (!a[s]) {
        if (!e[s]) {
          var l = "function" == typeof require && require;
          if (!o && l) return l(s, !0);
          if (r) return r(s, !0);
          var h = new Error("Cannot find module '" + s + "'");
          throw h.code = "MODULE_NOT_FOUND", h
        }
        var d = a[s] = {
          exports: {}
        };
        e[s][0].call(d.exports, function (t) {
          var a = e[s][1][t];
          return n(a || t)
        }, d, d.exports, t, e, a, i)
      }
      return a[s].exports
    }
    for (var r = "function" == typeof require && require, s = 0; s < i.length; s++) n(i[s]);
    return n
  }({
    1: [function (t, e, a) {
      "use strict";

      function i(t) {
        if (!(this instanceof i)) return new i(t);
        this.options = s.assign({
          level: _,
          method: c,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: u,
          to: ""
        }, t || {});
        var e = this.options;
        e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h, this.strm.avail_out = 0;
        var a = r.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
        if (a !== f) throw new Error(l[a]);
        if (e.header && r.deflateSetHeader(this.strm, e.header), e.dictionary) {
          var n;
          if (n = "string" == typeof e.dictionary ? o.string2buf(e.dictionary) : "[object ArrayBuffer]" === d.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, (a = r.deflateSetDictionary(this.strm, n)) !== f) throw new Error(l[a]);
          this._dict_set = !0
        }
      }

      function n(t, e) {
        var a = new i(e);
        if (a.push(t, !0), a.err) throw a.msg || l[a.err];
        return a.result
      }
      var r = t("./zlib/deflate"),
        s = t("./utils/common"),
        o = t("./utils/strings"),
        l = t("./zlib/messages"),
        h = t("./zlib/zstream"),
        d = Object.prototype.toString,
        f = 0,
        _ = -1,
        u = 0,
        c = 8;
      i.prototype.push = function (t, e) {
        var a, i, n = this.strm,
          l = this.options.chunkSize;
        if (this.ended) return !1;
        i = e === ~~e ? e : !0 === e ? 4 : 0, "string" == typeof t ? n.input = o.string2buf(t) : "[object ArrayBuffer]" === d.call(t) ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;
        do {
          if (0 === n.avail_out && (n.output = new s.Buf8(l), n.next_out = 0, n.avail_out = l), 1 !== (a = r.deflate(n, i)) && a !== f) return this.onEnd(a), this.ended = !0, !1;
          0 !== n.avail_out && (0 !== n.avail_in || 4 !== i && 2 !== i) || ("string" === this.options.to ? this.onData(o.buf2binstring(s.shrinkBuf(n.output, n.next_out))) : this.onData(s.shrinkBuf(n.output, n.next_out)))
        } while ((n.avail_in > 0 || 0 === n.avail_out) && 1 !== a);
        return 4 === i ? (a = r.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === f) : 2 !== i || (this.onEnd(f), n.avail_out = 0, !0)
      }, i.prototype.onData = function (t) {
        this.chunks.push(t)
      }, i.prototype.onEnd = function (t) {
        t === f && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
      }, a.Deflate = i, a.deflate = n, a.deflateRaw = function (t, e) {
        return e = e || {}, e.raw = !0, n(t, e)
      }, a.gzip = function (t, e) {
        return e = e || {}, e.gzip = !0, n(t, e)
      }
    }, {
      "./utils/common": 3,
      "./utils/strings": 4,
      "./zlib/deflate": 8,
      "./zlib/messages": 13,
      "./zlib/zstream": 15
    }],
    2: [function (t, e, a) {
      "use strict";

      function i(t) {
        if (!(this instanceof i)) return new i(t);
        this.options = s.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, t || {});
        var e = this.options;
        e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d, this.strm.avail_out = 0;
        var a = r.inflateInit2(this.strm, e.windowBits);
        if (a !== l.Z_OK) throw new Error(h[a]);
        this.header = new f, r.inflateGetHeader(this.strm, this.header)
      }

      function n(t, e) {
        var a = new i(e);
        if (a.push(t, !0), a.err) throw a.msg || h[a.err];
        return a.result
      }
      var r = t("./zlib/inflate"),
        s = t("./utils/common"),
        o = t("./utils/strings"),
        l = t("./zlib/constants"),
        h = t("./zlib/messages"),
        d = t("./zlib/zstream"),
        f = t("./zlib/gzheader"),
        _ = Object.prototype.toString;
      i.prototype.push = function (t, e) {
        var a, i, n, h, d, f, u = this.strm,
          c = this.options.chunkSize,
          b = this.options.dictionary,
          g = !1;
        if (this.ended) return !1;
        i = e === ~~e ? e : !0 === e ? l.Z_FINISH : l.Z_NO_FLUSH, "string" == typeof t ? u.input = o.binstring2buf(t) : "[object ArrayBuffer]" === _.call(t) ? u.input = new Uint8Array(t) : u.input = t, u.next_in = 0, u.avail_in = u.input.length;
        do {
          if (0 === u.avail_out && (u.output = new s.Buf8(c), u.next_out = 0, u.avail_out = c), (a = r.inflate(u, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && b && (f = "string" == typeof b ? o.string2buf(b) : "[object ArrayBuffer]" === _.call(b) ? new Uint8Array(b) : b, a = r.inflateSetDictionary(this.strm, f)), a === l.Z_BUF_ERROR && !0 === g && (a = l.Z_OK, g = !1), a !== l.Z_STREAM_END && a !== l.Z_OK) return this.onEnd(a), this.ended = !0, !1;
          u.next_out && (0 !== u.avail_out && a !== l.Z_STREAM_END && (0 !== u.avail_in || i !== l.Z_FINISH && i !== l.Z_SYNC_FLUSH) || ("string" === this.options.to ? (n = o.utf8border(u.output, u.next_out), h = u.next_out - n, d = o.buf2string(u.output, n), u.next_out = h, u.avail_out = c - h, h && s.arraySet(u.output, u.output, n, h, 0), this.onData(d)) : this.onData(s.shrinkBuf(u.output, u.next_out)))), 0 === u.avail_in && 0 === u.avail_out && (g = !0)
        } while ((u.avail_in > 0 || 0 === u.avail_out) && a !== l.Z_STREAM_END);
        return a === l.Z_STREAM_END && (i = l.Z_FINISH), i === l.Z_FINISH ? (a = r.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === l.Z_OK) : i !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), u.avail_out = 0, !0)
      }, i.prototype.onData = function (t) {
        this.chunks.push(t)
      }, i.prototype.onEnd = function (t) {
        t === l.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = s.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
      }, a.Inflate = i, a.inflate = n, a.inflateRaw = function (t, e) {
        return e = e || {}, e.raw = !0, n(t, e)
      }, a.ungzip = n
    }, {
      "./utils/common": 3,
      "./utils/strings": 4,
      "./zlib/constants": 6,
      "./zlib/gzheader": 9,
      "./zlib/inflate": 11,
      "./zlib/messages": 13,
      "./zlib/zstream": 15
    }],
    3: [function (t, e, a) {
      "use strict";

      function i(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
      }
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      a.assign = function (t) {
        for (var e = Array.prototype.slice.call(arguments, 1); e.length;) {
          var a = e.shift();
          if (a) {
            if ("object" != typeof a) throw new TypeError(a + "must be non-object");
            for (var n in a) i(a, n) && (t[n] = a[n])
          }
        }
        return t
      }, a.shrinkBuf = function (t, e) {
        return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t)
      };
      var r = {
          arraySet: function (t, e, a, i, n) {
            if (e.subarray && t.subarray) t.set(e.subarray(a, a + i), n);
            else
              for (var r = 0; r < i; r++) t[n + r] = e[a + r]
          },
          flattenChunks: function (t) {
            var e, a, i, n, r, s;
            for (i = 0, e = 0, a = t.length; e < a; e++) i += t[e].length;
            for (s = new Uint8Array(i), n = 0, e = 0, a = t.length; e < a; e++) r = t[e], s.set(r, n), n += r.length;
            return s
          }
        },
        s = {
          arraySet: function (t, e, a, i, n) {
            for (var r = 0; r < i; r++) t[n + r] = e[a + r]
          },
          flattenChunks: function (t) {
            return [].concat.apply([], t)
          }
        };
      a.setTyped = function (t) {
        t ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, r)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, s))
      }, a.setTyped(n)
    }, {}],
    4: [function (t, e, a) {
      "use strict";

      function i(t, e) {
        if (e < 65537 && (t.subarray && s || !t.subarray && r)) return String.fromCharCode.apply(null, n.shrinkBuf(t, e));
        for (var a = "", i = 0; i < e; i++) a += String.fromCharCode(t[i]);
        return a
      }
      var n = t("./common"),
        r = !0,
        s = !0;
      try {
        String.fromCharCode.apply(null, [0])
      } catch (t) {
        r = !1
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1))
      } catch (t) {
        s = !1
      }
      for (var o = new n.Buf8(256), l = 0; l < 256; l++) o[l] = l >= 252 ? 6 : l >= 248 ? 5 : l >= 240 ? 4 : l >= 224 ? 3 : l >= 192 ? 2 : 1;
      o[254] = o[254] = 1, a.string2buf = function (t) {
        var e, a, i, r, s, o = t.length,
          l = 0;
        for (r = 0; r < o; r++) 55296 == (64512 & (a = t.charCodeAt(r))) && r + 1 < o && 56320 == (64512 & (i = t.charCodeAt(r + 1))) && (a = 65536 + (a - 55296 << 10) + (i - 56320), r++), l += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
        for (e = new n.Buf8(l), s = 0, r = 0; s < l; r++) 55296 == (64512 & (a = t.charCodeAt(r))) && r + 1 < o && 56320 == (64512 & (i = t.charCodeAt(r + 1))) && (a = 65536 + (a - 55296 << 10) + (i - 56320), r++), a < 128 ? e[s++] = a : a < 2048 ? (e[s++] = 192 | a >>> 6, e[s++] = 128 | 63 & a) : a < 65536 ? (e[s++] = 224 | a >>> 12, e[s++] = 128 | a >>> 6 & 63, e[s++] = 128 | 63 & a) : (e[s++] = 240 | a >>> 18, e[s++] = 128 | a >>> 12 & 63, e[s++] = 128 | a >>> 6 & 63, e[s++] = 128 | 63 & a);
        return e
      }, a.buf2binstring = function (t) {
        return i(t, t.length)
      }, a.binstring2buf = function (t) {
        for (var e = new n.Buf8(t.length), a = 0, i = e.length; a < i; a++) e[a] = t.charCodeAt(a);
        return e
      }, a.buf2string = function (t, e) {
        var a, n, r, s, l = e || t.length,
          h = new Array(2 * l);
        for (n = 0, a = 0; a < l;)
          if ((r = t[a++]) < 128) h[n++] = r;
          else if ((s = o[r]) > 4) h[n++] = 65533, a += s - 1;
        else {
          for (r &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && a < l;) r = r << 6 | 63 & t[a++], s--;
          s > 1 ? h[n++] = 65533 : r < 65536 ? h[n++] = r : (r -= 65536, h[n++] = 55296 | r >> 10 & 1023, h[n++] = 56320 | 1023 & r)
        }
        return i(h, n)
      }, a.utf8border = function (t, e) {
        var a;
        for ((e = e || t.length) > t.length && (e = t.length), a = e - 1; a >= 0 && 128 == (192 & t[a]);) a--;
        return a < 0 ? e : 0 === a ? e : a + o[t[a]] > e ? a : e
      }
    }, {
      "./common": 3
    }],
    5: [function (t, e, a) {
      "use strict";
      e.exports = function (t, e, a, i) {
        for (var n = 65535 & t | 0, r = t >>> 16 & 65535 | 0, s = 0; 0 !== a;) {
          a -= s = a > 2e3 ? 2e3 : a;
          do {
            r = r + (n = n + e[i++] | 0) | 0
          } while (--s);
          n %= 65521, r %= 65521
        }
        return n | r << 16 | 0
      }
    }, {}],
    6: [function (t, e, a) {
      "use strict";
      e.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      }
    }, {}],
    7: [function (t, e, a) {
      "use strict";
      var i = function () {
        for (var t, e = [], a = 0; a < 256; a++) {
          t = a;
          for (var i = 0; i < 8; i++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
          e[a] = t
        }
        return e
      }();
      e.exports = function (t, e, a, n) {
        var r = i,
          s = n + a;
        t ^= -1;
        for (var o = n; o < s; o++) t = t >>> 8 ^ r[255 & (t ^ e[o])];
        return -1 ^ t
      }
    }, {}],
    8: [function (t, e, a) {
      "use strict";

      function i(t, e) {
        return t.msg = A[e], e
      }

      function n(t) {
        return (t << 1) - (t > 4 ? 9 : 0)
      }

      function r(t) {
        for (var e = t.length; --e >= 0;) t[e] = 0
      }

      function s(t) {
        var e = t.state,
          a = e.pending;
        a > t.avail_out && (a = t.avail_out), 0 !== a && (z.arraySet(t.output, e.pending_buf, e.pending_out, a, t.next_out), t.next_out += a, e.pending_out += a, t.total_out += a, t.avail_out -= a, e.pending -= a, 0 === e.pending && (e.pending_out = 0))
      }

      function o(t, e) {
        B._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, s(t.strm)
      }

      function l(t, e) {
        t.pending_buf[t.pending++] = e
      }

      function h(t, e) {
        t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e
      }

      function d(t, e, a, i) {
        var n = t.avail_in;
        return n > i && (n = i), 0 === n ? 0 : (t.avail_in -= n, z.arraySet(e, t.input, t.next_in, n, a), 1 === t.state.wrap ? t.adler = S(t.adler, e, n, a) : 2 === t.state.wrap && (t.adler = E(t.adler, e, n, a)), t.next_in += n, t.total_in += n, n)
      }

      function f(t, e) {
        var a, i, n = t.max_chain_length,
          r = t.strstart,
          s = t.prev_length,
          o = t.nice_match,
          l = t.strstart > t.w_size - it ? t.strstart - (t.w_size - it) : 0,
          h = t.window,
          d = t.w_mask,
          f = t.prev,
          _ = t.strstart + at,
          u = h[r + s - 1],
          c = h[r + s];
        t.prev_length >= t.good_match && (n >>= 2), o > t.lookahead && (o = t.lookahead);
        do {
          if (a = e, h[a + s] === c && h[a + s - 1] === u && h[a] === h[r] && h[++a] === h[r + 1]) {
            r += 2, a++;
            do {} while (h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && h[++r] === h[++a] && r < _);
            if (i = at - (_ - r), r = _ - at, i > s) {
              if (t.match_start = e, s = i, i >= o) break;
              u = h[r + s - 1], c = h[r + s]
            }
          }
        } while ((e = f[e & d]) > l && 0 != --n);
        return s <= t.lookahead ? s : t.lookahead
      }

      function _(t) {
        var e, a, i, n, r, s = t.w_size;
        do {
          if (n = t.window_size - t.lookahead - t.strstart, t.strstart >= s + (s - it)) {
            z.arraySet(t.window, t.window, s, s, 0), t.match_start -= s, t.strstart -= s, t.block_start -= s, e = a = t.hash_size;
            do {
              i = t.head[--e], t.head[e] = i >= s ? i - s : 0
            } while (--a);
            e = a = s;
            do {
              i = t.prev[--e], t.prev[e] = i >= s ? i - s : 0
            } while (--a);
            n += s
          }
          if (0 === t.strm.avail_in) break;
          if (a = d(t.strm, t.window, t.strstart + t.lookahead, n), t.lookahead += a, t.lookahead + t.insert >= et)
            for (r = t.strstart - t.insert, t.ins_h = t.window[r], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[r + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[r + et - 1]) & t.hash_mask, t.prev[r & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = r, r++, t.insert--, !(t.lookahead + t.insert < et)););
        } while (t.lookahead < it && 0 !== t.strm.avail_in)
      }

      function u(t, e) {
        for (var a, i;;) {
          if (t.lookahead < it) {
            if (_(t), t.lookahead < it && e === Z) return _t;
            if (0 === t.lookahead) break
          }
          if (a = 0, t.lookahead >= et && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== a && t.strstart - a <= t.w_size - it && (t.match_length = f(t, a)), t.match_length >= et)
            if (i = B._tr_tally(t, t.strstart - t.match_start, t.match_length - et), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= et) {
              t.match_length--;
              do {
                t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart
              } while (0 != --t.match_length);
              t.strstart++
            } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
          else i = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
          if (i && (o(t, !1), 0 === t.strm.avail_out)) return _t
        }
        return t.insert = t.strstart < et - 1 ? t.strstart : et - 1, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? _t : ut
      }

      function c(t, e) {
        for (var a, i, n;;) {
          if (t.lookahead < it) {
            if (_(t), t.lookahead < it && e === Z) return _t;
            if (0 === t.lookahead) break
          }
          if (a = 0, t.lookahead >= et && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = et - 1, 0 !== a && t.prev_length < t.max_lazy_match && t.strstart - a <= t.w_size - it && (t.match_length = f(t, a), t.match_length <= 5 && (t.strategy === H || t.match_length === et && t.strstart - t.match_start > 4096) && (t.match_length = et - 1)), t.prev_length >= et && t.match_length <= t.prev_length) {
            n = t.strstart + t.lookahead - et, i = B._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - et), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
            do {
              ++t.strstart <= n && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + et - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart)
            } while (0 != --t.prev_length);
            if (t.match_available = 0, t.match_length = et - 1, t.strstart++, i && (o(t, !1), 0 === t.strm.avail_out)) return _t
          } else if (t.match_available) {
            if ((i = B._tr_tally(t, 0, t.window[t.strstart - 1])) && o(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return _t
          } else t.match_available = 1, t.strstart++, t.lookahead--
        }
        return t.match_available && (i = B._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < et - 1 ? t.strstart : et - 1, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? _t : ut
      }

      function b(t, e) {
        for (var a, i, n, r, s = t.window;;) {
          if (t.lookahead <= at) {
            if (_(t), t.lookahead <= at && e === Z) return _t;
            if (0 === t.lookahead) break
          }
          if (t.match_length = 0, t.lookahead >= et && t.strstart > 0 && (n = t.strstart - 1, (i = s[n]) === s[++n] && i === s[++n] && i === s[++n])) {
            r = t.strstart + at;
            do {} while (i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && n < r);
            t.match_length = at - (r - n), t.match_length > t.lookahead && (t.match_length = t.lookahead)
          }
          if (t.match_length >= et ? (a = B._tr_tally(t, 1, t.match_length - et), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (a = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), a && (o(t, !1), 0 === t.strm.avail_out)) return _t
        }
        return t.insert = 0, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? _t : ut
      }

      function g(t, e) {
        for (var a;;) {
          if (0 === t.lookahead && (_(t), 0 === t.lookahead)) {
            if (e === Z) return _t;
            break
          }
          if (t.match_length = 0, a = B._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, a && (o(t, !1), 0 === t.strm.avail_out)) return _t
        }
        return t.insert = 0, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : t.last_lit && (o(t, !1), 0 === t.strm.avail_out) ? _t : ut
      }

      function m(t, e, a, i, n) {
        this.good_length = t, this.max_lazy = e, this.nice_length = a, this.max_chain = i, this.func = n
      }

      function w(t) {
        t.window_size = 2 * t.w_size, r(t.head), t.max_lazy_match = x[t.level].max_lazy, t.good_match = x[t.level].good_length, t.nice_match = x[t.level].nice_length, t.max_chain_length = x[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = et - 1, t.match_available = 0, t.ins_h = 0
      }

      function p() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = q, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new z.Buf16(2 * $), this.dyn_dtree = new z.Buf16(2 * (2 * Q + 1)), this.bl_tree = new z.Buf16(2 * (2 * V + 1)), r(this.dyn_ltree), r(this.dyn_dtree), r(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new z.Buf16(tt + 1), this.heap = new z.Buf16(2 * J + 1), r(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new z.Buf16(2 * J + 1), r(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
      }

      function v(t) {
        var e;
        return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = Y, e = t.state, e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? rt : dt, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = Z, B._tr_init(e), D) : i(t, U)
      }

      function k(t) {
        var e = v(t);
        return e === D && w(t.state), e
      }

      function y(t, e, a, n, r, s) {
        if (!t) return U;
        var o = 1;
        if (e === L && (e = 6), n < 0 ? (o = 0, n = -n) : n > 15 && (o = 2, n -= 16), r < 1 || r > G || a !== q || n < 8 || n > 15 || e < 0 || e > 9 || s < 0 || s > M) return i(t, U);
        8 === n && (n = 9);
        var l = new p;
        return t.state = l, l.strm = t, l.wrap = o, l.gzhead = null, l.w_bits = n, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = r + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + et - 1) / et), l.window = new z.Buf8(2 * l.w_size), l.head = new z.Buf16(l.hash_size), l.prev = new z.Buf16(l.w_size), l.lit_bufsize = 1 << r + 6, l.pending_buf_size = 4 * l.lit_bufsize, l.pending_buf = new z.Buf8(l.pending_buf_size), l.d_buf = 1 * l.lit_bufsize, l.l_buf = 3 * l.lit_bufsize, l.level = e, l.strategy = s, l.method = a, k(t)
      }
      var x, z = t("../utils/common"),
        B = t("./trees"),
        S = t("./adler32"),
        E = t("./crc32"),
        A = t("./messages"),
        Z = 0,
        R = 1,
        C = 3,
        N = 4,
        O = 5,
        D = 0,
        I = 1,
        U = -2,
        T = -3,
        F = -5,
        L = -1,
        H = 1,
        j = 2,
        K = 3,
        M = 4,
        P = 0,
        Y = 2,
        q = 8,
        G = 9,
        X = 15,
        W = 8,
        J = 286,
        Q = 30,
        V = 19,
        $ = 2 * J + 1,
        tt = 15,
        et = 3,
        at = 258,
        it = at + et + 1,
        nt = 32,
        rt = 42,
        st = 69,
        ot = 73,
        lt = 91,
        ht = 103,
        dt = 113,
        ft = 666,
        _t = 1,
        ut = 2,
        ct = 3,
        bt = 4,
        gt = 3;
      x = [new m(0, 0, 0, 0, function (t, e) {
        var a = 65535;
        for (a > t.pending_buf_size - 5 && (a = t.pending_buf_size - 5);;) {
          if (t.lookahead <= 1) {
            if (_(t), 0 === t.lookahead && e === Z) return _t;
            if (0 === t.lookahead) break
          }
          t.strstart += t.lookahead, t.lookahead = 0;
          var i = t.block_start + a;
          if ((0 === t.strstart || t.strstart >= i) && (t.lookahead = t.strstart - i, t.strstart = i, o(t, !1), 0 === t.strm.avail_out)) return _t;
          if (t.strstart - t.block_start >= t.w_size - it && (o(t, !1), 0 === t.strm.avail_out)) return _t
        }
        return t.insert = 0, e === N ? (o(t, !0), 0 === t.strm.avail_out ? ct : bt) : (t.strstart > t.block_start && (o(t, !1), t.strm.avail_out), _t)
      }), new m(4, 4, 8, 4, u), new m(4, 5, 16, 8, u), new m(4, 6, 32, 32, u), new m(4, 4, 16, 16, c), new m(8, 16, 32, 32, c), new m(8, 16, 128, 128, c), new m(8, 32, 128, 256, c), new m(32, 128, 258, 1024, c), new m(32, 258, 258, 4096, c)], a.deflateInit = function (t, e) {
        return y(t, e, q, X, W, P)
      }, a.deflateInit2 = y, a.deflateReset = k, a.deflateResetKeep = v, a.deflateSetHeader = function (t, e) {
        return t && t.state ? 2 !== t.state.wrap ? U : (t.state.gzhead = e, D) : U
      }, a.deflate = function (t, e) {
        var a, o, d, f;
        if (!t || !t.state || e > O || e < 0) return t ? i(t, U) : U;
        if (o = t.state, !t.output || !t.input && 0 !== t.avail_in || o.status === ft && e !== N) return i(t, 0 === t.avail_out ? F : U);
        if (o.strm = t, a = o.last_flush, o.last_flush = e, o.status === rt)
          if (2 === o.wrap) t.adler = 0, l(o, 31), l(o, 139), l(o, 8), o.gzhead ? (l(o, (o.gzhead.text ? 1 : 0) + (o.gzhead.hcrc ? 2 : 0) + (o.gzhead.extra ? 4 : 0) + (o.gzhead.name ? 8 : 0) + (o.gzhead.comment ? 16 : 0)), l(o, 255 & o.gzhead.time), l(o, o.gzhead.time >> 8 & 255), l(o, o.gzhead.time >> 16 & 255), l(o, o.gzhead.time >> 24 & 255), l(o, 9 === o.level ? 2 : o.strategy >= j || o.level < 2 ? 4 : 0), l(o, 255 & o.gzhead.os), o.gzhead.extra && o.gzhead.extra.length && (l(o, 255 & o.gzhead.extra.length), l(o, o.gzhead.extra.length >> 8 & 255)), o.gzhead.hcrc && (t.adler = E(t.adler, o.pending_buf, o.pending, 0)), o.gzindex = 0, o.status = st) : (l(o, 0), l(o, 0), l(o, 0), l(o, 0), l(o, 0), l(o, 9 === o.level ? 2 : o.strategy >= j || o.level < 2 ? 4 : 0), l(o, gt), o.status = dt);
          else {
            var _ = q + (o.w_bits - 8 << 4) << 8;
            _ |= (o.strategy >= j || o.level < 2 ? 0 : o.level < 6 ? 1 : 6 === o.level ? 2 : 3) << 6, 0 !== o.strstart && (_ |= nt), _ += 31 - _ % 31, o.status = dt, h(o, _), 0 !== o.strstart && (h(o, t.adler >>> 16), h(o, 65535 & t.adler)), t.adler = 1
          } if (o.status === st)
          if (o.gzhead.extra) {
            for (d = o.pending; o.gzindex < (65535 & o.gzhead.extra.length) && (o.pending !== o.pending_buf_size || (o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending !== o.pending_buf_size));) l(o, 255 & o.gzhead.extra[o.gzindex]), o.gzindex++;
            o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), o.gzindex === o.gzhead.extra.length && (o.gzindex = 0, o.status = ot)
          } else o.status = ot;
        if (o.status === ot)
          if (o.gzhead.name) {
            d = o.pending;
            do {
              if (o.pending === o.pending_buf_size && (o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending === o.pending_buf_size)) {
                f = 1;
                break
              }
              f = o.gzindex < o.gzhead.name.length ? 255 & o.gzhead.name.charCodeAt(o.gzindex++) : 0, l(o, f)
            } while (0 !== f);
            o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), 0 === f && (o.gzindex = 0, o.status = lt)
          } else o.status = lt;
        if (o.status === lt)
          if (o.gzhead.comment) {
            d = o.pending;
            do {
              if (o.pending === o.pending_buf_size && (o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), s(t), d = o.pending, o.pending === o.pending_buf_size)) {
                f = 1;
                break
              }
              f = o.gzindex < o.gzhead.comment.length ? 255 & o.gzhead.comment.charCodeAt(o.gzindex++) : 0, l(o, f)
            } while (0 !== f);
            o.gzhead.hcrc && o.pending > d && (t.adler = E(t.adler, o.pending_buf, o.pending - d, d)), 0 === f && (o.status = ht)
          } else o.status = ht;
        if (o.status === ht && (o.gzhead.hcrc ? (o.pending + 2 > o.pending_buf_size && s(t), o.pending + 2 <= o.pending_buf_size && (l(o, 255 & t.adler), l(o, t.adler >> 8 & 255), t.adler = 0, o.status = dt)) : o.status = dt), 0 !== o.pending) {
          if (s(t), 0 === t.avail_out) return o.last_flush = -1, D
        } else if (0 === t.avail_in && n(e) <= n(a) && e !== N) return i(t, F);
        if (o.status === ft && 0 !== t.avail_in) return i(t, F);
        if (0 !== t.avail_in || 0 !== o.lookahead || e !== Z && o.status !== ft) {
          var u = o.strategy === j ? g(o, e) : o.strategy === K ? b(o, e) : x[o.level].func(o, e);
          if (u !== ct && u !== bt || (o.status = ft), u === _t || u === ct) return 0 === t.avail_out && (o.last_flush = -1), D;
          if (u === ut && (e === R ? B._tr_align(o) : e !== O && (B._tr_stored_block(o, 0, 0, !1), e === C && (r(o.head), 0 === o.lookahead && (o.strstart = 0, o.block_start = 0, o.insert = 0))), s(t), 0 === t.avail_out)) return o.last_flush = -1, D
        }
        return e !== N ? D : o.wrap <= 0 ? I : (2 === o.wrap ? (l(o, 255 & t.adler), l(o, t.adler >> 8 & 255), l(o, t.adler >> 16 & 255), l(o, t.adler >> 24 & 255), l(o, 255 & t.total_in), l(o, t.total_in >> 8 & 255), l(o, t.total_in >> 16 & 255), l(o, t.total_in >> 24 & 255)) : (h(o, t.adler >>> 16), h(o, 65535 & t.adler)), s(t), o.wrap > 0 && (o.wrap = -o.wrap), 0 !== o.pending ? D : I)
      }, a.deflateEnd = function (t) {
        var e;
        return t && t.state ? (e = t.state.status) !== rt && e !== st && e !== ot && e !== lt && e !== ht && e !== dt && e !== ft ? i(t, U) : (t.state = null, e === dt ? i(t, T) : D) : U
      }, a.deflateSetDictionary = function (t, e) {
        var a, i, n, s, o, l, h, d, f = e.length;
        if (!t || !t.state) return U;
        if (a = t.state, 2 === (s = a.wrap) || 1 === s && a.status !== rt || a.lookahead) return U;
        for (1 === s && (t.adler = S(t.adler, e, f, 0)), a.wrap = 0, f >= a.w_size && (0 === s && (r(a.head), a.strstart = 0, a.block_start = 0, a.insert = 0), d = new z.Buf8(a.w_size), z.arraySet(d, e, f - a.w_size, a.w_size, 0), e = d, f = a.w_size), o = t.avail_in, l = t.next_in, h = t.input, t.avail_in = f, t.next_in = 0, t.input = e, _(a); a.lookahead >= et;) {
          i = a.strstart, n = a.lookahead - (et - 1);
          do {
            a.ins_h = (a.ins_h << a.hash_shift ^ a.window[i + et - 1]) & a.hash_mask, a.prev[i & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = i, i++
          } while (--n);
          a.strstart = i, a.lookahead = et - 1, _(a)
        }
        return a.strstart += a.lookahead, a.block_start = a.strstart, a.insert = a.lookahead, a.lookahead = 0, a.match_length = a.prev_length = et - 1, a.match_available = 0, t.next_in = l, t.input = h, t.avail_in = o, a.wrap = s, D
      }, a.deflateInfo = "pako deflate (from Nodeca project)"
    }, {
      "../utils/common": 3,
      "./adler32": 5,
      "./crc32": 7,
      "./messages": 13,
      "./trees": 14
    }],
    9: [function (t, e, a) {
      "use strict";
      e.exports = function () {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
      }
    }, {}],
    10: [function (t, e, a) {
      "use strict";
      e.exports = function (t, e) {
        var a, i, n, r, s, o, l, h, d, f, _, u, c, b, g, m, w, p, v, k, y, x, z, B, S;
        a = t.state, i = t.next_in, B = t.input, n = i + (t.avail_in - 5), r = t.next_out, S = t.output, s = r - (e - t.avail_out), o = r + (t.avail_out - 257), l = a.dmax, h = a.wsize, d = a.whave, f = a.wnext, _ = a.window, u = a.hold, c = a.bits, b = a.lencode, g = a.distcode, m = (1 << a.lenbits) - 1, w = (1 << a.distbits) - 1;
        t: do {
          c < 15 && (u += B[i++] << c, c += 8, u += B[i++] << c, c += 8), p = b[u & m];
          e: for (;;) {
            if (v = p >>> 24, u >>>= v, c -= v, 0 === (v = p >>> 16 & 255)) S[r++] = 65535 & p;
            else {
              if (!(16 & v)) {
                if (0 == (64 & v)) {
                  p = b[(65535 & p) + (u & (1 << v) - 1)];
                  continue e
                }
                if (32 & v) {
                  a.mode = 12;
                  break t
                }
                t.msg = "invalid literal/length code", a.mode = 30;
                break t
              }
              k = 65535 & p, (v &= 15) && (c < v && (u += B[i++] << c, c += 8), k += u & (1 << v) - 1, u >>>= v, c -= v), c < 15 && (u += B[i++] << c, c += 8, u += B[i++] << c, c += 8), p = g[u & w];
              a: for (;;) {
                if (v = p >>> 24, u >>>= v, c -= v, !(16 & (v = p >>> 16 & 255))) {
                  if (0 == (64 & v)) {
                    p = g[(65535 & p) + (u & (1 << v) - 1)];
                    continue a
                  }
                  t.msg = "invalid distance code", a.mode = 30;
                  break t
                }
                if (y = 65535 & p, v &= 15, c < v && (u += B[i++] << c, (c += 8) < v && (u += B[i++] << c, c += 8)), (y += u & (1 << v) - 1) > l) {
                  t.msg = "invalid distance too far back", a.mode = 30;
                  break t
                }
                if (u >>>= v, c -= v, v = r - s, y > v) {
                  if ((v = y - v) > d && a.sane) {
                    t.msg = "invalid distance too far back", a.mode = 30;
                    break t
                  }
                  if (x = 0, z = _, 0 === f) {
                    if (x += h - v, v < k) {
                      k -= v;
                      do {
                        S[r++] = _[x++]
                      } while (--v);
                      x = r - y, z = S
                    }
                  } else if (f < v) {
                    if (x += h + f - v, (v -= f) < k) {
                      k -= v;
                      do {
                        S[r++] = _[x++]
                      } while (--v);
                      if (x = 0, f < k) {
                        k -= v = f;
                        do {
                          S[r++] = _[x++]
                        } while (--v);
                        x = r - y, z = S
                      }
                    }
                  } else if (x += f - v, v < k) {
                    k -= v;
                    do {
                      S[r++] = _[x++]
                    } while (--v);
                    x = r - y, z = S
                  }
                  for (; k > 2;) S[r++] = z[x++], S[r++] = z[x++], S[r++] = z[x++], k -= 3;
                  k && (S[r++] = z[x++], k > 1 && (S[r++] = z[x++]))
                } else {
                  x = r - y;
                  do {
                    S[r++] = S[x++], S[r++] = S[x++], S[r++] = S[x++], k -= 3
                  } while (k > 2);
                  k && (S[r++] = S[x++], k > 1 && (S[r++] = S[x++]))
                }
                break
              }
            }
            break
          }
        } while (i < n && r < o);
        i -= k = c >> 3, u &= (1 << (c -= k << 3)) - 1, t.next_in = i, t.next_out = r, t.avail_in = i < n ? n - i + 5 : 5 - (i - n), t.avail_out = r < o ? o - r + 257 : 257 - (r - o), a.hold = u, a.bits = c
      }
    }, {}],
    11: [function (t, e, a) {
      "use strict";

      function i(t) {
        return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24)
      }

      function n() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new u.Buf16(320), this.work = new u.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
      }

      function r(t) {
        var e;
        return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = N, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new u.Buf32(dt), e.distcode = e.distdyn = new u.Buf32(ft), e.sane = 1, e.back = -1, z) : E
      }

      function s(t) {
        var e;
        return t && t.state ? (e = t.state, e.wsize = 0, e.whave = 0, e.wnext = 0, r(t)) : E
      }

      function o(t, e) {
        var a, i;
        return t && t.state ? (i = t.state, e < 0 ? (a = 0, e = -e) : (a = 1 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? E : (null !== i.window && i.wbits !== e && (i.window = null), i.wrap = a, i.wbits = e, s(t))) : E
      }

      function l(t, e) {
        var a, i;
        return t ? (i = new n, t.state = i, i.window = null, (a = o(t, e)) !== z && (t.state = null), a) : E
      }

      function h(t) {
        if (ut) {
          var e;
          for (f = new u.Buf32(512), _ = new u.Buf32(32), e = 0; e < 144;) t.lens[e++] = 8;
          for (; e < 256;) t.lens[e++] = 9;
          for (; e < 280;) t.lens[e++] = 7;
          for (; e < 288;) t.lens[e++] = 8;
          for (m(p, t.lens, 0, 288, f, 0, t.work, {
              bits: 9
            }), e = 0; e < 32;) t.lens[e++] = 5;
          m(v, t.lens, 0, 32, _, 0, t.work, {
            bits: 5
          }), ut = !1
        }
        t.lencode = f, t.lenbits = 9, t.distcode = _, t.distbits = 5
      }

      function d(t, e, a, i) {
        var n, r = t.state;
        return null === r.window && (r.wsize = 1 << r.wbits, r.wnext = 0, r.whave = 0, r.window = new u.Buf8(r.wsize)), i >= r.wsize ? (u.arraySet(r.window, e, a - r.wsize, r.wsize, 0), r.wnext = 0, r.whave = r.wsize) : ((n = r.wsize - r.wnext) > i && (n = i), u.arraySet(r.window, e, a - i, n, r.wnext), (i -= n) ? (u.arraySet(r.window, e, a - i, i, 0), r.wnext = i, r.whave = r.wsize) : (r.wnext += n, r.wnext === r.wsize && (r.wnext = 0), r.whave < r.wsize && (r.whave += n))), 0
      }
      var f, _, u = t("../utils/common"),
        c = t("./adler32"),
        b = t("./crc32"),
        g = t("./inffast"),
        m = t("./inftrees"),
        w = 0,
        p = 1,
        v = 2,
        k = 4,
        y = 5,
        x = 6,
        z = 0,
        B = 1,
        S = 2,
        E = -2,
        A = -3,
        Z = -4,
        R = -5,
        C = 8,
        N = 1,
        O = 2,
        D = 3,
        I = 4,
        U = 5,
        T = 6,
        F = 7,
        L = 8,
        H = 9,
        j = 10,
        K = 11,
        M = 12,
        P = 13,
        Y = 14,
        q = 15,
        G = 16,
        X = 17,
        W = 18,
        J = 19,
        Q = 20,
        V = 21,
        $ = 22,
        tt = 23,
        et = 24,
        at = 25,
        it = 26,
        nt = 27,
        rt = 28,
        st = 29,
        ot = 30,
        lt = 31,
        ht = 32,
        dt = 852,
        ft = 592,
        _t = 15,
        ut = !0;
      a.inflateReset = s, a.inflateReset2 = o, a.inflateResetKeep = r, a.inflateInit = function (t) {
        return l(t, _t)
      }, a.inflateInit2 = l, a.inflate = function (t, e) {
        var a, n, r, s, o, l, f, _, dt, ft, _t, ut, ct, bt, gt, mt, wt, pt, vt, kt, yt, xt, zt, Bt, St = 0,
          Et = new u.Buf8(4),
          At = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return E;
        (a = t.state).mode === M && (a.mode = P), o = t.next_out, r = t.output, f = t.avail_out, s = t.next_in, n = t.input, l = t.avail_in, _ = a.hold, dt = a.bits, ft = l, _t = f, xt = z;
        t: for (;;) switch (a.mode) {
          case N:
            if (0 === a.wrap) {
              a.mode = P;
              break
            }
            for (; dt < 16;) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            if (2 & a.wrap && 35615 === _) {
              a.check = 0, Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = b(a.check, Et, 2, 0), _ = 0, dt = 0, a.mode = O;
              break
            }
            if (a.flags = 0, a.head && (a.head.done = !1), !(1 & a.wrap) || (((255 & _) << 8) + (_ >> 8)) % 31) {
              t.msg = "incorrect header check", a.mode = ot;
              break
            }
            if ((15 & _) !== C) {
              t.msg = "unknown compression method", a.mode = ot;
              break
            }
            if (_ >>>= 4, dt -= 4, yt = 8 + (15 & _), 0 === a.wbits) a.wbits = yt;
            else if (yt > a.wbits) {
              t.msg = "invalid window size", a.mode = ot;
              break
            }
            a.dmax = 1 << yt, t.adler = a.check = 1, a.mode = 512 & _ ? j : M, _ = 0, dt = 0;
            break;
          case O:
            for (; dt < 16;) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            if (a.flags = _, (255 & a.flags) !== C) {
              t.msg = "unknown compression method", a.mode = ot;
              break
            }
            if (57344 & a.flags) {
              t.msg = "unknown header flags set", a.mode = ot;
              break
            }
            a.head && (a.head.text = _ >> 8 & 1), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = b(a.check, Et, 2, 0)), _ = 0, dt = 0, a.mode = D;
          case D:
            for (; dt < 32;) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            a.head && (a.head.time = _), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, Et[2] = _ >>> 16 & 255, Et[3] = _ >>> 24 & 255, a.check = b(a.check, Et, 4, 0)), _ = 0, dt = 0, a.mode = I;
          case I:
            for (; dt < 16;) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            a.head && (a.head.xflags = 255 & _, a.head.os = _ >> 8), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = b(a.check, Et, 2, 0)), _ = 0, dt = 0, a.mode = U;
          case U:
            if (1024 & a.flags) {
              for (; dt < 16;) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              a.length = _, a.head && (a.head.extra_len = _), 512 & a.flags && (Et[0] = 255 & _, Et[1] = _ >>> 8 & 255, a.check = b(a.check, Et, 2, 0)), _ = 0, dt = 0
            } else a.head && (a.head.extra = null);
            a.mode = T;
          case T:
            if (1024 & a.flags && ((ut = a.length) > l && (ut = l), ut && (a.head && (yt = a.head.extra_len - a.length, a.head.extra || (a.head.extra = new Array(a.head.extra_len)), u.arraySet(a.head.extra, n, s, ut, yt)), 512 & a.flags && (a.check = b(a.check, n, ut, s)), l -= ut, s += ut, a.length -= ut), a.length)) break t;
            a.length = 0, a.mode = F;
          case F:
            if (2048 & a.flags) {
              if (0 === l) break t;
              ut = 0;
              do {
                yt = n[s + ut++], a.head && yt && a.length < 65536 && (a.head.name += String.fromCharCode(yt))
              } while (yt && ut < l);
              if (512 & a.flags && (a.check = b(a.check, n, ut, s)), l -= ut, s += ut, yt) break t
            } else a.head && (a.head.name = null);
            a.length = 0, a.mode = L;
          case L:
            if (4096 & a.flags) {
              if (0 === l) break t;
              ut = 0;
              do {
                yt = n[s + ut++], a.head && yt && a.length < 65536 && (a.head.comment += String.fromCharCode(yt))
              } while (yt && ut < l);
              if (512 & a.flags && (a.check = b(a.check, n, ut, s)), l -= ut, s += ut, yt) break t
            } else a.head && (a.head.comment = null);
            a.mode = H;
          case H:
            if (512 & a.flags) {
              for (; dt < 16;) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              if (_ !== (65535 & a.check)) {
                t.msg = "header crc mismatch", a.mode = ot;
                break
              }
              _ = 0, dt = 0
            }
            a.head && (a.head.hcrc = a.flags >> 9 & 1, a.head.done = !0), t.adler = a.check = 0, a.mode = M;
            break;
          case j:
            for (; dt < 32;) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            t.adler = a.check = i(_), _ = 0, dt = 0, a.mode = K;
          case K:
            if (0 === a.havedict) return t.next_out = o, t.avail_out = f, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = dt, S;
            t.adler = a.check = 1, a.mode = M;
          case M:
            if (e === y || e === x) break t;
          case P:
            if (a.last) {
              _ >>>= 7 & dt, dt -= 7 & dt, a.mode = nt;
              break
            }
            for (; dt < 3;) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            switch (a.last = 1 & _, _ >>>= 1, dt -= 1, 3 & _) {
              case 0:
                a.mode = Y;
                break;
              case 1:
                if (h(a), a.mode = Q, e === x) {
                  _ >>>= 2, dt -= 2;
                  break t
                }
                break;
              case 2:
                a.mode = X;
                break;
              case 3:
                t.msg = "invalid block type", a.mode = ot
            }
            _ >>>= 2, dt -= 2;
            break;
          case Y:
            for (_ >>>= 7 & dt, dt -= 7 & dt; dt < 32;) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            if ((65535 & _) != (_ >>> 16 ^ 65535)) {
              t.msg = "invalid stored block lengths", a.mode = ot;
              break
            }
            if (a.length = 65535 & _, _ = 0, dt = 0, a.mode = q, e === x) break t;
          case q:
            a.mode = G;
          case G:
            if (ut = a.length) {
              if (ut > l && (ut = l), ut > f && (ut = f), 0 === ut) break t;
              u.arraySet(r, n, s, ut, o), l -= ut, s += ut, f -= ut, o += ut, a.length -= ut;
              break
            }
            a.mode = M;
            break;
          case X:
            for (; dt < 14;) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            if (a.nlen = 257 + (31 & _), _ >>>= 5, dt -= 5, a.ndist = 1 + (31 & _), _ >>>= 5, dt -= 5, a.ncode = 4 + (15 & _), _ >>>= 4, dt -= 4, a.nlen > 286 || a.ndist > 30) {
              t.msg = "too many length or distance symbols", a.mode = ot;
              break
            }
            a.have = 0, a.mode = W;
          case W:
            for (; a.have < a.ncode;) {
              for (; dt < 3;) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              a.lens[At[a.have++]] = 7 & _, _ >>>= 3, dt -= 3
            }
            for (; a.have < 19;) a.lens[At[a.have++]] = 0;
            if (a.lencode = a.lendyn, a.lenbits = 7, zt = {
                bits: a.lenbits
              }, xt = m(w, a.lens, 0, 19, a.lencode, 0, a.work, zt), a.lenbits = zt.bits, xt) {
              t.msg = "invalid code lengths set", a.mode = ot;
              break
            }
            a.have = 0, a.mode = J;
          case J:
            for (; a.have < a.nlen + a.ndist;) {
              for (; St = a.lencode[_ & (1 << a.lenbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= dt);) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              if (wt < 16) _ >>>= gt, dt -= gt, a.lens[a.have++] = wt;
              else {
                if (16 === wt) {
                  for (Bt = gt + 2; dt < Bt;) {
                    if (0 === l) break t;
                    l--, _ += n[s++] << dt, dt += 8
                  }
                  if (_ >>>= gt, dt -= gt, 0 === a.have) {
                    t.msg = "invalid bit length repeat", a.mode = ot;
                    break
                  }
                  yt = a.lens[a.have - 1], ut = 3 + (3 & _), _ >>>= 2, dt -= 2
                } else if (17 === wt) {
                  for (Bt = gt + 3; dt < Bt;) {
                    if (0 === l) break t;
                    l--, _ += n[s++] << dt, dt += 8
                  }
                  dt -= gt, yt = 0, ut = 3 + (7 & (_ >>>= gt)), _ >>>= 3, dt -= 3
                } else {
                  for (Bt = gt + 7; dt < Bt;) {
                    if (0 === l) break t;
                    l--, _ += n[s++] << dt, dt += 8
                  }
                  dt -= gt, yt = 0, ut = 11 + (127 & (_ >>>= gt)), _ >>>= 7, dt -= 7
                }
                if (a.have + ut > a.nlen + a.ndist) {
                  t.msg = "invalid bit length repeat", a.mode = ot;
                  break
                }
                for (; ut--;) a.lens[a.have++] = yt
              }
            }
            if (a.mode === ot) break;
            if (0 === a.lens[256]) {
              t.msg = "invalid code -- missing end-of-block", a.mode = ot;
              break
            }
            if (a.lenbits = 9, zt = {
                bits: a.lenbits
              }, xt = m(p, a.lens, 0, a.nlen, a.lencode, 0, a.work, zt), a.lenbits = zt.bits, xt) {
              t.msg = "invalid literal/lengths set", a.mode = ot;
              break
            }
            if (a.distbits = 6, a.distcode = a.distdyn, zt = {
                bits: a.distbits
              }, xt = m(v, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, zt), a.distbits = zt.bits, xt) {
              t.msg = "invalid distances set", a.mode = ot;
              break
            }
            if (a.mode = Q, e === x) break t;
          case Q:
            a.mode = V;
          case V:
            if (l >= 6 && f >= 258) {
              t.next_out = o, t.avail_out = f, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = dt, g(t, _t), o = t.next_out, r = t.output, f = t.avail_out, s = t.next_in, n = t.input, l = t.avail_in, _ = a.hold, dt = a.bits, a.mode === M && (a.back = -1);
              break
            }
            for (a.back = 0; St = a.lencode[_ & (1 << a.lenbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= dt);) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            if (mt && 0 == (240 & mt)) {
              for (pt = gt, vt = mt, kt = wt; St = a.lencode[kt + ((_ & (1 << pt + vt) - 1) >> pt)], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(pt + gt <= dt);) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              _ >>>= pt, dt -= pt, a.back += pt
            }
            if (_ >>>= gt, dt -= gt, a.back += gt, a.length = wt, 0 === mt) {
              a.mode = it;
              break
            }
            if (32 & mt) {
              a.back = -1, a.mode = M;
              break
            }
            if (64 & mt) {
              t.msg = "invalid literal/length code", a.mode = ot;
              break
            }
            a.extra = 15 & mt, a.mode = $;
          case $:
            if (a.extra) {
              for (Bt = a.extra; dt < Bt;) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              a.length += _ & (1 << a.extra) - 1, _ >>>= a.extra, dt -= a.extra, a.back += a.extra
            }
            a.was = a.length, a.mode = tt;
          case tt:
            for (; St = a.distcode[_ & (1 << a.distbits) - 1], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(gt <= dt);) {
              if (0 === l) break t;
              l--, _ += n[s++] << dt, dt += 8
            }
            if (0 == (240 & mt)) {
              for (pt = gt, vt = mt, kt = wt; St = a.distcode[kt + ((_ & (1 << pt + vt) - 1) >> pt)], gt = St >>> 24, mt = St >>> 16 & 255, wt = 65535 & St, !(pt + gt <= dt);) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              _ >>>= pt, dt -= pt, a.back += pt
            }
            if (_ >>>= gt, dt -= gt, a.back += gt, 64 & mt) {
              t.msg = "invalid distance code", a.mode = ot;
              break
            }
            a.offset = wt, a.extra = 15 & mt, a.mode = et;
          case et:
            if (a.extra) {
              for (Bt = a.extra; dt < Bt;) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              a.offset += _ & (1 << a.extra) - 1, _ >>>= a.extra, dt -= a.extra, a.back += a.extra
            }
            if (a.offset > a.dmax) {
              t.msg = "invalid distance too far back", a.mode = ot;
              break
            }
            a.mode = at;
          case at:
            if (0 === f) break t;
            if (ut = _t - f, a.offset > ut) {
              if ((ut = a.offset - ut) > a.whave && a.sane) {
                t.msg = "invalid distance too far back", a.mode = ot;
                break
              }
              ut > a.wnext ? (ut -= a.wnext, ct = a.wsize - ut) : ct = a.wnext - ut, ut > a.length && (ut = a.length), bt = a.window
            } else bt = r, ct = o - a.offset, ut = a.length;
            ut > f && (ut = f), f -= ut, a.length -= ut;
            do {
              r[o++] = bt[ct++]
            } while (--ut);
            0 === a.length && (a.mode = V);
            break;
          case it:
            if (0 === f) break t;
            r[o++] = a.length, f--, a.mode = V;
            break;
          case nt:
            if (a.wrap) {
              for (; dt < 32;) {
                if (0 === l) break t;
                l--, _ |= n[s++] << dt, dt += 8
              }
              if (_t -= f, t.total_out += _t, a.total += _t, _t && (t.adler = a.check = a.flags ? b(a.check, r, _t, o - _t) : c(a.check, r, _t, o - _t)), _t = f, (a.flags ? _ : i(_)) !== a.check) {
                t.msg = "incorrect data check", a.mode = ot;
                break
              }
              _ = 0, dt = 0
            }
            a.mode = rt;
          case rt:
            if (a.wrap && a.flags) {
              for (; dt < 32;) {
                if (0 === l) break t;
                l--, _ += n[s++] << dt, dt += 8
              }
              if (_ !== (4294967295 & a.total)) {
                t.msg = "incorrect length check", a.mode = ot;
                break
              }
              _ = 0, dt = 0
            }
            a.mode = st;
          case st:
            xt = B;
            break t;
          case ot:
            xt = A;
            break t;
          case lt:
            return Z;
          case ht:
          default:
            return E
        }
        return t.next_out = o, t.avail_out = f, t.next_in = s, t.avail_in = l, a.hold = _, a.bits = dt, (a.wsize || _t !== t.avail_out && a.mode < ot && (a.mode < nt || e !== k)) && d(t, t.output, t.next_out, _t - t.avail_out) ? (a.mode = lt, Z) : (ft -= t.avail_in, _t -= t.avail_out, t.total_in += ft, t.total_out += _t, a.total += _t, a.wrap && _t && (t.adler = a.check = a.flags ? b(a.check, r, _t, t.next_out - _t) : c(a.check, r, _t, t.next_out - _t)), t.data_type = a.bits + (a.last ? 64 : 0) + (a.mode === M ? 128 : 0) + (a.mode === Q || a.mode === q ? 256 : 0), (0 === ft && 0 === _t || e === k) && xt === z && (xt = R), xt)
      }, a.inflateEnd = function (t) {
        if (!t || !t.state) return E;
        var e = t.state;
        return e.window && (e.window = null), t.state = null, z
      }, a.inflateGetHeader = function (t, e) {
        var a;
        return t && t.state ? 0 == (2 & (a = t.state).wrap) ? E : (a.head = e, e.done = !1, z) : E
      }, a.inflateSetDictionary = function (t, e) {
        var a, i, n = e.length;
        return t && t.state ? 0 !== (a = t.state).wrap && a.mode !== K ? E : a.mode === K && (i = 1, (i = c(i, e, n, 0)) !== a.check) ? A : d(t, e, n, n) ? (a.mode = lt, Z) : (a.havedict = 1, z) : E
      }, a.inflateInfo = "pako inflate (from Nodeca project)"
    }, {
      "../utils/common": 3,
      "./adler32": 5,
      "./crc32": 7,
      "./inffast": 10,
      "./inftrees": 12
    }],
    12: [function (t, e, a) {
      "use strict";
      var i = t("../utils/common"),
        n = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
        r = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
        s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
        o = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      e.exports = function (t, e, a, l, h, d, f, _) {
        var u, c, b, g, m, w, p, v, k, y = _.bits,
          x = 0,
          z = 0,
          B = 0,
          S = 0,
          E = 0,
          A = 0,
          Z = 0,
          R = 0,
          C = 0,
          N = 0,
          O = null,
          D = 0,
          I = new i.Buf16(16),
          U = new i.Buf16(16),
          T = null,
          F = 0;
        for (x = 0; x <= 15; x++) I[x] = 0;
        for (z = 0; z < l; z++) I[e[a + z]]++;
        for (E = y, S = 15; S >= 1 && 0 === I[S]; S--);
        if (E > S && (E = S), 0 === S) return h[d++] = 20971520, h[d++] = 20971520, _.bits = 1, 0;
        for (B = 1; B < S && 0 === I[B]; B++);
        for (E < B && (E = B), R = 1, x = 1; x <= 15; x++)
          if (R <<= 1, (R -= I[x]) < 0) return -1;
        if (R > 0 && (0 === t || 1 !== S)) return -1;
        for (U[1] = 0, x = 1; x < 15; x++) U[x + 1] = U[x] + I[x];
        for (z = 0; z < l; z++) 0 !== e[a + z] && (f[U[e[a + z]]++] = z);
        if (0 === t ? (O = T = f, w = 19) : 1 === t ? (O = n, D -= 257, T = r, F -= 257, w = 256) : (O = s, T = o, w = -1), N = 0, z = 0, x = B, m = d, A = E, Z = 0, b = -1, C = 1 << E, g = C - 1, 1 === t && C > 852 || 2 === t && C > 592) return 1;
        for (;;) {
          p = x - Z, f[z] < w ? (v = 0, k = f[z]) : f[z] > w ? (v = T[F + f[z]], k = O[D + f[z]]) : (v = 96, k = 0), u = 1 << x - Z, B = c = 1 << A;
          do {
            h[m + (N >> Z) + (c -= u)] = p << 24 | v << 16 | k | 0
          } while (0 !== c);
          for (u = 1 << x - 1; N & u;) u >>= 1;
          if (0 !== u ? (N &= u - 1, N += u) : N = 0, z++, 0 == --I[x]) {
            if (x === S) break;
            x = e[a + f[z]]
          }
          if (x > E && (N & g) !== b) {
            for (0 === Z && (Z = E), m += B, R = 1 << (A = x - Z); A + Z < S && !((R -= I[A + Z]) <= 0);) A++, R <<= 1;
            if (C += 1 << A, 1 === t && C > 852 || 2 === t && C > 592) return 1;
            h[b = N & g] = E << 24 | A << 16 | m - d | 0
          }
        }
        return 0 !== N && (h[m + N] = x - Z << 24 | 64 << 16 | 0), _.bits = E, 0
      }
    }, {
      "../utils/common": 3
    }],
    13: [function (t, e, a) {
      "use strict";
      e.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      }
    }, {}],
    14: [function (t, e, a) {
      "use strict";

      function i(t) {
        for (var e = t.length; --e >= 0;) t[e] = 0
      }

      function n(t, e, a, i, n) {
        this.static_tree = t, this.extra_bits = e, this.extra_base = a, this.elems = i, this.max_length = n, this.has_stree = t && t.length
      }

      function r(t, e) {
        this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
      }

      function s(t) {
        return t < 256 ? et[t] : et[256 + (t >>> 7)]
      }

      function o(t, e) {
        t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255
      }

      function l(t, e, a) {
        t.bi_valid > M - a ? (t.bi_buf |= e << t.bi_valid & 65535, o(t, t.bi_buf), t.bi_buf = e >> M - t.bi_valid, t.bi_valid += a - M) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += a)
      }

      function h(t, e, a) {
        l(t, a[2 * e], a[2 * e + 1])
      }

      function d(t, e) {
        var a = 0;
        do {
          a |= 1 & t, t >>>= 1, a <<= 1
        } while (--e > 0);
        return a >>> 1
      }

      function f(t) {
        16 === t.bi_valid ? (o(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8)
      }

      function _(t, e) {
        var a, i, n, r, s, o, l = e.dyn_tree,
          h = e.max_code,
          d = e.stat_desc.static_tree,
          f = e.stat_desc.has_stree,
          _ = e.stat_desc.extra_bits,
          u = e.stat_desc.extra_base,
          c = e.stat_desc.max_length,
          b = 0;
        for (r = 0; r <= K; r++) t.bl_count[r] = 0;
        for (l[2 * t.heap[t.heap_max] + 1] = 0, a = t.heap_max + 1; a < j; a++)(r = l[2 * l[2 * (i = t.heap[a]) + 1] + 1] + 1) > c && (r = c, b++), l[2 * i + 1] = r, i > h || (t.bl_count[r]++, s = 0, i >= u && (s = _[i - u]), o = l[2 * i], t.opt_len += o * (r + s), f && (t.static_len += o * (d[2 * i + 1] + s)));
        if (0 !== b) {
          do {
            for (r = c - 1; 0 === t.bl_count[r];) r--;
            t.bl_count[r]--, t.bl_count[r + 1] += 2, t.bl_count[c]--, b -= 2
          } while (b > 0);
          for (r = c; 0 !== r; r--)
            for (i = t.bl_count[r]; 0 !== i;)(n = t.heap[--a]) > h || (l[2 * n + 1] !== r && (t.opt_len += (r - l[2 * n + 1]) * l[2 * n], l[2 * n + 1] = r), i--)
        }
      }

      function u(t, e, a) {
        var i, n, r = new Array(K + 1),
          s = 0;
        for (i = 1; i <= K; i++) r[i] = s = s + a[i - 1] << 1;
        for (n = 0; n <= e; n++) {
          var o = t[2 * n + 1];
          0 !== o && (t[2 * n] = d(r[o]++, o))
        }
      }

      function c() {
        var t, e, a, i, r, s = new Array(K + 1);
        for (a = 0, i = 0; i < U - 1; i++)
          for (it[i] = a, t = 0; t < 1 << W[i]; t++) at[a++] = i;
        for (at[a - 1] = i, r = 0, i = 0; i < 16; i++)
          for (nt[i] = r, t = 0; t < 1 << J[i]; t++) et[r++] = i;
        for (r >>= 7; i < L; i++)
          for (nt[i] = r << 7, t = 0; t < 1 << J[i] - 7; t++) et[256 + r++] = i;
        for (e = 0; e <= K; e++) s[e] = 0;
        for (t = 0; t <= 143;) $[2 * t + 1] = 8, t++, s[8]++;
        for (; t <= 255;) $[2 * t + 1] = 9, t++, s[9]++;
        for (; t <= 279;) $[2 * t + 1] = 7, t++, s[7]++;
        for (; t <= 287;) $[2 * t + 1] = 8, t++, s[8]++;
        for (u($, F + 1, s), t = 0; t < L; t++) tt[2 * t + 1] = 5, tt[2 * t] = d(t, 5);
        rt = new n($, W, T + 1, F, K), st = new n(tt, J, 0, L, K), ot = new n(new Array(0), Q, 0, H, P)
      }

      function b(t) {
        var e;
        for (e = 0; e < F; e++) t.dyn_ltree[2 * e] = 0;
        for (e = 0; e < L; e++) t.dyn_dtree[2 * e] = 0;
        for (e = 0; e < H; e++) t.bl_tree[2 * e] = 0;
        t.dyn_ltree[2 * Y] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0
      }

      function g(t) {
        t.bi_valid > 8 ? o(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
      }

      function m(t, e, a, i) {
        g(t), i && (o(t, a), o(t, ~a)), A.arraySet(t.pending_buf, t.window, e, a, t.pending), t.pending += a
      }

      function w(t, e, a, i) {
        var n = 2 * e,
          r = 2 * a;
        return t[n] < t[r] || t[n] === t[r] && i[e] <= i[a]
      }

      function p(t, e, a) {
        for (var i = t.heap[a], n = a << 1; n <= t.heap_len && (n < t.heap_len && w(e, t.heap[n + 1], t.heap[n], t.depth) && n++, !w(e, i, t.heap[n], t.depth));) t.heap[a] = t.heap[n], a = n, n <<= 1;
        t.heap[a] = i
      }

      function v(t, e, a) {
        var i, n, r, o, d = 0;
        if (0 !== t.last_lit)
          do {
            i = t.pending_buf[t.d_buf + 2 * d] << 8 | t.pending_buf[t.d_buf + 2 * d + 1], n = t.pending_buf[t.l_buf + d], d++, 0 === i ? h(t, n, e) : (h(t, (r = at[n]) + T + 1, e), 0 !== (o = W[r]) && l(t, n -= it[r], o), h(t, r = s(--i), a), 0 !== (o = J[r]) && l(t, i -= nt[r], o))
          } while (d < t.last_lit);
        h(t, Y, e)
      }

      function k(t, e) {
        var a, i, n, r = e.dyn_tree,
          s = e.stat_desc.static_tree,
          o = e.stat_desc.has_stree,
          l = e.stat_desc.elems,
          h = -1;
        for (t.heap_len = 0, t.heap_max = j, a = 0; a < l; a++) 0 !== r[2 * a] ? (t.heap[++t.heap_len] = h = a, t.depth[a] = 0) : r[2 * a + 1] = 0;
        for (; t.heap_len < 2;) r[2 * (n = t.heap[++t.heap_len] = h < 2 ? ++h : 0)] = 1, t.depth[n] = 0, t.opt_len--, o && (t.static_len -= s[2 * n + 1]);
        for (e.max_code = h, a = t.heap_len >> 1; a >= 1; a--) p(t, r, a);
        n = l;
        do {
          a = t.heap[1], t.heap[1] = t.heap[t.heap_len--], p(t, r, 1), i = t.heap[1], t.heap[--t.heap_max] = a, t.heap[--t.heap_max] = i, r[2 * n] = r[2 * a] + r[2 * i], t.depth[n] = (t.depth[a] >= t.depth[i] ? t.depth[a] : t.depth[i]) + 1, r[2 * a + 1] = r[2 * i + 1] = n, t.heap[1] = n++, p(t, r, 1)
        } while (t.heap_len >= 2);
        t.heap[--t.heap_max] = t.heap[1], _(t, e), u(r, h, t.bl_count)
      }

      function y(t, e, a) {
        var i, n, r = -1,
          s = e[1],
          o = 0,
          l = 7,
          h = 4;
        for (0 === s && (l = 138, h = 3), e[2 * (a + 1) + 1] = 65535, i = 0; i <= a; i++) n = s, s = e[2 * (i + 1) + 1], ++o < l && n === s || (o < h ? t.bl_tree[2 * n] += o : 0 !== n ? (n !== r && t.bl_tree[2 * n]++, t.bl_tree[2 * q]++) : o <= 10 ? t.bl_tree[2 * G]++ : t.bl_tree[2 * X]++, o = 0, r = n, 0 === s ? (l = 138, h = 3) : n === s ? (l = 6, h = 3) : (l = 7, h = 4))
      }

      function x(t, e, a) {
        var i, n, r = -1,
          s = e[1],
          o = 0,
          d = 7,
          f = 4;
        for (0 === s && (d = 138, f = 3), i = 0; i <= a; i++)
          if (n = s, s = e[2 * (i + 1) + 1], !(++o < d && n === s)) {
            if (o < f)
              do {
                h(t, n, t.bl_tree)
              } while (0 != --o);
            else 0 !== n ? (n !== r && (h(t, n, t.bl_tree), o--), h(t, q, t.bl_tree), l(t, o - 3, 2)) : o <= 10 ? (h(t, G, t.bl_tree), l(t, o - 3, 3)) : (h(t, X, t.bl_tree), l(t, o - 11, 7));
            o = 0, r = n, 0 === s ? (d = 138, f = 3) : n === s ? (d = 6, f = 3) : (d = 7, f = 4)
          }
      }

      function z(t) {
        var e;
        for (y(t, t.dyn_ltree, t.l_desc.max_code), y(t, t.dyn_dtree, t.d_desc.max_code), k(t, t.bl_desc), e = H - 1; e >= 3 && 0 === t.bl_tree[2 * V[e] + 1]; e--);
        return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
      }

      function B(t, e, a, i) {
        var n;
        for (l(t, e - 257, 5), l(t, a - 1, 5), l(t, i - 4, 4), n = 0; n < i; n++) l(t, t.bl_tree[2 * V[n] + 1], 3);
        x(t, t.dyn_ltree, e - 1), x(t, t.dyn_dtree, a - 1)
      }

      function S(t) {
        var e, a = 4093624447;
        for (e = 0; e <= 31; e++, a >>>= 1)
          if (1 & a && 0 !== t.dyn_ltree[2 * e]) return R;
        if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return C;
        for (e = 32; e < T; e++)
          if (0 !== t.dyn_ltree[2 * e]) return C;
        return R
      }

      function E(t, e, a, i) {
        l(t, (O << 1) + (i ? 1 : 0), 3), m(t, e, a, !0)
      }
      var A = t("../utils/common"),
        Z = 4,
        R = 0,
        C = 1,
        N = 2,
        O = 0,
        D = 1,
        I = 2,
        U = 29,
        T = 256,
        F = T + 1 + U,
        L = 30,
        H = 19,
        j = 2 * F + 1,
        K = 15,
        M = 16,
        P = 7,
        Y = 256,
        q = 16,
        G = 17,
        X = 18,
        W = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
        J = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
        Q = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
        V = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
        $ = new Array(2 * (F + 2));
      i($);
      var tt = new Array(2 * L);
      i(tt);
      var et = new Array(512);
      i(et);
      var at = new Array(256);
      i(at);
      var it = new Array(U);
      i(it);
      var nt = new Array(L);
      i(nt);
      var rt, st, ot, lt = !1;
      a._tr_init = function (t) {
        lt || (c(), lt = !0), t.l_desc = new r(t.dyn_ltree, rt), t.d_desc = new r(t.dyn_dtree, st), t.bl_desc = new r(t.bl_tree, ot), t.bi_buf = 0, t.bi_valid = 0, b(t)
      }, a._tr_stored_block = E, a._tr_flush_block = function (t, e, a, i) {
        var n, r, s = 0;
        t.level > 0 ? (t.strm.data_type === N && (t.strm.data_type = S(t)), k(t, t.l_desc), k(t, t.d_desc), s = z(t), n = t.opt_len + 3 + 7 >>> 3, (r = t.static_len + 3 + 7 >>> 3) <= n && (n = r)) : n = r = a + 5, a + 4 <= n && -1 !== e ? E(t, e, a, i) : t.strategy === Z || r === n ? (l(t, (D << 1) + (i ? 1 : 0), 3), v(t, $, tt)) : (l(t, (I << 1) + (i ? 1 : 0), 3), B(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), v(t, t.dyn_ltree, t.dyn_dtree)), b(t), i && g(t)
      }, a._tr_tally = function (t, e, a) {
        return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & a, t.last_lit++, 0 === e ? t.dyn_ltree[2 * a]++ : (t.matches++, e--, t.dyn_ltree[2 * (at[a] + T + 1)]++, t.dyn_dtree[2 * s(e)]++), t.last_lit === t.lit_bufsize - 1
      }, a._tr_align = function (t) {
        l(t, D << 1, 3), h(t, Y, $), f(t)
      }
    }, {
      "../utils/common": 3
    }],
    15: [function (t, e, a) {
      "use strict";
      e.exports = function () {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
      }
    }, {}],
    "/": [function (t, e, a) {
      "use strict";
      var i = {};
      (0, t("./lib/utils/common").assign)(i, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = i
    }, {
      "./lib/deflate": 1,
      "./lib/inflate": 2,
      "./lib/utils/common": 3,
      "./lib/zlib/constants": 6
    }]
  }, {}, [])("/")
});
(function (global) {

  var models = {
    "af": "ie  didieen ingan  envan vang te n dverer e v ge bede  vende in tele dererset oor 'n'n at eersteordaarsie waes e saan onis in e ordee basirinonde wel  isande eeide dom ke  omeri woe gr dalewat void it rd  aalik wet d ope tngsse enduit st leenster ree aiesworg vstan s na prn o meal of  vierdleee k deiteerkik e re pn ve ie neeneliwer of datelnieikes etaage virheiir regedes vur proeleionwete l moe mdaasios d he toentardnge ooeurlleienn bekelinraa niontbesrdivoons n adeldignas sa grniskom uimenop insonaeres o son gig moe kors gesnalvole hgebruiangigeoetar wysligas n w asmetgs deut vaalerwditkenssekel huewedinn t seestikan pntwt ieni kan edoealiemegronte honsigeniergewn hor  maindne ek aatn ' skide tadatskagersoon ks i afteend eelhulneewoorikd vn mre artebrlankkeronaamtrestrkanreeleit ograhetevotandenist dobrutoeolgrskuikrwyminlgeg eg onstr vgtewaawe ansesiesevoeepagel hivinnses ws tteieitpre",
    "ar": " الالعلعرعراراق فيفي ين ية ن االمات من ي ا منالأة ااق  وااء الإ أنوالما  عللى ت اون هم اقيام ل اأن م االتلا الاان ها ال ة وا ارهالاميين وللأمنا علىن يالباد القد اذا ه ا باالدب امريلم  إن للسلاأمرريكمة ى اا ي عن هذء ار اكانقتلإسلالحوا  إلا أبالن مالسرة لإسن وهابي وير  كالة يات لاانتن أيكيالرالوة فدة الجقي وي الذالشاميانيذه عن لماهذهول اف اويبرية ل أم لم مايد  أيإرهع اعملولاإلىابين فختطلك نه ني إن دينف الذيي أي ب وأا عالختل تي قد لدي كل معاب اختار النعلام ومع س اكل لاءن بن تي معربم ب وق يقا لا مالفتطادادلمسله هذا محؤلابي ة من لهؤلكن لإرلتي أو ان عما فة أطافعب ل من عور يا  يسا تة براءعالقواقيةلعام يمي ميةنيةأي ابابغدبل رب عماغدامالملييس  بأ بع بغ ومباتبيةذلكعة قاوقييكي م مي ع عر قاا ورى ق اواتوم  هؤا بدامدي راتشعبلانلشعلقوليان هي تي ي وه يحجراجماحمددم كم لاولرهماعن قنة هي  بل به له ويا كاذااع ت متخاخابر ملمتمسلى أيستيطا لأ ليأمناستبعضة تري صداق وقولمد نتخنفسنهاهناأعمأنهائنالآالكحة د مر عربي",
    "az": "lərin ın larda an ir də ki  biən əriarıər dirnda kirinnınəsiini ed qa tə ba olasıilərın yaanı vəndəni araınıınd busi ib aq dəniyanə rə n bsınvə irilə ninəli de mübirn sri ək  az səar bilzərbu danediindmanun ərə halanyyəiyy il ner kə b isna nunır  da həa binəsinyanərb də mə qədırli olarbaazəcanlı nla et göalıaycbayeftistn ineftləycayətəcə laildnı tinldilikn hn moyuraqya əti aradaedəmassı ınaə dələayıiyilmaməkn dti yinyunət azıft i tllin ara  cə gə ko nə oya danacəkeyiilmirllayliylubn ərilrləunuverün ə oəni he ma on paaladeyi mimalməmətparyə ətl al mi sa əladıakıandardartayii ai qi yiliillisən on qolurlastəsə tantelyarədə me rə ve yea kat başdiyentetihəsi iik la mişn nnu qarrantərxanə aə gə t düamab kdileraetmi bkilmiln rqlar srassiysontimyerə k gü so sö te xaai barctidi erigörgüngəlhbəihəikiisilinmaimaqn kn tn vonuqanqəztə xalyibyihzetzırıb ə məze br in ir pr ta to üça oalianianlaqlazibri",
    "bg": "на  нато  пр зата  поитете а па с отза атаия  в е н даа н се кода от анипрене енио нни се  и но анеетоа вва ване па ооторанат ред неа ди п допро съли принияскитела ипо ри  е  каиракатниените зи со состче  раисто п из сае диники мин миа бавае вие полствт н въ ст тоазае оов ст ът и ниятнатра  бъ чеалне сен ести дленнисо оови об сла ратоконносровще  ре с  спватешеи вието вовестаа ка тдатентка леднетористрстъти тър теа за мад анаенои оинаитима скаслетвотерцияят  бе де паатевенви вити зи инарнововаповрезритса ята го щеалив пграе иедиелииликазкитлноменолираз ве гр им ме пъавиакоачавинво говданди до ед ериерождаитоковколлнимерначо золаон онапраравремсиястит птанха ше шенълг ба сиаробълв ргаре еелнемеикоимако коила лгао дозиоитподресриестот кт мт суст би дв дъ ма мо ни осалаансараатиацибешвъре редвемажави киалицаичекиялито бовоодиокапосродседслут итовувациачеся з во ил ск тр цеамиарибатби брабъд",
    "ca": " dees de la  lael que el coents d qu i en er  a ls nt  pee la d enperci ar ue al  seestat  ests  s  praci unresmens edels as p reles l'na a l ca d'elsa pia ns con letata ci da ara a e noant alt ds i dita re a scoms citaonsstaica por a inprotre pauesambiondesun  mada s sa ian mb  aml de dva pretere ee ca mciaunai encitra teonaos t en el cca ciol p trparr lt ae paqunta soameerar ee sadan as q si haalstes va m icintes ls mi aor  moistectlitm s toir a tespranstrom l sst nts meno r dd'al'aatsrias t tasenrs eixtars nn ltale at part mi lltictenser aqinantra fstiol a qforuraersariintactl'e fir se ttorsi stereca r feis em n dcarbre fo vi analii pix elll mposorml li l acfers resseu e mensaraerisa ssius orttotll porora citanassn costnesraca uverontha  tiitzgrat c n a vrencatnal riquat l dot srmauali ss fn ps vte t i bactetammanl tial faic  veblea nalltzaies s'le ompr c ncrtiit rreficanyon  sar ptur",
    "ceb": "ng sa  saangga nga ka ngan  an na ma nia sa non  pa sia ka m baonga iila mgmgaa piyaa aay ka alaingg mn sg nlan gina ni o sg pn n daag pagg syanayoo nsi  moa bg aailg bhana dasunagya manne pankon il laakaakoanabasko od yo  di ko uga ug kkanla lensurug  aiapaaw d sg dg gilenin iy sueneog ot abaahaas imo kia tagabaneronano kranronsilunausa usa gahianier ha i areryon puininakro to ure ed og wailimo n and o a ad du praroi sma n mulound taaraasaatoawadmue nedminamakmunniysanwa  tu una lbayigaikaitakinlismayos  arad aliamaersipaisamaonimt stin ak ap hiaboagpanoatag igangkagpai mihak slawor rs siytag al at ha hu ima hbu e sgmakaslagmonnahngor sra sabsamsulubauha lo readaakiayabahce d nlabpa paks ns stantawte umaura in lua cabiat awobatdaldlaeleg tg ugaygo habhini ei nkabkaplaylinnilpampaspropulta tonugaugmunt co gu mi pi tia oabuadladoaghagkao artbalcitdi dtodunentg egongugia ibaicein inuit kaa",
    "cs": " pr poní pro nana  přch  je neže  že se do ro st v  vepřese ho sta to vy zaou  a to  byla ce e vistle podí p vle ne sje ké by em ých odovaředdy eníkonli ně str záve  ka sve pit ládohorovroztervláím  kohodnispříský mi ob soa palibudednickkteku o sal ci e til ny né odlovárotsouání bu mo o astbylde ek ost mí taes jedky lasm pnesnímranremrosého de kt ni si výat jí ký mi pretaktany vřek ch li ná pa ředa dlednei pi vly mino no vpoltravalvnííchý přej ce kd lea sa zcene kedseklemikl latlo miénovpraskuskéstitavti ty vánvé y ny sí sí vě p dn ně sp čsa na tak dnídohe be mejnenaestinim znalnouná oviovéovýrskstátí třetů udeza é pém í d ir zvaleaněaveckédene zechen erýhlai siérlovmu nebnico bo mpadpotravroprý sedsi t ptictu tě u pu vvá výšzvýčníří ům  bl br ho ja re s  z  zda vaniatoblabriečneřeh vi nie ilairsitekovnoso oo poceodyohloliovoplapočprára ritrodry sd skossdtelu svatveřvitvlay pálnčssšen al",
    "cy": "yn dd  yn y yddethth  i aetd ych od ol edd ga gw'r au ddiad  cy gy ei o iadyr an bodwed bo ddel n y amdi edion  we ym ar rhodd ca maaeloeddaen addaer h yallei  llam eu fodfydl yn gwynd ai gmaeneuos  ned idoddoln cr hwydwyrai ar in rth fy he me yr'n diaesth chaii did r yy b dy haadai bn ioterottesy gyd  ad mr uncyndauddyedoi ci withlaelland odarydtho a  draidainddodydfyngynholio o awchwybyboych br by di fe na o' peartbyddrogall elaimr n nr arhywn ynn on r caed gd od wgangwyn dn fn onedni o'rr dud weiwrt an cw da ni pa pr wyd edaidimeudgwaiddim irilwyn bnolr orwy ch er fo ge hy i' ro sa trbobcwycyfdiodyneithelhynichll mddn rondpror cr gredrhau au cu yy cymdymryw  ac be bl co osadwae af d pefneicen eoles fergelh ghodiedir lafn hna nydodoofyrddrierosstwtwyydayng at de go id oe â 'chac achae'al bl d cd ldanddeddwdirdlaed elaelleneewngydhauhywi ai fiolionl al iliamedmonn sno oblolarefrn thiun ",
    "da": "er en  deet derde for fo i at  atre det handeereingden me oggerter er siand afor  st ti enog ar il r sigetilke r eaf kke ma påom på ed ge endnget se sler skelsernsigne ligr dska vihar be sean ikkllegenn fstet at drin ikes ng verr bsenedemenr i he etig lanmednd rne da ine tmmeund ome ee mherle r ft fså te  soelet e koestske ble fektmarbrue ael ersretsomtteve  la ud veagee de hlsemanrugselser fi op prdt e in mr m an re saionnerrest igetn soneorbt hvisår  frbile kensindommt m hv jedanentftenin mie oe pn onte kuellnasorer hr kstastodagerikunldemerr ar vrekrert otortør få må toboechee vi divekabns oelse t v al bo unansdreirekøborsoverent bør  kaaldbetgt iskkalkomlevn dn iprir prbrsøgtel så te vaal direjefisgsåiscjerkerogsschst t kuge diag d ag iilll alskn aon samstrtetvar moartashatte bhanhavklakonn tnedr ora rrevesvil el kr ovanne uessfrag ag dintngsrdetra åraktasiem gelgymholkanmnan hnskold",
    "de": "en er  dederie  didiescheincheichdenin te ch  eiungn dnd  beveres  zueitgenund un au inchtit ten daent veand geine mir dhenng nde voe dbermenei mit stterrent d ereren sste see sht desistne aufe aiscon rte re wegesuch fü sobeie enenr sachfürierparür  haas ert an pa sa sp wifortagzu dasreihe hrentesenvor scechetzheilann apd st staeselic ab sigte waitikein engeseitrazen im laartim llen wrderecsetstrteitte nie peheersg dnicvon al pran auserfr etzetüruf ag alsar chsendge igeionls n mngsnisnt ords ssse tüahle bedeem lenn iormprorkeruns dwahwerürk meageattellesthatn bollrafs atsc es fo gr jaabeaucbene negelien ur vre ritsag amagtahrbrade erdheritele n pn vor rbert sicwieübe is übchachie fe meriiedmmenerr astit at stis koarbds gann zr fr wranse t iweiwir br npam besd ddeue ge kefoet eutfenhselten rnpdr brhet wtz  fr ih ke maameangd seilel eraerhh di dkann fn lntsochragrd spdsprtio ar en kaarkass",
    "en": " ththehe ed  to iner ingng  annd  ofandto of  coat on in  a d t hee tiones  rere hat sa st haherthatioor  ''en  whe sentn ts aas foris t t beld e ars  waut ve ll al  mae i fo's an est hi mo se prs tatest tereretednt verd a wise e cectns  only toley r t caatits all nohiss oerscone oearf te wwasonssta'' stin astot h weid th  itce  diaved hcouproad ollry d se m soillctite toreveg tit  ch dehavoulty ulduse alarech me outovewitys chit aithoth ab te wos srest wtine be hncet sy te pelehins inte lile  doaidheyne s w as fr trendsai el ne su't ay houivelecn't yebutd oo ty o ho mebe cale ehadple at bu lad bs hsayt i are fghthilighintnotren is pa shayscomn sr ariny a unn com thi miby d ie de nt o bye rerioldomewheyea grar itymplounoneow r ss ftat ba vobousamtimvotaboantds ialinemanmen or poampcandere llesny ot rectesthoicaildir ndeoseouspresteeraperr oredrie bo lealiarsorerics mstr faessie istlaturi",
    "es": " dede  laos la el es  qu coe las que elue en ent en senteresconest ess d lo prlos y do ón ión unciódelo d poa dacistate adopreto para ea lra al e ese proar ia o e reidadadtrapors p a a paracia pacomno  di inienn lad ante smena con un lasnci trcioierntotivn dn eor s cencernio a sicis e madose ae cempicaivol pn cr eta tere desaez mpro as a ca suion cu juan da eneerona recro tar al anbiee per l cn pompten emistnesntao cso teseral dl mlesntro sorerá s qs ystoa aa raridese qiviliclo n aoneoraperpuer lre renunaía adacasereideminn sndoranrno ac ex go noa tabableeceectl al glidnsionsracriostruerust ha le mi mu ob pe pu soa ialeca ctoe ie uesoferficgobjo ma mplo pobis msa sepstestitadtody s ciandcescó dore meciecoesiintizal elarmienerorcrciriatictor as sice dene re tenderiespialidoinaincmito lomeplirass tsidsuptabuenuesuravo vor sa tiablaliasoastcorcticuedivducensetiimiinileco qoceortralrmarocrod",
    "et": "st  kaon ja  va on ja kose astle es as is ud  sada ga  taajasta ku pea kestistks ta al avaid saamiste val etnud teinn se tua value kiselu ma mes miet ikulinad el imene nna ha in ke võa sa tab e sesi la lie veksemalaslesrjutletsitusupauseustvar läaliarjde etei tigailmkuili tul ei me sõaalatadusei nikpeas ks osalsõnterul või el nea jateendi kitakarkorl olt maaolistivadään ju jä kü ma po ütaasaksat ed erihoii ska la nnioidpairitus ütl aa lo to vea eadaaidamianddlae jegagi gu i pidlik inijupkalkaskeskohs es pselsseui  pi siaruedaevafili vidainglääme na ndanimoleotsriss lsiat p en mu ol põ su vä üha la pagaaleapsarve aelaikalleloomalpett kteetisvatäneõnn es fi via ia oaabaapalaaltamaanue pe tealelihaahinivakonku liklm minn toduoonpsari si stut et sti uleuurvasvee ki ni nä raaigakaallatue eeisersi eii iisil imaitskkakuhl klatmajnduni niiomaoolrsoru rvas tseksonstet mtajtamudeuhovai ag os pa re",
    "eu": "en an etata  etizan eko ide baa egiz es giarrbidrenrriarela sku beasuesksuntas izeanekoelaik kubn an itzaubiza zan era baskeran brretentze as koa aa galdanide deeea ek katkonn dontuan du naataegiestk enikntuntzskatua de di ez hea da kak akiakoartatuazibatberitzkunn ho briartetatunezar al ar haakuatzbaidardeadeleenemaerriakiarin inakianarnazneao eorrra stetekzakzekzio da em hi ho ma oiaguateaurbesdindirdutertez eziharherhitia ienikaio ireitek bk gkidkorldan onkoo aoinorirakrearierikrratanteatu unaundunturrutez ezko au eg gu ir ki ora ha jabeagiai ailaitapearideze eeareekerdereezaezkgirgithori eianiekilainkintiraitaituk nkapkoakumlanldemaimanmenn gn una ntao hoa oropenrdiri rtastateltettiktuetziumeun uztzeazenziazin az bi bu el ga jo mu ti un za zia na oa sa ta zabaadiakealaandar audbakbalbegbehbuldaudendu duie be de he oeakeetehaelkenbeteetigabgingo gusgutguzhauibeinbineioairuiuriziizkizo",
    "fa": "ان ای ه ا اي دربه  بردر ران بهی ااز ين می  ازده ست است اس کهکه ايرند اين هايراود  راهای خوته را رایرد ن بکرد و  کرات براد کمانی د انخواشور بان ا ساتمیری اتما اواه ات عراق ر مراقعرای ب تا توار ر ان مه بور يد ی ک ام دا کناهدهد  آن می ني گفد اگفت کشا بنی ها کشو روت کنيوه موی ی ت شوال دارمه ن که ديه  ماامهد بزاروراگزا پيآن انتت افت ه نی خاماباتما مللنامير ی می ه آم ای منانسانيت دردهسازن دنه ورد او بي سو شدادهاندبا ت بر بز ازماستهن ره سوانوز ی ری س هساباام اورتخاخابخودد ددن رهاروزرگزنتخه شه ههستيت يم  دو دي مو نو هم کااد اریانیبر بودت هح هحالرش عه لی وم ژان سلآمراح توسداددامر دره ريکزی سلاشودلاحمريننده عيمايکاپيمگر  آژ ال بو مق مل ویآژاازمازیباربرنر آز سسعهشتهماتن آن پنس ه گوسعيانيومکا کامکند خا سرآورارداقدايمايیبرگت عتن خت د ور خرک زيرفتهقدال تمينن گه آه خه کورکويويوريوييی ک تی ش اق حا حق دس شک عم يکا تا دارجبينت مت وتايدستر حر سرناز بشکالل م کمز ندانواو اورهون ونديمز آو اع فر مت نه هر وز گز",
    "fi": "en in an on istta ja n tsa staaann p onssattatä  ka pasi  jan kllaän eenn vksiettnentaattä vaillitt jo kon s tuia  sua paa la llen mle ttena  ta veat  viutt saisesen ku nä päste ola taismaati a ooitpää pia valaineisiteltti sia kalliinkinstäuomvii ma seenä mua sestisslläloklä n jn otoivenytt liainet inan an nollplotenuställään todenmenokisuosä tääuksvat al ke tea eliitaiteiäisää  plelli tideikkki ntaovaystyt ä päyt ha pe täa naiki pi vnytnäypalteeun  mea messkaupaistuut voi eta heishtei oiikitajoumisninnutsiassävan ty yhaksimeloime n en hn loinomeottouksitstitettieukkä k ra tiajaasientigaiigitejankaakselaalanli näjoletiiusiäjä ova aantavaei erikankkulailisläimatoispelsilstytajtavttutyöyösä o ai pua ja laalarvassienimiimmitäka keskueleelinllooneri t ot ptu valvuo ei he hy my voalialoanoastattaukelielyhtiikakenkkilysminmyöohtomatusumiyksät äälös  ar eu hu naaatalkaluansarjennhankuun ysetsim",
    "fr": "es  dede  leentle nt la s d laionon re  pae le d l'e p co prtions  enne quer llesur en atiue  po d'par a et it  qumenonste  ett d redes unie s l supou au à coner  noaite cse té du  du déce e eis n ds a soe re sourresssieur seemeestus surantiqus puneussl'aprotertreendrs  cee at pun  ma ru réousrisrussseansar come mirencentet l av mo teil me onttena pdanpasquis es s inistllenoupré'unaird'air n eropts  daa sas au denmaimisorioutrmesiotteux a dienn antrommortouvs csontesverère il m  sa vea raisavadi n pstiven miainencforitélaroirremrenrroréssiet atur pe tod'uellerrersideineissmesporransitst t rutivaié lési di n' éta casse tin ndeprerats mstetaitchui uroès  es fo tr'adappauxe àettitilitnalopér dra rairors rtatutéà l afancaraartbrechédree fenslemn rn tndrnneonnposs ttiqure tualeandaveclacoue nembinsjoummerierèssemstrt iuesuniuveé dée  ch do eu fa lo ne raarlattec ical al'ol'émmintaormou r urle",
    "ha": " dada in an ya  wa yana ar a d mawa a aa ka s tawan a  ba kata a yn d ha na su sakinsa ata koa tsu  gaai  sha muwaiyama a wasayanka anishia ba ha camaba nann a muana yia g zai d kuakayi n kannke tar ciikin sko  raki ne a zmathaknine dnnaumandaa nadacikni rinunaarakumakk ce dumann yncisarakiawaci kankararin mandhi n tga owaashkamdanewansaaliami ab doancn rayai nsunuka al nea'acewcinmastakun abakowa rra  ja ƙaen r dsamtsa ruce i aabiidamutn gn jsana ƙharon i msuk ak jiyar'yakwamin 'yanebaninsruwi kn h adaken wshautu ƴabaytanƴanbinduke mn nokayinɗan faa ikkire za alaasuhani ymarranƙasaddarsgabirammau d tsabbabuagagarn b ɗaaciaikam dune si bi wkaskokwam amamfbbadinfangwai swatanoaredaiirima' laalldamikami shetumuni an ai ke kidagmaimfano nsuo dsakum  bi gw kwjamyyaa jfa uta hu'a ansaɗaddahinniyr sbatdargani tntaokiomisala lkacllawadwarammdomr mrassai loatshalkatli lokn cnartinafabubi gisamak",
    "haw": " kana  o ka  ma a  laa ia m i la anaai ia a oa ka ho k kea ai k ho iaua  na mee ke aau ke ma maiaku akahi ha ko e a l nome ku akakanno i aho ou  aii oa po lo aamaa n ani mhani iihokoune  iho iikionahoole e h heina waea akou ikahoe i lu a pahoie ierako u mkuamakoi kaii na ehinane oli hmeawahlake mo nu likaki a wmalhi e nu ohik kue lelera berineabeainalalo  pokon abolehe paumahva elakaunak oekeioia ieram oioa ehohoviehova uaunaarao sawao onauu nwa waihel ae alae ta aik hialeilalelalieikoloonu loauae oolahonmamnan auahalaunuaohooma aoii aluimamauikeapaeloliipoeaianoa ino moka'u ahoei ekaha lu neiholinoo eemaiwaoluadanaapa u kewahualamluao hooku h liahuamuui  il mo seeialaw hu ikaile pli lunuliio kiknohu e saaawaweenahalkollan le nea'uilokapokosa  pehoploaopepe  ad puaheaolia'lailohna'oomaauerikulwe akekeklaari ikukaklimnahnernuionoa udamkumlokmuaumawalwi 'i a'iaanaloetamu oheu pulauwa nuamo",
    "hi": "  हैमें मेने की के है  के की कोों को ा ह कासे ा के कं कया  कि सेका ी क ने औरऔर ना कि भी ी स जा परार  करी ह होही िया इस रहर कुनाता ान े स भी राे ह चु पापर चुननाव कहप्र भाराजहैंा सै कैं नी ल कीं ़ी था री ाव े ब प्क्षपा ले  देला हा ाजप था नहइस कर जपानहीभाजयोंर सहीं अम बा मा विरीकिए े प्या हीं मकारा जे ल ता दि सा हमा ना माक़्ता एक सं स्अमरक़ीताजमरीस्था थार् हुइराएक न कर मराकी जी न इर उन पहकहाते े अ तो सुति ती तो मिलिक ियो्रे अप फ़ लि लो समम कर्टहो ा चाई ानेिन ्य  उस क़ सक सैं पं हगी त कमानर नष्टस कस्ताँ ी बी म्री दो मि मु ले शां सज़ात्रथी लिएसी ़ा ़ारांगे दे म्व  ना बनंग्कांगा ग्रजा ज्यदी न मपारभा रहीरे रेसली सभाा राल ी अीकीे तेश  अं तक याई हकरनतक देशवर्ायाी भेस ्ष  गय जि थी बड यह वांतरअंतक़ गयाटी निकन्हपहलबड़मारर परनेाज़ि इी रे जे व्ट ्टी अब लग वर सीं भउन्क ककियदेखपूरफ़्यह यानरिकरियर्डलेकसकतहोंहोगा अा दा पाद ाराित ी ती पो को द ते नि सर हां दअपनजानत मथितपनीमहलर हलोगव कहनाहल हाँाज्ानािक्िस्",
    "hr": "je  na pr pona  je zaijene  i ti da  ko neli  bi da u ma mo a nih za a sko i sa pkojproju se  goostto va  do toe ni p od rano akoka ni  ka se mo sti nimaja privatsta suatie pta tske inij trcijjennoso s izom troiliitipos ala ia oe sijainiprestrla og ovo svektnjeo podirva nialiminrija ta zatsivao tod ojera  hra ma uhrvim ke o ioviredrivte bi e ogodi dlekumizvodine uenejedji ljenogsu  a  el mi o a daluelei uizvktrlumo doriradstoa kanjavae kmennico joj oveskitvrunavor di no s  ta tvi ii okakrošskovod sa ćea badiamoenigovijuku o noraravrujsmotavtruu pve  in placibitde dišemai mikaištjerki mogniknovnu ojioliplapodst stitratrevo  sm štdane zi tio istkonlo stvu sujeustće ći što dr im liadaaftaniao arsatae temoi kinejemkovlikljimjenafnernihnjaogooizomepotranri roirtkskateru iu ovi vrt me ugak amadrže ee ge mem emeenjenter ereergeurgo i bi zjetksio uodaonaprarebremroptrižav ci eu re te uv veajuan ",
    "hu": " a  az szaz  meen  el hoek gy tt ettsze feés  kitet beet ter kö éshogmegogysztte t azeta mneknt ségszáak  vaan ezera ta  miintköz iseszfelminnakorszer tea aa kis  cseleer mensi tekti  necsaentz ea talaerees lomltemonondrszszattezágány fo maai benel eneik jeltásáll ha le álagyaláiszy azteás  ale aegyelyforlatlt n aogaon re st ságt mán ét ült jegi k aküllamlenlásmáss kvezásoözö taa sa vaszatáetőkezletmagnemszéz mát éteölt de gy ké mo vá éra ba famiat atoattbefdtagyahati slasndtrt szot ktártésvanásáól  bé eg or pá pé vebanekeeküelőervetefogi akisládntenyenyiok omáos ránrássalt evályarágoálaégeényött táadóelhfejhethozilljárkésllomi ny ontrenresrins as esszzt  ez ka ke ko rea ha ndendó efogadgatgyehelk eketlesmánndenisozzt bt it étattosvalz ozakád ályáraésiész ak am es há ny töakaartatóaztbbeberciócsoem etietégali tiniistja kerki korkozl éljályen vni pálrorrólrüls cs ps ss vsokt jt ttartelvat",
    "id": "an  mekanangng  pemen di ke da seeng benganya teah beraka yadandi yann ppera mita pada ataadaya ta  inalaeriia a dn kam ga at eran dter kaa pariembn mri  baaanak ra  itaraelani aliranar erulaha basiawaebagann b hainimer la miandenawan saahalamn inda waa iduag mmi n arustelyak andalh di singminnggtakamibebdengatianih padrgasanua  dea targdareluhari ki mi pikain inyitumban tntupanpensahtantu a kbaneduekag dka kerndentaorausa du maa sai antbasendi dirakamlann sulial apaereertliamemrkasi talung aka aa waniaskentgarhaai iisakedmbeskatoruanuk uka ad toasaayabagdiadunerjmasna rekritsihus  bia hamadibersg shanik kemma n lnitr brjasa  ju or si tia yagaanyas culemeemuenyepaerberlgi h mi akelli melniaopartasiatahulaun unt at bu pu taagialuambbahbiser i tibeir ja k mkarlailallu mpangknjaor pa paspemrakriksebtamtemtoptukuniwar al ga ge ir ja mu na pr su unad adiaktannapobelbulderegaekeemaempeneenjesa",
    "is": "að um  aðir ið ur  ve í na  á  se er ogar og ver miinnnn  fyer fyr ek en ha heekk stki st ði  ba me viig riryri umg flegleins ð s ei þain kkir hr segieinga ingra sta va þeannen milsemtjóarðdi eithafillinsistlljndir ar esegun var bi el fo ge yfandaugbaubigegaelderðfirfooginittn snginumod oodsinta tt viðyfið eð f hr sé þva ea áem gi i fjarjórljam er áreirstrðarðirðustjundvegví ð vþaðþví fj ko sleikendertessfjáfurgirhúsjárn eri tarð þðarðurþes br hú kr le upa seggi sirtja kiðlenmeðmikn bnarnirnunr fr vriðrt stit vti unauppða óna al fr gra vallan da eiðeð fa frag egergiðgt hanhefhelherhrai ai ei vi þikijónjörka królíkm hn angar lramru ráðrónsvoviní bí hð hð kð mörð af fa lí rá sk sv tea ba fa ha ka uafiagnarnastberefuennerbergfi g agariðskerkkelanljólltma miðn vn ínanndanduniðnnannunu r orbergislösé t at htiltinuguvilyggá sð að bórnögnöku at fi fé ka ma no sa si ti áka ma ta ía þafaafsaldarf",
    "it": " dito la  dedi no  core ione d e le delne ti ell la unni i dper peent inonehe ta ziocheo da dna atoe s soi sllaa pli te  al cher  pa siconsta pra c seel ia si e p dae ii pontanoi callazinteon ntio s rii ao aun  anarearie ai eitamenri  ca il no poa santil in a laticiae cro annestglità  que lnta a como cra  le nealiereist ma è io lleme eraicaostprotaruna pida tat miattca mo nonparsti fa i  re suessinintoo lssittoa eamecolei ma o iza  sta aaleancanii miano ponisiotantti loi rociolionaonotra l a reriettlo nzaquestrtertta ba li teasse fenzfornnooloorirestor ci voa ial chie nliapreriauniver spimol al cransensoctic fi moa nce deiggigioitil slitll monolapacsimtituttvol ar fo ha saacce riremanntrratscotrotutva  do gi me sc tu ve via mbercanciti lieritàlliminn pnatndao eo fo uoreoroortstotentivvanartccoci cosdale vi iilainol pn cnitoleomepo riosa  ce es tra bandataderensersgi ialinaittizilanlormil",
    "kk": "ан ен ың  қа баай ндаын  са алді арыды ып  мұ біасыда най жамұнстағанн бұна боныңін ларсын деағатан көбірер меназаындыны меандеріболдыңқазатысы тынғы  кеар зақық алаалыаныараағыгентартертырайдардде ға  қобарің қан бе қыақсгердандарлықлғаынаір іріғас таа бгі едіелейдын кн толарыніп қстқтаң б ай ол соайтдағигелерлыпн аік ақтбағкенн қны ргерғаыр  аралғасабасберге етіна ндене нигрдыры сай ау кү ни от өзаудеп ияллтын жн оосыотырыпрі ткеты ы бы жылыысыі сқар бұ да же тұ құадыайлап атаенійлан мн сндындір мтайтіны тыс інд биа жауыдепдіңекеерийынкеллдыма нанонып жп ор бриярлаудашылы аықті аі біз ілің қ ас ек жо мә ос ре сеалддалдегдейе бет жасй блаулдаметнынсарсі ті ырыытаісің аөте ат ел жү ма то шыа аалтамаарластбұлдайдықек ельесіздікөтлемль н еп ар аресса та ттетұршы ы ды қыз қыт ко не ой ор сұ түальареаттдірев егіедаекіелдергердиядкеркетлыслісмедмпин дні нінп тпекрелртарілрінсенталшілы кы мыст",
    "ky": "ын ан  жаен да  таар ин  каары ал ба билар бо кыалан к сандагантар деандн б кеардменн таранын да мекыр чен ары  когендаркенктауу енеери шаалыат на  кө эматыдандепдынеп ненрын беканлуургытаншайыргүн  ар маагыактаныгы гызды рдаай бирболер н сндыун ча ында кагаайланаап га лгенчап крдытууыны ан өзамаатадинйт лгалоооо ри тиныз ып өрү па эка балгасыаштбизкелктетал не суакыентиндир калн дндеогоондоюнр бр мрансалстасы ураыгы аш ми сы туал артборелгениет жатйлокарн могуп ап жр эсынык юнч бу ура аак алдалубарбербоюге донегиектефтиз катлдын чн эн өндонефон сатторты удаул улаууды бы жы кыл ынаэкеясы ат до жы со чыаасайтастбаабашгаргындө е бек жыли бик ияскызлдалыкмдан жндини нинордрдостота терттитуртынуп ушуфтиыктүп өн  ай бү ич иш мо пр ре өк өта да уа эаймамдаттбекбулголдегегеейтелеенджаки киниириймактоликмакмесн ун шнттол олопарракрүүсырти тикттатөру жу сшкаы мызыылдэмеүрүөлүөтө же тү эл өна жады",
    "la": "um us ut et is  et in qutur presttio auam em aut dientin dict e esur atiionst  utae qua dent  su siituuntrumia es ter rentiraes equiio proit peritaoneiciius cot dbuspram e noeditiaue ibu se ader  fiiliquet ide oru teali peaedcitm dt stattemtist pstite cumereium exratta conctionira s i cu saeninisnteeriomire s aminos ti uer ma uem snemt m mo po uigenictm iriss st auae dom at c geas e ie pne  cainequos p ale enturo tritusuitatuiniiqum postresura ac fua eantnesnimsuntrae as d pa uoecu om tuad cutomns q eiex icutoruid ip mee seraeruiamideips iua sdo e deiuicaim m cm utiu hocatistnaton ptiregrits tsicspe en spdiseliliqlismenmusnumpossio an grabiaccectri uan leeccetegranonse uenuis fa tratee cfilna ni puls fui at ccedami einalegnosoripecropstauiaeneiueiuisiut tt utibtit da nea dandegeequhomimulorm mmnindonero er esittumutua pbisbitcerctadomfuti signintmodndunitribrtitasund aberrersiteitim to p",
    "lt": "as  pa kaai us os is  ne irir ti  prausinis ppasių  ta viiau ko sukaio pusi savo taialitų io jo s kstaiai bu nuiusmo  poiens stas meuvokad iš lato aisie kururi kuijočiaau metje  vaad  apand gr tikalasii pičis is vinko nės buvs a gaaipavimaspritik reetujos daentoliparantarataramagalimoiško s at be į mintin tus n jodarip rei tedžikasninteivie li secijgarlaiartlaurasno o ktą  arėjovičigapravis namenokirašs tietikaintkomtamaugavories b steimko nuspolriasauapime ne sik šii nia iciojasakstiui amelieo tpiečiu di pegriioslialins ds gta uot ja užauti sinomą ojeravdėlntio atojėl  to vyar inalico vseisu  mi pidiniš lansi tus baasaataklaomitat an jialsenajų nuoperrigs mvalytačio rai kliknetnė tistuoytięs ų sadaarido eikeisistlstma nessavsiotau kiaikaudiesoris rska geasteiget iamisamisnamomežiaabaaulikrką ntara tur madieei i tnasrinstotietuvvosų p dėareatsenėiliimakarms niar prods l o e pes ideik ja ",
    "lv": "as  la pa nees  unun  ka vaar s p ar viis ai  noja ijaiemem tu tievielataksienkstiess arakatvtvi ja pika  irir ta  sats  kāās  tiot s n ie taarīparpie prkā  at raam inātā  izjaslai naautiešs s ap ko stiekietjauus rī tikībana  gacijs i uzjums vms var ku majā stas u tādiekaikasska ci dakurlietasa peststāšannesnies ds mval di es reno to umuvaiši  vēkumnu ries tām ad et mu s l beaudturvijviņājubasgadi nikaos a vnototistsaiku aā aāk  toiedstuti u pvēlāci šogi ko pros rtāju su vvisaunks strzina aadīda darenaicikranasstīšu  mēa necii sie iņaju lasr tumsšiebu citi ainama pusra  au se sla saisešiiecikupārs bs ksotādā in li tranaesoikrmanne u k tuan av betbūtim isklīdnavrasri s gstiīdz aiarbcindasentgali plikmā nekpatrētsi traušivei br pu skalsamaedzekaešuiegjiskamlstnākoliprepēcrottāsusiēl ēs  bi de me pāa iaidajāiktkatliclodmi ni prirādrīgsimtrāu lutouz ēc ītā ce jā sva tagaaizatuba ciedu dzidzī",
    "mk": "на  ната атаија прто ја  заа н и а сте ите коот  де поа дво за  во од се несе  доа вка ањеа по пувација оициетоо нанини  влдекекањетќе  е а за иат влаго е нод пре го да ма ре ќеалии ди ниотнатово па ра соовепраштоње а еда датдоне ве де зе сконнитно ониотопарпристат н шта кацива вање пенила ладмакнесноспроренјат ин ме тоа га ма ракеаковорговедоенаи ииракедне ницнијостра ратредскатен ка сп јаа тадеарте ге икатласниоо сри  ба биаваатевнид ндендовдрждуве оен ереерии пи синакојнцио мо ооднпорскиспоствститвоти  об ова балнарабаре кед ентеѓуи оии меѓо дојапотразрашспрстот дци  бе гр др из стаа бидведглаекоендесеетсзаци тизаинсистки ковколку лицо зо иоваолкореориподрањрефржаровртисо торферценцит а  вр гл дп мо ни но оп ота ќабоадаасаашаба ботвааватвотги граде диндумевредуеноераес ењеже заки вилаитукоакоиланлкуложмотндунсто воа оалобров овиовнои ор ормој ретседст тертијтоафорцииѓу  ал ве вм ги ду",
    "mn": "ын  байн байийнуул улулсан  ханийн хгаасыний лсы бой бэн ах болол н боло хэонгголгуунгоыг жил молаглламон тє хуайдны он санхий аж орл ун тулгайгдлыйг  задэсн андэулаээ агаийгvй аа й алынн з аю зєаарад ар гvйзєважиал аюуг хлгvлж сниэснюулйдллыгнхиуудхам нэ сагийлахлєлрєнєгч таилллийлэхрийэх  ер эрвлєерєийллонлєгєвлєнх хоариих ханэр єн vvлж бтэйх хэрх vн ньvндалтйлєнь тєр га суаандааилцйгул алаан нрууэй  тон срилєриааггч лээн орэгсууэрэїїл yн бу дэ ол ту шиyндашиг тиг йл харшинэг єр  их хє хїам ангин йгалсан vн еналнд хууцааэд ээрєл vйладаайналаамтгахд хдалзарл бланн дсэнуллх бхэр бv да зоvрэаадгээлэнн ин энганэ талтынхурэл  на ни онvлэаг аж ай атабарг бгадгїйй хлт н мна ороульчинэж энэээдїй їлэ би тэ энаныдийдээлаллгалд логль н ун їр бралсонтайудлэлтэргєлє vй в  гэ хvарабvрд нд ол хлс лтын гнэгогтолыоёрр трээтавтогуурхоёхэлхэээлэёр  ав ас аш ду со чи эв єраалалдамжандасувэрг удвэжvvлцалэл",
    "no": "er en et  dedet i foril  fo meingom  ha ogter er ti stog tilne  vire  en sete or de kkeke ar ng r sene soe sderan somsteat ed r i av inmen at ko påhar sierepå ndeandelsetttteligt sdent iikkmedn srt serskat ekersenav lerr atene fr er tedeig  rehanllener bl frle  vee tlanmmenge be ik om å ellselstaver et sknteoneorer dske an ladelgenninr fr vse  poir jonmernenommsjo fl saernkomr mr orenvilalees n at f leblie ee ie vhetye  iral e oideitilitnnerant otaltattt  kaansasjge innkonlsepett dvi  utenteriolir pretrisstostrt a gaallapeg sillirakapnn oppr hrin br ope mertgerionkallsknes gj mi prange he reltenni sistjenkanlt nalrestorassdree be pmeln tnseortperregsjet pt v hv nå vaannatoe aestiseiskoilordpolra rakssetoi grak eg eleg aigeighm en fn vndrnskrert mundvarår  he no nyendeteflyg igheierindintlinn dn prnesaksiet btid al pa trag dige de kessholi dlagledn en in oprir bst  fe li ryairaked seasegi",
    "ne": "को का मा हरु नेनेपपालेपा समले  प्प्रकारा सएको भए छ  भा्रम गररुक र भारारत का विभएकालीली ा पीहरार्ो छना रु ालक्या बाएकाने न्ता बाकोार ा भाहर्रोक्षन् ारी निा नी स डुक्रजनायो ा छेवा्ता रात्यन्दहुना कामाी न्दा सेछन्म्बरोतसेवस्तस्रेका्त  बी हुक्तत्ररत र्नर्या राकाुको एक सं सुबीबबीसलकोस्यीबीीसीेकोो स्यक छन जन बि मु स्गर्ताहन्धबारमन्मस्रुललाईा वाई ाल िका त् मा यस रुताकबन्र बरण रुपरेकष्टसम्सी ाएकुकाुक् अध अन तथ थि दे पर बैतथाता दा द्दनी बाटयक्री रीहर्मलकासमसा अा एाट िय ो पो म्न ्ने्षा पा यो हाअधिडुवत भत सथा धिकपमाबैठमुदया युकर नरतिवानसारा आा जा हुद्ुपमुलेुवाैठको ब्तर्य ्यस क् मन रहचारतियदै निरनु पर्रक्र्दसमासुराउनान ानमारणालेि बियोुन्ुरक्त््बन्रा्ष  आर जल बे या साआएकएक कर्जलसणकात रद्रधानधि नकानमानि ममारम रहेराजलस्ला वारसकाहिलहेका तारेिन्िस्े सो नो रोत ्धि्मी्रस दु पन बत बन भनंयुआरमखि ण्डतकातालदी देखनियपनिप्तबतामी म्भर सरम्लमाविशषाकसंया डा मानकालमि भित ी पी रु भुनेे गेखिेर ो भो वो ह्भ ्र  ता नम ना",
    "nl": "en de  deet an  heer  van dvaneenhet geoor eeder enij aargente ver in meaanden weat in  da teeerndetersten v vo ziingn hvoois  optie aaedeerders beemetenkenn e ni veentijnjn meeietn wng nie ischtdatereie ijkn brdear e be amett del ondt h ale wop ren di onal andbijzij bi hi wior r dt v wae hllert anghijmenn an zrs  ome oe vendestn tpar pa pr zee ge pn pordoudraascht eegeichienaatek lenn mngent overd wer ma midaae klijmern gn oom sent bwij hoe melegemhebpenude bo jadiee eelierkle prorij er zae densindke n knd nennter hs ds et z b  co ik ko ovekehouik itilanns t gt m do le zoamse zg vit je ls maan inkerkeuit ha ka mo re st toagealsarkartbene re sertezeht ijdlemr vrtet pzegzicaakaalag alebbech e tebberzft ge ledmstn noekr it ot wteltteuurwe zit af li uiak allautdooe ieneergetegesheejaajkekeekelkomleemoen sortrecs os vtegtijvenwaawel an au bu gr pl ti'' adedage lecheeleftgergt ig ittj dpperda",
    "nr": "okula ngaa n ngna amaa iko  ukelelo elaanga ua kukuaba kuwa enzlelho ni ngoathphaethkhaanaisange nao nthoe ntheha esinyekwetjh kwise uma a nele hlaa elanbenndl noimiundungthinziye isiutho eebehetkutandsa elofunekosebbanuluakaeliwene i ameniba we nel wekuflwai n iszi  lokwalokelwgokonalekhi li ganbon iiingka o iakhanethuulakelmth imga  lendafannoki kendsi o waphhate ualakublunikho lezia lo usisnamemi abhulkus wosekazikhoiini uasiloliniuphuhlkhuno o yakoa bi eo ki l bemal yei indeiphmelekethakunngie kengo s yoso ma mkhjhaiswlwe ezdi a we akulunyumeza anyahlkuheen siiliitjzokihl eske hlohakpheluldlelukda ekaamb sezismbihondlaakujenzin bahami a boo aaliuseilesikhanwokokhhlunyasitanikuzo oufaswaindzaknislisgabmi  em koano elhwaufua ywo  inlimtlokatwakkanthwo zithndiyokyo mitmisaboekuhabinynanezekhealolu manhe ezokupubu zogamhelwanombamknzaolahumkukdu  lakomi yobui boduokwgap kabe  ilaluatje b",
    "nso": "go  go le a le  dia gya lo  yaa mka  kala  t o ya ta kba et wa  mo e a b se ba ma boe gt a o a lo tna o la delodi a so go keleo ang t eo bmo e te megoeo e lngwse e bkgoela wa gae kagoo m kgga ditolot he do d yeanelelwe  tlthuona tht whutanatlawanabaola megware ongt olaoe so sa yaloseta pi aenga ao etho kegwe hahloedi laao  tsakahlaalaswa we bjo ogoragahabgobletke diksa  i oba hlthedira nithbjaye no  samollwati manolee etseo woreto at ethe ykantshgonnetanokarge ho lok sw nai bdipi ooka ge omko emopelnt e amellegtlhme etephea eo no iwalokonyabolodiwegte e nta anyyeokgapolangri it uto mmitiareo fha gatothikao h itsheathaleiriphaahl teohltha rebonlha phdin pero mi omii t faaroasei lne lalogokol wot iomo bemogmoklenilelwema utanseamoa o feokgja pannagekgi iapagetlonra aem yoatltlokeltel kh poe oa wenti ebo ganhetmala fotlutiogasenkwamaeekammekgejala ringlekseplagofewagg yrolepeekoboko padilog",
    "pl": "ie nieem  ni po prdzi naże rzena łemwie w  żego  byprzowaię  do siowi pa zach egoał sięej wałym aniałeto  i  to tee p je z czybyłpanstakie jado  ch cz wiiała ppow mili enizie ta wało ać dy ak e w a  od stniarzyied ktodzcieczeia ielktóo ptórści sp wyjaktakzy  moałęproskitemłęs tre mjesmy  roedzeliiej rza nalean e sestle o si pki  coadaczne te zentny prerząy s ko o acham e no tolipodzia go kaby iegiernośrozspoychząd mnaczadzbiechomnio nostpraze ła  soa mczaiemić obiył yło mu móa tacjci e bichkanmi mieoścrowzenzyd al rea wdenedyił ko o wracśmy ma ra sz tye jiskji ka m sno o zrezwa ów łowść  obecheczezyi wja konmówne ni nownympolpotyde dl sya sakialidlaiczku oczst strszytrzwiay pza  wtchcesziecim la o msa waćy nzaczec gda zardco dare rienm nm wmiamożrawrdztantedtegwiłwtey zznazłoa rawibarcjicządoweż gdyiekje o dtałwalwszzedówięsa ba lu woalnarnba dzoe chodigiligm pmyśo conirelskustey wystz w",
    "ps": " د اؤ  اؤنو ې دره  پهنه چې  چېپه ه دته و اونوو د اوانوونهه ک داه ادې ښې  کېان لو هم و مکښېه مى ا نو ته کښرونکې ده له به رو  همه ووى او توندا  کو کړقام تررانه پې وې پ به خوتو د دد اه تو پيا  خپ دو را مش پرارورې م دمشر شو ورار دى  اد دى مود پلي و ک مق يوؤ دخپلسرهه چور  تا دې رو سر مل کاؤ اارهبرومه ه بو تپښت با دغ قب له وا پا پښد مد هلې ماتمو ه هوي ې بې ک ده قاال اماد نقبره نپار اث بي لا لراثاد خدارريخشرامقانۍ ه ره لولويو کوم دد لو مح مر وواتواريالواندخاند تسې لى نورو لي چړي ښتوې ل جو سيام بانتارتر ثارخو دو ر کل دمونندېو نول وه ى وي دې اې تې ي حک خب نه پوا دتې جوړحکمحکوخبردانر دغه قافمحکوالومتويلى دى ميرهپر کولې ه تي خا وک يا ځاؤ قانۍبى غو ه خو بودايدوړې کال بر قد مي وي کرؤ مات اييتى تياتيرخوادغودم ديمر وقديم خمانمې نيونږ ه يو سو چوانوروونږپورړه ړو ۍ دې ن اه زي سو شي هر هغ ښااتلاق انيبريبې ت اد بد سر مرى عرالانمى نى و خوئ ورکورېون وکړى چيمهيې ښتنکه کړيې خے ش تح تو در دپ صو عر ول يؤ پۀ څوا ا",
    "pt": "de  deos as que coão o d quue  a do ent sea ds de aes  prra da  es pato  o em cono p doestnteção da rema par tearaida e adeis  um poa aa pdadno te  noaçãproal come ds a asa cer mens eaisntoresa sadoists pteme ce sia o so ao ce pstata traura di pear e eserumamosse  cao e naa edesontpor in maecto qrias csteverciadosicastr ao emdase titoizapretos nãadanãoesseveor rans ns ttur ac faa renserina sso si é braespmo nosro um a nao icolizmino nonspritenticões tra magae niliimem ancinhantaspetivam anoarcasscere oeceemoga o mragso são au os saalica emaempiciidoinhissl dla licm cmaioncpecrams q ci en foa oamecarco dereirho io om orar asenter br exa uculdeve uha mprnceocaoverios osa semtesunivenzaççõe ad al an mi mo ve à a ia qalaamoblicencolcosctoe me vedegásiasitaivandoo torer dralreas fsidtrovelvidás  ap ar ce ou pú so via factarrbilcame fe iel forlemlidlo m dmarndeo oomoortperpúbr ureiremrosrressi",
    "pt-br": "eq ent enq eq ig eg ing  ididantete  es inadeag dadde ia ing br saestinqlinmo nq o aseq co li ni o a aa cadoasibradoriq ntao bor q nrassilstrta treus  a  ag an ca e  eq g  i  ir nc q  se veantar ciacone aeirel ig iliimoio ir ncio tro vel ap bo de fr tra ba ea ga vapoas busca cetcindese be setafrei aibuil irola liqnibntio co qos ra re reqs as ssansimtarto ult ba ci el em fi gr gu ia mu pe po re ri si su te via oa sabealcandaraargaribenboccarco do e fe ge le oem emoen es espexeficg ng sgraguaiasicaidiilaileinhl bl eleiloqmosmulnadniont ntoo go roceontoq posq vr br er ir sradranremrg riarios es pstastitigtiltraua ue va xeq '  ab ad ae al am aq ar b  bi bl bu cc ch di et ex fa ic il im is it ll m  me na ne ng nu ob ou pi qu ss st ti ub un v  x ' ca da fa ia na pa tabraciad adaadraerafealvambampan anaanganhanianoanqapaaq atiatoazib nbanbarbigbilbiqbliblubonbrebribsebucc fc icadcafcagcalcancc ",
    "pt-pt": "equentquequiguiuen linguqu uid co vede gueidanteo aa aadedadel ingmo nquntasequ nvel de o  sea cadoar estia inqio iqulino co portporta te  ag eq nc pi po saa da eantas ca ciadesdo gu imol pnciro rtustrtugu suesui  a  an ap ba bi ca fr gu in pe quaguapacondore fe geirfreho i aicaiguiroliqntio bo lo sor r ora reqs csimtarto ue uinult ci en ho mu ni re s  si sua sa vabeag al andanhapoatabanbenbicboicapcarcinco comctodeie be oe secaen er es exeficforgalgraiasichicoidiiliir iraisbla lismbomulna nhoniont o qo ro toc oioomboo os parpe r br er sranre recs as ssansboso statantratreu vugauguxeq ab ad al am aq ar au b  bo c  ch ct cu el es ex fa fi ga gr id ir ne ng nu ob oo pa ps pt r  ra ri ss st ta te tr ub un vi voa fa ia la ma oa rachaciactad afaageagralfalham ambamianaanganqaquaraarbarcargariarrasaatiautazib nbarbatberbigbilbiqbliboaboeborbsec ic lc pcadcamcasch chachechiciococcoicouctrcuecul",
    "ro": " de înde  a ul  coîn re e dea  di prle şi areat conui  şii dii  cue aluiernte cu  laa ccă dine cor ulune terla să tattre ac săestst tă  ca ma pecuristmâna di cnat cei aia in scu miatoaţiie  re sea aintntrtruuriă a fo paateinitulentminpreproa pe pe sei nă parrnarultor in ro tr unal aleartce e ee îfositanteomâostromru strver ex naa flornisrearit al eu noacecerilenalpriri stasteţie au da ju poar au eleereeriinan an cresse t atea că do fia satăcome şeurguvi siceilina recreprilrnertiurouveă p ar o  su videcdreoaronspe rii ad gea ma rainalicarcatecueneeptextiloiu n porisecu puneă cştiţia ch guai aniceae fiscl alicliumarnicnt nulrist ct ptictidu aucr as dr fa nu pu tocradisenţescgenit ivil dn dnd nu ondpenralrivrtestit dta to unixteândînsă s bl st uca ba ia lairastblabricheducdule measediespi li picaicăir iunjudlailulmaimenni pusputra rairopsilti trau sua udeursân întţă  lu mo s  sa sca uan atu",
    "ru": " на прто  нели  поно  в на ть не  и  коом про тоих  каатьото заие ователтор деой сти отах ми стр бе во раая ватей ет же ичеия ов сто обверго и ви пи сии исто восттра теелиерекотльнникнтио срорствчес бо ве да ин но с  со сп ст чталиамивиддете нельескестзали ниваконогоодножнольорировскося терчто мо са этантвсеерреслидеинаиноироитека ко колкомла нияо толоранредсь тивтичых  ви вс го ма слакоаниастбезделе де пем жнои дикаказкакки носо нопаприрроскити товые  вы до ме ни од ро св чиа наетазаатебесв пва е ве ме сез ениза знаиникамкахктоловмерможналницны нымораороот порравресрисросскат нтомчитшко бы о  тр уж чу шка ба ва рабиалаалоальаннатибинвесвново вшидалдатдное зегоелееннентетеи оилиисьит ициковленлькменмы нетни нныногнойномо побновеовнорыперпо прапреразропры се слисовтретсяуроцелчноь вькоьноэтоют я н ан ес же из кт ми мы пе се цеа ма па тавшажеак ал алеанеачиаютбнаболбы в ив сванградаждене к",
    "sk": " pr po ne a ch  na jení je  dona ova v to ho ou  toickterže  st zaostých sepro tee s žea p ktpre by o se kon přa sné ně stiakoistmu ameentky la pod ve obom vat kostaem le a vby e pko eriktesa éhoe vmertel ak sv záhlalaslo  taa nej li ne  saak aniateia sou soeníie  rece e noritic vya tké noso sstrti uje splovo poliová náaledene oku val am ro siniepoltra alalio vtor mo nici o ním  le pa s al atierooverovváních ja z ckée z odbylde dobneppraricspotak vša ae tlitme nejno nýco ta je aen estjí mi slostáu vfornoupospřesi tom vla zly ormrisza zák k at ckýdnodosdy jakkovny resrorstovan opda do e jhodlenný o zpozpriranu s abaj astit ktoo oobyodou pva áníí pým  in miať dovka nskáln an bu sl tre mechedni nkýcnícov příí a aj boa dideo ao dochpovsvoé s kd vo výbudichil ilini nímod oslouhravrozst stvtu u avály sí sí v hl li mea me bh si pi sitiládnemnovopouhlenoensmennesobote vedvláy n ma mu vábezbyvcho",
    "sl": "je  pr po je v  za napreda  daki ti ja ne  inin li no na ni  bijo  nenjee pi pprio pred doanjem ih  bo ki iz se soal  dee vi sko biliraove br obe bi novase za la  jaatiso ter taa sdele d dr oda nar jalji rit ka ko paa banie ser ililovo vtov ir ni voa jbi briitileto ntanše  le teenieriitakatporproalike oliov prari uarve  toa ia vakoarjatedi do ga le lo mero sodaoropod ma mo sia pbode negaju ka ljeravta a oe te zi di vilalitnihodostito varvedvol la no vsa daguajadejdnjedagovguajagjemkonku nijomoočipovrakrjastateva taj ed ejaentev i ii oijoistostskestr ra s  tr šearnbo drži jiloizvjenljansko do iom oraovorazržatakva venžav me čeameavie ie oekagrei tijail itekraljumorniko tobiodnranre stostvudiv ivan am sp st tu ve žeajoaleapodaldrue jednejoeloestetjevaijiik im itvmobnapnekpolposratskitičtomtontratudtvev bvilvsečit av gra zansastavtdane medsfori zkotmi nimo bo ood odloizot parpotrjeroitemval",
    "so": "ka ay da  ayaaloo aan kaan in  inadamaaaba soalibadaddsoo naahaku ta  wayo a somayaa ba ku la ooiyashaa addanabnta da mankauu y iayaha raa dh qaa kalabaadoohadliyoom ha sha da ia naaree ey y kya  ee iyaa aaqgaalam bua ba mad agaamaiyola a ca leenintshewaxyee si uua haasalkdhagu heeii iramado ao kqay ah ca wuankashaxaeeden ga haan an snaanayo dtaau buxuwuxxuu ci do ho taa ga uanaayodhiiinlaglinlkao isanu sunauun ga xa xuaababtaq aqaaraarlcaacireegeelisakallahneyqaarlasadsiiu dwad ad ar di jo ra sa u  yia ja qaadaataayah aleamkarias ayebusdalddudiidu duued egegeyhayhiiidainejoolaalaymarmeen bn dn mno o bo loogoonrgash sidu qunkushxa y d bi gu is ke lo me mu qo uga ea oa wadiadoagual antarkasaawibtabuld adagdando e sgalgayguuh ehaligaihiiriiyekenladlidlshmagmunn hn ina o no woodoororaqabqorrabritrtas osabskato u au hu uud uguulsuudwaaxusy by qy syadyayyih aa bo br go ji mi of ti um wi xoa x",
    "sq": "të  tënë për pë e sht në shse et ë së t sehe jë ër dhe paë në p që dhnjëë m njëshin  meqë  poe ne tishmë së me htë ka sie ke p i anëar  nuundve  ëse s mënukparuaruk jo rë ta ë fen it minhetn eri shqë d do ndsh ën atëhqiistë q gj ng tha ndo endimindir tratë bëri muartashqip koe medherije ka ngasi te ë kësi ma tievehjeiramunon po re  prim lito tur ë eë vët  ku sëe des ga itijetndëolishitje bë z gjekanshkëndës  de kj ru viaragovkjoor r prtorugtetugoaliarrat d tht i pipëizijnën noheshushët etika earëetëhumnd ndroshovarimtosva  fa fia sheni nmarndoporrissa sistësumëvizzit di mbaj anaatadëre aeshimejeslarn sntepolr nranresrrëtarë aë i at jo kë rea kai akthë hëni ii mia mennisshmstrt kt nt së gërkëve ai ci ed ja kr qe ta vea pcilel erëgjihtei tjenjitk dmënn tnyroripasra rierëstoruajyreëm ëny ar du ga jedëse ee zha hmeikainiiteithkohkraku limlisqënrëns st dt ttirtënverë j ba in tr zga aa ma tabr",
    "sr": " на је поје  и  не прга  свог а сих на којога у а пне ни ти  даом  ве сри сско оба нда е нно ного јој  зава е си пма никоброва коа идије пка ко когостсвествститраедиимапокпраразте  бо ви саавобрагосе иелиениза икиио преравраду сју ња  би до стастбојебои ним ку ланнебовоогоослојшпедстрчас го кр мо чла ма оакоачавелветвогедаиститиијеокослосрбчла бе ос от ре сеа ван богбровенграе оикаијакихкомли ну отаојнподрбсредројса снитачтваја ји  ка ов тра јавиаз анобиовикво говдние чегои оиваивоик инеиниипекипликло нашносо тод одионаојипочпрора рисродрстсе спостатићу ду ну очинша једјниће  м  ме ни он па сл теа уаваавеавнанаао атиациајуањабскворвосвскдине уеднезиекаеноетоењаживи ги ии ки тикуичкки крсла лавлитме меннацо но по уоднолиорносноспочепскречрпссвоскисласрпсу та тавтвеу бјезћи  ен жи им му од су та хр ча шт њеа да за ка тадуалоаниасованвачвањведви вновотвојву добдрудседу е бе де мем емаентенц",
    "ss": " ku lela ekua knga nga nngea llo  neetikwendze no l loelaemaentsi  kwtsii lwa lelkute kundni elofunesi sieletintfo tile khatsee lphaungi k emti sa  umisaelindlingsetwe isena angetfkheando n wentinyetfubena eutsletdzaimisekko lokeniye ba nkhebealoo klanga abaseb yehe lwakel te lakuswematiikhnekalakufi nokuatsmtshlawena t nagekuhlkubnguka akafutkankwa likuconkbananaulu se imakhumea ilestimulainilweza fo hul nohanli ipha stiskhuta dzibe emima endo tekea u kaanelekmelelwkunsislonutfanykhokulhlo baufuaphlune shalindiswo suseekwme ndvenguphhatne so lulnomte lolawunellu ha watmenete lwnemakozinkuhshabhagab inalemisteme eo ee twekdzeomewel luembnis ektsau lo ydleutelenswaphemkhntfukesitinye iwo aniphiwetsinnhlmalmbamfufu labsiktawno hlee uekiasealiulwve ekazelntabontekbo sigamaileuletfwmphumakupemtasidluishumtgeno wikeigahakabenetgankisndengiukhbekmo phuselelui tantdvoa yvo humlisdlagamivejenket",
    "st": "ng ho  lele  ho tsa msa la  kaa h diya ka  yaa tengets ba moa l selo  bowa tsaa bna ba  e  a a k maangtsese o ta da sha so o le ho ye ttlatsholoe le mo bo esebebeelathuelee kanae b th hatsoo ao k wakgotswthoo hong lahutditane mea e tlolaedielodi ona kewan o a papatjhhlo sasheletabaloklaoeo a ao smanto  hla nisae dswesetpa  nao mg lhet kggotahaethre e ejhaphelanotlg klekitsekgsenao disg mothe aithhlae ske molpelg hhabbetsanatsmo lwawe alalenntsdipkapiso mmutoaloe nsi ta o wemoswatsiokebedthe pha ywenkenenahwane oreatlanohelmotbo g ti bkgahorngonanno o ntlhshwkelphaetjbonellg sgolthaaledikkolbak ntikao d teohlg y loti hisileg boko ethana omatohoodilelmeldinkaro ouo monhahte me  ito fnenhebingbolbelhlepuolaltlohalophebahatheoarobatko banleho ioletle fekgepanakeg eakaeko perike ymmeamalhaeha faebomohmaeeteaemotsahio putaokgntlpalgeti le fokaseplatahlboteselahlonakga f puaseg amorkannahbohe p",
    "sv": "en  deet er tt om förar de att föing in at i detch an gen ant ssomte  octer halleoch sk sora r a mevarndeär  koon ansintn sna  en fr på st vaandntepå skata  viderällörs omda krika nst hoas stär dt fupp benger staltälör  avgerillng e sektadeeraersharll lldrinrnasäkundinnligns  ma pr upageav ivaktildaornsonts ttaäkr sj tiavtberelsetakolmenn dt kvtaår jukmann fninr irsäsjusso ära sachag bacdenettftehornbaollrnbstetil ef sia ae hed eftga ig it lermedn ind så tiv bl et fi säat dese agargetlanlssostr br ere retstat i ge he rea fallbosetslekletnernnanner frits ssenstotorvavygg ka så tr utad al aree ogonkomn an hngar hrent dtagtartreätt få hä sea da ia paleannarabyggt hanigtkanla n onomnskommr kr pr vs fs kt at pver bo br ku nåa ba edelenses finigem sn pnågor r orbers rt s as nskrt otentioven al ja p  r  saa hbetckedrae fe iedaenoeräessionjagm fne nnspror trarrivrätt et tustvadöre ar by kr miarb",
    "sw": " wawa a ka m ku yaa wya ni  maka a una za ia  naikama alia n amilikwa kwini haameanai n zaa hemai mi ykuwla o wa yatasem laatichii wuwaakili ekaira nca sikikatnch ka kia bajiambra ri rikadamatmbamesyo zi da hi i kja kuttekwan bia aakaao asichaeseezake mojoja hia zendha ji mu shiwat bwakearabw i himbtikwakwal hu mi mk ni ra uma lateeshinaishkimo k ira ialaaniaq azihini aidiimaitarairaqsha ms seaframaanoea elefrigo i iifaiwaiyokuslialiomajmkuno tanuliutawen ala jaadaidariawaba fa ndengenyao yu wua umowazye  ut via da taifdi ereingkinndao noa taitoausautowasyakzo  ji mwa paiaamuangbikbo dele weneengichiriitiitoki kirko kuumarmbomilngingoo longsi ta taku yumuusiuu wam af ba li si zia vamiatuawierifanfurgeri zisiizoleambimwanyeo ho monirezsaasersintattistu uinukiur wi yar da en mp ny ta ul wea ca faisapoayobardhie aekeenyeonhaihanhiyhuri simwkalkwelaklammakmsane nguru salswate ti ukuumaunauru",
    "tl": "ng ang na saan nansa na  ma caay n g anong gaat  paala sia nga g ng mitog cmansang singto ilaina di taagaiyaacag t atayaamalana aquia ca snag bag itan't  cuauag p nios 'y a m n la  lao nyan ayusacayon ya  ital apaatat nuanahaasapag gug ldi magabag aaraa pin anait si cusg buina tas n nhin hia'tali buganumaa dagcaqug d tuaonaricasi nniypina igcasiya'yyaoag ca hanilipansinualn snam lucanditguiy ngalhatnal isbagfra fr sua l coani bi daaloisaitamayo ssiluna in pil nnilo apatsact s uaaguailbindalg hndioonua  haindrans ntinuloengg finilahlo rairintong uinulono'yt a ara bad baycalgyailematn apaura tayy mantbani mnasnayno sti tiagsg gta uituno ib yaa uabiaticapig is la' do puapiayogosgullaltagtiltuny cy syonanoburibaisilamnacnatni ntood pa rgourg m adrastcaggaygsii pinolenlinm gmarnahto' dea hcatcauconiqulacmabminog parsal zaao dooipinodnteuhaula reilllitmacnito'tor orasumy p al mi umacoadaagdcab",
    "tlh": "tlhe' gh i'  'eu'  viatla'  ghej  ho ch mu tlngameywi'be'an ch ganchulh ing'e'hinjatlhi da jao' ughaq cha poey  'a je'ej pang ad  qaoh eh ah ghaje  luholaw' jiongpu'aj vadw' ' jha'is tah' 'angh 'ponam lawmo'qu'hbeol vamaghmu'ahvbejoghuch' vachhug lo quchohvaij  lalu'vis ne pu so ta va'acdi'hu'lahmoh 'o' mdaqhahn hnehu'may'ghoh vmehoy  ma nu'meel  ba be de ng' th dhvioq  wa' l'wihmeli'uq  bobogdelh ph tichvil qe wiahbbanenghaqhohov viq ha ti' n' p'a'hwiighlo'y'  du no yu'mo'vadajdaseghhommucom otlus  bi tu' hchmh qhovnisqaruj ' q'chh mhmojihparwij hu' d'a etlh gh jh llodmaqochwa'yuq di le pe ya'dicheechih ijain j 'j mlhwpa' 'i mi qi ro ru'beanpghighuh bhayhchiq npuod paqqayrdasoh do me qo sa' c' g' s'luamlardas d pgmeh nhtai'vj jjijlenngmqanqmevajwiv mo ni'la'pu'quar armdwig pghdh chamhlahquiloiqaiqij pj tj vladlhomarmugpusq sq trghrmasovta'tintu'u'dvetyliyu' to'ohaqqartat aylaytet hajhar",
    "tn": " di lego le  gong  tsya  yasa tlh mo boa mlo tsa e o ta bwa  kaa ka tka a gengoloo yla  a a detsmo se  tl batsh maba a ltseso na elo seelee do llhoe tdi e g kgditkgoo kanglhae me ewe aneo me ke longsetwanelatsotlao de bolangwgweo babaatla p o a ao aotla so edirthuga  gashwotsakahabhwaagao ggantswanamol kehut meonalelitslaokgadikgot falet waoseno t hsweediatsa ne sokoothkwakar tha ealatiro ndipisagatti anobot nn halenaloanyaroitiirio ssennetke ho maiikaekato ithre g mhatbo g let emoamaisorolfa iwakanshesi ao g kwenlolo obositla ythelwae n laore mmko thae aeo lhebolha  poisii blan nai talene gonrisirabon sag yg gphaogamelro golo w kwi l titlologpor jaa f nehoklot pue yutog thomokg koo famegorta  pents khthogeladiareeteasemonheooroomonennelilenngntlaboogoaranseegoheluo mogsanularagkolte etlbat tepuoamoofelatatiolerabtsiiromanaelegalwera dintlesekingyo a o reaotusoo rerejwaaemlamlek jwgwamok",
    "tr": "laren leran in  bi yaeride  kair arı ba de haın arabir ve sailele ndeda  buanainiınıer ve  yılmayıl olar n bndaayali ası geindn kesilannlaak anıenini nı rınsan ko yemazbaşilirinalıaz halınd da güeleılmığıekigüni biçidenkarsi  ile yna yorek n s içbu e bim ki lenri sın soün  taniniğitanyan sinatnınkanrı çinğı elin aır  aninen yola aral e slikn dsin al düanlne ya ım ına beadaalaamailmor sı yen meatıdi etikenla lı oru gö inande dmenun önea dat e ae gyar kuayıdanediiriünüği ılıemeeğii ki yıla çaa yalkdı edeel ndıra üne südıre kereik imiişimasn hsüryle ad fi gi sea karlaşıiyoklalığnemneyrmestetı unlver sı te toa saşkeklendkalliğmintıruluunuyapye ı işkaştı bü ke kiardartaşan inditi topı b va önakicakey filisiklekurmanncenlenunrakık  en yoa glismakn gtiryas iş yöalebilbulet i diyekilma n en tnu olurlate yönçık ay mü ço çıa aa batadergeli gi iillistldılu mekmlen çonuoplranratrdırkesiysonta tçıtın",
    "ts": " kuku na ka wa a n swa mya a k tiswihi la  ya le hia ta v vani  nandz maa h xia si nelei kanaa lngalo va le akaelairheka vuiwaa x kayi  waisasa ko ta ga wu wi tir ek mi nio yeloawuisiswai thlaa e ta ng laa yri eri rirhiekeumbu tndl yilani veswmbei la re kanglesulati yono wonalawxa nelyo leliko loamb a i y xaanewani sondfanendi ho lu kmbin'wke dyo falamnhlo songno  kou n haho okou hi mo n yonguo ku yatiu lvanuluandmbakumu vwo be ha riwdzasi  eno h hlo teyi ntilalokdzinge mualato a w byarhakutsawakrho'wa ndminlavtimleytikdletinmatlerletselhismellu ikaa angoengo x nkamusiwanienima  nhmi swoetitanmo hamiwe khhanlekntiunghakdzoete tsavahu fumkarvul wukulundi xnhuyisxikbisxi e yra hle huwekanoyena dsisolopfui wnyie nso ki funisotshkonnkuheli be hariimii eindvumntsimekommfuise mfhindlavutgani rbanbyamilintats dyu se xilekelkwa noi fasiza urio mrhae lin'etavoni akho woiki rau eo ezo yininkanyket",
    "uk": " на занняня на  прогого ськ по у відере мі неих ть пер віів  пе щольнми ні не ти атиеннміспрауваникпроравівн табудвлірів ко ріально омущо  виму ревся інн до упавланнкомли лінногупр бу з  роза и нновороостстаті ють мо ні якборва ваненьи пнь овіронстіта у вькоіст в  редо е пзабий нсьо во пприі п ку пі спа пабоансаціватвнии вимика неннічонаої повькиьноізнічн ав ма ор су чи іна зам ає вневтодоментжитзниим итлла нихницоваовиом портьсу рьсяідоільісь ва ді жи че і а ва наливезвноевеезезеництки кихконку ласля можначнимноїо бовуодиою ро роксноспотактвату у пцтвьния зі мії  вс гр де но па се ук їха оавтастаютварденди ду знаи зикоисяитикогменномну о но собуовопларанривробскатантимтисто траудочинчниі вію  а  во да кв ме об ск ти фі є а ра са уак аніартаснв увиквіздовдподівевіенсже и ми сикаичнкі ківміжнанносо уоблоднок олоотрренримрозсь сі тлатіву зугоудічи ше я ня уідпій інаія  ка ни ос си то тр уг",
    "ur": "یں  کیکے  کےنے  کہے ککی میں میہے وں کہ  ہےان ہیںور  کویا  ان نےسے  سے کرستا اواورتانر کی ک اسے ا پا ہو پررف  کاا کی ا ہیدر کو  ایں ک مش ملات صدراکسشرفمشرپاککستی م دی صد یہا ہن کوالیہ ے و بھ دواس ر انہیکا ے سئی ہ ایت ے ہت ک سالے ہا ے ب واار نی کہای ہے م سی لیانہانیر مر پریتن مھا یر  جا جنئے پر ں نہ کی وے د تو تھ گیایکل کنا کر ں میک  باا تدی ن سکیایوںے جال تو ں اے پ چاام بھیتی تے دوسس کملکن اہوریے  مو وکائیارتالےبھاردیری وہ ویزں دھی ی س رہ من نہ ور وہ ہنا ااستت ات پد کز مند وردوکلگی گیاہ پیز ے ت اع اپ جس جم جو سراپناکثتھاثریدیار درت رویسی ملاندووستپروچاہکثرکلاہ ہہندہو ے ل اک دا سن وز پیا چاء اتھاقااہ تھ دو ر بروارے ساتف کقاتلا لاءم مم کمن نوںو اکرنں ہھارہوئہی یش  ام لا مس پو پہانےت مت ہج کدونزیرس سش کف نل ہلاقلی وریوزیونوکھنگا ں سں گھنےھے ہ بہ جہر ی آی پ حا وف گاا جا گاد ادیاعظاہتجس جمہجو ر سر ہرنےس مسا سندسنگظم عظمل ملیےمل موہمہونگھو صورٹوہنکن گھ گے ں جں وں یہ دہن ہوںے حے گے ی اگ بع رو شا",
    "uz": "ан ганларга нг ингнинда ни идаариигаиниар ди  биани боданлга ҳа ва саги илан би б кў таир  маагаалабирри тгаланлика кагиатита адидагрга йи ми па бў қа қиа биллли асии тик илиллаардвчива иб ирилигнгаран ке ўза сахтбўлигикўррдарниса  бе бу да жаа тазиерии аилгйилманпахридти увчхта не со учайтллитла ай фр эт ҳоа қалиаробербилборимиистон ринтертилун фрақил ба олансефтзиркатмилнефсагчи ўра на те эна эам арнат иш ма нларличилшга иш му ўқаравази уиқ моқримучучунши энгқувҳам сў шибарбекдами ҳишиладолиоллориоқдр бра рлаунифт ўлгўқу де ка қўа ўабаамматлб кбошзбеи вим ин ишллаблейминн дндаоқ р мрилсидталтантидтонўзб ам киа ҳангандартаётдиренти ди ми ои эиройтинсуодиор си тиштобэтиқарқда бл ге до ду но пр ра фо қоа ма оайдалоамаблег ндолейрек ергжарзиди ки фий илолдилиблинми мман вн кн ўн ҳозиораосирасришркароқстотинхатшир ав рў ту ўта павтадаазаанлб ббойбу втог эгиндардендунидеионирлишгйхакелкўплио",
    "ve": "ha  vha mna  u a ntshwa a u nangavha ts dz khdzaa vya  yaa tho la  zw muedzvhuga shiza a k ngkha mahumne  ndo nlo dzishu haa do yndaelezwiahoangno  a elaa zhu shai n waanahi kano danoa hzwa th migana lsa handi u tandndiyo thedo ri vhoni ka urisi o tmbeo wanewe zo i te ni hsheusho kzi da a athu laa pzan i a slwaulai daka domisheditali  huiwa lui vhe  kaeloso ambavh sho vi klelu vdzou s fhmo nweo lumiwahisihela iveladztani maththiwi  urhatinele vheanya yhonisaalao aaluudiumb bvash te lilusnyahasledswahuso iumoonendetha itkhongomushake yea ivho mu nhinthomutayofhi satelhulhunuloithma  yolane v phgo i ao uhud pfukazhiuvhdzwingelwilawo mbou diteiswasie kndufheo hmelu bikabo guddzhkonifh tae duth hoi zwanulumadinwothanidiswitou bveetsu iadie mfhanahdalwin sisho inyamlayekaa fi uendi yaloi lusomulta delu k mbpha didadalio spfukhwe a ko nehenmasumeiniishudziraoniluknelisombadzuhomi szwonguaraunz",
    "vi": "ng  th chg t nhông kh trnh  côcôn tyty i tn t ngại  tich y lền  đưhi  gởgởiiềntiềởi  gi le vichoho khá vàhác pham hànáchôi i nượcợc  tôchúiệttôiên úngệt  cóc tcó húnviệđượ nag ci cn cn nt nvà n ln đàngác ất h lnamân ăm  hà là nă qu tạg mnămtạiới  lẹay e gh hi vi đle lẹ ều ời hânnhit t củ mộ về đian củalà mộtvề ànhết ột ủa  bi cáa canhcách ciềum tện  ho's avee'sel g nle'n vo cravs tthitravelận ến  ba cu sa đó đếc cchuhiềhuykhinhânhưongronthuthưtroy cày đếnườiườnề vờng vớcuộg điếtiệnngào tu cuộcvớià cài ơngươnải ộc ức  an lậ ra sẽ số tổa kbiếc nc đchứg vgiagàyhánhônhư hứci gi hi ki piênkhôlậpn kra rênsẽ t cthàtrêtổ u ny tìnhấy ập ổ c má đểai c sgườh vhoahoạinhm nmáyn gngưnhậo noa oànp csố t đy vào áy ăn đó để ướcần ển ớc  bá cơ cả cầ họ kỳ li mạ sở tặ vé vụ đạa đbaycơ g shanhươi skỳ m cn mn po boạiquasở thathátặnvàové vụ y bàn ángơ sầu ật ặngọc ở tững du lu ta to từ ở a vao c vcả du g lgiả",
    "xh": "la  kulo ngaa k ngoku kw uka nukuye a iyo elaelea unyewe wa amae niseababa ho enzo nngokubngeathfuno elelungubako eloezio kthekwana kweange ile ka esio y nae kethpha inkunnziandni ban ye nolwalun okanyzi li  neulua eeligoko lebeundisasebndo ezthoo ido beningkwindlunyalaa aeyoe ukan abthii ki no uo zelwsa sekayoheto oeka umhi bo so isiwenlweapha lya ekoana yokufiniimialiha awuwanentuththaza ulakho iianee aisouph leilezinnts siengnokonghlazwe elokaekilisazi lotsh amufuantiswo anguo s bainteniunewulhulseli euselanke nisemi li isiph ima oakamfu ziinkmalleymannyanekakhume koalotu i untuizwkelizii isi ganaseindi andinelalusisubokutmthkuslekmisnde zo weaniga ikosizno phue ehonondne ithkulgamgenpho izphehatkhuiinhanzo lu ulondaqo zikhelo m lwzisdleuhlmenolomeldelnzaokookwolukuknteswalawenk yai ygaqshaaqoe likhnkqule kaonkthuwo bonkupquba ykqudla eshe anolumbe iga zeo wakumgankete  olze kumemfesh",
    "zu": "okula nga nga n kua kthi ukezie nukule lo hi wa  noa uelawe a ini elezinuthamaelophaingabaathandenzethesima lel um katheungngengothonyekweeniiziye  kwndlho a ena zi hetkane ue iundiseisindakhaba i knomfun ez izke beno eisazwekelka akanzio ne komakwa neanyanghlai umthkubo kanaaneikhebekutha  isaziulusebalaonkbani eazwwen abhana ai nimilanhatlwa nainiakhli ngunkenokumeekeelwyo aphkus es okiph immeli i lo in amkhoza gokseklunkunlweshasikkufhaka ythusa o ukhuayohule aalienglu ne  koeliubadlee eith yoa lnelmis sikula osislokgeno zi aemiumaekaalomaniswthao ilonso uphuhlntuzimmalindwez bao o yi weulapheo yileo lwo welga tu hleokwfan lekazaseanindebo ngiule emmeninyambmbiganifuo santhelikaonai lfut fuze u anhlnin zoendsigu kgabufaishushkuzno gamkuh yenyanezzisdlukatdlatsh seikekuqgu osiswalul ziimae lkupmo nzaasiko kumleksheumtunyyokwanwamameonglismkhahlaleuseo aalugapsi hlonjeomto wokhhe komi s"
  };

  global._languageData = (typeof module === "object" && module.exports === global && module || {}).exports = models;

})(this);
/*   Guess the natural language of a text
 *   Copyright (c) 2012-2014, Rich Tibbett
 *   http://github.com/richtr/guessLanguage.js/
 *
 *   Original Python package:
 *   Copyright (c) 2008, Kent S Johnson
 *   http://code.google.com/p/guess-language/
 *
 *   Original C++ version for KDE:
 *   Copyright (c) 2006 Jacob R Rideout <kde@jacobrideout.net>
 *   http://websvn.kde.org/branches/work/sonnet-refactoring/common/nlp/guesslanguage.cpp?view=markup
 *
 *   Original Language::Guess Perl module:
 *   Copyright (c) 2004-2006 Maciej Ceglowski
 *   http://web.archive.org/web/20090228163219/http://languid.cantbedone.org/
 *
 *   Note: Language::Guess is GPL-licensed. KDE developers received permission
 *   from the author to distribute their port under LGPL:
 *   http://lists.kde.org/?l=kde-sonnet&m=116910092228811&w=2
 *
 *   This program is free software: you can redistribute it and/or modify it
 *   under the terms of the GNU Lesser General Public License as published
 *   by the Free Software Foundation, either version 3 of the License,
 *   or (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty
 *   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *   See the GNU Lesser General Public License for more details.
 *
 *   You should have received a copy of the GNU Lesser General Public License
 *   along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

(function (global, undefined) {

  var guessLanguage = function () {

    var models = global._languageData || {};

    if (typeof module === "object" && module.exports === global) {
      models = require('./_languageData') || {};
    }

    var MAX_LENGTH = 4096;
    var MIN_LENGTH = 20;
    var MAX_GRAMS = 300;

    var NAME_MAP = {
      "ab": "Abkhazian",
      "af": "Afrikaans",
      "ar": "Arabic",
      "az": "Azeri",
      "be": "Belarusian",
      "bg": "Bulgarian",
      "bn": "Bengali",
      "bo": "Tibetan",
      "br": "Breton",
      "ca": "Catalan",
      "ceb": "Cebuano",
      "cs": "Czech",
      "cy": "Welsh",
      "da": "Danish",
      "de": "German",
      "el": "Greek",
      "en": "English",
      "eo": "Esperanto",
      "es": "Spanish",
      "et": "Estonian",
      "eu": "Basque",
      "fa": "Farsi",
      "fi": "Finnish",
      "fo": "Faroese",
      "fr": "French",
      "fy": "Frisian",
      "gd": "Scots Gaelic",
      "gl": "Galician",
      "gu": "Gujarati",
      "ha": "Hausa",
      "haw": "Hawaiian",
      "he": "Hebrew",
      "hi": "Hindi",
      "hmn": "Pahawh Hmong",
      "hr": "Croatian",
      "hu": "Hungarian",
      "hy": "Armenian",
      "id": "Indonesian",
      "is": "Icelandic",
      "it": "Italian",
      "ja": "Japanese",
      "ka": "Georgian",
      "kk": "Kazakh",
      "km": "Cambodian",
      "ko": "Korean",
      "ku": "Kurdish",
      "ky": "Kyrgyz",
      "la": "Latin",
      "lt": "Lithuanian",
      "lv": "Latvian",
      "mg": "Malagasy",
      "mk": "Macedonian",
      "ml": "Malayalam",
      "mn": "Mongolian",
      "mr": "Marathi",
      "ms": "Malay",
      "nd": "Ndebele",
      "ne": "Nepali",
      "nl": "Dutch",
      "nn": "Nynorsk",
      "no": "Norwegian",
      "nso": "Sepedi",
      "pa": "Punjabi",
      "pl": "Polish",
      "ps": "Pashto",
      "pt": "Portuguese",
      "pt-PT": "Portuguese (Portugal)",
      "pt-BR": "Portuguese (Brazil)",
      "ro": "Romanian",
      "ru": "Russian",
      "sa": "Sanskrit",
      "bs": "Serbo-Croatian",
      "sk": "Slovak",
      "sl": "Slovene",
      "so": "Somali",
      "sq": "Albanian",
      "sr": "Serbian",
      "sv": "Swedish",
      "sw": "Swahili",
      "ta": "Tamil",
      "te": "Telugu",
      "th": "Thai",
      "tl": "Tagalog",
      "tlh": "Klingon",
      "tn": "Setswana",
      "tr": "Turkish",
      "ts": "Tsonga",
      "tw": "Twi",
      "uk": "Ukrainian",
      "ur": "Urdu",
      "uz": "Uzbek",
      "ve": "Venda",
      "vi": "Vietnamese",
      "xh": "Xhosa",
      "zh": "Chinese",
      "zh-TW": "Traditional Chinese (Taiwan)",
      "zu": "Zulu"
    };

    var IANA_MAP = {
      "ab": 12026,
      "af": 40,
      "ar": 26020,
      "az": 26030,
      "be": 11890,
      "bg": 26050,
      "bn": 26040,
      "bo": 26601,
      "br": 1361,
      "ca": 3,
      "ceb": 26060,
      "cs": 26080,
      "cy": 26560,
      "da": 26090,
      "de": 26160,
      "el": 26165,
      "en": 26110,
      "eo": 11933,
      "es": 26460,
      "et": 26120,
      "eu": 1232,
      "fa": 26130,
      "fi": 26140,
      "fo": 11817,
      "fr": 26150,
      "fy": 1353,
      "gd": 65555,
      "gl": 1252,
      "gu": 26599,
      "ha": 26170,
      "haw": 26180,
      "he": 26592,
      "hi": 26190,
      "hr": 26070,
      "hu": 26200,
      "hy": 26597,
      "id": 26220,
      "is": 26210,
      "it": 26230,
      "ja": 26235,
      "ka": 26600,
      "kk": 26240,
      "km": 1222,
      "ko": 26255,
      "ku": 11815,
      "ky": 26260,
      "la": 26280,
      "lt": 26300,
      "lv": 26290,
      "mg": 1362,
      "mk": 26310,
      "ml": 26598,
      "mn": 26320,
      "mr": 1201,
      "ms": 1147,
      "ne": 26330,
      "nl": 26100,
      "nn": 172,
      "no": 26340,
      "pa": 65550,
      "pl": 26380,
      "ps": 26350,
      "pt": 26390,
      "ro": 26400,
      "ru": 26410,
      "sa": 1500,
      "bs": 1399,
      "sk": 26430,
      "sl": 26440,
      "so": 26450,
      "sq": 26010,
      "sr": 26420,
      "sv": 26480,
      "sw": 26470,
      "ta": 26595,
      "te": 26596,
      "th": 26594,
      "tl": 26490,
      "tlh": 26250,
      "tn": 65578,
      "tr": 26500,
      "tw": 1499,
      "uk": 26520,
      "ur": 26530,
      "uz": 26540,
      "vi": 26550,
      "zh": 26065,
      "zh-TW": 22
    };

    var SINGLETONS = [
      ["Armenian", "hy"],
      ["Hebrew", "he"],
      ["Bengali", "bn"],
      ["Gurmukhi", "pa"],
      ["Greek", "el"],
      ["Gujarati", "gu"],
      ["Oriya", "or"],
      ["Tamil", "ta"],
      ["Telugu", "te"],
      ["Kannada", "kn"],
      ["Malayalam", "ml"],
      ["Sinhala", "si"],
      ["Thai", "th"],
      ["Lao", "lo"],
      ["Tibetan", "bo"],
      ["Burmese", "my"],
      ["Georgian", "ka"],
      ["Mongolian", "mn"],
      ["Khmer", "km"],
      ["Pahawh Hmong", "hmn"]
    ];

    var UNKNOWN = 'unknown';

    var BASIC_LATIN = ["en", "ceb", "ha", "so", "tlh", "id", "haw", "la", "sw", "eu", "nr", "nso", "zu", "xh", "ss", "st", "tn", "ts"];
    var EXTENDED_LATIN = ["cs", "af", "pl", "hr", "ro", "sk", "sl", "tr", "hu", "az", "et", "sq", "ca", "es", "fr", "de", "nl", "it", "da", "is", "no", "sv", "fi", "lv", "pt", "ve", "lt", "tl", "cy", "vi"];
    var ALL_LATIN = BASIC_LATIN.concat(EXTENDED_LATIN);
    var CYRILLIC = ["ru", "uk", "kk", "uz", "mn", "sr", "mk", "bg", "ky"];
    var ARABIC = ["ar", "fa", "ps", "ur"];
    var DEVANAGARI = ["hi", "ne"];
    var PT = ["pt-BR", "pt-PT"];

    // Unicode char greedy regex block range matchers
    var unicodeBlockTests = {
      "Basic Latin": /[\u0000-\u007F]/g,
      "Latin-1 Supplement": /[\u0080-\u00FF]/g,
      "Latin Extended-A": /[\u0100-\u017F]/g,
      "Latin Extended-B": /[\u0180-\u024F]/g,
      "IPA Extensions": /[\u0250-\u02AF]/g,
      "Spacing Modifier Letters": /[\u02B0-\u02FF]/g,
      "Combining Diacritical Marks": /[\u0300-\u036F]/g,
      "Greek and Coptic": /[\u0370-\u03FF]/g,
      "Cyrillic": /[\u0400-\u04FF]/g,
      "Cyrillic Supplement": /[\u0500-\u052F]/g,
      "Armenian": /[\u0530-\u058F]/g,
      "Hebrew": /[\u0590-\u05FF]/g,
      "Arabic": /[\u0600-\u06FF]/g,
      "Syriac": /[\u0700-\u074F]/g,
      "Arabic Supplement": /[\u0750-\u077F]/g,
      "Thaana": /[\u0780-\u07BF]/g,
      "NKo": /[\u07C0-\u07FF]/g,
      "Devanagari": /[\u0900-\u097F]/g,
      "Bengali": /[\u0980-\u09FF]/g,
      "Gurmukhi": /[\u0A00-\u0A7F]/g,
      "Gujarati": /[\u0A80-\u0AFF]/g,
      "Oriya": /[\u0B00-\u0B7F]/g,
      "Tamil": /[\u0B80-\u0BFF]/g,
      "Telugu": /[\u0C00-\u0C7F]/g,
      "Kannada": /[\u0C80-\u0CFF]/g,
      "Malayalam": /[\u0D00-\u0D7F]/g,
      "Sinhala": /[\u0D80-\u0DFF]/g,
      "Thai": /[\u0E00-\u0E7F]/g,
      "Lao": /[\u0E80-\u0EFF]/g,
      "Tibetan": /[\u0F00-\u0FFF]/g,
      "Burmese": /[\u1000-\u109F]/g,
      "Georgian": /[\u10A0-\u10FF]/g,
      "Hangul Jamo": /[\u1100-\u11FF]/g,
      "Ethiopic": /[\u1200-\u137F]/g,
      "Ethiopic Supplement": /[\u1380-\u139F]/g,
      "Cherokee": /[\u13A0-\u13FF]/g,
      "Unified Canadian Aboriginal Syllabics": /[\u1400-\u167F]/g,
      "Ogham": /[\u1680-\u169F]/g,
      "Runic": /[\u16A0-\u16FF]/g,
      "Pahawh Hmong": /[\u16B0-\u16B8]/g,
      "Tagalog": /[\u1700-\u171F]/g,
      "Hanunoo": /[\u1720-\u173F]/g,
      "Buhid": /[\u1740-\u175F]/g,
      "Tagbanwa": /[\u1760-\u177F]/g,
      "Khmer": /[\u1780-\u17FF]/g,
      "Mongolian": /[\u1800-\u18AF]/g,
      "Limbu": /[\u1900-\u194F]/g,
      "Tai Le": /[\u1950-\u197F]/g,
      "New Tai Lue": /[\u1980-\u19DF]/g,
      "Khmer Symbols": /[\u19E0-\u19FF]/g,
      "Buginese": /[\u1A00-\u1A1F]/g,
      "Balinese": /[\u1B00-\u1B7F]/g,
      "Phonetic Extensions": /[\u1D00-\u1D7F]/g,
      "Phonetic Extensions Supplement": /[\u1D80-\u1DBF]/g,
      "Combining Diacritical Marks Supplement": /[\u1DC0-\u1DFF]/g,
      "Latin Extended Additional": /[\u1E00-\u1EFF]/g,
      "Greek Extended": /[\u1F00-\u1FFF]/g,
      "General Punctuation": /[\u2000-\u206F]/g,
      "Superscripts and Subscripts": /[\u2070-\u209F]/g,
      "Currency Symbols": /[\u20A0-\u20CF]/g,
      "Combining Diacritical Marks for Symbols": /[\u20D0-\u20FF]/g,
      "Letterlike Symbols": /[\u2100-\u214F]/g,
      "Number Forms": /[\u2150-\u218F]/g,
      "Arrows": /[\u2190-\u21FF]/g,
      "Mathematical Operators": /[\u2200-\u22FF]/g,
      "Miscellaneous Technical": /[\u2300-\u23FF]/g,
      "Control Pictures": /[\u2400-\u243F]/g,
      "Optical Character Recognition": /[\u2440-\u245F]/g,
      "Enclosed Alphanumerics": /[\u2460-\u24FF]/g,
      "Box Drawing": /[\u2500-\u257F]/g,
      "Block Elements": /[\u2580-\u259F]/g,
      "Geometric Shapes": /[\u25A0-\u25FF]/g,
      "Miscellaneous Symbols": /[\u2600-\u26FF]/g,
      "Dingbats": /[\u2700-\u27BF]/g,
      "Miscellaneous Mathematical Symbols-A": /[\u27C0-\u27EF]/g,
      "Supplemental Arrows-A": /[\u27F0-\u27FF]/g,
      "Braille Patterns": /[\u2800-\u28FF]/g,
      "Supplemental Arrows-B": /[\u2900-\u297F]/g,
      "Miscellaneous Mathematical Symbols-B": /[\u2980-\u29FF]/g,
      "Supplemental Mathematical Operators": /[\u2A00-\u2AFF]/g,
      "Miscellaneous Symbols and Arrows": /[\u2B00-\u2BFF]/g,
      "Glagolitic": /[\u2C00-\u2C5F]/g,
      "Latin Extended-C": /[\u2C60-\u2C7F]/g,
      "Coptic": /[\u2C80-\u2CFF]/g,
      "Georgian Supplement": /[\u2D00-\u2D2F]/g,
      "Tifinagh": /[\u2D30-\u2D7F]/g,
      "Ethiopic Extended": /[\u2D80-\u2DDF]/g,
      "Supplemental Punctuation": /[\u2E00-\u2E7F]/g,
      "CJK Radicals Supplement": /[\u2E80-\u2EFF]/g,
      "KangXi Radicals": /[\u2F00-\u2FDF]/g,
      "Ideographic Description Characters": /[\u2FF0-\u2FFF]/g,
      "CJK Symbols and Punctuation": /[\u3000-\u303F]/g,
      "Hiragana": /[\u3040-\u309F]/g,
      "Katakana": /[\u30A0-\u30FF]/g,
      "Bopomofo": /[\u3100-\u312F]/g,
      "Hangul Compatibility Jamo": /[\u3130-\u318F]/g,
      "Kanbun": /[\u3190-\u319F]/g,
      "Bopomofo Extended": /[\u31A0-\u31BF]/g,
      "CJK Strokes": /[\u31C0-\u31EF]/g,
      "Katakana Phonetic Extensions": /[\u31F0-\u31FF]/g,
      "Enclosed CJK Letters and Months": /[\u3200-\u32FF]/g,
      "CJK Compatibility": /[\u3300-\u33FF]/g,
      "CJK Unified Ideographs Extension A": /[\u3400-\u4DBF]/g,
      "Yijing Hexagram Symbols": /[\u4DC0-\u4DFF]/g,
      "CJK Unified Ideographs": /[\u4E00-\u9FFF]/g,
      "Yi Syllables": /[\uA000-\uA48F]/g,
      "Yi Radicals": /[\uA490-\uA4CF]/g,
      "Modifier Tone Letters": /[\uA700-\uA71F]/g,
      "Latin Extended-D": /[\uA720-\uA7FF]/g,
      "Syloti Nagri": /[\uA800-\uA82F]/g,
      "Phags-pa": /[\uA840-\uA87F]/g,
      "Hangul Syllables": /[\uAC00-\uD7AF]/g,
      "High Surrogates": /[\uD800-\uDB7F]/g,
      "High Private Use Surrogates": /[\uDB80-\uDBFF]/g,
      "Low Surrogates": /[\uDC00-\uDFFF]/g,
      "Private Use Area": /[\uE000-\uF8FF]/g,
      "CJK Compatibility Ideographs": /[\uF900-\uFAFF]/g,
      "Alphabetic Presentation Forms": /[\uFB00-\uFB4F]/g,
      "Arabic Presentation Forms-A": /[\uFB50-\uFDFF]/g,
      "Variation Selectors": /[\uFE00-\uFE0F]/g,
      "Vertical Forms": /[\uFE10-\uFE1F]/g,
      "Combining Half Marks": /[\uFE20-\uFE2F]/g,
      "CJK Compatibility Forms": /[\uFE30-\uFE4F]/g,
      "Small Form Variants": /[\uFE50-\uFE6F]/g,
      "Arabic Presentation Forms-B": /[\uFE70-\uFEFF]/g,
      "Halfwidth and Fullwidth Forms": /[\uFF00-\uFFEF]/g,
      "Specials": /[\uFFF0-\uFFFF]/g
    };

    function findRuns(text) {

      var relevantRuns = {};

      for (var key in unicodeBlockTests) {

        // Count the number of characters in each character block.
        var charCount = text.match(unicodeBlockTests[key]);

        // return run types that used for 40% or more of the string
        // always return basic latin if found more than 15%
        // and extended additional latin if over 10% (for Vietnamese)
        var pct = (charCount ? charCount.length : 0) / text.length;

        relevantRuns[key] = pct;

      }

      return relevantRuns;
    }

    function identify(text, callback) {

      var scripts = findRuns(text);

      // Identify the language.
      if (scripts["Hangul Syllables"] + scripts["Hangul Jamo"] + scripts["Hangul Compatibility Jamo"] >= 0.4) {
        callback.apply(undefined, ["ko"]);
        return;
      }

      if (scripts["Greek and Coptic"] >= 0.4) {
        callback.apply(undefined, ["el"]);
        return;
      }

      if (scripts["Hiragana"] + scripts["Katakana"] + scripts["Katakana Phonetic Extensions"] >= 0.2) {
        callback.apply(undefined, ["ja"]);
        return;
      }

      if (scripts["CJK Unified Ideographs"] + scripts["Bopomofo"] + scripts["Bopomofo Extended"] + scripts["KangXi Radicals"] >= 0.4) {
        callback.apply(undefined, ["zh"]);
        return;
      }

      if (scripts["Cyrillic"] >= 0.4) {
        check(text, CYRILLIC, callback);
        return;
      }

      if (scripts["Arabic"] + scripts["Arabic Presentation Forms-A"] + scripts["Arabic Presentation Forms-B"] >= 0.4) {
        check(text, ARABIC, callback);
        return;
      }

      if (scripts["Devanagari"] >= 0.4) {
        check(text, DEVANAGARI, callback);
        return;
      }

      // Try languages with unique scripts
      for (var i = 0, l = SINGLETONS.length; i < l; i++) {
        if (scripts[SINGLETONS[i][0]] >= 0.4) {
          callback.apply(undefined, [SINGLETONS[i][1]]);
          return;
        }
      }

      // Extended Latin
      if (scripts["Latin-1 Supplement"] + scripts["Latin Extended-A"] + scripts["IPA Extensions"] >= 0.4) {
        check(text, EXTENDED_LATIN, function (latinLang) {
          if (latinLang == "pt") {
            check(text, PT, callback);
          } else {
            callback.apply(undefined, [latinLang]);
          }
        });
        return;
      }

      if (scripts["Basic Latin"] >= 0.15) {
        check(text, ALL_LATIN, callback);
        return;
      }

      callback.apply(undefined, [UNKNOWN]);
    }

    function check(sample, langs, callback) {

      if (sample.length < MIN_LENGTH) {
        callback.apply(undefined, [UNKNOWN]);
        return;
      }

      var scores = {};
      var model = createOrderedModel(sample);
      for (var i = 0, l = langs.length; i < l; i++) {

        var lkey = langs[i].toLowerCase();

        var knownModel = createKnownModel(lkey) || null;

        if (!knownModel) {
          continue;
        }

        scores[lkey] = distance(model, knownModel);

      }

      var scoresArr = [];
      for (var index in scores) {
        scoresArr.push([index, scores[index]]);
      }

      if (scoresArr.length == 0) {
        callback.apply(undefined, [UNKNOWN]);
        return;
      }

      // we want the lowest score, less distance = greater chance of match
      var sortedScores = scoresArr.sort(function (objA, objB) {
        return objA[1] - objB[1]; // sort low-to-high
      });

      // return the best match we've now calculated
      callback.apply(undefined, [sortedScores[0][0]]);
    }

    function createOrderedModel(content) {
      // Create a list of trigrams in content sorted by frequency.
      var trigrams = {},
        sortedTrigrams = [];
      var content = content.toLowerCase();

      var contentArr = content.split("");
      for (var i = 0, l = contentArr.length - 2; i < l; i++) {
        var trigramKey = contentArr[i] + contentArr[i + 1] + contentArr[i + 2] + "";
        if (!trigrams[trigramKey]) {
          trigrams[trigramKey] = 1;
        } else {
          trigrams[trigramKey] += 1;
        }
      }

      // convert object to array
      for (var i in trigrams) {
        sortedTrigrams[sortedTrigrams.length] = [i, trigrams[i]];
      }

      // sort array results
      return sortedTrigrams.sort(function (objA, objB) {
        return objB[1] - objA[1]; // sort high-to-low
      });
    }

    var knownModelCache = {};

    function createKnownModel(key) {
      // Check if known model has been pre-computed in cache
      if (knownModelCache[key]) {
        return knownModelCache[key];
      }

      var data = models[key];
      if (!data) {
        return {};
      }

      // Extract known trigram model data
      var dataArr = data.match(/([\s\S]{1,3})/g);
      // Contruct known trigram object based on provided raw data
      var knownModel = {};
      for (var i = 0, l = dataArr.length; i < l; i++) {
        knownModel[dataArr[i]] = i;
      }

      // Store in known model pre-computed cache
      knownModelCache[key] = knownModel;

      return knownModel;
    }

    function distance(model, knownModel) {
      // Calculate the distance to the known model.
      var dist = 0;

      for (var i = 0, l = model.length; i < l; i++) {

        if (knownModel[model[i][0]]) {

          dist += Math.abs(model[i][1] - knownModel[model[i][0]]);

        } else {

          dist += MAX_GRAMS;

        }

      }

      return dist;
    }

    return {
      detect: function (text, callback) {
        // Return the ISO 639-2 language identifier, i.e. 'en'.

        if (!text) {
          callback.apply(undefined, [UNKNOWN]);
          return;
        }

        text = text.substr(0, MAX_LENGTH).replace(/[\u0021-\u0040]/g, '');

        identify(text, callback);

      },
      info: function (text, callback) {
        // Return language info tuple (id, code, name), i.e. ('en', 26110, 'English').

        this.detect(text, function (language) {

          if (language === UNKNOWN) {
            callback.apply(undefined, [
              [UNKNOWN, UNKNOWN, UNKNOWN]
            ]);
            return;
          }

          callback.apply(undefined, [

            [language, IANA_MAP[language], NAME_MAP[language]]

          ]);

        });

      },
      code: function (text, callback) {
        // Return the language IANA code, i.e. 26110.

        this.detect(text, function (language) {

          if (language === UNKNOWN) {
            callback.apply(undefined, [-1]);
            return;
          }

          callback.apply(undefined, [

            IANA_MAP[language]

          ]);

        });

      },
      name: function (text, callback) {
        // Return the full language name, i.e. 'English'.

        this.detect(text, function (language) {

          if (language === UNKNOWN) {
            callback.apply(undefined, [UNKNOWN]);
            return;
          }

          callback.apply(undefined, [

            NAME_MAP[language]

          ]);

        });

      }
    };

  };

  global.guessLanguage = (global.module || {}).exports = new guessLanguage();

})(this);
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS = CryptoJS || function (u, p) {
  var d = {},
    l = d.lib = {},
    s = function () {},
    t = l.Base = {
      extend: function (a) {
        s.prototype = this;
        var c = new s;
        a && c.mixIn(a);
        c.hasOwnProperty("init") || (c.init = function () {
          c.$super.init.apply(this, arguments)
        });
        c.init.prototype = c;
        c.$super = this;
        return c
      },
      create: function () {
        var a = this.extend();
        a.init.apply(a, arguments);
        return a
      },
      init: function () {},
      mixIn: function (a) {
        for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);
        a.hasOwnProperty("toString") && (this.toString = a.toString)
      },
      clone: function () {
        return this.init.prototype.extend(this)
      }
    },
    r = l.WordArray = t.extend({
      init: function (a, c) {
        a = this.words = a || [];
        this.sigBytes = c != p ? c : 4 * a.length
      },
      toString: function (a) {
        return (a || v).stringify(this)
      },
      concat: function (a) {
        var c = this.words,
          e = a.words,
          j = this.sigBytes;
        a = a.sigBytes;
        this.clamp();
        if (j % 4)
          for (var k = 0; k < a; k++) c[j + k >>> 2] |= (e[k >>> 2] >>> 24 - 8 * (k % 4) & 255) << 24 - 8 * ((j + k) % 4);
        else if (65535 < e.length)
          for (k = 0; k < a; k += 4) c[j + k >>> 2] = e[k >>> 2];
        else c.push.apply(c, e);
        this.sigBytes += a;
        return this
      },
      clamp: function () {
        var a = this.words,
          c = this.sigBytes;
        a[c >>> 2] &= 4294967295 <<
          32 - 8 * (c % 4);
        a.length = u.ceil(c / 4)
      },
      clone: function () {
        var a = t.clone.call(this);
        a.words = this.words.slice(0);
        return a
      },
      random: function (a) {
        for (var c = [], e = 0; e < a; e += 4) c.push(4294967296 * u.random() | 0);
        return new r.init(c, a)
      }
    }),
    w = d.enc = {},
    v = w.Hex = {
      stringify: function (a) {
        var c = a.words;
        a = a.sigBytes;
        for (var e = [], j = 0; j < a; j++) {
          var k = c[j >>> 2] >>> 24 - 8 * (j % 4) & 255;
          e.push((k >>> 4).toString(16));
          e.push((k & 15).toString(16))
        }
        return e.join("")
      },
      parse: function (a) {
        for (var c = a.length, e = [], j = 0; j < c; j += 2) e[j >>> 3] |= parseInt(a.substr(j,
          2), 16) << 24 - 4 * (j % 8);
        return new r.init(e, c / 2)
      }
    },
    b = w.Latin1 = {
      stringify: function (a) {
        var c = a.words;
        a = a.sigBytes;
        for (var e = [], j = 0; j < a; j++) e.push(String.fromCharCode(c[j >>> 2] >>> 24 - 8 * (j % 4) & 255));
        return e.join("")
      },
      parse: function (a) {
        for (var c = a.length, e = [], j = 0; j < c; j++) e[j >>> 2] |= (a.charCodeAt(j) & 255) << 24 - 8 * (j % 4);
        return new r.init(e, c)
      }
    },
    x = w.Utf8 = {
      stringify: function (a) {
        try {
          return decodeURIComponent(escape(b.stringify(a)))
        } catch (c) {
          throw Error("Malformed UTF-8 data");
        }
      },
      parse: function (a) {
        return b.parse(unescape(encodeURIComponent(a)))
      }
    },
    q = l.BufferedBlockAlgorithm = t.extend({
      reset: function () {
        this._data = new r.init;
        this._nDataBytes = 0
      },
      _append: function (a) {
        "string" == typeof a && (a = x.parse(a));
        this._data.concat(a);
        this._nDataBytes += a.sigBytes
      },
      _process: function (a) {
        var c = this._data,
          e = c.words,
          j = c.sigBytes,
          k = this.blockSize,
          b = j / (4 * k),
          b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0);
        a = b * k;
        j = u.min(4 * a, j);
        if (a) {
          for (var q = 0; q < a; q += k) this._doProcessBlock(e, q);
          q = e.splice(0, a);
          c.sigBytes -= j
        }
        return new r.init(q, j)
      },
      clone: function () {
        var a = t.clone.call(this);
        a._data = this._data.clone();
        return a
      },
      _minBufferSize: 0
    });
  l.Hasher = q.extend({
    cfg: t.extend(),
    init: function (a) {
      this.cfg = this.cfg.extend(a);
      this.reset()
    },
    reset: function () {
      q.reset.call(this);
      this._doReset()
    },
    update: function (a) {
      this._append(a);
      this._process();
      return this
    },
    finalize: function (a) {
      a && this._append(a);
      return this._doFinalize()
    },
    blockSize: 16,
    _createHelper: function (a) {
      return function (b, e) {
        return (new a.init(e)).finalize(b)
      }
    },
    _createHmacHelper: function (a) {
      return function (b, e) {
        return (new n.HMAC.init(a,
          e)).finalize(b)
      }
    }
  });
  var n = d.algo = {};
  return d
}(Math);
(function () {
  var u = CryptoJS,
    p = u.lib.WordArray;
  u.enc.Base64 = {
    stringify: function (d) {
      var l = d.words,
        p = d.sigBytes,
        t = this._map;
      d.clamp();
      d = [];
      for (var r = 0; r < p; r += 3)
        for (var w = (l[r >>> 2] >>> 24 - 8 * (r % 4) & 255) << 16 | (l[r + 1 >>> 2] >>> 24 - 8 * ((r + 1) % 4) & 255) << 8 | l[r + 2 >>> 2] >>> 24 - 8 * ((r + 2) % 4) & 255, v = 0; 4 > v && r + 0.75 * v < p; v++) d.push(t.charAt(w >>> 6 * (3 - v) & 63));
      if (l = t.charAt(64))
        for (; d.length % 4;) d.push(l);
      return d.join("")
    },
    parse: function (d) {
      var l = d.length,
        s = this._map,
        t = s.charAt(64);
      t && (t = d.indexOf(t), -1 != t && (l = t));
      for (var t = [], r = 0, w = 0; w <
        l; w++)
        if (w % 4) {
          var v = s.indexOf(d.charAt(w - 1)) << 2 * (w % 4),
            b = s.indexOf(d.charAt(w)) >>> 6 - 2 * (w % 4);
          t[r >>> 2] |= (v | b) << 24 - 8 * (r % 4);
          r++
        } return p.create(t, r)
    },
    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
  }
})();
(function (u) {
  function p(b, n, a, c, e, j, k) {
    b = b + (n & a | ~n & c) + e + k;
    return (b << j | b >>> 32 - j) + n
  }

  function d(b, n, a, c, e, j, k) {
    b = b + (n & c | a & ~c) + e + k;
    return (b << j | b >>> 32 - j) + n
  }

  function l(b, n, a, c, e, j, k) {
    b = b + (n ^ a ^ c) + e + k;
    return (b << j | b >>> 32 - j) + n
  }

  function s(b, n, a, c, e, j, k) {
    b = b + (a ^ (n | ~c)) + e + k;
    return (b << j | b >>> 32 - j) + n
  }
  for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 > x; x++) b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0;
  r = r.MD5 = v.extend({
    _doReset: function () {
      this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878])
    },
    _doProcessBlock: function (q, n) {
      for (var a = 0; 16 > a; a++) {
        var c = n + a,
          e = q[c];
        q[c] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360
      }
      var a = this._hash.words,
        c = q[n + 0],
        e = q[n + 1],
        j = q[n + 2],
        k = q[n + 3],
        z = q[n + 4],
        r = q[n + 5],
        t = q[n + 6],
        w = q[n + 7],
        v = q[n + 8],
        A = q[n + 9],
        B = q[n + 10],
        C = q[n + 11],
        u = q[n + 12],
        D = q[n + 13],
        E = q[n + 14],
        x = q[n + 15],
        f = a[0],
        m = a[1],
        g = a[2],
        h = a[3],
        f = p(f, m, g, h, c, 7, b[0]),
        h = p(h, f, m, g, e, 12, b[1]),
        g = p(g, h, f, m, j, 17, b[2]),
        m = p(m, g, h, f, k, 22, b[3]),
        f = p(f, m, g, h, z, 7, b[4]),
        h = p(h, f, m, g, r, 12, b[5]),
        g = p(g, h, f, m, t, 17, b[6]),
        m = p(m, g, h, f, w, 22, b[7]),
        f = p(f, m, g, h, v, 7, b[8]),
        h = p(h, f, m, g, A, 12, b[9]),
        g = p(g, h, f, m, B, 17, b[10]),
        m = p(m, g, h, f, C, 22, b[11]),
        f = p(f, m, g, h, u, 7, b[12]),
        h = p(h, f, m, g, D, 12, b[13]),
        g = p(g, h, f, m, E, 17, b[14]),
        m = p(m, g, h, f, x, 22, b[15]),
        f = d(f, m, g, h, e, 5, b[16]),
        h = d(h, f, m, g, t, 9, b[17]),
        g = d(g, h, f, m, C, 14, b[18]),
        m = d(m, g, h, f, c, 20, b[19]),
        f = d(f, m, g, h, r, 5, b[20]),
        h = d(h, f, m, g, B, 9, b[21]),
        g = d(g, h, f, m, x, 14, b[22]),
        m = d(m, g, h, f, z, 20, b[23]),
        f = d(f, m, g, h, A, 5, b[24]),
        h = d(h, f, m, g, E, 9, b[25]),
        g = d(g, h, f, m, k, 14, b[26]),
        m = d(m, g, h, f, v, 20, b[27]),
        f = d(f, m, g, h, D, 5, b[28]),
        h = d(h, f,
          m, g, j, 9, b[29]),
        g = d(g, h, f, m, w, 14, b[30]),
        m = d(m, g, h, f, u, 20, b[31]),
        f = l(f, m, g, h, r, 4, b[32]),
        h = l(h, f, m, g, v, 11, b[33]),
        g = l(g, h, f, m, C, 16, b[34]),
        m = l(m, g, h, f, E, 23, b[35]),
        f = l(f, m, g, h, e, 4, b[36]),
        h = l(h, f, m, g, z, 11, b[37]),
        g = l(g, h, f, m, w, 16, b[38]),
        m = l(m, g, h, f, B, 23, b[39]),
        f = l(f, m, g, h, D, 4, b[40]),
        h = l(h, f, m, g, c, 11, b[41]),
        g = l(g, h, f, m, k, 16, b[42]),
        m = l(m, g, h, f, t, 23, b[43]),
        f = l(f, m, g, h, A, 4, b[44]),
        h = l(h, f, m, g, u, 11, b[45]),
        g = l(g, h, f, m, x, 16, b[46]),
        m = l(m, g, h, f, j, 23, b[47]),
        f = s(f, m, g, h, c, 6, b[48]),
        h = s(h, f, m, g, w, 10, b[49]),
        g = s(g, h, f, m,
          E, 15, b[50]),
        m = s(m, g, h, f, r, 21, b[51]),
        f = s(f, m, g, h, u, 6, b[52]),
        h = s(h, f, m, g, k, 10, b[53]),
        g = s(g, h, f, m, B, 15, b[54]),
        m = s(m, g, h, f, e, 21, b[55]),
        f = s(f, m, g, h, v, 6, b[56]),
        h = s(h, f, m, g, x, 10, b[57]),
        g = s(g, h, f, m, t, 15, b[58]),
        m = s(m, g, h, f, D, 21, b[59]),
        f = s(f, m, g, h, z, 6, b[60]),
        h = s(h, f, m, g, C, 10, b[61]),
        g = s(g, h, f, m, j, 15, b[62]),
        m = s(m, g, h, f, A, 21, b[63]);
      a[0] = a[0] + f | 0;
      a[1] = a[1] + m | 0;
      a[2] = a[2] + g | 0;
      a[3] = a[3] + h | 0
    },
    _doFinalize: function () {
      var b = this._data,
        n = b.words,
        a = 8 * this._nDataBytes,
        c = 8 * b.sigBytes;
      n[c >>> 5] |= 128 << 24 - c % 32;
      var e = u.floor(a /
        4294967296);
      n[(c + 64 >>> 9 << 4) + 15] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;
      n[(c + 64 >>> 9 << 4) + 14] = (a << 8 | a >>> 24) & 16711935 | (a << 24 | a >>> 8) & 4278255360;
      b.sigBytes = 4 * (n.length + 1);
      this._process();
      b = this._hash;
      n = b.words;
      for (a = 0; 4 > a; a++) c = n[a], n[a] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;
      return b
    },
    clone: function () {
      var b = v.clone.call(this);
      b._hash = this._hash.clone();
      return b
    }
  });
  t.MD5 = v._createHelper(r);
  t.HmacMD5 = v._createHmacHelper(r)
})(Math);
(function () {
  var u = CryptoJS,
    p = u.lib,
    d = p.Base,
    l = p.WordArray,
    p = u.algo,
    s = p.EvpKDF = d.extend({
      cfg: d.extend({
        keySize: 4,
        hasher: p.MD5,
        iterations: 1
      }),
      init: function (d) {
        this.cfg = this.cfg.extend(d)
      },
      compute: function (d, r) {
        for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length < q;) {
          n && s.update(n);
          var n = s.update(d).finalize(r);
          s.reset();
          for (var a = 1; a < p; a++) n = s.finalize(n), s.reset();
          b.concat(n)
        }
        b.sigBytes = 4 * q;
        return b
      }
    });
  u.EvpKDF = function (d, l, p) {
    return s.create(p).compute(d,
      l)
  }
})();
CryptoJS.lib.Cipher || function (u) {
  var p = CryptoJS,
    d = p.lib,
    l = d.Base,
    s = d.WordArray,
    t = d.BufferedBlockAlgorithm,
    r = p.enc.Base64,
    w = p.algo.EvpKDF,
    v = d.Cipher = t.extend({
      cfg: l.extend(),
      createEncryptor: function (e, a) {
        return this.create(this._ENC_XFORM_MODE, e, a)
      },
      createDecryptor: function (e, a) {
        return this.create(this._DEC_XFORM_MODE, e, a)
      },
      init: function (e, a, b) {
        this.cfg = this.cfg.extend(b);
        this._xformMode = e;
        this._key = a;
        this.reset()
      },
      reset: function () {
        t.reset.call(this);
        this._doReset()
      },
      process: function (e) {
        this._append(e);
        return this._process()
      },
      finalize: function (e) {
        e && this._append(e);
        return this._doFinalize()
      },
      keySize: 4,
      ivSize: 4,
      _ENC_XFORM_MODE: 1,
      _DEC_XFORM_MODE: 2,
      _createHelper: function (e) {
        return {
          encrypt: function (b, k, d) {
            return ("string" == typeof k ? c : a).encrypt(e, b, k, d)
          },
          decrypt: function (b, k, d) {
            return ("string" == typeof k ? c : a).decrypt(e, b, k, d)
          }
        }
      }
    });
  d.StreamCipher = v.extend({
    _doFinalize: function () {
      return this._process(!0)
    },
    blockSize: 1
  });
  var b = p.mode = {},
    x = function (e, a, b) {
      var c = this._iv;
      c ? this._iv = u : c = this._prevBlock;
      for (var d = 0; d < b; d++) e[a + d] ^=
        c[d]
    },
    q = (d.BlockCipherMode = l.extend({
      createEncryptor: function (e, a) {
        return this.Encryptor.create(e, a)
      },
      createDecryptor: function (e, a) {
        return this.Decryptor.create(e, a)
      },
      init: function (e, a) {
        this._cipher = e;
        this._iv = a
      }
    })).extend();
  q.Encryptor = q.extend({
    processBlock: function (e, a) {
      var b = this._cipher,
        c = b.blockSize;
      x.call(this, e, a, c);
      b.encryptBlock(e, a);
      this._prevBlock = e.slice(a, a + c)
    }
  });
  q.Decryptor = q.extend({
    processBlock: function (e, a) {
      var b = this._cipher,
        c = b.blockSize,
        d = e.slice(a, a + c);
      b.decryptBlock(e, a);
      x.call(this,
        e, a, c);
      this._prevBlock = d
    }
  });
  b = b.CBC = q;
  q = (p.pad = {}).Pkcs7 = {
    pad: function (a, b) {
      for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, l = [], n = 0; n < c; n += 4) l.push(d);
      c = s.create(l, c);
      a.concat(c)
    },
    unpad: function (a) {
      a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255
    }
  };
  d.BlockCipher = v.extend({
    cfg: v.cfg.extend({
      mode: b,
      padding: q
    }),
    reset: function () {
      v.reset.call(this);
      var a = this.cfg,
        b = a.iv,
        a = a.mode;
      if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;
      else c = a.createDecryptor, this._minBufferSize = 1;
      this._mode = c.call(a,
        this, b && b.words)
    },
    _doProcessBlock: function (a, b) {
      this._mode.processBlock(a, b)
    },
    _doFinalize: function () {
      var a = this.cfg.padding;
      if (this._xformMode == this._ENC_XFORM_MODE) {
        a.pad(this._data, this.blockSize);
        var b = this._process(!0)
      } else b = this._process(!0), a.unpad(b);
      return b
    },
    blockSize: 4
  });
  var n = d.CipherParams = l.extend({
      init: function (a) {
        this.mixIn(a)
      },
      toString: function (a) {
        return (a || this.formatter).stringify(this)
      }
    }),
    b = (p.format = {}).OpenSSL = {
      stringify: function (a) {
        var b = a.ciphertext;
        a = a.salt;
        return (a ? s.create([1398893684,
          1701076831
        ]).concat(a).concat(b) : b).toString(r)
      },
      parse: function (a) {
        a = r.parse(a);
        var b = a.words;
        if (1398893684 == b[0] && 1701076831 == b[1]) {
          var c = s.create(b.slice(2, 4));
          b.splice(0, 4);
          a.sigBytes -= 16
        }
        return n.create({
          ciphertext: a,
          salt: c
        })
      }
    },
    a = d.SerializableCipher = l.extend({
      cfg: l.extend({
        format: b
      }),
      encrypt: function (a, b, c, d) {
        d = this.cfg.extend(d);
        var l = a.createEncryptor(c, d);
        b = l.finalize(b);
        l = l.cfg;
        return n.create({
          ciphertext: b,
          key: c,
          iv: l.iv,
          algorithm: a,
          mode: l.mode,
          padding: l.padding,
          blockSize: a.blockSize,
          formatter: d.format
        })
      },
      decrypt: function (a, b, c, d) {
        d = this.cfg.extend(d);
        b = this._parse(b, d.format);
        return a.createDecryptor(c, d).finalize(b.ciphertext)
      },
      _parse: function (a, b) {
        return "string" == typeof a ? b.parse(a, this) : a
      }
    }),
    p = (p.kdf = {}).OpenSSL = {
      execute: function (a, b, c, d) {
        d || (d = s.random(8));
        a = w.create({
          keySize: b + c
        }).compute(a, d);
        c = s.create(a.words.slice(b), 4 * c);
        a.sigBytes = 4 * b;
        return n.create({
          key: a,
          iv: c,
          salt: d
        })
      }
    },
    c = d.PasswordBasedCipher = a.extend({
      cfg: a.cfg.extend({
        kdf: p
      }),
      encrypt: function (b, c, d, l) {
        l = this.cfg.extend(l);
        d = l.kdf.execute(d,
          b.keySize, b.ivSize);
        l.iv = d.iv;
        b = a.encrypt.call(this, b, c, d.key, l);
        b.mixIn(d);
        return b
      },
      decrypt: function (b, c, d, l) {
        l = this.cfg.extend(l);
        c = this._parse(c, l.format);
        d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt);
        l.iv = d.iv;
        return a.decrypt.call(this, b, c, d.key, l)
      }
    })
}();
(function () {
  for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 > c; c++) a[c] = 128 > c ? c << 1 : c << 1 ^ 283;
  for (var e = 0, j = 0, c = 0; 256 > c; c++) {
    var k = j ^ j << 1 ^ j << 2 ^ j << 3 ^ j << 4,
      k = k >>> 8 ^ k & 255 ^ 99;
    l[e] = k;
    s[k] = e;
    var z = a[e],
      F = a[z],
      G = a[F],
      y = 257 * a[k] ^ 16843008 * k;
    t[e] = y << 24 | y >>> 8;
    r[e] = y << 16 | y >>> 16;
    w[e] = y << 8 | y >>> 24;
    v[e] = y;
    y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e;
    b[k] = y << 24 | y >>> 8;
    x[k] = y << 16 | y >>> 16;
    q[k] = y << 8 | y >>> 24;
    n[k] = y;
    e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1
  }
  var H = [0, 1, 2, 4, 8,
      16, 32, 64, 128, 27, 54
    ],
    d = d.AES = p.extend({
      _doReset: function () {
        for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j < a; j++)
          if (j < d) e[j] = c[j];
          else {
            var k = e[j - 1];
            j % d ? 6 < d && 4 == j % d && (k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255]) : (k = k << 8 | k >>> 24, k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255], k ^= H[j / d | 0] << 24);
            e[j] = e[j - d] ^ k
          } c = this._invKeySchedule = [];
        for (d = 0; d < a; d++) j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 > d || 4 >= j ? k : b[l[k >>> 24]] ^ x[l[k >>> 16 & 255]] ^ q[l[k >>>
          8 & 255]] ^ n[l[k & 255]]
      },
      encryptBlock: function (a, b) {
        this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l)
      },
      decryptBlock: function (a, c) {
        var d = a[c + 1];
        a[c + 1] = a[c + 3];
        a[c + 3] = d;
        this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s);
        d = a[c + 1];
        a[c + 1] = a[c + 3];
        a[c + 3] = d
      },
      _doCryptBlock: function (a, b, c, d, e, j, l, f) {
        for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r < m; r++) var q = d[g >>> 24] ^ e[h >>> 16 & 255] ^ j[k >>> 8 & 255] ^ l[n & 255] ^ c[p++],
          s = d[h >>> 24] ^ e[k >>> 16 & 255] ^ j[n >>> 8 & 255] ^ l[g & 255] ^ c[p++],
          t =
          d[k >>> 24] ^ e[n >>> 16 & 255] ^ j[g >>> 8 & 255] ^ l[h & 255] ^ c[p++],
          n = d[n >>> 24] ^ e[g >>> 16 & 255] ^ j[h >>> 8 & 255] ^ l[k & 255] ^ c[p++],
          g = q,
          h = s,
          k = t;
        q = (f[g >>> 24] << 24 | f[h >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[n & 255]) ^ c[p++];
        s = (f[h >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[n >>> 8 & 255] << 8 | f[g & 255]) ^ c[p++];
        t = (f[k >>> 24] << 24 | f[n >>> 16 & 255] << 16 | f[g >>> 8 & 255] << 8 | f[h & 255]) ^ c[p++];
        n = (f[n >>> 24] << 24 | f[g >>> 16 & 255] << 16 | f[h >>> 8 & 255] << 8 | f[k & 255]) ^ c[p++];
        a[b] = q;
        a[b + 1] = s;
        a[b + 2] = t;
        a[b + 3] = n
      },
      keySize: 8
    });
  u.AES = p._createHelper(d)
})();
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  var h = CryptoJS,
    j = h.lib.WordArray;
  h.enc.Base64 = {
    stringify: function (b) {
      var e = b.words,
        f = b.sigBytes,
        c = this._map;
      b.clamp();
      b = [];
      for (var a = 0; a < f; a += 3)
        for (var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++) b.push(c.charAt(d >>> 6 * (3 - g) & 63));
      if (e = c.charAt(64))
        for (; b.length % 4;) b.push(e);
      return b.join("")
    },
    parse: function (b) {
      var e = b.length,
        f = this._map,
        c = f.charAt(64);
      c && (c = b.indexOf(c), -1 != c && (e = c));
      for (var c = [], a = 0, d = 0; d <
        e; d++)
        if (d % 4) {
          var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4),
            h = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4);
          c[a >>> 2] |= (g | h) << 24 - 8 * (a % 4);
          a++
        } return j.create(c, a)
    },
    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
  }
})();
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (E) {
  function h(a, f, g, j, p, h, k) {
    a = a + (f & g | ~f & j) + p + k;
    return (a << h | a >>> 32 - h) + f
  }

  function k(a, f, g, j, p, h, k) {
    a = a + (f & j | g & ~j) + p + k;
    return (a << h | a >>> 32 - h) + f
  }

  function l(a, f, g, j, h, k, l) {
    a = a + (f ^ g ^ j) + h + l;
    return (a << k | a >>> 32 - k) + f
  }

  function n(a, f, g, j, h, k, l) {
    a = a + (g ^ (f | ~j)) + h + l;
    return (a << k | a >>> 32 - k) + f
  }
  for (var r = CryptoJS, q = r.lib, F = q.WordArray, s = q.Hasher, q = r.algo, a = [], t = 0; 64 > t; t++) a[t] = 4294967296 * E.abs(E.sin(t + 1)) | 0;
  q = q.MD5 = s.extend({
    _doReset: function () {
      this._hash = new F.init([1732584193, 4023233417, 2562383102, 271733878])
    },
    _doProcessBlock: function (m, f) {
      for (var g = 0; 16 > g; g++) {
        var j = f + g,
          p = m[j];
        m[j] = (p << 8 | p >>> 24) & 16711935 | (p << 24 | p >>> 8) & 4278255360
      }
      var g = this._hash.words,
        j = m[f + 0],
        p = m[f + 1],
        q = m[f + 2],
        r = m[f + 3],
        s = m[f + 4],
        t = m[f + 5],
        u = m[f + 6],
        v = m[f + 7],
        w = m[f + 8],
        x = m[f + 9],
        y = m[f + 10],
        z = m[f + 11],
        A = m[f + 12],
        B = m[f + 13],
        C = m[f + 14],
        D = m[f + 15],
        b = g[0],
        c = g[1],
        d = g[2],
        e = g[3],
        b = h(b, c, d, e, j, 7, a[0]),
        e = h(e, b, c, d, p, 12, a[1]),
        d = h(d, e, b, c, q, 17, a[2]),
        c = h(c, d, e, b, r, 22, a[3]),
        b = h(b, c, d, e, s, 7, a[4]),
        e = h(e, b, c, d, t, 12, a[5]),
        d = h(d, e, b, c, u, 17, a[6]),
        c = h(c, d, e, b, v, 22, a[7]),
        b = h(b, c, d, e, w, 7, a[8]),
        e = h(e, b, c, d, x, 12, a[9]),
        d = h(d, e, b, c, y, 17, a[10]),
        c = h(c, d, e, b, z, 22, a[11]),
        b = h(b, c, d, e, A, 7, a[12]),
        e = h(e, b, c, d, B, 12, a[13]),
        d = h(d, e, b, c, C, 17, a[14]),
        c = h(c, d, e, b, D, 22, a[15]),
        b = k(b, c, d, e, p, 5, a[16]),
        e = k(e, b, c, d, u, 9, a[17]),
        d = k(d, e, b, c, z, 14, a[18]),
        c = k(c, d, e, b, j, 20, a[19]),
        b = k(b, c, d, e, t, 5, a[20]),
        e = k(e, b, c, d, y, 9, a[21]),
        d = k(d, e, b, c, D, 14, a[22]),
        c = k(c, d, e, b, s, 20, a[23]),
        b = k(b, c, d, e, x, 5, a[24]),
        e = k(e, b, c, d, C, 9, a[25]),
        d = k(d, e, b, c, r, 14, a[26]),
        c = k(c, d, e, b, w, 20, a[27]),
        b = k(b, c, d, e, B, 5, a[28]),
        e = k(e, b,
          c, d, q, 9, a[29]),
        d = k(d, e, b, c, v, 14, a[30]),
        c = k(c, d, e, b, A, 20, a[31]),
        b = l(b, c, d, e, t, 4, a[32]),
        e = l(e, b, c, d, w, 11, a[33]),
        d = l(d, e, b, c, z, 16, a[34]),
        c = l(c, d, e, b, C, 23, a[35]),
        b = l(b, c, d, e, p, 4, a[36]),
        e = l(e, b, c, d, s, 11, a[37]),
        d = l(d, e, b, c, v, 16, a[38]),
        c = l(c, d, e, b, y, 23, a[39]),
        b = l(b, c, d, e, B, 4, a[40]),
        e = l(e, b, c, d, j, 11, a[41]),
        d = l(d, e, b, c, r, 16, a[42]),
        c = l(c, d, e, b, u, 23, a[43]),
        b = l(b, c, d, e, x, 4, a[44]),
        e = l(e, b, c, d, A, 11, a[45]),
        d = l(d, e, b, c, D, 16, a[46]),
        c = l(c, d, e, b, q, 23, a[47]),
        b = n(b, c, d, e, j, 6, a[48]),
        e = n(e, b, c, d, v, 10, a[49]),
        d = n(d, e, b, c,
          C, 15, a[50]),
        c = n(c, d, e, b, t, 21, a[51]),
        b = n(b, c, d, e, A, 6, a[52]),
        e = n(e, b, c, d, r, 10, a[53]),
        d = n(d, e, b, c, y, 15, a[54]),
        c = n(c, d, e, b, p, 21, a[55]),
        b = n(b, c, d, e, w, 6, a[56]),
        e = n(e, b, c, d, D, 10, a[57]),
        d = n(d, e, b, c, u, 15, a[58]),
        c = n(c, d, e, b, B, 21, a[59]),
        b = n(b, c, d, e, s, 6, a[60]),
        e = n(e, b, c, d, z, 10, a[61]),
        d = n(d, e, b, c, q, 15, a[62]),
        c = n(c, d, e, b, x, 21, a[63]);
      g[0] = g[0] + b | 0;
      g[1] = g[1] + c | 0;
      g[2] = g[2] + d | 0;
      g[3] = g[3] + e | 0
    },
    _doFinalize: function () {
      var a = this._data,
        f = a.words,
        g = 8 * this._nDataBytes,
        j = 8 * a.sigBytes;
      f[j >>> 5] |= 128 << 24 - j % 32;
      var h = E.floor(g /
        4294967296);
      f[(j + 64 >>> 9 << 4) + 15] = (h << 8 | h >>> 24) & 16711935 | (h << 24 | h >>> 8) & 4278255360;
      f[(j + 64 >>> 9 << 4) + 14] = (g << 8 | g >>> 24) & 16711935 | (g << 24 | g >>> 8) & 4278255360;
      a.sigBytes = 4 * (f.length + 1);
      this._process();
      a = this._hash;
      f = a.words;
      for (g = 0; 4 > g; g++) j = f[g], f[g] = (j << 8 | j >>> 24) & 16711935 | (j << 24 | j >>> 8) & 4278255360;
      return a
    },
    clone: function () {
      var a = s.clone.call(this);
      a._hash = this._hash.clone();
      return a
    }
  });
  r.MD5 = s._createHelper(q);
  r.HmacMD5 = s._createHmacHelper(q)
})(Math);
! function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.forge = t() : e.forge = t()
}(this, function () {
  return function (e) {
    function t(a) {
      if (r[a]) return r[a].exports;
      var n = r[a] = {
        i: a,
        l: !1,
        exports: {}
      };
      return e[a].call(n.exports, n, n.exports, t), n.l = !0, n.exports
    }
    var r = {};
    return t.m = e, t.c = r, t.i = function (e) {
      return e
    }, t.d = function (e, r, a) {
      t.o(e, r) || Object.defineProperty(e, r, {
        configurable: !1,
        enumerable: !0,
        get: a
      })
    }, t.n = function (e) {
      var r = e && e.__esModule ? function () {
        return e.default
      } : function () {
        return e
      };
      return t.d(r, "a", r), r
    }, t.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t)
    }, t.p = "", t(t.s = 42)
  }([function (e, t) {
    e.exports = {
      options: {
        usePureJavaScript: !1
      }
    }
  }, function (e, t, r) {
    function a(e) {
      if (8 !== e && 16 !== e && 24 !== e && 32 !== e) throw new Error("Only 8, 16, 24, or 32 bits supported: " + e)
    }

    function n(e) {
      if (this.data = "", this.read = 0, "string" == typeof e) this.data = e;
      else if (o.isArrayBuffer(e) || o.isArrayBufferView(e)) {
        var t = new Uint8Array(e);
        try {
          this.data = String.fromCharCode.apply(null, t)
        } catch (e) {
          for (var r = 0; r < t.length; ++r) this.putByte(t[r])
        }
      } else(e instanceof n || "object" == typeof e && "string" == typeof e.data && "number" == typeof e.read) && (this.data = e.data, this.read = e.read);
      this._constructedStringLength = 0
    }

    function i(e, t) {
      t = t || {}, this.read = t.readOffset || 0, this.growSize = t.growSize || 1024;
      var r = o.isArrayBuffer(e),
        a = o.isArrayBufferView(e);
      return r || a ? (r ? this.data = new DataView(e) : this.data = new DataView(e.buffer, e.byteOffset, e.byteLength), void(this.write = "writeOffset" in t ? t.writeOffset : this.data.byteLength)) : (this.data = new DataView(new ArrayBuffer(0)), this.write = 0, null !== e && void 0 !== e && this.putBytes(e), void("writeOffset" in t && (this.write = t.writeOffset)))
    }
    var s = r(0),
      o = e.exports = s.util = s.util || {};
    ! function () {
      function e(e) {
        if (e.source === window && e.data === t) {
          e.stopPropagation();
          var a = r.slice();
          r.length = 0, a.forEach(function (e) {
            e()
          })
        }
      }
      if ("undefined" != typeof process && process.nextTick) return o.nextTick = process.nextTick, void("function" == typeof setImmediate ? o.setImmediate = setImmediate : o.setImmediate = o.nextTick);
      if ("function" == typeof setImmediate) return o.setImmediate = function () {
        return setImmediate.apply(void 0, arguments)
      }, void(o.nextTick = function (e) {
        return setImmediate(e)
      });
      if (o.setImmediate = function (e) {
          setTimeout(e, 0)
        }, "undefined" != typeof window && "function" == typeof window.postMessage) {
        var t = "forge.setImmediate",
          r = [];
        o.setImmediate = function (e) {
          r.push(e), 1 === r.length && window.postMessage(t, "*")
        }, window.addEventListener("message", e, !0)
      }
      if ("undefined" != typeof MutationObserver) {
        var a = Date.now(),
          n = !0,
          i = document.createElement("div"),
          r = [];
        new MutationObserver(function () {
          var e = r.slice();
          r.length = 0, e.forEach(function (e) {
            e()
          })
        }).observe(i, {
          attributes: !0
        });
        var s = o.setImmediate;
        o.setImmediate = function (e) {
          Date.now() - a > 15 ? (a = Date.now(), s(e)) : (r.push(e), 1 === r.length && i.setAttribute("a", n = !n))
        }
      }
      o.nextTick = o.setImmediate
    }(), o.isNodejs = "undefined" != typeof process && process.versions && process.versions.node, o.isArray = Array.isArray || function (e) {
      return "[object Array]" === Object.prototype.toString.call(e)
    }, o.isArrayBuffer = function (e) {
      return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer
    }, o.isArrayBufferView = function (e) {
      return e && o.isArrayBuffer(e.buffer) && void 0 !== e.byteLength
    }, o.ByteBuffer = n, o.ByteStringBuffer = n;
    var c = 4096;
    o.ByteStringBuffer.prototype._optimizeConstructedString = function (e) {
      this._constructedStringLength += e, this._constructedStringLength > c && (this.data.substr(0, 1), this._constructedStringLength = 0)
    }, o.ByteStringBuffer.prototype.length = function () {
      return this.data.length - this.read
    }, o.ByteStringBuffer.prototype.isEmpty = function () {
      return this.length() <= 0
    }, o.ByteStringBuffer.prototype.putByte = function (e) {
      return this.putBytes(String.fromCharCode(e))
    }, o.ByteStringBuffer.prototype.fillWithByte = function (e, t) {
      e = String.fromCharCode(e);
      for (var r = this.data; t > 0;) 1 & t && (r += e), t >>>= 1, t > 0 && (e += e);
      return this.data = r, this._optimizeConstructedString(t), this
    }, o.ByteStringBuffer.prototype.putBytes = function (e) {
      return this.data += e, this._optimizeConstructedString(e.length), this
    }, o.ByteStringBuffer.prototype.putString = function (e) {
      return this.putBytes(o.encodeUtf8(e))
    }, o.ByteStringBuffer.prototype.putInt16 = function (e) {
      return this.putBytes(String.fromCharCode(e >> 8 & 255) + String.fromCharCode(255 & e))
    }, o.ByteStringBuffer.prototype.putInt24 = function (e) {
      return this.putBytes(String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(255 & e))
    }, o.ByteStringBuffer.prototype.putInt32 = function (e) {
      return this.putBytes(String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(255 & e))
    }, o.ByteStringBuffer.prototype.putInt16Le = function (e) {
      return this.putBytes(String.fromCharCode(255 & e) + String.fromCharCode(e >> 8 & 255))
    }, o.ByteStringBuffer.prototype.putInt24Le = function (e) {
      return this.putBytes(String.fromCharCode(255 & e) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255))
    }, o.ByteStringBuffer.prototype.putInt32Le = function (e) {
      return this.putBytes(String.fromCharCode(255 & e) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 24 & 255))
    }, o.ByteStringBuffer.prototype.putInt = function (e, t) {
      a(t);
      var r = "";
      do t -= 8, r += String.fromCharCode(e >> t & 255); while (t > 0);
      return this.putBytes(r)
    }, o.ByteStringBuffer.prototype.putSignedInt = function (e, t) {
      return e < 0 && (e += 2 << t - 1), this.putInt(e, t)
    }, o.ByteStringBuffer.prototype.putBuffer = function (e) {
      return this.putBytes(e.getBytes())
    }, o.ByteStringBuffer.prototype.getByte = function () {
      return this.data.charCodeAt(this.read++)
    }, o.ByteStringBuffer.prototype.getInt16 = function () {
      var e = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      return this.read += 2, e
    }, o.ByteStringBuffer.prototype.getInt24 = function () {
      var e = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      return this.read += 3, e
    }, o.ByteStringBuffer.prototype.getInt32 = function () {
      var e = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      return this.read += 4, e
    }, o.ByteStringBuffer.prototype.getInt16Le = function () {
      var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      return this.read += 2, e
    }, o.ByteStringBuffer.prototype.getInt24Le = function () {
      var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      return this.read += 3, e
    }, o.ByteStringBuffer.prototype.getInt32Le = function () {
      var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      return this.read += 4, e
    }, o.ByteStringBuffer.prototype.getInt = function (e) {
      a(e);
      var t = 0;
      do t = (t << 8) + this.data.charCodeAt(this.read++), e -= 8; while (e > 0);
      return t
    }, o.ByteStringBuffer.prototype.getSignedInt = function (e) {
      var t = this.getInt(e),
        r = 2 << e - 2;
      return t >= r && (t -= r << 1), t
    }, o.ByteStringBuffer.prototype.getBytes = function (e) {
      var t;
      return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : 0 === e ? t = "" : (t = 0 === this.read ? this.data : this.data.slice(this.read), this.clear()), t
    }, o.ByteStringBuffer.prototype.bytes = function (e) {
      return "undefined" == typeof e ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e)
    }, o.ByteStringBuffer.prototype.at = function (e) {
      return this.data.charCodeAt(this.read + e)
    }, o.ByteStringBuffer.prototype.setAt = function (e, t) {
      return this.data = this.data.substr(0, this.read + e) + String.fromCharCode(t) + this.data.substr(this.read + e + 1), this
    }, o.ByteStringBuffer.prototype.last = function () {
      return this.data.charCodeAt(this.data.length - 1)
    }, o.ByteStringBuffer.prototype.copy = function () {
      var e = o.createBuffer(this.data);
      return e.read = this.read, e
    }, o.ByteStringBuffer.prototype.compact = function () {
      return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this
    }, o.ByteStringBuffer.prototype.clear = function () {
      return this.data = "", this.read = 0, this
    }, o.ByteStringBuffer.prototype.truncate = function (e) {
      var t = Math.max(0, this.length() - e);
      return this.data = this.data.substr(this.read, t), this.read = 0, this
    }, o.ByteStringBuffer.prototype.toHex = function () {
      for (var e = "", t = this.read; t < this.data.length; ++t) {
        var r = this.data.charCodeAt(t);
        r < 16 && (e += "0"), e += r.toString(16)
      }
      return e
    }, o.ByteStringBuffer.prototype.toString = function () {
      return o.decodeUtf8(this.bytes())
    }, o.DataBuffer = i, o.DataBuffer.prototype.length = function () {
      return this.write - this.read
    }, o.DataBuffer.prototype.isEmpty = function () {
      return this.length() <= 0
    }, o.DataBuffer.prototype.accommodate = function (e, t) {
      if (this.length() >= e) return this;
      t = Math.max(t || this.growSize, e);
      var r = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength),
        a = new Uint8Array(this.length() + t);
      return a.set(r), this.data = new DataView(a.buffer), this
    }, o.DataBuffer.prototype.putByte = function (e) {
      return this.accommodate(1), this.data.setUint8(this.write++, e), this
    }, o.DataBuffer.prototype.fillWithByte = function (e, t) {
      this.accommodate(t);
      for (var r = 0; r < t; ++r) this.data.setUint8(e);
      return this
    }, o.DataBuffer.prototype.putBytes = function (e, t) {
      if (o.isArrayBufferView(e)) {
        var r = new Uint8Array(e.buffer, e.byteOffset, e.byteLength),
          a = r.byteLength - r.byteOffset;
        this.accommodate(a);
        var n = new Uint8Array(this.data.buffer, this.write);
        return n.set(r), this.write += a, this
      }
      if (o.isArrayBuffer(e)) {
        var r = new Uint8Array(e);
        this.accommodate(r.byteLength);
        var n = new Uint8Array(this.data.buffer);
        return n.set(r, this.write), this.write += r.byteLength, this
      }
      if (e instanceof o.DataBuffer || "object" == typeof e && "number" == typeof e.read && "number" == typeof e.write && o.isArrayBufferView(e.data)) {
        var r = new Uint8Array(e.data.byteLength, e.read, e.length());
        this.accommodate(r.byteLength);
        var n = new Uint8Array(e.data.byteLength, this.write);
        return n.set(r), this.write += r.byteLength, this
      }
      if (e instanceof o.ByteStringBuffer && (e = e.data, t = "binary"), t = t || "binary", "string" == typeof e) {
        var i;
        if ("hex" === t) return this.accommodate(Math.ceil(e.length / 2)), i = new Uint8Array(this.data.buffer, this.write), this.write += o.binary.hex.decode(e, i, this.write), this;
        if ("base64" === t) return this.accommodate(3 * Math.ceil(e.length / 4)), i = new Uint8Array(this.data.buffer, this.write), this.write += o.binary.base64.decode(e, i, this.write), this;
        if ("utf8" === t && (e = o.encodeUtf8(e), t = "binary"), "binary" === t || "raw" === t) return this.accommodate(e.length), i = new Uint8Array(this.data.buffer, this.write), this.write += o.binary.raw.decode(i), this;
        if ("utf16" === t) return this.accommodate(2 * e.length), i = new Uint16Array(this.data.buffer, this.write), this.write += o.text.utf16.encode(i), this;
        throw new Error("Invalid encoding: " + t)
      }
      throw Error("Invalid parameter: " + e)
    }, o.DataBuffer.prototype.putBuffer = function (e) {
      return this.putBytes(e), e.clear(), this
    }, o.DataBuffer.prototype.putString = function (e) {
      return this.putBytes(e, "utf16")
    }, o.DataBuffer.prototype.putInt16 = function (e) {
      return this.accommodate(2), this.data.setInt16(this.write, e), this.write += 2, this
    }, o.DataBuffer.prototype.putInt24 = function (e) {
      return this.accommodate(3), this.data.setInt16(this.write, e >> 8 & 65535), this.data.setInt8(this.write, e >> 16 & 255), this.write += 3, this
    }, o.DataBuffer.prototype.putInt32 = function (e) {
      return this.accommodate(4), this.data.setInt32(this.write, e), this.write += 4, this
    }, o.DataBuffer.prototype.putInt16Le = function (e) {
      return this.accommodate(2), this.data.setInt16(this.write, e, !0), this.write += 2, this
    }, o.DataBuffer.prototype.putInt24Le = function (e) {
      return this.accommodate(3), this.data.setInt8(this.write, e >> 16 & 255), this.data.setInt16(this.write, e >> 8 & 65535, !0), this.write += 3, this
    }, o.DataBuffer.prototype.putInt32Le = function (e) {
      return this.accommodate(4), this.data.setInt32(this.write, e, !0), this.write += 4, this
    }, o.DataBuffer.prototype.putInt = function (e, t) {
      a(t), this.accommodate(t / 8);
      do t -= 8, this.data.setInt8(this.write++, e >> t & 255); while (t > 0);
      return this
    }, o.DataBuffer.prototype.putSignedInt = function (e, t) {
      return a(t), this.accommodate(t / 8), e < 0 && (e += 2 << t - 1), this.putInt(e, t)
    }, o.DataBuffer.prototype.getByte = function () {
      return this.data.getInt8(this.read++)
    }, o.DataBuffer.prototype.getInt16 = function () {
      var e = this.data.getInt16(this.read);
      return this.read += 2, e
    }, o.DataBuffer.prototype.getInt24 = function () {
      var e = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      return this.read += 3, e
    }, o.DataBuffer.prototype.getInt32 = function () {
      var e = this.data.getInt32(this.read);
      return this.read += 4, e
    }, o.DataBuffer.prototype.getInt16Le = function () {
      var e = this.data.getInt16(this.read, !0);
      return this.read += 2, e
    }, o.DataBuffer.prototype.getInt24Le = function () {
      var e = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
      return this.read += 3, e
    }, o.DataBuffer.prototype.getInt32Le = function () {
      var e = this.data.getInt32(this.read, !0);
      return this.read += 4, e
    }, o.DataBuffer.prototype.getInt = function (e) {
      a(e);
      var t = 0;
      do t = (t << 8) + this.data.getInt8(this.read++), e -= 8; while (e > 0);
      return t
    }, o.DataBuffer.prototype.getSignedInt = function (e) {
      var t = this.getInt(e),
        r = 2 << e - 2;
      return t >= r && (t -= r << 1), t
    }, o.DataBuffer.prototype.getBytes = function (e) {
      var t;
      return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : 0 === e ? t = "" : (t = 0 === this.read ? this.data : this.data.slice(this.read), this.clear()), t
    }, o.DataBuffer.prototype.bytes = function (e) {
      return "undefined" == typeof e ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e)
    }, o.DataBuffer.prototype.at = function (e) {
      return this.data.getUint8(this.read + e)
    }, o.DataBuffer.prototype.setAt = function (e, t) {
      return this.data.setUint8(e, t), this
    }, o.DataBuffer.prototype.last = function () {
      return this.data.getUint8(this.write - 1)
    }, o.DataBuffer.prototype.copy = function () {
      return new o.DataBuffer(this)
    }, o.DataBuffer.prototype.compact = function () {
      if (this.read > 0) {
        var e = new Uint8Array(this.data.buffer, this.read),
          t = new Uint8Array(e.byteLength);
        t.set(e), this.data = new DataView(t), this.write -= this.read, this.read = 0
      }
      return this
    }, o.DataBuffer.prototype.clear = function () {
      return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this
    }, o.DataBuffer.prototype.truncate = function (e) {
      return this.write = Math.max(0, this.length() - e), this.read = Math.min(this.read, this.write), this
    }, o.DataBuffer.prototype.toHex = function () {
      for (var e = "", t = this.read; t < this.data.byteLength; ++t) {
        var r = this.data.getUint8(t);
        r < 16 && (e += "0"), e += r.toString(16)
      }
      return e
    }, o.DataBuffer.prototype.toString = function (e) {
      var t = new Uint8Array(this.data, this.read, this.length());
      if (e = e || "utf8", "binary" === e || "raw" === e) return o.binary.raw.encode(t);
      if ("hex" === e) return o.binary.hex.encode(t);
      if ("base64" === e) return o.binary.base64.encode(t);
      if ("utf8" === e) return o.text.utf8.decode(t);
      if ("utf16" === e) return o.text.utf16.decode(t);
      throw new Error("Invalid encoding: " + e)
    }, o.createBuffer = function (e, t) {
      return t = t || "raw", void 0 !== e && "utf8" === t && (e = o.encodeUtf8(e)), new o.ByteBuffer(e)
    }, o.fillString = function (e, t) {
      for (var r = ""; t > 0;) 1 & t && (r += e), t >>>= 1, t > 0 && (e += e);
      return r
    }, o.xorBytes = function (e, t, r) {
      for (var a = "", n = "", i = "", s = 0, o = 0; r > 0; --r, ++s) n = e.charCodeAt(s) ^ t.charCodeAt(s), o >= 10 && (a += i, i = "", o = 0), i += String.fromCharCode(n), ++o;
      return a += i
    }, o.hexToBytes = function (e) {
      var t = "",
        r = 0;
      for (e.length & !0 && (r = 1, t += String.fromCharCode(parseInt(e[0], 16))); r < e.length; r += 2) t += String.fromCharCode(parseInt(e.substr(r, 2), 16));
      return t
    }, o.bytesToHex = function (e) {
      return o.createBuffer(e).toHex()
    }, o.int32ToBytes = function (e) {
      return String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(255 & e)
    };
    var u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      l = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
    o.encode64 = function (e, t) {
      for (var r, a, n, i = "", s = "", o = 0; o < e.length;) r = e.charCodeAt(o++), a = e.charCodeAt(o++), n = e.charCodeAt(o++), i += u.charAt(r >> 2), i += u.charAt((3 & r) << 4 | a >> 4), isNaN(a) ? i += "==" : (i += u.charAt((15 & a) << 2 | n >> 6), i += isNaN(n) ? "=" : u.charAt(63 & n)), t && i.length > t && (s += i.substr(0, t) + "\r\n", i = i.substr(t));
      return s += i
    }, o.decode64 = function (e) {
      e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      for (var t, r, a, n, i = "", s = 0; s < e.length;) t = l[e.charCodeAt(s++) - 43], r = l[e.charCodeAt(s++) - 43], a = l[e.charCodeAt(s++) - 43], n = l[e.charCodeAt(s++) - 43], i += String.fromCharCode(t << 2 | r >> 4), 64 !== a && (i += String.fromCharCode((15 & r) << 4 | a >> 2), 64 !== n && (i += String.fromCharCode((3 & a) << 6 | n)));
      return i
    }, o.encodeUtf8 = function (e) {
      return unescape(encodeURIComponent(e))
    }, o.decodeUtf8 = function (e) {
      return decodeURIComponent(escape(e))
    }, o.binary = {
      raw: {},
      hex: {},
      base64: {}
    }, o.binary.raw.encode = function (e) {
      return String.fromCharCode.apply(null, e)
    }, o.binary.raw.decode = function (e, t, r) {
      var a = t;
      a || (a = new Uint8Array(e.length)), r = r || 0;
      for (var n = r, i = 0; i < e.length; ++i) a[n++] = e.charCodeAt(i);
      return t ? n - r : a
    }, o.binary.hex.encode = o.bytesToHex, o.binary.hex.decode = function (e, t, r) {
      var a = t;
      a || (a = new Uint8Array(Math.ceil(e.length / 2))), r = r || 0;
      var n = 0,
        i = r;
      for (1 & e.length && (n = 1, a[i++] = parseInt(e[0], 16)); n < e.length; n += 2) a[i++] = parseInt(e.substr(n, 2), 16);
      return t ? i - r : a
    }, o.binary.base64.encode = function (e, t) {
      for (var r, a, n, i = "", s = "", o = 0; o < e.byteLength;) r = e[o++], a = e[o++], n = e[o++], i += u.charAt(r >> 2), i += u.charAt((3 & r) << 4 | a >> 4), isNaN(a) ? i += "==" : (i += u.charAt((15 & a) << 2 | n >> 6), i += isNaN(n) ? "=" : u.charAt(63 & n)), t && i.length > t && (s += i.substr(0, t) + "\r\n", i = i.substr(t));
      return s += i
    }, o.binary.base64.decode = function (e, t, r) {
      var a = t;
      a || (a = new Uint8Array(3 * Math.ceil(e.length / 4))), e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""), r = r || 0;
      for (var n, i, s, o, c = 0, u = r; c < e.length;) n = l[e.charCodeAt(c++) - 43], i = l[e.charCodeAt(c++) - 43], s = l[e.charCodeAt(c++) - 43], o = l[e.charCodeAt(c++) - 43], a[u++] = n << 2 | i >> 4, 64 !== s && (a[u++] = (15 & i) << 4 | s >> 2, 64 !== o && (a[u++] = (3 & s) << 6 | o));
      return t ? u - r : a.subarray(0, u)
    }, o.text = {
      utf8: {},
      utf16: {}
    }, o.text.utf8.encode = function (e, t, r) {
      e = o.encodeUtf8(e);
      var a = t;
      a || (a = new Uint8Array(e.length)), r = r || 0;
      for (var n = r, i = 0; i < e.length; ++i) a[n++] = e.charCodeAt(i);
      return t ? n - r : a
    }, o.text.utf8.decode = function (e) {
      return o.decodeUtf8(String.fromCharCode.apply(null, e))
    }, o.text.utf16.encode = function (e, t, r) {
      var a = t;
      a || (a = new Uint8Array(2 * e.length));
      var n = new Uint16Array(a.buffer);
      r = r || 0;
      for (var i = r, s = r, o = 0; o < e.length; ++o) n[s++] = e.charCodeAt(o), i += 2;
      return t ? i - r : a
    }, o.text.utf16.decode = function (e) {
      return String.fromCharCode.apply(null, new Uint16Array(e.buffer))
    }, o.deflate = function (e, t, r) {
      if (t = o.decode64(e.deflate(o.encode64(t)).rval), r) {
        var a = 2,
          n = t.charCodeAt(1);
        32 & n && (a = 6), t = t.substring(a, t.length - 4)
      }
      return t
    }, o.inflate = function (e, t, r) {
      var a = e.inflate(o.encode64(t)).rval;
      return null === a ? null : o.decode64(a)
    };
    var p = function (e, t, r) {
        if (!e) throw new Error("WebStorage not available.");
        var a;
        if (null === r ? a = e.removeItem(t) : (r = o.encode64(JSON.stringify(r)), a = e.setItem(t, r)), "undefined" != typeof a && a.rval !== !0) {
          var n = new Error(a.error.message);
          throw n.id = a.error.id, n.name = a.error.name, n
        }
      },
      h = function (e, t) {
        if (!e) throw new Error("WebStorage not available.");
        var r = e.getItem(t);
        if (e.init)
          if (null === r.rval) {
            if (r.error) {
              var a = new Error(r.error.message);
              throw a.id = r.error.id, a.name = r.error.name, a
            }
            r = null
          } else r = r.rval;
        return null !== r && (r = JSON.parse(o.decode64(r))), r
      },
      f = function (e, t, r, a) {
        var n = h(e, t);
        null === n && (n = {}), n[r] = a, p(e, t, n)
      },
      d = function (e, t, r) {
        var a = h(e, t);
        return null !== a && (a = r in a ? a[r] : null), a
      },
      y = function (e, t, r) {
        var a = h(e, t);
        if (null !== a && r in a) {
          delete a[r];
          var n = !0;
          for (var i in a) {
            n = !1;
            break
          }
          n && (a = null), p(e, t, a)
        }
      },
      g = function (e, t) {
        p(e, t, null)
      },
      v = function (e, t, r) {
        var a = null;
        "undefined" == typeof r && (r = ["web", "flash"]);
        var n, i = !1,
          s = null;
        for (var o in r) {
          n = r[o];
          try {
            if ("flash" === n || "both" === n) {
              if (null === t[0]) throw new Error("Flash local storage not available.");
              a = e.apply(this, t), i = "flash" === n
            }
            "web" !== n && "both" !== n || (t[0] = localStorage, a = e.apply(this, t), i = !0)
          } catch (e) {
            s = e
          }
          if (i) break
        }
        if (!i) throw s;
        return a
      };
    o.setItem = function (e, t, r, a, n) {
      v(f, arguments, n)
    }, o.getItem = function (e, t, r, a) {
      return v(d, arguments, a)
    }, o.removeItem = function (e, t, r, a) {
      v(y, arguments, a)
    }, o.clearItems = function (e, t, r) {
      v(g, arguments, r)
    }, o.parseUrl = function (e) {
      var t = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
      t.lastIndex = 0;
      var r = t.exec(e),
        a = null === r ? null : {
          full: e,
          scheme: r[1],
          host: r[2],
          port: r[3],
          path: r[4]
        };
      return a && (a.fullHost = a.host, a.port ? 80 !== a.port && "http" === a.scheme ? a.fullHost += ":" + a.port : 443 !== a.port && "https" === a.scheme && (a.fullHost += ":" + a.port) : "http" === a.scheme ? a.port = 80 : "https" === a.scheme && (a.port = 443), a.full = a.scheme + "://" + a.fullHost), a
    };
    var m = null;
    o.getQueryVariables = function (e) {
      var t, r = function (e) {
        for (var t = {}, r = e.split("&"), a = 0; a < r.length; a++) {
          var n, i, s = r[a].indexOf("=");
          s > 0 ? (n = r[a].substring(0, s), i = r[a].substring(s + 1)) : (n = r[a], i = null), n in t || (t[n] = []), n in Object.prototype || null === i || t[n].push(unescape(i))
        }
        return t
      };
      return "undefined" == typeof e ? (null === m && (m = "undefined" != typeof window && window.location && window.location.search ? r(window.location.search.substring(1)) : {}), t = m) : t = r(e), t
    }, o.parseFragment = function (e) {
      var t = e,
        r = "",
        a = e.indexOf("?");
      a > 0 && (t = e.substring(0, a), r = e.substring(a + 1));
      var n = t.split("/");
      n.length > 0 && "" === n[0] && n.shift();
      var i = "" === r ? {} : o.getQueryVariables(r);
      return {
        pathString: t,
        queryString: r,
        path: n,
        query: i
      }
    }, o.makeRequest = function (e) {
      var t = o.parseFragment(e),
        r = {
          path: t.pathString,
          query: t.queryString,
          getPath: function (e) {
            return "undefined" == typeof e ? t.path : t.path[e]
          },
          getQuery: function (e, r) {
            var a;
            return "undefined" == typeof e ? a = t.query : (a = t.query[e], a && "undefined" != typeof r && (a = a[r])), a
          },
          getQueryLast: function (e, t) {
            var a, n = r.getQuery(e);
            return a = n ? n[n.length - 1] : t
          }
        };
      return r
    }, o.makeLink = function (e, t, r) {
      e = jQuery.isArray(e) ? e.join("/") : e;
      var a = jQuery.param(t || {});
      return r = r || "", e + (a.length > 0 ? "?" + a : "") + (r.length > 0 ? "#" + r : "")
    }, o.setPath = function (e, t, r) {
      if ("object" == typeof e && null !== e)
        for (var a = 0, n = t.length; a < n;) {
          var i = t[a++];
          if (a == n) e[i] = r;
          else {
            var s = i in e;
            (!s || s && "object" != typeof e[i] || s && null === e[i]) && (e[i] = {}), e = e[i]
          }
        }
    }, o.getPath = function (e, t, r) {
      for (var a = 0, n = t.length, i = !0; i && a < n && "object" == typeof e && null !== e;) {
        var s = t[a++];
        i = s in e, i && (e = e[s])
      }
      return i ? e : r
    }, o.deletePath = function (e, t) {
      if ("object" == typeof e && null !== e)
        for (var r = 0, a = t.length; r < a;) {
          var n = t[r++];
          if (r == a) delete e[n];
          else {
            if (!(n in e) || "object" != typeof e[n] || null === e[n]) break;
            e = e[n]
          }
        }
    }, o.isEmpty = function (e) {
      for (var t in e)
        if (e.hasOwnProperty(t)) return !1;
      return !0
    }, o.format = function (e) {
      for (var t, r, a = /%./g, n = 0, i = [], s = 0; t = a.exec(e);) {
        r = e.substring(s, a.lastIndex - 2), r.length > 0 && i.push(r), s = a.lastIndex;
        var o = t[0][1];
        switch (o) {
          case "s":
          case "o":
            n < arguments.length ? i.push(arguments[n++ + 1]) : i.push("<?>");
            break;
          case "%":
            i.push("%");
            break;
          default:
            i.push("<%" + o + "?>")
        }
      }
      return i.push(e.substring(s)), i.join("")
    }, o.formatNumber = function (e, t, r, a) {
      var n = e,
        i = isNaN(t = Math.abs(t)) ? 2 : t,
        s = void 0 === r ? "," : r,
        o = void 0 === a ? "." : a,
        c = n < 0 ? "-" : "",
        u = parseInt(n = Math.abs(+n || 0).toFixed(i), 10) + "",
        l = u.length > 3 ? u.length % 3 : 0;
      return c + (l ? u.substr(0, l) + o : "") + u.substr(l).replace(/(\d{3})(?=\d)/g, "$1" + o) + (i ? s + Math.abs(n - u).toFixed(i).slice(2) : "")
    }, o.formatSize = function (e) {
      return e = e >= 1073741824 ? o.formatNumber(e / 1073741824, 2, ".", "") + " GiB" : e >= 1048576 ? o.formatNumber(e / 1048576, 2, ".", "") + " MiB" : e >= 1024 ? o.formatNumber(e / 1024, 0) + " KiB" : o.formatNumber(e, 0) + " bytes"
    }, o.bytesFromIP = function (e) {
      return e.indexOf(".") !== -1 ? o.bytesFromIPv4(e) : e.indexOf(":") !== -1 ? o.bytesFromIPv6(e) : null
    }, o.bytesFromIPv4 = function (e) {
      if (e = e.split("."), 4 !== e.length) return null;
      for (var t = o.createBuffer(), r = 0; r < e.length; ++r) {
        var a = parseInt(e[r], 10);
        if (isNaN(a)) return null;
        t.putByte(a)
      }
      return t.getBytes()
    }, o.bytesFromIPv6 = function (e) {
      var t = 0;
      e = e.split(":").filter(function (e) {
        return 0 === e.length && ++t, !0
      });
      for (var r = 2 * (8 - e.length + t), a = o.createBuffer(), n = 0; n < 8; ++n)
        if (e[n] && 0 !== e[n].length) {
          var i = o.hexToBytes(e[n]);
          i.length < 2 && a.putByte(0), a.putBytes(i)
        } else a.fillWithByte(0, r), r = 0;
      return a.getBytes()
    }, o.bytesToIP = function (e) {
      return 4 === e.length ? o.bytesToIPv4(e) : 16 === e.length ? o.bytesToIPv6(e) : null
    }, o.bytesToIPv4 = function (e) {
      if (4 !== e.length) return null;
      for (var t = [], r = 0; r < e.length; ++r) t.push(e.charCodeAt(r));
      return t.join(".")
    }, o.bytesToIPv6 = function (e) {
      if (16 !== e.length) return null;
      for (var t = [], r = [], a = 0, n = 0; n < e.length; n += 2) {
        for (var i = o.bytesToHex(e[n] + e[n + 1]);
          "0" === i[0] && "0" !== i;) i = i.substr(1);
        if ("0" === i) {
          var s = r[r.length - 1],
            c = t.length;
          s && c === s.end + 1 ? (s.end = c, s.end - s.start > r[a].end - r[a].start && (a = r.length - 1)) : r.push({
            start: c,
            end: c
          })
        }
        t.push(i)
      }
      if (r.length > 0) {
        var u = r[a];
        u.end - u.start > 0 && (t.splice(u.start, u.end - u.start + 1, ""), 0 === u.start && t.unshift(""), 7 === u.end && t.push(""))
      }
      return t.join(":")
    }, o.estimateCores = function (e, t) {
      function r(e, s, c) {
        if (0 === s) {
          var u = Math.floor(e.reduce(function (e, t) {
            return e + t
          }, 0) / e.length);
          return o.cores = Math.max(1, u), URL.revokeObjectURL(i), t(null, o.cores)
        }
        a(c, function (t, a) {
          e.push(n(c, a)), r(e, s - 1, c)
        })
      }

      function a(e, t) {
        for (var r = [], a = [], n = 0; n < e; ++n) {
          var s = new Worker(i);
          s.addEventListener("message", function (n) {
            if (a.push(n.data), a.length === e) {
              for (var i = 0; i < e; ++i) r[i].terminate();
              t(null, a)
            }
          }), r.push(s)
        }
        for (var n = 0; n < e; ++n) r[n].postMessage(n)
      }

      function n(e, t) {
        for (var r = [], a = 0; a < e; ++a)
          for (var n = t[a], i = r[a] = [], s = 0; s < e; ++s)
            if (a !== s) {
              var o = t[s];
              (n.st > o.st && n.st < o.et || o.st > n.st && o.st < n.et) && i.push(s)
            } return r.reduce(function (e, t) {
          return Math.max(e, t.length)
        }, 0)
      }
      if ("function" == typeof e && (t = e, e = {}), e = e || {}, "cores" in o && !e.update) return t(null, o.cores);
      if ("undefined" != typeof navigator && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) return o.cores = navigator.hardwareConcurrency, t(null, o.cores);
      if ("undefined" == typeof Worker) return o.cores = 1, t(null, o.cores);
      if ("undefined" == typeof Blob) return o.cores = 2, t(null, o.cores);
      var i = URL.createObjectURL(new Blob(["(", function () {
        self.addEventListener("message", function (e) {
          for (var t = Date.now(), r = t + 4; Date.now() < r;);
          self.postMessage({
            st: t,
            et: r
          })
        })
      }.toString(), ")()"], {
        type: "application/javascript"
      }));
      r([], 5, 16)
    }
  }, function (e, t, r) {
    var a = r(0);
    r(5), r(30), r(28), r(1),
      function () {
        return a.random && a.random.getBytes ? void(e.exports = a.random) : void
        function (t) {
          function r() {
            var e = a.prng.create(n);
            return e.getBytes = function (t, r) {
              return e.generate(t, r)
            }, e.getBytesSync = function (t) {
              return e.generate(t)
            }, e
          }
          var n = {},
            i = new Array(4),
            s = a.util.createBuffer();
          n.formatKey = function (e) {
            var t = a.util.createBuffer(e);
            return e = new Array(4), e[0] = t.getInt32(), e[1] = t.getInt32(), e[2] = t.getInt32(), e[3] = t.getInt32(), a.aes._expandKey(e, !1)
          }, n.formatSeed = function (e) {
            var t = a.util.createBuffer(e);
            return e = new Array(4), e[0] = t.getInt32(), e[1] = t.getInt32(), e[2] = t.getInt32(), e[3] = t.getInt32(), e
          }, n.cipher = function (e, t) {
            return a.aes._updateBlock(e, t, i, !1), s.putInt32(i[0]), s.putInt32(i[1]), s.putInt32(i[2]), s.putInt32(i[3]), s.getBytes()
          }, n.increment = function (e) {
            return ++e[3], e
          }, n.md = a.md.sha256;
          var o = r(),
            c = null;
          if ("undefined" != typeof window) {
            var u = window.crypto || window.msCrypto;
            u && u.getRandomValues && (c = function (e) {
              return u.getRandomValues(e)
            })
          }
          if (a.options.usePureJavaScript || !a.util.isNodejs && !c) {
            if ("undefined" == typeof window || void 0 === window.document, o.collectInt(+new Date, 32), "undefined" != typeof navigator) {
              var l = "";
              for (var p in navigator) try {
                "string" == typeof navigator[p] && (l += navigator[p])
              } catch (e) {}
              o.collect(l), l = null
            }
            t && (t().mousemove(function (e) {
              o.collectInt(e.clientX, 16), o.collectInt(e.clientY, 16)
            }), t().keypress(function (e) {
              o.collectInt(e.charCode, 8)
            }))
          }
          if (a.random)
            for (var p in o) a.random[p] = o[p];
          else a.random = o;
          a.random.createInstance = r, e.exports = a.random
        }("undefined" != typeof jQuery ? jQuery : null)
      }()
  }, function (e, t, r) {
    function a(e, t, r) {
      if (r > t) {
        var a = new Error("Too few bytes to parse DER.");
        throw a.available = e.length(), a.remaining = t, a.requested = r, a
      }
    }

    function n(e, t, r, i) {
      var c;
      a(e, t, 2);
      var u = e.getByte();
      t--;
      var l = 192 & u,
        p = 31 & u;
      c = e.length();
      var h = o(e, t);
      if (t -= c - e.length(), void 0 !== h && h > t) {
        if (i.strict) {
          var f = new Error("Too few bytes to read ASN.1 value.");
          throw f.available = e.length(), f.remaining = t, f.requested = h, f
        }
        h = t
      }
      var d, y, g = 32 === (32 & u);
      if (g)
        if (d = [], void 0 === h)
          for (;;) {
            if (a(e, t, 2), e.bytes(2) === String.fromCharCode(0, 0)) {
              e.getBytes(2), t -= 2;
              break
            }
            c = e.length(), d.push(n(e, t, r + 1, i)), t -= c - e.length()
          } else
            for (; h > 0;) c = e.length(), d.push(n(e, h, r + 1, i)), t -= c - e.length(), h -= c - e.length();
      if (void 0 === d && l === s.Class.UNIVERSAL && p === s.Type.BITSTRING && (y = e.bytes(h)), void 0 === d && i.decodeBitStrings && l === s.Class.UNIVERSAL && p === s.Type.BITSTRING && h > 1) {
        var v = e.read,
          m = t,
          C = 0;
        if (p === s.Type.BITSTRING && (a(e, t, 1), C = e.getByte(), t--), 0 === C) try {
          c = e.length();
          var E = {
              verbose: i.verbose,
              strict: !0,
              decodeBitStrings: !0
            },
            S = n(e, t, r + 1, E),
            T = c - e.length();
          t -= T, p == s.Type.BITSTRING && T++;
          var I = S.tagClass;
          T !== h || I !== s.Class.UNIVERSAL && I !== s.Class.CONTEXT_SPECIFIC || (d = [S])
        } catch (e) {}
        void 0 === d && (e.read = v, t = m)
      }
      if (void 0 === d) {
        if (void 0 === h) {
          if (i.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.");
          h = t
        }
        if (p === s.Type.BMPSTRING)
          for (d = ""; h > 0; h -= 2) a(e, t, 2), d += String.fromCharCode(e.getInt16()), t -= 2;
        else d = e.getBytes(h)
      }
      var A = void 0 === y ? null : {
        bitStringContents: y
      };
      return s.create(l, p, g, d, A)
    }
    var i = r(0);
    r(1), r(6);
    var s = e.exports = i.asn1 = i.asn1 || {};
    s.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    }, s.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    }, s.create = function (e, t, r, a, n) {
      if (i.util.isArray(a)) {
        for (var o = [], c = 0; c < a.length; ++c) void 0 !== a[c] && o.push(a[c]);
        a = o
      }
      var u = {
        tagClass: e,
        type: t,
        constructed: r,
        composed: r || i.util.isArray(a),
        value: a
      };
      return n && "bitStringContents" in n && (u.bitStringContents = n.bitStringContents, u.original = s.copy(u)), u
    }, s.copy = function (e, t) {
      var r;
      if (i.util.isArray(e)) {
        r = [];
        for (var a = 0; a < e.length; ++a) r.push(s.copy(e[a], t));
        return r
      }
      return "string" == typeof e ? e : (r = {
        tagClass: e.tagClass,
        type: e.type,
        constructed: e.constructed,
        composed: e.composed,
        value: s.copy(e.value, t)
      }, t && !t.excludeBitStringContents && (r.bitStringContents = e.bitStringContents), r)
    }, s.equals = function (e, t, r) {
      if (i.util.isArray(e)) {
        if (!i.util.isArray(t)) return !1;
        if (e.length !== t.length) return !1;
        for (var a = 0; a < e.length; ++a) return !!s.equals(e[a], t[a])
      }
      if (typeof e != typeof t) return !1;
      if ("string" == typeof e) return e === t;
      var n = e.tagClass === t.tagClass && e.type === t.type && e.constructed === t.constructed && e.composed === t.composed && s.equals(e.value, t.value);
      return r && r.includeBitStringContents && (n = n && e.bitStringContents === t.bitStringContents), n
    }, s.getBerValueLength = function (e) {
      var t = e.getByte();
      if (128 !== t) {
        var r, a = 128 & t;
        return r = a ? e.getInt((127 & t) << 3) : t
      }
    };
    var o = function (e, t) {
      var r = e.getByte();
      if (t--, 128 !== r) {
        var n, i = 128 & r;
        if (i) {
          var s = 127 & r;
          a(e, t, s), n = e.getInt(s << 3)
        } else n = r;
        if (n < 0) throw new Error("Negative length: " + n);
        return n
      }
    };
    s.fromDer = function (e, t) {
      return void 0 === t && (t = {
        strict: !0,
        decodeBitStrings: !0
      }), "boolean" == typeof t && (t = {
        strict: t,
        decodeBitStrings: !0
      }), "strict" in t || (t.strict = !0), "decodeBitStrings" in t || (t.decodeBitStrings = !0), "string" == typeof e && (e = i.util.createBuffer(e)), n(e, e.length(), 0, t)
    }, s.toDer = function (e) {
      var t = i.util.createBuffer(),
        r = e.tagClass | e.type,
        a = i.util.createBuffer(),
        n = !1;
      if ("bitStringContents" in e && (n = !0, e.original && (n = s.equals(e, e.original))), n) a.putBytes(e.bitStringContents);
      else if (e.composed) {
        e.constructed ? r |= 32 : a.putByte(0);
        for (var o = 0; o < e.value.length; ++o) void 0 !== e.value[o] && a.putBuffer(s.toDer(e.value[o]))
      } else if (e.type === s.Type.BMPSTRING)
        for (var o = 0; o < e.value.length; ++o) a.putInt16(e.value.charCodeAt(o));
      else e.type === s.Type.INTEGER && e.value.length > 1 && (0 === e.value.charCodeAt(0) && 0 === (128 & e.value.charCodeAt(1)) || 255 === e.value.charCodeAt(0) && 128 === (128 & e.value.charCodeAt(1))) ? a.putBytes(e.value.substr(1)) : a.putBytes(e.value);
      if (t.putByte(r), a.length() <= 127) t.putByte(127 & a.length());
      else {
        var c = a.length(),
          u = "";
        do u += String.fromCharCode(255 & c), c >>>= 8; while (c > 0);
        t.putByte(128 | u.length);
        for (var o = u.length - 1; o >= 0; --o) t.putByte(u.charCodeAt(o))
      }
      return t.putBuffer(a), t
    }, s.oidToDer = function (e) {
      var t = e.split("."),
        r = i.util.createBuffer();
      r.putByte(40 * parseInt(t[0], 10) + parseInt(t[1], 10));
      for (var a, n, s, o, c = 2; c < t.length; ++c) {
        a = !0, n = [], s = parseInt(t[c], 10);
        do o = 127 & s, s >>>= 7, a || (o |= 128), n.push(o), a = !1; while (s > 0);
        for (var u = n.length - 1; u >= 0; --u) r.putByte(n[u])
      }
      return r
    }, s.derToOid = function (e) {
      var t;
      "string" == typeof e && (e = i.util.createBuffer(e));
      var r = e.getByte();
      t = Math.floor(r / 40) + "." + r % 40;
      for (var a = 0; e.length() > 0;) r = e.getByte(),
        a <<= 7, 128 & r ? a += 127 & r : (t += "." + (a + r), a = 0);
      return t
    }, s.utcTimeToDate = function (e) {
      var t = new Date,
        r = parseInt(e.substr(0, 2), 10);
      r = r >= 50 ? 1900 + r : 2e3 + r;
      var a = parseInt(e.substr(2, 2), 10) - 1,
        n = parseInt(e.substr(4, 2), 10),
        i = parseInt(e.substr(6, 2), 10),
        s = parseInt(e.substr(8, 2), 10),
        o = 0;
      if (e.length > 11) {
        var c = e.charAt(10),
          u = 10;
        "+" !== c && "-" !== c && (o = parseInt(e.substr(10, 2), 10), u += 2)
      }
      if (t.setUTCFullYear(r, a, n), t.setUTCHours(i, s, o, 0), u && (c = e.charAt(u), "+" === c || "-" === c)) {
        var l = parseInt(e.substr(u + 1, 2), 10),
          p = parseInt(e.substr(u + 4, 2), 10),
          h = 60 * l + p;
        h *= 6e4, "+" === c ? t.setTime(+t - h) : t.setTime(+t + h)
      }
      return t
    }, s.generalizedTimeToDate = function (e) {
      var t = new Date,
        r = parseInt(e.substr(0, 4), 10),
        a = parseInt(e.substr(4, 2), 10) - 1,
        n = parseInt(e.substr(6, 2), 10),
        i = parseInt(e.substr(8, 2), 10),
        s = parseInt(e.substr(10, 2), 10),
        o = parseInt(e.substr(12, 2), 10),
        c = 0,
        u = 0,
        l = !1;
      "Z" === e.charAt(e.length - 1) && (l = !0);
      var p = e.length - 5,
        h = e.charAt(p);
      if ("+" === h || "-" === h) {
        var f = parseInt(e.substr(p + 1, 2), 10),
          d = parseInt(e.substr(p + 4, 2), 10);
        u = 60 * f + d, u *= 6e4, "+" === h && (u *= -1), l = !0
      }
      return "." === e.charAt(14) && (c = 1e3 * parseFloat(e.substr(14), 10)), l ? (t.setUTCFullYear(r, a, n), t.setUTCHours(i, s, o, c), t.setTime(+t + u)) : (t.setFullYear(r, a, n), t.setHours(i, s, o, c)), t
    }, s.dateToUtcTime = function (e) {
      if ("string" == typeof e) return e;
      var t = "",
        r = [];
      r.push(("" + e.getUTCFullYear()).substr(2)), r.push("" + (e.getUTCMonth() + 1)), r.push("" + e.getUTCDate()), r.push("" + e.getUTCHours()), r.push("" + e.getUTCMinutes()), r.push("" + e.getUTCSeconds());
      for (var a = 0; a < r.length; ++a) r[a].length < 2 && (t += "0"), t += r[a];
      return t += "Z"
    }, s.dateToGeneralizedTime = function (e) {
      if ("string" == typeof e) return e;
      var t = "",
        r = [];
      r.push("" + e.getUTCFullYear()), r.push("" + (e.getUTCMonth() + 1)), r.push("" + e.getUTCDate()), r.push("" + e.getUTCHours()), r.push("" + e.getUTCMinutes()), r.push("" + e.getUTCSeconds());
      for (var a = 0; a < r.length; ++a) r[a].length < 2 && (t += "0"), t += r[a];
      return t += "Z"
    }, s.integerToDer = function (e) {
      var t = i.util.createBuffer();
      if (e >= -128 && e < 128) return t.putSignedInt(e, 8);
      if (e >= -32768 && e < 32768) return t.putSignedInt(e, 16);
      if (e >= -8388608 && e < 8388608) return t.putSignedInt(e, 24);
      if (e >= -2147483648 && e < 2147483648) return t.putSignedInt(e, 32);
      var r = new Error("Integer too large; max is 32-bits.");
      throw r.integer = e, r
    }, s.derToInteger = function (e) {
      "string" == typeof e && (e = i.util.createBuffer(e));
      var t = 8 * e.length();
      if (t > 32) throw new Error("Integer too large; max is 32-bits.");
      return e.getSignedInt(t)
    }, s.validate = function (e, t, r, a) {
      var n = !1;
      if (e.tagClass !== t.tagClass && "undefined" != typeof t.tagClass || e.type !== t.type && "undefined" != typeof t.type) a && (e.tagClass !== t.tagClass && a.push("[" + t.name + '] Expected tag class "' + t.tagClass + '", got "' + e.tagClass + '"'), e.type !== t.type && a.push("[" + t.name + '] Expected type "' + t.type + '", got "' + e.type + '"'));
      else if (e.constructed === t.constructed || "undefined" == typeof t.constructed) {
        if (n = !0, t.value && i.util.isArray(t.value))
          for (var o = 0, c = 0; n && c < t.value.length; ++c) n = t.value[c].optional || !1, e.value[o] && (n = s.validate(e.value[o], t.value[c], r, a), n ? ++o : t.value[c].optional && (n = !0)), !n && a && a.push("[" + t.name + '] Tag class "' + t.tagClass + '", type "' + t.type + '" expected value length "' + t.value.length + '", got "' + e.value.length + '"');
        if (n && r && (t.capture && (r[t.capture] = e.value), t.captureAsn1 && (r[t.captureAsn1] = e), t.captureBitStringContents && "bitStringContents" in e && (r[t.captureBitStringContents] = e.bitStringContents), t.captureBitStringValue && "bitStringContents" in e)) {
          if (e.bitStringContents.length < 2) r[t.captureBitStringValue] = "";
          else {
            var u = e.bitStringContents.charCodeAt(0);
            if (0 !== u) throw new Error("captureBitStringValue only supported for zero unused bits");
            r[t.captureBitStringValue] = e.bitStringContents.slice(1)
          }
        }
      } else a && a.push("[" + t.name + '] Expected constructed "' + t.constructed + '", got "' + e.constructed + '"');
      return n
    };
    var c = /[^\\u0000-\\u00ff]/;
    s.prettyPrint = function (e, t, r) {
      var a = "";
      t = t || 0, r = r || 2, t > 0 && (a += "\n");
      for (var n = "", o = 0; o < t * r; ++o) n += " ";
      switch (a += n + "Tag: ", e.tagClass) {
        case s.Class.UNIVERSAL:
          a += "Universal:";
          break;
        case s.Class.APPLICATION:
          a += "Application:";
          break;
        case s.Class.CONTEXT_SPECIFIC:
          a += "Context-Specific:";
          break;
        case s.Class.PRIVATE:
          a += "Private:"
      }
      if (e.tagClass === s.Class.UNIVERSAL) switch (a += e.type, e.type) {
        case s.Type.NONE:
          a += " (None)";
          break;
        case s.Type.BOOLEAN:
          a += " (Boolean)";
          break;
        case s.Type.INTEGER:
          a += " (Integer)";
          break;
        case s.Type.BITSTRING:
          a += " (Bit string)";
          break;
        case s.Type.OCTETSTRING:
          a += " (Octet string)";
          break;
        case s.Type.NULL:
          a += " (Null)";
          break;
        case s.Type.OID:
          a += " (Object Identifier)";
          break;
        case s.Type.ODESC:
          a += " (Object Descriptor)";
          break;
        case s.Type.EXTERNAL:
          a += " (External or Instance of)";
          break;
        case s.Type.REAL:
          a += " (Real)";
          break;
        case s.Type.ENUMERATED:
          a += " (Enumerated)";
          break;
        case s.Type.EMBEDDED:
          a += " (Embedded PDV)";
          break;
        case s.Type.UTF8:
          a += " (UTF8)";
          break;
        case s.Type.ROID:
          a += " (Relative Object Identifier)";
          break;
        case s.Type.SEQUENCE:
          a += " (Sequence)";
          break;
        case s.Type.SET:
          a += " (Set)";
          break;
        case s.Type.PRINTABLESTRING:
          a += " (Printable String)";
          break;
        case s.Type.IA5String:
          a += " (IA5String (ASCII))";
          break;
        case s.Type.UTCTIME:
          a += " (UTC time)";
          break;
        case s.Type.GENERALIZEDTIME:
          a += " (Generalized time)";
          break;
        case s.Type.BMPSTRING:
          a += " (BMP String)"
      } else a += e.type;
      if (a += "\n", a += n + "Constructed: " + e.constructed + "\n", e.composed) {
        for (var u = 0, l = "", o = 0; o < e.value.length; ++o) void 0 !== e.value[o] && (u += 1, l += s.prettyPrint(e.value[o], t + 1, r), o + 1 < e.value.length && (l += ","));
        a += n + "Sub values: " + u + l
      } else {
        if (a += n + "Value: ", e.type === s.Type.OID) {
          var p = s.derToOid(e.value);
          a += p, i.pki && i.pki.oids && p in i.pki.oids && (a += " (" + i.pki.oids[p] + ") ")
        }
        if (e.type === s.Type.INTEGER) try {
          a += s.derToInteger(e.value)
        } catch (t) {
          a += "0x" + i.util.bytesToHex(e.value)
        } else if (e.type === s.Type.BITSTRING) {
          if (a += e.value.length > 1 ? "0x" + i.util.bytesToHex(e.value.slice(1)) : "(none)", e.value.length > 0) {
            var h = e.value.charCodeAt(0);
            1 == h ? a += " (1 unused bit shown)" : h > 1 && (a += " (" + h + " unused bits shown)")
          }
        } else e.type === s.Type.OCTETSTRING ? (c.test(e.value) || (a += "(" + e.value + ") "), a += "0x" + i.util.bytesToHex(e.value)) : a += e.type === s.Type.UTF8 ? i.util.decodeUtf8(e.value) : e.type === s.Type.PRINTABLESTRING || e.type === s.Type.IA5String ? e.value : c.test(e.value) ? "0x" + i.util.bytesToHex(e.value) : 0 === e.value.length ? "[null]" : e.value
      }
      return a
    }
  }, function (e, t, r) {
    var a = r(0);
    e.exports = a.md = a.md || {}, a.md.algorithms = a.md.algorithms || {}
  }, function (e, t, r) {
    function a(e, t) {
      var r = function () {
        return new c.aes.Algorithm(e, t)
      };
      c.cipher.registerAlgorithm(e, r)
    }

    function n() {
      d = !0, p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      for (var e = new Array(256), t = 0; t < 128; ++t) e[t] = t << 1, e[t + 128] = t + 128 << 1 ^ 283;
      u = new Array(256), l = new Array(256), h = new Array(4), f = new Array(4);
      for (var t = 0; t < 4; ++t) h[t] = new Array(256), f[t] = new Array(256);
      for (var r, a, n, i, s, o, c, y = 0, g = 0, t = 0; t < 256; ++t) {
        i = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4, i = i >> 8 ^ 255 & i ^ 99, u[y] = i, l[i] = y, s = e[i], r = e[y], a = e[r], n = e[a], o = s << 24 ^ i << 16 ^ i << 8 ^ (i ^ s), c = (r ^ a ^ n) << 24 ^ (y ^ n) << 16 ^ (y ^ a ^ n) << 8 ^ (y ^ r ^ n);
        for (var v = 0; v < 4; ++v) h[v][y] = o, f[v][i] = c, o = o << 24 | o >>> 8, c = c << 24 | c >>> 8;
        0 === y ? y = g = 1 : (y = r ^ e[e[e[r ^ n]]], g ^= e[e[g]])
      }
    }

    function i(e, t) {
      for (var r, a = e.slice(0), n = 1, i = a.length, s = i + 6 + 1, o = y * s, c = i; c < o; ++c) r = a[c - 1], c % i === 0 ? (r = u[r >>> 16 & 255] << 24 ^ u[r >>> 8 & 255] << 16 ^ u[255 & r] << 8 ^ u[r >>> 24] ^ p[n] << 24, n++) : i > 6 && c % i === 4 && (r = u[r >>> 24] << 24 ^ u[r >>> 16 & 255] << 16 ^ u[r >>> 8 & 255] << 8 ^ u[255 & r]), a[c] = a[c - i] ^ r;
      if (t) {
        var l, h = f[0],
          d = f[1],
          g = f[2],
          v = f[3],
          m = a.slice(0);
        o = a.length;
        for (var c = 0, C = o - y; c < o; c += y, C -= y)
          if (0 === c || c === o - y) m[c] = a[C], m[c + 1] = a[C + 3], m[c + 2] = a[C + 2], m[c + 3] = a[C + 1];
          else
            for (var E = 0; E < y; ++E) l = a[C + E], m[c + (3 & -E)] = h[u[l >>> 24]] ^ d[u[l >>> 16 & 255]] ^ g[u[l >>> 8 & 255]] ^ v[u[255 & l]];
        a = m
      }
      return a
    }

    function s(e, t, r, a) {
      var n, i, s, o, c, p = e.length / 4 - 1;
      a ? (n = f[0], i = f[1], s = f[2], o = f[3], c = l) : (n = h[0], i = h[1], s = h[2], o = h[3], c = u);
      var d, y, g, v, m, C, E;
      d = t[0] ^ e[0], y = t[a ? 3 : 1] ^ e[1], g = t[2] ^ e[2], v = t[a ? 1 : 3] ^ e[3];
      for (var S = 3, T = 1; T < p; ++T) m = n[d >>> 24] ^ i[y >>> 16 & 255] ^ s[g >>> 8 & 255] ^ o[255 & v] ^ e[++S], C = n[y >>> 24] ^ i[g >>> 16 & 255] ^ s[v >>> 8 & 255] ^ o[255 & d] ^ e[++S], E = n[g >>> 24] ^ i[v >>> 16 & 255] ^ s[d >>> 8 & 255] ^ o[255 & y] ^ e[++S], v = n[v >>> 24] ^ i[d >>> 16 & 255] ^ s[y >>> 8 & 255] ^ o[255 & g] ^ e[++S], d = m, y = C, g = E;
      r[0] = c[d >>> 24] << 24 ^ c[y >>> 16 & 255] << 16 ^ c[g >>> 8 & 255] << 8 ^ c[255 & v] ^ e[++S], r[a ? 3 : 1] = c[y >>> 24] << 24 ^ c[g >>> 16 & 255] << 16 ^ c[v >>> 8 & 255] << 8 ^ c[255 & d] ^ e[++S], r[2] = c[g >>> 24] << 24 ^ c[v >>> 16 & 255] << 16 ^ c[d >>> 8 & 255] << 8 ^ c[255 & y] ^ e[++S], r[a ? 1 : 3] = c[v >>> 24] << 24 ^ c[d >>> 16 & 255] << 16 ^ c[y >>> 8 & 255] << 8 ^ c[255 & g] ^ e[++S]
    }

    function o(e) {
      e = e || {};
      var t, r = (e.mode || "CBC").toUpperCase(),
        a = "AES-" + r;
      t = e.decrypt ? c.cipher.createDecipher(a, e.key) : c.cipher.createCipher(a, e.key);
      var n = t.start;
      return t.start = function (e, r) {
        var a = null;
        r instanceof c.util.ByteBuffer && (a = r, r = {}), r = r || {}, r.output = a, r.iv = e, n.call(t, r)
      }, t
    }
    var c = r(0);
    r(12), r(18), r(1), e.exports = c.aes = c.aes || {}, c.aes.startEncrypting = function (e, t, r, a) {
      var n = o({
        key: e,
        output: r,
        decrypt: !1,
        mode: a
      });
      return n.start(t), n
    }, c.aes.createEncryptionCipher = function (e, t) {
      return o({
        key: e,
        output: null,
        decrypt: !1,
        mode: t
      })
    }, c.aes.startDecrypting = function (e, t, r, a) {
      var n = o({
        key: e,
        output: r,
        decrypt: !0,
        mode: a
      });
      return n.start(t), n
    }, c.aes.createDecryptionCipher = function (e, t) {
      return o({
        key: e,
        output: null,
        decrypt: !0,
        mode: t
      })
    }, c.aes.Algorithm = function (e, t) {
      d || n();
      var r = this;
      r.name = e, r.mode = new t({
        blockSize: 16,
        cipher: {
          encrypt: function (e, t) {
            return s(r._w, e, t, !1)
          },
          decrypt: function (e, t) {
            return s(r._w, e, t, !0)
          }
        }
      }), r._init = !1
    }, c.aes.Algorithm.prototype.initialize = function (e) {
      if (!this._init) {
        var t, r = e.key;
        if ("string" != typeof r || 16 !== r.length && 24 !== r.length && 32 !== r.length) {
          if (c.util.isArray(r) && (16 === r.length || 24 === r.length || 32 === r.length)) {
            t = r, r = c.util.createBuffer();
            for (var a = 0; a < t.length; ++a) r.putByte(t[a])
          }
        } else r = c.util.createBuffer(r);
        if (!c.util.isArray(r)) {
          t = r, r = [];
          var n = t.length();
          if (16 === n || 24 === n || 32 === n) {
            n >>>= 2;
            for (var a = 0; a < n; ++a) r.push(t.getInt32())
          }
        }
        if (!c.util.isArray(r) || 4 !== r.length && 6 !== r.length && 8 !== r.length) throw new Error("Invalid key parameter.");
        var s = this.mode.name,
          o = ["CFB", "OFB", "CTR", "GCM"].indexOf(s) !== -1;
        this._w = i(r, e.decrypt && !o), this._init = !0
      }
    }, c.aes._expandKey = function (e, t) {
      return d || n(), i(e, t)
    }, c.aes._updateBlock = s, a("AES-ECB", c.cipher.modes.ecb), a("AES-CBC", c.cipher.modes.cbc), a("AES-CFB", c.cipher.modes.cfb), a("AES-OFB", c.cipher.modes.ofb), a("AES-CTR", c.cipher.modes.ctr), a("AES-GCM", c.cipher.modes.gcm);
    var u, l, p, h, f, d = !1,
      y = 4
  }, function (e, t, r) {
    function a(e, t) {
      s[e] = t, s[t] = e
    }

    function n(e, t) {
      s[e] = t
    }
    var i = r(0);
    i.pki = i.pki || {};
    var s = e.exports = i.pki.oids = i.oids = i.oids || {};
    a("1.2.840.113549.1.1.1", "rsaEncryption"), a("1.2.840.113549.1.1.4", "md5WithRSAEncryption"), a("1.2.840.113549.1.1.5", "sha1WithRSAEncryption"), a("1.2.840.113549.1.1.7", "RSAES-OAEP"), a("1.2.840.113549.1.1.8", "mgf1"), a("1.2.840.113549.1.1.9", "pSpecified"), a("1.2.840.113549.1.1.10", "RSASSA-PSS"), a("1.2.840.113549.1.1.11", "sha256WithRSAEncryption"), a("1.2.840.113549.1.1.12", "sha384WithRSAEncryption"), a("1.2.840.113549.1.1.13", "sha512WithRSAEncryption"), a("1.3.14.3.2.7", "desCBC"), a("1.3.14.3.2.26", "sha1"), a("2.16.840.1.101.3.4.2.1", "sha256"), a("2.16.840.1.101.3.4.2.2", "sha384"), a("2.16.840.1.101.3.4.2.3", "sha512"), a("1.2.840.113549.2.5", "md5"), a("1.2.840.113549.1.7.1", "data"), a("1.2.840.113549.1.7.2", "signedData"), a("1.2.840.113549.1.7.3", "envelopedData"), a("1.2.840.113549.1.7.4", "signedAndEnvelopedData"), a("1.2.840.113549.1.7.5", "digestedData"), a("1.2.840.113549.1.7.6", "encryptedData"), a("1.2.840.113549.1.9.1", "emailAddress"), a("1.2.840.113549.1.9.2", "unstructuredName"), a("1.2.840.113549.1.9.3", "contentType"), a("1.2.840.113549.1.9.4", "messageDigest"), a("1.2.840.113549.1.9.5", "signingTime"), a("1.2.840.113549.1.9.6", "counterSignature"), a("1.2.840.113549.1.9.7", "challengePassword"), a("1.2.840.113549.1.9.8", "unstructuredAddress"), a("1.2.840.113549.1.9.14", "extensionRequest"), a("1.2.840.113549.1.9.20", "friendlyName"), a("1.2.840.113549.1.9.21", "localKeyId"), a("1.2.840.113549.1.9.22.1", "x509Certificate"), a("1.2.840.113549.1.12.10.1.1", "keyBag"), a("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag"), a("1.2.840.113549.1.12.10.1.3", "certBag"), a("1.2.840.113549.1.12.10.1.4", "crlBag"), a("1.2.840.113549.1.12.10.1.5", "secretBag"), a("1.2.840.113549.1.12.10.1.6", "safeContentsBag"), a("1.2.840.113549.1.5.13", "pkcs5PBES2"), a("1.2.840.113549.1.5.12", "pkcs5PBKDF2"), a("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4"), a("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4"), a("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC"), a("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC"), a("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC"), a("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC"), a("1.2.840.113549.2.7", "hmacWithSHA1"), a("1.2.840.113549.2.8", "hmacWithSHA224"), a("1.2.840.113549.2.9", "hmacWithSHA256"), a("1.2.840.113549.2.10", "hmacWithSHA384"), a("1.2.840.113549.2.11", "hmacWithSHA512"), a("1.2.840.113549.3.7", "des-EDE3-CBC"), a("2.16.840.1.101.3.4.1.2", "aes128-CBC"), a("2.16.840.1.101.3.4.1.22", "aes192-CBC"), a("2.16.840.1.101.3.4.1.42", "aes256-CBC"), a("2.5.4.3", "commonName"), a("2.5.4.5", "serialName"), a("2.5.4.6", "countryName"), a("2.5.4.7", "localityName"), a("2.5.4.8", "stateOrProvinceName"), a("2.5.4.10", "organizationName"), a("2.5.4.11", "organizationalUnitName"), a("2.16.840.1.113730.1.1", "nsCertType"), n("2.5.29.1", "authorityKeyIdentifier"), n("2.5.29.2", "keyAttributes"), n("2.5.29.3", "certificatePolicies"), n("2.5.29.4", "keyUsageRestriction"), n("2.5.29.5", "policyMapping"), n("2.5.29.6", "subtreesConstraint"), n("2.5.29.7", "subjectAltName"), n("2.5.29.8", "issuerAltName"), n("2.5.29.9", "subjectDirectoryAttributes"), n("2.5.29.10", "basicConstraints"), n("2.5.29.11", "nameConstraints"), n("2.5.29.12", "policyConstraints"), n("2.5.29.13", "basicConstraints"), a("2.5.29.14", "subjectKeyIdentifier"), a("2.5.29.15", "keyUsage"), n("2.5.29.16", "privateKeyUsagePeriod"), a("2.5.29.17", "subjectAltName"), a("2.5.29.18", "issuerAltName"), a("2.5.29.19", "basicConstraints"), n("2.5.29.20", "cRLNumber"), n("2.5.29.21", "cRLReason"), n("2.5.29.22", "expirationDate"), n("2.5.29.23", "instructionCode"), n("2.5.29.24", "invalidityDate"), n("2.5.29.25", "cRLDistributionPoints"), n("2.5.29.26", "issuingDistributionPoint"), n("2.5.29.27", "deltaCRLIndicator"), n("2.5.29.28", "issuingDistributionPoint"), n("2.5.29.29", "certificateIssuer"), n("2.5.29.30", "nameConstraints"), a("2.5.29.31", "cRLDistributionPoints"), a("2.5.29.32", "certificatePolicies"), n("2.5.29.33", "policyMappings"), n("2.5.29.34", "policyConstraints"), a("2.5.29.35", "authorityKeyIdentifier"), n("2.5.29.36", "policyConstraints"), a("2.5.29.37", "extKeyUsage"), n("2.5.29.46", "freshestCRL"), n("2.5.29.54", "inhibitAnyPolicy"), a("1.3.6.1.4.1.11129.2.4.2", "timestampList"), a("1.3.6.1.5.5.7.1.1", "authorityInfoAccess"), a("1.3.6.1.5.5.7.3.1", "serverAuth"), a("1.3.6.1.5.5.7.3.2", "clientAuth"), a("1.3.6.1.5.5.7.3.3", "codeSigning"), a("1.3.6.1.5.5.7.3.4", "emailProtection"), a("1.3.6.1.5.5.7.3.8", "timeStamping")
  }, function (e, t, r) {
    function a(e) {
      for (var t = e.name + ": ", r = [], a = function (e, t) {
          return " " + t
        }, n = 0; n < e.values.length; ++n) r.push(e.values[n].replace(/^(\S+\r\n)/, a));
      t += r.join(",") + "\r\n";
      for (var i = 0, s = -1, n = 0; n < t.length; ++n, ++i)
        if (i > 65 && s !== -1) {
          var o = t[s];
          "," === o ? (++s, t = t.substr(0, s) + "\r\n " + t.substr(s)) : t = t.substr(0, s) + "\r\n" + o + t.substr(s + 1), i = n - s - 1, s = -1, ++n
        } else " " !== t[n] && "\t" !== t[n] && "," !== t[n] || (s = n);
      return t
    }

    function n(e) {
      return e.replace(/^\s+/, "")
    }
    var i = r(0);
    r(1);
    var s = e.exports = i.pem = i.pem || {};
    s.encode = function (e, t) {
      t = t || {};
      var r, n = "-----BEGIN " + e.type + "-----\r\n";
      if (e.procType && (r = {
          name: "Proc-Type",
          values: [String(e.procType.version), e.procType.type]
        }, n += a(r)), e.contentDomain && (r = {
          name: "Content-Domain",
          values: [e.contentDomain]
        }, n += a(r)), e.dekInfo && (r = {
          name: "DEK-Info",
          values: [e.dekInfo.algorithm]
        }, e.dekInfo.parameters && r.values.push(e.dekInfo.parameters), n += a(r)), e.headers)
        for (var s = 0; s < e.headers.length; ++s) n += a(e.headers[s]);
      return e.procType && (n += "\r\n"), n += i.util.encode64(e.body, t.maxline || 64) + "\r\n", n += "-----END " + e.type + "-----\r\n"
    }, s.decode = function (e) {
      for (var t, r = [], a = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, s = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, o = /\r?\n/;;) {
        if (t = a.exec(e), !t) break;
        var c = {
          type: t[1],
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: i.util.decode64(t[3])
        };
        if (r.push(c), t[2]) {
          for (var u = t[2].split(o), l = 0; t && l < u.length;) {
            for (var p = u[l].replace(/\s+$/, ""), h = l + 1; h < u.length; ++h) {
              var f = u[h];
              if (!/\s/.test(f[0])) break;
              p += f, l = h
            }
            if (t = p.match(s)) {
              for (var d = {
                  name: t[1],
                  values: []
                }, y = t[2].split(","), g = 0; g < y.length; ++g) d.values.push(n(y[g]));
              if (c.procType)
                if (c.contentDomain || "Content-Domain" !== d.name)
                  if (c.dekInfo || "DEK-Info" !== d.name) c.headers.push(d);
                  else {
                    if (0 === d.values.length) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                    c.dekInfo = {
                      algorithm: y[0],
                      parameters: y[1] || null
                    }
                  }
              else c.contentDomain = y[0] || "";
              else {
                if ("Proc-Type" !== d.name) throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                if (2 !== d.values.length) throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                c.procType = {
                  version: y[0],
                  type: y[1]
                }
              }
            }++l
          }
          if ("ENCRYPTED" === c.procType && !c.dekInfo) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".')
        }
      }
      if (0 === r.length) throw new Error("Invalid PEM formatted message.");
      return r
    }
  }, function (e, t, r) {
    var a = r(0);
    r(4), r(1);
    var n = e.exports = a.hmac = a.hmac || {};
    n.create = function () {
      var e = null,
        t = null,
        r = null,
        n = null,
        i = {};
      return i.start = function (i, s) {
        if (null !== i)
          if ("string" == typeof i) {
            if (i = i.toLowerCase(), !(i in a.md.algorithms)) throw new Error('Unknown hash algorithm "' + i + '"');
            t = a.md.algorithms[i].create()
          } else t = i;
        if (null === s) s = e;
        else {
          if ("string" == typeof s) s = a.util.createBuffer(s);
          else if (a.util.isArray(s)) {
            var o = s;
            s = a.util.createBuffer();
            for (var c = 0; c < o.length; ++c) s.putByte(o[c])
          }
          var u = s.length();
          u > t.blockLength && (t.start(), t.update(s.bytes()), s = t.digest()), r = a.util.createBuffer(), n = a.util.createBuffer(), u = s.length();
          for (var c = 0; c < u; ++c) {
            var o = s.at(c);
            r.putByte(54 ^ o), n.putByte(92 ^ o)
          }
          if (u < t.blockLength)
            for (var o = t.blockLength - u, c = 0; c < o; ++c) r.putByte(54), n.putByte(92);
          e = s, r = r.bytes(), n = n.bytes()
        }
        t.start(), t.update(r)
      }, i.update = function (e) {
        t.update(e)
      }, i.getMac = function () {
        var e = t.digest().bytes();
        return t.start(), t.update(n), t.update(e), t.digest()
      }, i.digest = i.getMac, i
    }
  }, function (e, t, r) {
    function a() {
      o = String.fromCharCode(128), o += i.util.fillString(String.fromCharCode(0), 64), c = !0
    }

    function n(e, t, r) {
      for (var a, n, i, s, o, c, u, l, p = r.length(); p >= 64;) {
        for (n = e.h0, i = e.h1, s = e.h2, o = e.h3, c = e.h4, l = 0; l < 16; ++l) a = r.getInt32(), t[l] = a, u = o ^ i & (s ^ o), a = (n << 5 | n >>> 27) + u + c + 1518500249 + a, c = o, o = s, s = (i << 30 | i >>> 2) >>> 0, i = n, n = a;
        for (; l < 20; ++l) a = t[l - 3] ^ t[l - 8] ^ t[l - 14] ^ t[l - 16], a = a << 1 | a >>> 31, t[l] = a, u = o ^ i & (s ^ o), a = (n << 5 | n >>> 27) + u + c + 1518500249 + a, c = o, o = s, s = (i << 30 | i >>> 2) >>> 0, i = n, n = a;
        for (; l < 32; ++l) a = t[l - 3] ^ t[l - 8] ^ t[l - 14] ^ t[l - 16], a = a << 1 | a >>> 31, t[l] = a, u = i ^ s ^ o, a = (n << 5 | n >>> 27) + u + c + 1859775393 + a, c = o, o = s, s = (i << 30 | i >>> 2) >>> 0, i = n, n = a;
        for (; l < 40; ++l) a = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], a = a << 2 | a >>> 30, t[l] = a, u = i ^ s ^ o, a = (n << 5 | n >>> 27) + u + c + 1859775393 + a, c = o, o = s, s = (i << 30 | i >>> 2) >>> 0, i = n, n = a;
        for (; l < 60; ++l) a = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], a = a << 2 | a >>> 30, t[l] = a, u = i & s | o & (i ^ s), a = (n << 5 | n >>> 27) + u + c + 2400959708 + a, c = o, o = s, s = (i << 30 | i >>> 2) >>> 0, i = n, n = a;
        for (; l < 80; ++l) a = t[l - 6] ^ t[l - 16] ^ t[l - 28] ^ t[l - 32], a = a << 2 | a >>> 30, t[l] = a, u = i ^ s ^ o, a = (n << 5 | n >>> 27) + u + c + 3395469782 + a, c = o, o = s, s = (i << 30 | i >>> 2) >>> 0, i = n, n = a;
        e.h0 = e.h0 + n | 0, e.h1 = e.h1 + i | 0, e.h2 = e.h2 + s | 0, e.h3 = e.h3 + o | 0, e.h4 = e.h4 + c | 0, p -= 64
      }
    }
    var i = r(0);
    r(4), r(1);
    var s = e.exports = i.sha1 = i.sha1 || {};
    i.md.sha1 = i.md.algorithms.sha1 = s, s.create = function () {
      c || a();
      var e = null,
        t = i.util.createBuffer(),
        r = new Array(80),
        s = {
          algorithm: "sha1",
          blockLength: 64,
          digestLength: 20,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 8
        };
      return s.start = function () {
        s.messageLength = 0, s.fullMessageLength = s.messageLength64 = [];
        for (var r = s.messageLengthSize / 4, a = 0; a < r; ++a) s.fullMessageLength.push(0);
        return t = i.util.createBuffer(), e = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        }, s
      }, s.start(), s.update = function (a, o) {
        "utf8" === o && (a = i.util.encodeUtf8(a));
        var c = a.length;
        s.messageLength += c, c = [c / 4294967296 >>> 0, c >>> 0];
        for (var u = s.fullMessageLength.length - 1; u >= 0; --u) s.fullMessageLength[u] += c[1], c[1] = c[0] + (s.fullMessageLength[u] / 4294967296 >>> 0), s.fullMessageLength[u] = s.fullMessageLength[u] >>> 0, c[0] = c[1] / 4294967296 >>> 0;
        return t.putBytes(a), n(e, r, t), (t.read > 2048 || 0 === t.length()) && t.compact(), s
      }, s.digest = function () {
        var a = i.util.createBuffer();
        a.putBytes(t.bytes());
        var c = s.fullMessageLength[s.fullMessageLength.length - 1] + s.messageLengthSize,
          u = c & s.blockLength - 1;
        a.putBytes(o.substr(0, s.blockLength - u));
        for (var l, p, h = 8 * s.fullMessageLength[0], f = 0; f < s.fullMessageLength.length - 1; ++f) l = 8 * s.fullMessageLength[f + 1], p = l / 4294967296 >>> 0, h += p, a.putInt32(h >>> 0), h = l >>> 0;
        a.putInt32(h);
        var d = {
          h0: e.h0,
          h1: e.h1,
          h2: e.h2,
          h3: e.h3,
          h4: e.h4
        };
        n(d, r, a);
        var y = i.util.createBuffer();
        return y.putInt32(d.h0), y.putInt32(d.h1), y.putInt32(d.h2), y.putInt32(d.h3), y.putInt32(d.h4), y
      }, s
    };
    var o = null,
      c = !1
  }, function (e, t, r) {
    function a(e, t) {
      var r = function () {
        return new o.des.Algorithm(e, t)
      };
      o.cipher.registerAlgorithm(e, r)
    }

    function n(e) {
      for (var t, r = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], a = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], n = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], i = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], s = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], o = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], c = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], u = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], l = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], p = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], h = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], f = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], d = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], y = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], g = e.length() > 8 ? 3 : 1, v = [], m = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], C = 0, E = 0; E < g; E++) {
        var S = e.getInt32(),
          T = e.getInt32();
        t = 252645135 & (S >>> 4 ^ T), T ^= t, S ^= t << 4, t = 65535 & (T >>> -16 ^ S), S ^= t, T ^= t << -16, t = 858993459 & (S >>> 2 ^ T), T ^= t, S ^= t << 2, t = 65535 & (T >>> -16 ^ S), S ^= t, T ^= t << -16, t = 1431655765 & (S >>> 1 ^ T), T ^= t, S ^= t << 1, t = 16711935 & (T >>> 8 ^ S), S ^= t, T ^= t << 8, t = 1431655765 & (S >>> 1 ^ T), T ^= t, S ^= t << 1, t = S << 8 | T >>> 20 & 240, S = T << 24 | T << 8 & 16711680 | T >>> 8 & 65280 | T >>> 24 & 240, T = t;
        for (var I = 0; I < m.length; ++I) {
          m[I] ? (S = S << 2 | S >>> 26, T = T << 2 | T >>> 26) : (S = S << 1 | S >>> 27, T = T << 1 | T >>> 27), S &= -15, T &= -15;
          var A = r[S >>> 28] | a[S >>> 24 & 15] | n[S >>> 20 & 15] | i[S >>> 16 & 15] | s[S >>> 12 & 15] | o[S >>> 8 & 15] | c[S >>> 4 & 15],
            b = u[T >>> 28] | l[T >>> 24 & 15] | p[T >>> 20 & 15] | h[T >>> 16 & 15] | f[T >>> 12 & 15] | d[T >>> 8 & 15] | y[T >>> 4 & 15];
          t = 65535 & (b >>> 16 ^ A), v[C++] = A ^ t, v[C++] = b ^ t << 16
        }
      }
      return v
    }

    function i(e, t, r, a) {
      var n, i = 32 === e.length ? 3 : 9;
      n = 3 === i ? a ? [30, -2, -2] : [0, 32, 2] : a ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      var s, o = t[0],
        g = t[1];
      s = 252645135 & (o >>> 4 ^ g), g ^= s, o ^= s << 4, s = 65535 & (o >>> 16 ^ g), g ^= s, o ^= s << 16, s = 858993459 & (g >>> 2 ^ o), o ^= s, g ^= s << 2, s = 16711935 & (g >>> 8 ^ o), o ^= s, g ^= s << 8, s = 1431655765 & (o >>> 1 ^ g), g ^= s, o ^= s << 1, o = o << 1 | o >>> 31, g = g << 1 | g >>> 31;
      for (var v = 0; v < i; v += 3) {
        for (var m = n[v + 1], C = n[v + 2], E = n[v]; E != m; E += C) {
          var S = g ^ e[E],
            T = (g >>> 4 | g << 28) ^ e[E + 1];
          s = o, o = g, g = s ^ (u[S >>> 24 & 63] | p[S >>> 16 & 63] | f[S >>> 8 & 63] | y[63 & S] | c[T >>> 24 & 63] | l[T >>> 16 & 63] | h[T >>> 8 & 63] | d[63 & T])
        }
        s = o, o = g, g = s
      }
      o = o >>> 1 | o << 31, g = g >>> 1 | g << 31, s = 1431655765 & (o >>> 1 ^ g), g ^= s, o ^= s << 1, s = 16711935 & (g >>> 8 ^ o), o ^= s, g ^= s << 8, s = 858993459 & (g >>> 2 ^ o), o ^= s, g ^= s << 2, s = 65535 & (o >>> 16 ^ g), g ^= s, o ^= s << 16, s = 252645135 & (o >>> 4 ^ g), g ^= s, o ^= s << 4, r[0] = o, r[1] = g
    }

    function s(e) {
      e = e || {};
      var t, r = (e.mode || "CBC").toUpperCase(),
        a = "DES-" + r;
      t = e.decrypt ? o.cipher.createDecipher(a, e.key) : o.cipher.createCipher(a, e.key);
      var n = t.start;
      return t.start = function (e, r) {
        var a = null;
        r instanceof o.util.ByteBuffer && (a = r, r = {}), r = r || {}, r.output = a, r.iv = e, n.call(t, r)
      }, t
    }
    var o = r(0);
    r(12), r(18), r(1), e.exports = o.des = o.des || {}, o.des.startEncrypting = function (e, t, r, a) {
      var n = s({
        key: e,
        output: r,
        decrypt: !1,
        mode: a || (null === t ? "ECB" : "CBC")
      });
      return n.start(t), n
    }, o.des.createEncryptionCipher = function (e, t) {
      return s({
        key: e,
        output: null,
        decrypt: !1,
        mode: t
      })
    }, o.des.startDecrypting = function (e, t, r, a) {
      var n = s({
        key: e,
        output: r,
        decrypt: !0,
        mode: a || (null === t ? "ECB" : "CBC")
      });
      return n.start(t), n
    }, o.des.createDecryptionCipher = function (e, t) {
      return s({
        key: e,
        output: null,
        decrypt: !0,
        mode: t
      })
    }, o.des.Algorithm = function (e, t) {
      var r = this;
      r.name = e, r.mode = new t({
        blockSize: 8,
        cipher: {
          encrypt: function (e, t) {
            return i(r._keys, e, t, !1)
          },
          decrypt: function (e, t) {
            return i(r._keys, e, t, !0)
          }
        }
      }), r._init = !1
    }, o.des.Algorithm.prototype.initialize = function (e) {
      if (!this._init) {
        var t = o.util.createBuffer(e.key);
        if (0 === this.name.indexOf("3DES") && 24 !== t.length()) throw new Error("Invalid Triple-DES key size: " + 8 * t.length());
        this._keys = n(t), this._init = !0
      }
    }, a("DES-ECB", o.cipher.modes.ecb), a("DES-CBC", o.cipher.modes.cbc), a("DES-CFB", o.cipher.modes.cfb), a("DES-OFB", o.cipher.modes.ofb), a("DES-CTR", o.cipher.modes.ctr), a("3DES-ECB", o.cipher.modes.ecb), a("3DES-CBC", o.cipher.modes.cbc), a("3DES-CFB", o.cipher.modes.cfb), a("3DES-OFB", o.cipher.modes.ofb), a("3DES-CTR", o.cipher.modes.ctr);
    var c = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756],
      u = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344],
      l = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584],
      p = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928],
      h = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080],
      f = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312],
      d = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154],
      y = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696]
  }, function (e, t, r) {
    function a(e, t, r) {
      var a = p.util.createBuffer(),
        n = Math.ceil(t.n.bitLength() / 8);
      if (e.length > n - 11) {
        var i = new Error("Message is too long for PKCS#1 v1.5 padding.");
        throw i.length = e.length, i.max = n - 11, i
      }
      a.putByte(0), a.putByte(r);
      var s, o = n - 3 - e.length;
      if (0 === r || 1 === r) {
        s = 0 === r ? 0 : 255;
        for (var c = 0; c < o; ++c) a.putByte(s)
      } else
        for (; o > 0;) {
          for (var u = 0, l = p.random.getBytes(o), c = 0; c < o; ++c) s = l.charCodeAt(c), 0 === s ? ++u : a.putByte(s);
          o = u
        }
      return a.putByte(0), a.putBytes(e), a
    }

    function n(e, t, r, a) {
      var n = Math.ceil(t.n.bitLength() / 8),
        i = p.util.createBuffer(e),
        s = i.getByte(),
        o = i.getByte();
      if (0 !== s || r && 0 !== o && 1 !== o || !r && 2 != o || r && 0 === o && "undefined" == typeof a) throw new Error("Encryption block is invalid.");
      var c = 0;
      if (0 === o) {
        c = n - 3 - a;
        for (var u = 0; u < c; ++u)
          if (0 !== i.getByte()) throw new Error("Encryption block is invalid.")
      } else if (1 === o)
        for (c = 0; i.length() > 1;) {
          if (255 !== i.getByte()) {
            --i.read;
            break
          }++c
        } else if (2 === o)
          for (c = 0; i.length() > 1;) {
            if (0 === i.getByte()) {
              --i.read;
              break
            }++c
          }
      var l = i.getByte();
      if (0 !== l || c !== n - 3 - i.length()) throw new Error("Encryption block is invalid.");
      return i.getBytes()
    }

    function i(e, t, r) {
      function a() {
        n(e.pBits, function (t, a) {
          return t ? r(t) : (e.p = a, null !== e.q ? i(t, e.q) : void n(e.qBits, i))
        })
      }

      function n(e, t) {
        p.prime.generateProbablePrime(e, s, t)
      }

      function i(t, s) {
        if (t) return r(t);
        if (e.q = s, e.p.compareTo(e.q) < 0) {
          var o = e.p;
          e.p = e.q, e.q = o
        }
        if (0 !== e.p.subtract(h.ONE).gcd(e.e).compareTo(h.ONE)) return e.p = null, void a();
        if (0 !== e.q.subtract(h.ONE).gcd(e.e).compareTo(h.ONE)) return e.q = null, void n(e.qBits, i);
        if (e.p1 = e.p.subtract(h.ONE), e.q1 = e.q.subtract(h.ONE), e.phi = e.p1.multiply(e.q1), 0 !== e.phi.gcd(e.e).compareTo(h.ONE)) return e.p = e.q = null, void a();
        if (e.n = e.p.multiply(e.q), e.n.bitLength() !== e.bits) return e.q = null, void n(e.qBits, i);
        var c = e.e.modInverse(e.phi);
        e.keys = {
          privateKey: d.rsa.setPrivateKey(e.n, e.e, c, e.p, e.q, c.mod(e.p1), c.mod(e.q1), e.q.modInverse(e.p)),
          publicKey: d.rsa.setPublicKey(e.n, e.e)
        }, r(null, e.keys)
      }
      "function" == typeof t && (r = t, t = {}), t = t || {};
      var s = {
        algorithm: {
          name: t.algorithm || "PRIMEINC",
          options: {
            workers: t.workers || 2,
            workLoad: t.workLoad || 100,
            workerScript: t.workerScript
          }
        }
      };
      "prng" in t && (s.prng = t.prng), a()
    }

    function s(e) {
      var t = e.toString(16);
      t[0] >= "8" && (t = "00" + t);
      var r = p.util.hexToBytes(t);
      return r.length > 1 && (0 === r.charCodeAt(0) && 0 === (128 & r.charCodeAt(1)) || 255 === r.charCodeAt(0) && 128 === (128 & r.charCodeAt(1))) ? r.substr(1) : r
    }

    function o(e) {
      return e <= 100 ? 27 : e <= 150 ? 18 : e <= 200 ? 15 : e <= 250 ? 12 : e <= 300 ? 9 : e <= 350 ? 8 : e <= 400 ? 7 : e <= 500 ? 6 : e <= 600 ? 5 : e <= 800 ? 4 : e <= 1250 ? 3 : 2
    }

    function c(e) {
      return "undefined" != typeof window && "object" == typeof window.crypto && "object" == typeof window.crypto.subtle && "function" == typeof window.crypto.subtle[e];
    }

    function u(e) {
      return "undefined" != typeof window && "object" == typeof window.msCrypto && "object" == typeof window.msCrypto.subtle && "function" == typeof window.msCrypto.subtle[e]
    }

    function l(e) {
      for (var t = p.util.hexToBytes(e.toString(16)), r = new Uint8Array(t.length), a = 0; a < t.length; ++a) r[a] = t.charCodeAt(a);
      return r
    }
    var p = r(0);
    if (r(3), r(13), r(6), r(23), r(27), r(2), r(1), "undefined" == typeof h) var h = p.jsbn.BigInteger;
    var f = p.asn1;
    p.pki = p.pki || {}, e.exports = p.pki.rsa = p.rsa = p.rsa || {};
    var d = p.pki,
      y = [6, 4, 2, 4, 2, 4, 6, 2],
      g = {
        name: "PrivateKeyInfo",
        tagClass: f.Class.UNIVERSAL,
        type: f.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PrivateKeyInfo.version",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyVersion"
        }, {
          name: "PrivateKeyInfo.privateKeyAlgorithm",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: f.Class.UNIVERSAL,
            type: f.Type.OID,
            constructed: !1,
            capture: "privateKeyOid"
          }]
        }, {
          name: "PrivateKeyInfo",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.OCTETSTRING,
          constructed: !1,
          capture: "privateKey"
        }]
      },
      v = {
        name: "RSAPrivateKey",
        tagClass: f.Class.UNIVERSAL,
        type: f.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "RSAPrivateKey.version",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyVersion"
        }, {
          name: "RSAPrivateKey.modulus",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyModulus"
        }, {
          name: "RSAPrivateKey.publicExponent",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyPublicExponent"
        }, {
          name: "RSAPrivateKey.privateExponent",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyPrivateExponent"
        }, {
          name: "RSAPrivateKey.prime1",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyPrime1"
        }, {
          name: "RSAPrivateKey.prime2",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyPrime2"
        }, {
          name: "RSAPrivateKey.exponent1",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyExponent1"
        }, {
          name: "RSAPrivateKey.exponent2",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyExponent2"
        }, {
          name: "RSAPrivateKey.coefficient",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "privateKeyCoefficient"
        }]
      },
      m = {
        name: "RSAPublicKey",
        tagClass: f.Class.UNIVERSAL,
        type: f.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "RSAPublicKey.modulus",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "publicKeyModulus"
        }, {
          name: "RSAPublicKey.exponent",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.INTEGER,
          constructed: !1,
          capture: "publicKeyExponent"
        }]
      },
      C = p.pki.rsa.publicKeyValidator = {
        name: "SubjectPublicKeyInfo",
        tagClass: f.Class.UNIVERSAL,
        type: f.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "subjectPublicKeyInfo",
        value: [{
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: f.Class.UNIVERSAL,
            type: f.Type.OID,
            constructed: !1,
            capture: "publicKeyOid"
          }]
        }, {
          name: "SubjectPublicKeyInfo.subjectPublicKey",
          tagClass: f.Class.UNIVERSAL,
          type: f.Type.BITSTRING,
          constructed: !1,
          value: [{
            name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
            tagClass: f.Class.UNIVERSAL,
            type: f.Type.SEQUENCE,
            constructed: !0,
            optional: !0,
            captureAsn1: "rsaPublicKey"
          }]
        }]
      },
      E = function (e) {
        var t;
        if (!(e.algorithm in d.oids)) {
          var r = new Error("Unknown message digest algorithm.");
          throw r.algorithm = e.algorithm, r
        }
        t = d.oids[e.algorithm];
        var a = f.oidToDer(t).getBytes(),
          n = f.create(f.Class.UNIVERSAL, f.Type.SEQUENCE, !0, []),
          i = f.create(f.Class.UNIVERSAL, f.Type.SEQUENCE, !0, []);
        i.value.push(f.create(f.Class.UNIVERSAL, f.Type.OID, !1, a)), i.value.push(f.create(f.Class.UNIVERSAL, f.Type.NULL, !1, ""));
        var s = f.create(f.Class.UNIVERSAL, f.Type.OCTETSTRING, !1, e.digest().getBytes());
        return n.value.push(i), n.value.push(s), f.toDer(n).getBytes()
      },
      S = function (e, t, r) {
        if (r) return e.modPow(t.e, t.n);
        if (!t.p || !t.q) return e.modPow(t.d, t.n);
        t.dP || (t.dP = t.d.mod(t.p.subtract(h.ONE))), t.dQ || (t.dQ = t.d.mod(t.q.subtract(h.ONE))), t.qInv || (t.qInv = t.q.modInverse(t.p));
        var a;
        do a = new h(p.util.bytesToHex(p.random.getBytes(t.n.bitLength() / 8)), 16); while (a.compareTo(t.n) >= 0 || !a.gcd(t.n).equals(h.ONE));
        e = e.multiply(a.modPow(t.e, t.n)).mod(t.n);
        for (var n = e.mod(t.p).modPow(t.dP, t.p), i = e.mod(t.q).modPow(t.dQ, t.q); n.compareTo(i) < 0;) n = n.add(t.p);
        var s = n.subtract(i).multiply(t.qInv).mod(t.p).multiply(t.q).add(i);
        return s = s.multiply(a.modInverse(t.n)).mod(t.n)
      };
    d.rsa.encrypt = function (e, t, r) {
      var n, i = r,
        s = Math.ceil(t.n.bitLength() / 8);
      r !== !1 && r !== !0 ? (i = 2 === r, n = a(e, t, r)) : (n = p.util.createBuffer(), n.putBytes(e));
      for (var o = new h(n.toHex(), 16), c = S(o, t, i), u = c.toString(16), l = p.util.createBuffer(), f = s - Math.ceil(u.length / 2); f > 0;) l.putByte(0), --f;
      return l.putBytes(p.util.hexToBytes(u)), l.getBytes()
    }, d.rsa.decrypt = function (e, t, r, a) {
      var i = Math.ceil(t.n.bitLength() / 8);
      if (e.length !== i) {
        var s = new Error("Encrypted message length is invalid.");
        throw s.length = e.length, s.expected = i, s
      }
      var o = new h(p.util.createBuffer(e).toHex(), 16);
      if (o.compareTo(t.n) >= 0) throw new Error("Encrypted message is invalid.");
      for (var c = S(o, t, r), u = c.toString(16), l = p.util.createBuffer(), f = i - Math.ceil(u.length / 2); f > 0;) l.putByte(0), --f;
      return l.putBytes(p.util.hexToBytes(u)), a !== !1 ? n(l.getBytes(), t, r) : l.getBytes()
    }, d.rsa.createKeyPairGenerationState = function (e, t, r) {
      "string" == typeof e && (e = parseInt(e, 10)), e = e || 2048, r = r || {};
      var a, n = r.prng || p.random,
        i = {
          nextBytes: function (e) {
            for (var t = n.getBytesSync(e.length), r = 0; r < e.length; ++r) e[r] = t.charCodeAt(r)
          }
        },
        s = r.algorithm || "PRIMEINC";
      if ("PRIMEINC" !== s) throw new Error("Invalid key generation algorithm: " + s);
      return a = {
        algorithm: s,
        state: 0,
        bits: e,
        rng: i,
        eInt: t || 65537,
        e: new h(null),
        p: null,
        q: null,
        qBits: e >> 1,
        pBits: e - (e >> 1),
        pqState: 0,
        num: null,
        keys: null
      }, a.e.fromInt(a.eInt), a
    }, d.rsa.stepKeyPairGenerationState = function (e, t) {
      "algorithm" in e || (e.algorithm = "PRIMEINC");
      var r = new h(null);
      r.fromInt(30);
      for (var a, n = 0, i = function (e, t) {
          return e | t
        }, s = +new Date, c = 0; null === e.keys && (t <= 0 || c < t);) {
        if (0 === e.state) {
          var u = null === e.p ? e.pBits : e.qBits,
            l = u - 1;
          0 === e.pqState ? (e.num = new h(u, e.rng), e.num.testBit(l) || e.num.bitwiseTo(h.ONE.shiftLeft(l), i, e.num), e.num.dAddOffset(31 - e.num.mod(r).byteValue(), 0), n = 0, ++e.pqState) : 1 === e.pqState ? e.num.bitLength() > u ? e.pqState = 0 : e.num.isProbablePrime(o(e.num.bitLength())) ? ++e.pqState : e.num.dAddOffset(y[n++ % 8], 0) : 2 === e.pqState ? e.pqState = 0 === e.num.subtract(h.ONE).gcd(e.e).compareTo(h.ONE) ? 3 : 0 : 3 === e.pqState && (e.pqState = 0, null === e.p ? e.p = e.num : e.q = e.num, null !== e.p && null !== e.q && ++e.state, e.num = null)
        } else if (1 === e.state) e.p.compareTo(e.q) < 0 && (e.num = e.p, e.p = e.q, e.q = e.num), ++e.state;
        else if (2 === e.state) e.p1 = e.p.subtract(h.ONE), e.q1 = e.q.subtract(h.ONE), e.phi = e.p1.multiply(e.q1), ++e.state;
        else if (3 === e.state) 0 === e.phi.gcd(e.e).compareTo(h.ONE) ? ++e.state : (e.p = null, e.q = null, e.state = 0);
        else if (4 === e.state) e.n = e.p.multiply(e.q), e.n.bitLength() === e.bits ? ++e.state : (e.q = null, e.state = 0);
        else if (5 === e.state) {
          var p = e.e.modInverse(e.phi);
          e.keys = {
            privateKey: d.rsa.setPrivateKey(e.n, e.e, p, e.p, e.q, p.mod(e.p1), p.mod(e.q1), e.q.modInverse(e.p)),
            publicKey: d.rsa.setPublicKey(e.n, e.e)
          }
        }
        a = +new Date, c += a - s, s = a
      }
      return null !== e.keys
    }, d.rsa.generateKeyPair = function (e, t, r, a) {
      if (1 === arguments.length ? "object" == typeof e ? (r = e, e = void 0) : "function" == typeof e && (a = e, e = void 0) : 2 === arguments.length ? "number" == typeof e ? "function" == typeof t ? (a = t, t = void 0) : "number" != typeof t && (r = t, t = void 0) : (r = e, a = t, e = void 0, t = void 0) : 3 === arguments.length && ("number" == typeof t ? "function" == typeof r && (a = r, r = void 0) : (a = r, r = t, t = void 0)), r = r || {}, void 0 === e && (e = r.bits || 2048), void 0 === t && (t = r.e || 65537), !p.options.usePureJavaScript && a && e >= 256 && e <= 16384 && (65537 === t || 3 === t)) {
        if (c("generateKey") && c("exportKey")) return window.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: e,
          publicExponent: l(t),
          hash: {
            name: "SHA-256"
          }
        }, !0, ["sign", "verify"]).then(function (e) {
          return window.crypto.subtle.exportKey("pkcs8", e.privateKey)
        }).then(void 0, function (e) {
          a(e)
        }).then(function (e) {
          if (e) {
            var t = d.privateKeyFromAsn1(f.fromDer(p.util.createBuffer(e)));
            a(null, {
              privateKey: t,
              publicKey: d.setRsaPublicKey(t.n, t.e)
            })
          }
        });
        if (u("generateKey") && u("exportKey")) {
          var n = window.msCrypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: e,
            publicExponent: l(t),
            hash: {
              name: "SHA-256"
            }
          }, !0, ["sign", "verify"]);
          return n.oncomplete = function (e) {
            var t = e.target.result,
              r = window.msCrypto.subtle.exportKey("pkcs8", t.privateKey);
            r.oncomplete = function (e) {
              var t = e.target.result,
                r = d.privateKeyFromAsn1(f.fromDer(p.util.createBuffer(t)));
              a(null, {
                privateKey: r,
                publicKey: d.setRsaPublicKey(r.n, r.e)
              })
            }, r.onerror = function (e) {
              a(e)
            }
          }, void(n.onerror = function (e) {
            a(e)
          })
        }
      }
      var s = d.rsa.createKeyPairGenerationState(e, t, r);
      return a ? void i(s, r, a) : (d.rsa.stepKeyPairGenerationState(s, 0), s.keys)
    }, d.setRsaPublicKey = d.rsa.setPublicKey = function (e, t) {
      var r = {
        n: e,
        e: t
      };
      return r.encrypt = function (e, t, n) {
        if ("string" == typeof t ? t = t.toUpperCase() : void 0 === t && (t = "RSAES-PKCS1-V1_5"), "RSAES-PKCS1-V1_5" === t) t = {
          encode: function (e, t, r) {
            return a(e, t, 2).getBytes()
          }
        };
        else if ("RSA-OAEP" === t || "RSAES-OAEP" === t) t = {
          encode: function (e, t) {
            return p.pkcs1.encode_rsa_oaep(t, e, n)
          }
        };
        else if (["RAW", "NONE", "NULL", null].indexOf(t) !== -1) t = {
          encode: function (e) {
            return e
          }
        };
        else if ("string" == typeof t) throw new Error('Unsupported encryption scheme: "' + t + '".');
        var i = t.encode(e, r, !0);
        return d.rsa.encrypt(i, r, !0)
      }, r.verify = function (e, t, a) {
        "string" == typeof a ? a = a.toUpperCase() : void 0 === a && (a = "RSASSA-PKCS1-V1_5"), "RSASSA-PKCS1-V1_5" === a ? a = {
          verify: function (e, t) {
            t = n(t, r, !0);
            var a = f.fromDer(t);
            return e === a.value[1].value
          }
        } : "NONE" !== a && "NULL" !== a && null !== a || (a = {
          verify: function (e, t) {
            return t = n(t, r, !0), e === t
          }
        });
        var i = d.rsa.decrypt(t, r, !0, !1);
        return a.verify(e, i, r.n.bitLength())
      }, r
    }, d.setRsaPrivateKey = d.rsa.setPrivateKey = function (e, t, r, a, i, s, o, c) {
      var u = {
        n: e,
        e: t,
        d: r,
        p: a,
        q: i,
        dP: s,
        dQ: o,
        qInv: c
      };
      return u.decrypt = function (e, t, r) {
        "string" == typeof t ? t = t.toUpperCase() : void 0 === t && (t = "RSAES-PKCS1-V1_5");
        var a = d.rsa.decrypt(e, u, !1, !1);
        if ("RSAES-PKCS1-V1_5" === t) t = {
          decode: n
        };
        else if ("RSA-OAEP" === t || "RSAES-OAEP" === t) t = {
          decode: function (e, t) {
            return p.pkcs1.decode_rsa_oaep(t, e, r)
          }
        };
        else {
          if (["RAW", "NONE", "NULL", null].indexOf(t) === -1) throw new Error('Unsupported encryption scheme: "' + t + '".');
          t = {
            decode: function (e) {
              return e
            }
          }
        }
        return t.decode(a, u, !1)
      }, u.sign = function (e, t) {
        var r = !1;
        "string" == typeof t && (t = t.toUpperCase()), void 0 === t || "RSASSA-PKCS1-V1_5" === t ? (t = {
          encode: E
        }, r = 1) : "NONE" !== t && "NULL" !== t && null !== t || (t = {
          encode: function () {
            return e
          }
        }, r = 1);
        var a = t.encode(e, u.n.bitLength());
        return d.rsa.encrypt(a, u, r)
      }, u
    }, d.wrapRsaPrivateKey = function (e) {
      return f.create(f.Class.UNIVERSAL, f.Type.SEQUENCE, !0, [f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, f.integerToDer(0).getBytes()), f.create(f.Class.UNIVERSAL, f.Type.SEQUENCE, !0, [f.create(f.Class.UNIVERSAL, f.Type.OID, !1, f.oidToDer(d.oids.rsaEncryption).getBytes()), f.create(f.Class.UNIVERSAL, f.Type.NULL, !1, "")]), f.create(f.Class.UNIVERSAL, f.Type.OCTETSTRING, !1, f.toDer(e).getBytes())])
    }, d.privateKeyFromAsn1 = function (e) {
      var t = {},
        r = [];
      if (f.validate(e, g, t, r) && (e = f.fromDer(p.util.createBuffer(t.privateKey))), t = {}, r = [], !f.validate(e, v, t, r)) {
        var a = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        throw a.errors = r, a
      }
      var n, i, s, o, c, u, l, y;
      return n = p.util.createBuffer(t.privateKeyModulus).toHex(), i = p.util.createBuffer(t.privateKeyPublicExponent).toHex(), s = p.util.createBuffer(t.privateKeyPrivateExponent).toHex(), o = p.util.createBuffer(t.privateKeyPrime1).toHex(), c = p.util.createBuffer(t.privateKeyPrime2).toHex(), u = p.util.createBuffer(t.privateKeyExponent1).toHex(), l = p.util.createBuffer(t.privateKeyExponent2).toHex(), y = p.util.createBuffer(t.privateKeyCoefficient).toHex(), d.setRsaPrivateKey(new h(n, 16), new h(i, 16), new h(s, 16), new h(o, 16), new h(c, 16), new h(u, 16), new h(l, 16), new h(y, 16))
    }, d.privateKeyToAsn1 = d.privateKeyToRSAPrivateKey = function (e) {
      return f.create(f.Class.UNIVERSAL, f.Type.SEQUENCE, !0, [f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, f.integerToDer(0).getBytes()), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.n)), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.e)), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.d)), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.p)), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.q)), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.dP)), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.dQ)), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.qInv))])
    }, d.publicKeyFromAsn1 = function (e) {
      var t = {},
        r = [];
      if (f.validate(e, C, t, r)) {
        var a = f.derToOid(t.publicKeyOid);
        if (a !== d.oids.rsaEncryption) {
          var n = new Error("Cannot read public key. Unknown OID.");
          throw n.oid = a, n
        }
        e = t.rsaPublicKey
      }
      if (r = [], !f.validate(e, m, t, r)) {
        var n = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        throw n.errors = r, n
      }
      var i = p.util.createBuffer(t.publicKeyModulus).toHex(),
        s = p.util.createBuffer(t.publicKeyExponent).toHex();
      return d.setRsaPublicKey(new h(i, 16), new h(s, 16))
    }, d.publicKeyToAsn1 = d.publicKeyToSubjectPublicKeyInfo = function (e) {
      return f.create(f.Class.UNIVERSAL, f.Type.SEQUENCE, !0, [f.create(f.Class.UNIVERSAL, f.Type.SEQUENCE, !0, [f.create(f.Class.UNIVERSAL, f.Type.OID, !1, f.oidToDer(d.oids.rsaEncryption).getBytes()), f.create(f.Class.UNIVERSAL, f.Type.NULL, !1, "")]), f.create(f.Class.UNIVERSAL, f.Type.BITSTRING, !1, [d.publicKeyToRSAPublicKey(e)])])
    }, d.publicKeyToRSAPublicKey = function (e) {
      return f.create(f.Class.UNIVERSAL, f.Type.SEQUENCE, !0, [f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.n)), f.create(f.Class.UNIVERSAL, f.Type.INTEGER, !1, s(e.e))])
    }
  }, function (e, t, r) {
    var a = r(0);
    r(1), e.exports = a.cipher = a.cipher || {}, a.cipher.algorithms = a.cipher.algorithms || {}, a.cipher.createCipher = function (e, t) {
      var r = e;
      if ("string" == typeof r && (r = a.cipher.getAlgorithm(r), r && (r = r())), !r) throw new Error("Unsupported algorithm: " + e);
      return new a.cipher.BlockCipher({
        algorithm: r,
        key: t,
        decrypt: !1
      })
    }, a.cipher.createDecipher = function (e, t) {
      var r = e;
      if ("string" == typeof r && (r = a.cipher.getAlgorithm(r), r && (r = r())), !r) throw new Error("Unsupported algorithm: " + e);
      return new a.cipher.BlockCipher({
        algorithm: r,
        key: t,
        decrypt: !0
      })
    }, a.cipher.registerAlgorithm = function (e, t) {
      e = e.toUpperCase(), a.cipher.algorithms[e] = t
    }, a.cipher.getAlgorithm = function (e) {
      return e = e.toUpperCase(), e in a.cipher.algorithms ? a.cipher.algorithms[e] : null
    };
    var n = a.cipher.BlockCipher = function (e) {
      this.algorithm = e.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = e.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = e.decrypt, this.algorithm.initialize(e)
    };
    n.prototype.start = function (e) {
      e = e || {};
      var t = {};
      for (var r in e) t[r] = e[r];
      t.decrypt = this._decrypt, this._finish = !1, this._input = a.util.createBuffer(), this.output = e.output || a.util.createBuffer(), this.mode.start(t)
    }, n.prototype.update = function (e) {
      for (e && this._input.putBuffer(e); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;);
      this._input.compact()
    }, n.prototype.finish = function (e) {
      !e || "ECB" !== this.mode.name && "CBC" !== this.mode.name || (this.mode.pad = function (t) {
        return e(this.blockSize, t, !1)
      }, this.mode.unpad = function (t) {
        return e(this.blockSize, t, !0)
      });
      var t = {};
      return t.decrypt = this._decrypt, t.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, t)) && (this._finish = !0, this.update(), !(this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, t)) && !(this.mode.afterFinish && !this.mode.afterFinish(this.output, t)))
    }
  }, function (e, t, r) {
    function a(e, t, r) {
      this.data = [], null != e && ("number" == typeof e ? this.fromNumber(e, t, r) : null == t && "string" != typeof e ? this.fromString(e, 256) : this.fromString(e, t))
    }

    function n() {
      return new a(null)
    }

    function i(e, t, r, a, n, i) {
      for (; --i >= 0;) {
        var s = t * this.data[e++] + r.data[a] + n;
        n = Math.floor(s / 67108864), r.data[a++] = 67108863 & s
      }
      return n
    }

    function s(e, t, r, a, n, i) {
      for (var s = 32767 & t, o = t >> 15; --i >= 0;) {
        var c = 32767 & this.data[e],
          u = this.data[e++] >> 15,
          l = o * c + u * s;
        c = s * c + ((32767 & l) << 15) + r.data[a] + (1073741823 & n), n = (c >>> 30) + (l >>> 15) + o * u + (n >>> 30), r.data[a++] = 1073741823 & c
      }
      return n
    }

    function o(e, t, r, a, n, i) {
      for (var s = 16383 & t, o = t >> 14; --i >= 0;) {
        var c = 16383 & this.data[e],
          u = this.data[e++] >> 14,
          l = o * c + u * s;
        c = s * c + ((16383 & l) << 14) + r.data[a] + n, n = (c >> 28) + (l >> 14) + o * u, r.data[a++] = 268435455 & c
      }
      return n
    }

    function c(e) {
      return ct.charAt(e)
    }

    function u(e, t) {
      var r = ut[e.charCodeAt(t)];
      return null == r ? -1 : r
    }

    function l(e) {
      for (var t = this.t - 1; t >= 0; --t) e.data[t] = this.data[t];
      e.t = this.t, e.s = this.s
    }

    function p(e) {
      this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this.data[0] = e : e < -1 ? this.data[0] = e + this.DV : this.t = 0
    }

    function h(e) {
      var t = n();
      return t.fromInt(e), t
    }

    function f(e, t) {
      var r;
      if (16 == t) r = 4;
      else if (8 == t) r = 3;
      else if (256 == t) r = 8;
      else if (2 == t) r = 1;
      else if (32 == t) r = 5;
      else {
        if (4 != t) return void this.fromRadix(e, t);
        r = 2
      }
      this.t = 0, this.s = 0;
      for (var n = e.length, i = !1, s = 0; --n >= 0;) {
        var o = 8 == r ? 255 & e[n] : u(e, n);
        o < 0 ? "-" == e.charAt(n) && (i = !0) : (i = !1, 0 == s ? this.data[this.t++] = o : s + r > this.DB ? (this.data[this.t - 1] |= (o & (1 << this.DB - s) - 1) << s, this.data[this.t++] = o >> this.DB - s) : this.data[this.t - 1] |= o << s, s += r, s >= this.DB && (s -= this.DB))
      }
      8 == r && 0 != (128 & e[0]) && (this.s = -1, s > 0 && (this.data[this.t - 1] |= (1 << this.DB - s) - 1 << s)), this.clamp(), i && a.ZERO.subTo(this, this)
    }

    function d() {
      for (var e = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == e;) --this.t
    }

    function y(e) {
      if (this.s < 0) return "-" + this.negate().toString(e);
      var t;
      if (16 == e) t = 4;
      else if (8 == e) t = 3;
      else if (2 == e) t = 1;
      else if (32 == e) t = 5;
      else {
        if (4 != e) return this.toRadix(e);
        t = 2
      }
      var r, a = (1 << t) - 1,
        n = !1,
        i = "",
        s = this.t,
        o = this.DB - s * this.DB % t;
      if (s-- > 0)
        for (o < this.DB && (r = this.data[s] >> o) > 0 && (n = !0, i = c(r)); s >= 0;) o < t ? (r = (this.data[s] & (1 << o) - 1) << t - o, r |= this.data[--s] >> (o += this.DB - t)) : (r = this.data[s] >> (o -= t) & a, o <= 0 && (o += this.DB, --s)), r > 0 && (n = !0), n && (i += c(r));
      return n ? i : "0"
    }

    function g() {
      var e = n();
      return a.ZERO.subTo(this, e), e
    }

    function v() {
      return this.s < 0 ? this.negate() : this
    }

    function m(e) {
      var t = this.s - e.s;
      if (0 != t) return t;
      var r = this.t;
      if (t = r - e.t, 0 != t) return this.s < 0 ? -t : t;
      for (; --r >= 0;)
        if (0 != (t = this.data[r] - e.data[r])) return t;
      return 0
    }

    function C(e) {
      var t, r = 1;
      return 0 != (t = e >>> 16) && (e = t, r += 16), 0 != (t = e >> 8) && (e = t, r += 8), 0 != (t = e >> 4) && (e = t, r += 4), 0 != (t = e >> 2) && (e = t, r += 2), 0 != (t = e >> 1) && (e = t, r += 1), r
    }

    function E() {
      return this.t <= 0 ? 0 : this.DB * (this.t - 1) + C(this.data[this.t - 1] ^ this.s & this.DM)
    }

    function S(e, t) {
      var r;
      for (r = this.t - 1; r >= 0; --r) t.data[r + e] = this.data[r];
      for (r = e - 1; r >= 0; --r) t.data[r] = 0;
      t.t = this.t + e, t.s = this.s
    }

    function T(e, t) {
      for (var r = e; r < this.t; ++r) t.data[r - e] = this.data[r];
      t.t = Math.max(this.t - e, 0), t.s = this.s
    }

    function I(e, t) {
      var r, a = e % this.DB,
        n = this.DB - a,
        i = (1 << n) - 1,
        s = Math.floor(e / this.DB),
        o = this.s << a & this.DM;
      for (r = this.t - 1; r >= 0; --r) t.data[r + s + 1] = this.data[r] >> n | o, o = (this.data[r] & i) << a;
      for (r = s - 1; r >= 0; --r) t.data[r] = 0;
      t.data[s] = o, t.t = this.t + s + 1, t.s = this.s, t.clamp()
    }

    function A(e, t) {
      t.s = this.s;
      var r = Math.floor(e / this.DB);
      if (r >= this.t) return void(t.t = 0);
      var a = e % this.DB,
        n = this.DB - a,
        i = (1 << a) - 1;
      t.data[0] = this.data[r] >> a;
      for (var s = r + 1; s < this.t; ++s) t.data[s - r - 1] |= (this.data[s] & i) << n, t.data[s - r] = this.data[s] >> a;
      a > 0 && (t.data[this.t - r - 1] |= (this.s & i) << n), t.t = this.t - r, t.clamp()
    }

    function b(e, t) {
      for (var r = 0, a = 0, n = Math.min(e.t, this.t); r < n;) a += this.data[r] - e.data[r], t.data[r++] = a & this.DM, a >>= this.DB;
      if (e.t < this.t) {
        for (a -= e.s; r < this.t;) a += this.data[r], t.data[r++] = a & this.DM, a >>= this.DB;
        a += this.s
      } else {
        for (a += this.s; r < e.t;) a -= e.data[r], t.data[r++] = a & this.DM, a >>= this.DB;
        a -= e.s
      }
      t.s = a < 0 ? -1 : 0, a < -1 ? t.data[r++] = this.DV + a : a > 0 && (t.data[r++] = a), t.t = r, t.clamp()
    }

    function B(e, t) {
      var r = this.abs(),
        n = e.abs(),
        i = r.t;
      for (t.t = i + n.t; --i >= 0;) t.data[i] = 0;
      for (i = 0; i < n.t; ++i) t.data[i + r.t] = r.am(0, n.data[i], t, i, 0, r.t);
      t.s = 0, t.clamp(), this.s != e.s && a.ZERO.subTo(t, t)
    }

    function N(e) {
      for (var t = this.abs(), r = e.t = 2 * t.t; --r >= 0;) e.data[r] = 0;
      for (r = 0; r < t.t - 1; ++r) {
        var a = t.am(r, t.data[r], e, 2 * r, 0, 1);
        (e.data[r + t.t] += t.am(r + 1, 2 * t.data[r], e, 2 * r + 1, a, t.t - r - 1)) >= t.DV && (e.data[r + t.t] -= t.DV, e.data[r + t.t + 1] = 1)
      }
      e.t > 0 && (e.data[e.t - 1] += t.am(r, t.data[r], e, 2 * r, 0, 1)), e.s = 0, e.clamp()
    }

    function k(e, t, r) {
      var i = e.abs();
      if (!(i.t <= 0)) {
        var s = this.abs();
        if (s.t < i.t) return null != t && t.fromInt(0), void(null != r && this.copyTo(r));
        null == r && (r = n());
        var o = n(),
          c = this.s,
          u = e.s,
          l = this.DB - C(i.data[i.t - 1]);
        l > 0 ? (i.lShiftTo(l, o), s.lShiftTo(l, r)) : (i.copyTo(o), s.copyTo(r));
        var p = o.t,
          h = o.data[p - 1];
        if (0 != h) {
          var f = h * (1 << this.F1) + (p > 1 ? o.data[p - 2] >> this.F2 : 0),
            d = this.FV / f,
            y = (1 << this.F1) / f,
            g = 1 << this.F2,
            v = r.t,
            m = v - p,
            E = null == t ? n() : t;
          for (o.dlShiftTo(m, E), r.compareTo(E) >= 0 && (r.data[r.t++] = 1, r.subTo(E, r)), a.ONE.dlShiftTo(p, E), E.subTo(o, o); o.t < p;) o.data[o.t++] = 0;
          for (; --m >= 0;) {
            var S = r.data[--v] == h ? this.DM : Math.floor(r.data[v] * d + (r.data[v - 1] + g) * y);
            if ((r.data[v] += o.am(0, S, r, m, 0, p)) < S)
              for (o.dlShiftTo(m, E), r.subTo(E, r); r.data[v] < --S;) r.subTo(E, r)
          }
          null != t && (r.drShiftTo(p, t), c != u && a.ZERO.subTo(t, t)), r.t = p, r.clamp(), l > 0 && r.rShiftTo(l, r), c < 0 && a.ZERO.subTo(r, r)
        }
      }
    }

    function R(e) {
      var t = n();
      return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(a.ZERO) > 0 && e.subTo(t, t), t
    }

    function w(e) {
      this.m = e
    }

    function L(e) {
      return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e
    }

    function _(e) {
      return e
    }

    function U(e) {
      e.divRemTo(this.m, null, e)
    }

    function D(e, t, r) {
      e.multiplyTo(t, r), this.reduce(r)
    }

    function P(e, t) {
      e.squareTo(t), this.reduce(t)
    }

    function V() {
      if (this.t < 1) return 0;
      var e = this.data[0];
      if (0 == (1 & e)) return 0;
      var t = 3 & e;
      return t = t * (2 - (15 & e) * t) & 15, t = t * (2 - (255 & e) * t) & 255, t = t * (2 - ((65535 & e) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t
    }

    function O(e) {
      this.m = e, this.mp = e.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t
    }

    function x(e) {
      var t = n();
      return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(a.ZERO) > 0 && this.m.subTo(t, t), t
    }

    function K(e) {
      var t = n();
      return e.copyTo(t), this.reduce(t), t
    }

    function M(e) {
      for (; e.t <= this.mt2;) e.data[e.t++] = 0;
      for (var t = 0; t < this.m.t; ++t) {
        var r = 32767 & e.data[t],
          a = r * this.mpl + ((r * this.mph + (e.data[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
        for (r = t + this.m.t, e.data[r] += this.m.am(0, a, e, t, 0, this.m.t); e.data[r] >= e.DV;) e.data[r] -= e.DV, e.data[++r]++
      }
      e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e)
    }

    function F(e, t) {
      e.squareTo(t), this.reduce(t)
    }

    function q(e, t, r) {
      e.multiplyTo(t, r), this.reduce(r)
    }

    function j() {
      return 0 == (this.t > 0 ? 1 & this.data[0] : this.s)
    }

    function H(e, t) {
      if (e > 4294967295 || e < 1) return a.ONE;
      var r = n(),
        i = n(),
        s = t.convert(this),
        o = C(e) - 1;
      for (s.copyTo(r); --o >= 0;)
        if (t.sqrTo(r, i), (e & 1 << o) > 0) t.mulTo(i, s, r);
        else {
          var c = r;
          r = i, i = c
        } return t.revert(r)
    }

    function G(e, t) {
      var r;
      return r = e < 256 || t.isEven() ? new w(t) : new O(t), this.exp(e, r)
    }

    function Q() {
      var e = n();
      return this.copyTo(e), e
    }

    function z() {
      if (this.s < 0) {
        if (1 == this.t) return this.data[0] - this.DV;
        if (0 == this.t) return -1
      } else {
        if (1 == this.t) return this.data[0];
        if (0 == this.t) return 0
      }
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0]
    }

    function W() {
      return 0 == this.t ? this.s : this.data[0] << 24 >> 24
    }

    function X() {
      return 0 == this.t ? this.s : this.data[0] << 16 >> 16
    }

    function Y(e) {
      return Math.floor(Math.LN2 * this.DB / Math.log(e))
    }

    function Z() {
      return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this.data[0] <= 0 ? 0 : 1
    }

    function J(e) {
      if (null == e && (e = 10), 0 == this.signum() || e < 2 || e > 36) return "0";
      var t = this.chunkSize(e),
        r = Math.pow(e, t),
        a = h(r),
        i = n(),
        s = n(),
        o = "";
      for (this.divRemTo(a, i, s); i.signum() > 0;) o = (r + s.intValue()).toString(e).substr(1) + o, i.divRemTo(a, i, s);
      return s.intValue().toString(e) + o
    }

    function $(e, t) {
      this.fromInt(0), null == t && (t = 10);
      for (var r = this.chunkSize(t), n = Math.pow(t, r), i = !1, s = 0, o = 0, c = 0; c < e.length; ++c) {
        var l = u(e, c);
        l < 0 ? "-" == e.charAt(c) && 0 == this.signum() && (i = !0) : (o = t * o + l, ++s >= r && (this.dMultiply(n), this.dAddOffset(o, 0), s = 0, o = 0))
      }
      s > 0 && (this.dMultiply(Math.pow(t, s)), this.dAddOffset(o, 0)), i && a.ZERO.subTo(this, this)
    }

    function ee(e, t, r) {
      if ("number" == typeof t)
        if (e < 2) this.fromInt(1);
        else
          for (this.fromNumber(e, r), this.testBit(e - 1) || this.bitwiseTo(a.ONE.shiftLeft(e - 1), ce, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(t);) this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(a.ONE.shiftLeft(e - 1), this);
      else {
        var n = new Array,
          i = 7 & e;
        n.length = (e >> 3) + 1, t.nextBytes(n), i > 0 ? n[0] &= (1 << i) - 1 : n[0] = 0, this.fromString(n, 256)
      }
    }

    function te() {
      var e = this.t,
        t = new Array;
      t[0] = this.s;
      var r, a = this.DB - e * this.DB % 8,
        n = 0;
      if (e-- > 0)
        for (a < this.DB && (r = this.data[e] >> a) != (this.s & this.DM) >> a && (t[n++] = r | this.s << this.DB - a); e >= 0;) a < 8 ? (r = (this.data[e] & (1 << a) - 1) << 8 - a, r |= this.data[--e] >> (a += this.DB - 8)) : (r = this.data[e] >> (a -= 8) & 255, a <= 0 && (a += this.DB, --e)), 0 != (128 & r) && (r |= -256), 0 == n && (128 & this.s) != (128 & r) && ++n, (n > 0 || r != this.s) && (t[n++] = r);
      return t
    }

    function re(e) {
      return 0 == this.compareTo(e)
    }

    function ae(e) {
      return this.compareTo(e) < 0 ? this : e
    }

    function ne(e) {
      return this.compareTo(e) > 0 ? this : e
    }

    function ie(e, t, r) {
      var a, n, i = Math.min(e.t, this.t);
      for (a = 0; a < i; ++a) r.data[a] = t(this.data[a], e.data[a]);
      if (e.t < this.t) {
        for (n = e.s & this.DM, a = i; a < this.t; ++a) r.data[a] = t(this.data[a], n);
        r.t = this.t
      } else {
        for (n = this.s & this.DM, a = i; a < e.t; ++a) r.data[a] = t(n, e.data[a]);
        r.t = e.t
      }
      r.s = t(this.s, e.s), r.clamp()
    }

    function se(e, t) {
      return e & t
    }

    function oe(e) {
      var t = n();
      return this.bitwiseTo(e, se, t), t
    }

    function ce(e, t) {
      return e | t
    }

    function ue(e) {
      var t = n();
      return this.bitwiseTo(e, ce, t), t
    }

    function le(e, t) {
      return e ^ t
    }

    function pe(e) {
      var t = n();
      return this.bitwiseTo(e, le, t), t
    }

    function he(e, t) {
      return e & ~t
    }

    function fe(e) {
      var t = n();
      return this.bitwiseTo(e, he, t), t
    }

    function de() {
      for (var e = n(), t = 0; t < this.t; ++t) e.data[t] = this.DM & ~this.data[t];
      return e.t = this.t, e.s = ~this.s, e
    }

    function ye(e) {
      var t = n();
      return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t
    }

    function ge(e) {
      var t = n();
      return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t
    }

    function ve(e) {
      if (0 == e) return -1;
      var t = 0;
      return 0 == (65535 & e) && (e >>= 16, t += 16), 0 == (255 & e) && (e >>= 8, t += 8), 0 == (15 & e) && (e >>= 4, t += 4), 0 == (3 & e) && (e >>= 2, t += 2), 0 == (1 & e) && ++t, t
    }

    function me() {
      for (var e = 0; e < this.t; ++e)
        if (0 != this.data[e]) return e * this.DB + ve(this.data[e]);
      return this.s < 0 ? this.t * this.DB : -1
    }

    function Ce(e) {
      for (var t = 0; 0 != e;) e &= e - 1, ++t;
      return t
    }

    function Ee() {
      for (var e = 0, t = this.s & this.DM, r = 0; r < this.t; ++r) e += Ce(this.data[r] ^ t);
      return e
    }

    function Se(e) {
      var t = Math.floor(e / this.DB);
      return t >= this.t ? 0 != this.s : 0 != (this.data[t] & 1 << e % this.DB)
    }

    function Te(e, t) {
      var r = a.ONE.shiftLeft(e);
      return this.bitwiseTo(r, t, r), r
    }

    function Ie(e) {
      return this.changeBit(e, ce)
    }

    function Ae(e) {
      return this.changeBit(e, he)
    }

    function be(e) {
      return this.changeBit(e, le)
    }

    function Be(e, t) {
      for (var r = 0, a = 0, n = Math.min(e.t, this.t); r < n;) a += this.data[r] + e.data[r], t.data[r++] = a & this.DM, a >>= this.DB;
      if (e.t < this.t) {
        for (a += e.s; r < this.t;) a += this.data[r], t.data[r++] = a & this.DM, a >>= this.DB;
        a += this.s
      } else {
        for (a += this.s; r < e.t;) a += e.data[r], t.data[r++] = a & this.DM, a >>= this.DB;
        a += e.s
      }
      t.s = a < 0 ? -1 : 0, a > 0 ? t.data[r++] = a : a < -1 && (t.data[r++] = this.DV + a), t.t = r, t.clamp()
    }

    function Ne(e) {
      var t = n();
      return this.addTo(e, t), t
    }

    function ke(e) {
      var t = n();
      return this.subTo(e, t), t
    }

    function Re(e) {
      var t = n();
      return this.multiplyTo(e, t), t
    }

    function we(e) {
      var t = n();
      return this.divRemTo(e, t, null), t
    }

    function Le(e) {
      var t = n();
      return this.divRemTo(e, null, t), t
    }

    function _e(e) {
      var t = n(),
        r = n();
      return this.divRemTo(e, t, r), new Array(t, r)
    }

    function Ue(e) {
      this.data[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp()
    }

    function De(e, t) {
      if (0 != e) {
        for (; this.t <= t;) this.data[this.t++] = 0;
        for (this.data[t] += e; this.data[t] >= this.DV;) this.data[t] -= this.DV, ++t >= this.t && (this.data[this.t++] = 0), ++this.data[t]
      }
    }

    function Pe() {}

    function Ve(e) {
      return e
    }

    function Oe(e, t, r) {
      e.multiplyTo(t, r)
    }

    function xe(e, t) {
      e.squareTo(t)
    }

    function Ke(e) {
      return this.exp(e, new Pe)
    }

    function Me(e, t, r) {
      var a = Math.min(this.t + e.t, t);
      for (r.s = 0, r.t = a; a > 0;) r.data[--a] = 0;
      var n;
      for (n = r.t - this.t; a < n; ++a) r.data[a + this.t] = this.am(0, e.data[a], r, a, 0, this.t);
      for (n = Math.min(e.t, t); a < n; ++a) this.am(0, e.data[a], r, a, 0, t - a);
      r.clamp()
    }

    function Fe(e, t, r) {
      --t;
      var a = r.t = this.t + e.t - t;
      for (r.s = 0; --a >= 0;) r.data[a] = 0;
      for (a = Math.max(t - this.t, 0); a < e.t; ++a) r.data[this.t + a - t] = this.am(t - a, e.data[a], r, 0, 0, this.t + a - t);
      r.clamp(), r.drShiftTo(1, r)
    }

    function qe(e) {
      this.r2 = n(), this.q3 = n(), a.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e
    }

    function je(e) {
      if (e.s < 0 || e.t > 2 * this.m.t) return e.mod(this.m);
      if (e.compareTo(this.m) < 0) return e;
      var t = n();
      return e.copyTo(t), this.reduce(t), t
    }

    function He(e) {
      return e
    }

    function Ge(e) {
      for (e.drShiftTo(this.m.t - 1, this.r2), e.t > this.m.t + 1 && (e.t = this.m.t + 1, e.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); e.compareTo(this.r2) < 0;) e.dAddOffset(1, this.m.t + 1);
      for (e.subTo(this.r2, e); e.compareTo(this.m) >= 0;) e.subTo(this.m, e)
    }

    function Qe(e, t) {
      e.squareTo(t), this.reduce(t)
    }

    function ze(e, t, r) {
      e.multiplyTo(t, r), this.reduce(r)
    }

    function We(e, t) {
      var r, a, i = e.bitLength(),
        s = h(1);
      if (i <= 0) return s;
      r = i < 18 ? 1 : i < 48 ? 3 : i < 144 ? 4 : i < 768 ? 5 : 6, a = i < 8 ? new w(t) : t.isEven() ? new qe(t) : new O(t);
      var o = new Array,
        c = 3,
        u = r - 1,
        l = (1 << r) - 1;
      if (o[1] = a.convert(this), r > 1) {
        var p = n();
        for (a.sqrTo(o[1], p); c <= l;) o[c] = n(), a.mulTo(p, o[c - 2], o[c]), c += 2
      }
      var f, d, y = e.t - 1,
        g = !0,
        v = n();
      for (i = C(e.data[y]) - 1; y >= 0;) {
        for (i >= u ? f = e.data[y] >> i - u & l : (f = (e.data[y] & (1 << i + 1) - 1) << u - i, y > 0 && (f |= e.data[y - 1] >> this.DB + i - u)), c = r; 0 == (1 & f);) f >>= 1, --c;
        if ((i -= c) < 0 && (i += this.DB, --y), g) o[f].copyTo(s), g = !1;
        else {
          for (; c > 1;) a.sqrTo(s, v), a.sqrTo(v, s), c -= 2;
          c > 0 ? a.sqrTo(s, v) : (d = s, s = v, v = d), a.mulTo(v, o[f], s)
        }
        for (; y >= 0 && 0 == (e.data[y] & 1 << i);) a.sqrTo(s, v), d = s, s = v, v = d, --i < 0 && (i = this.DB - 1, --y)
      }
      return a.revert(s)
    }

    function Xe(e) {
      var t = this.s < 0 ? this.negate() : this.clone(),
        r = e.s < 0 ? e.negate() : e.clone();
      if (t.compareTo(r) < 0) {
        var a = t;
        t = r, r = a
      }
      var n = t.getLowestSetBit(),
        i = r.getLowestSetBit();
      if (i < 0) return t;
      for (n < i && (i = n), i > 0 && (t.rShiftTo(i, t), r.rShiftTo(i, r)); t.signum() > 0;)(n = t.getLowestSetBit()) > 0 && t.rShiftTo(n, t), (n = r.getLowestSetBit()) > 0 && r.rShiftTo(n, r), t.compareTo(r) >= 0 ? (t.subTo(r, t), t.rShiftTo(1, t)) : (r.subTo(t, r), r.rShiftTo(1, r));
      return i > 0 && r.lShiftTo(i, r), r
    }

    function Ye(e) {
      if (e <= 0) return 0;
      var t = this.DV % e,
        r = this.s < 0 ? e - 1 : 0;
      if (this.t > 0)
        if (0 == t) r = this.data[0] % e;
        else
          for (var a = this.t - 1; a >= 0; --a) r = (t * r + this.data[a]) % e;
      return r
    }

    function Ze(e) {
      var t = e.isEven();
      if (this.isEven() && t || 0 == e.signum()) return a.ZERO;
      for (var r = e.clone(), n = this.clone(), i = h(1), s = h(0), o = h(0), c = h(1); 0 != r.signum();) {
        for (; r.isEven();) r.rShiftTo(1, r), t ? (i.isEven() && s.isEven() || (i.addTo(this, i), s.subTo(e, s)), i.rShiftTo(1, i)) : s.isEven() || s.subTo(e, s), s.rShiftTo(1, s);
        for (; n.isEven();) n.rShiftTo(1, n), t ? (o.isEven() && c.isEven() || (o.addTo(this, o), c.subTo(e, c)), o.rShiftTo(1, o)) : c.isEven() || c.subTo(e, c), c.rShiftTo(1, c);
        r.compareTo(n) >= 0 ? (r.subTo(n, r), t && i.subTo(o, i), s.subTo(c, s)) : (n.subTo(r, n), t && o.subTo(i, o), c.subTo(s, c))
      }
      return 0 != n.compareTo(a.ONE) ? a.ZERO : c.compareTo(e) >= 0 ? c.subtract(e) : c.signum() < 0 ? (c.addTo(e, c), c.signum() < 0 ? c.add(e) : c) : c
    }

    function Je(e) {
      var t, r = this.abs();
      if (1 == r.t && r.data[0] <= lt[lt.length - 1]) {
        for (t = 0; t < lt.length; ++t)
          if (r.data[0] == lt[t]) return !0;
        return !1
      }
      if (r.isEven()) return !1;
      for (t = 1; t < lt.length;) {
        for (var a = lt[t], n = t + 1; n < lt.length && a < pt;) a *= lt[n++];
        for (a = r.modInt(a); t < n;)
          if (a % lt[t++] == 0) return !1
      }
      return r.millerRabin(e)
    }

    function $e(e) {
      var t = this.subtract(a.ONE),
        r = t.getLowestSetBit();
      if (r <= 0) return !1;
      for (var n, i = t.shiftRight(r), s = et(), o = 0; o < e; ++o) {
        do n = new a(this.bitLength(), s); while (n.compareTo(a.ONE) <= 0 || n.compareTo(t) >= 0);
        var c = n.modPow(i, this);
        if (0 != c.compareTo(a.ONE) && 0 != c.compareTo(t)) {
          for (var u = 1; u++ < r && 0 != c.compareTo(t);)
            if (c = c.modPowInt(2, this), 0 == c.compareTo(a.ONE)) return !1;
          if (0 != c.compareTo(t)) return !1
        }
      }
      return !0
    }

    function et() {
      return {
        nextBytes: function (e) {
          for (var t = 0; t < e.length; ++t) e[t] = Math.floor(256 * Math.random())
        }
      }
    }
    var tt = r(0);
    e.exports = tt.jsbn = tt.jsbn || {};
    var rt, at = 0xdeadbeefcafe,
      nt = 15715070 == (16777215 & at);
    tt.jsbn.BigInteger = a, "undefined" == typeof navigator ? (a.prototype.am = o, rt = 28) : nt && "Microsoft Internet Explorer" == navigator.appName ? (a.prototype.am = s, rt = 30) : nt && "Netscape" != navigator.appName ? (a.prototype.am = i, rt = 26) : (a.prototype.am = o, rt = 28), a.prototype.DB = rt, a.prototype.DM = (1 << rt) - 1, a.prototype.DV = 1 << rt;
    var it = 52;
    a.prototype.FV = Math.pow(2, it), a.prototype.F1 = it - rt, a.prototype.F2 = 2 * rt - it;
    var st, ot, ct = "0123456789abcdefghijklmnopqrstuvwxyz",
      ut = new Array;
    for (st = "0".charCodeAt(0), ot = 0; ot <= 9; ++ot) ut[st++] = ot;
    for (st = "a".charCodeAt(0), ot = 10; ot < 36; ++ot) ut[st++] = ot;
    for (st = "A".charCodeAt(0), ot = 10; ot < 36; ++ot) ut[st++] = ot;
    w.prototype.convert = L, w.prototype.revert = _, w.prototype.reduce = U, w.prototype.mulTo = D, w.prototype.sqrTo = P, O.prototype.convert = x, O.prototype.revert = K, O.prototype.reduce = M, O.prototype.mulTo = q, O.prototype.sqrTo = F, a.prototype.copyTo = l, a.prototype.fromInt = p,
      a.prototype.fromString = f, a.prototype.clamp = d, a.prototype.dlShiftTo = S, a.prototype.drShiftTo = T, a.prototype.lShiftTo = I, a.prototype.rShiftTo = A, a.prototype.subTo = b, a.prototype.multiplyTo = B, a.prototype.squareTo = N, a.prototype.divRemTo = k, a.prototype.invDigit = V, a.prototype.isEven = j, a.prototype.exp = H, a.prototype.toString = y, a.prototype.negate = g, a.prototype.abs = v, a.prototype.compareTo = m, a.prototype.bitLength = E, a.prototype.mod = R, a.prototype.modPowInt = G, a.ZERO = h(0), a.ONE = h(1), Pe.prototype.convert = Ve, Pe.prototype.revert = Ve, Pe.prototype.mulTo = Oe, Pe.prototype.sqrTo = xe, qe.prototype.convert = je, qe.prototype.revert = He, qe.prototype.reduce = Ge, qe.prototype.mulTo = ze, qe.prototype.sqrTo = Qe;
    var lt = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509],
      pt = (1 << 26) / lt[lt.length - 1];
    a.prototype.chunkSize = Y, a.prototype.toRadix = J, a.prototype.fromRadix = $, a.prototype.fromNumber = ee, a.prototype.bitwiseTo = ie, a.prototype.changeBit = Te, a.prototype.addTo = Be, a.prototype.dMultiply = Ue, a.prototype.dAddOffset = De, a.prototype.multiplyLowerTo = Me, a.prototype.multiplyUpperTo = Fe, a.prototype.modInt = Ye, a.prototype.millerRabin = $e, a.prototype.clone = Q, a.prototype.intValue = z, a.prototype.byteValue = W, a.prototype.shortValue = X, a.prototype.signum = Z, a.prototype.toByteArray = te, a.prototype.equals = re, a.prototype.min = ae, a.prototype.max = ne, a.prototype.and = oe, a.prototype.or = ue, a.prototype.xor = pe, a.prototype.andNot = fe, a.prototype.not = de, a.prototype.shiftLeft = ye, a.prototype.shiftRight = ge, a.prototype.getLowestSetBit = me, a.prototype.bitCount = Ee, a.prototype.testBit = Se, a.prototype.setBit = Ie, a.prototype.clearBit = Ae, a.prototype.flipBit = be, a.prototype.add = Ne, a.prototype.subtract = ke, a.prototype.multiply = Re, a.prototype.divide = we, a.prototype.remainder = Le, a.prototype.divideAndRemainder = _e, a.prototype.modPow = We, a.prototype.modInverse = Ze, a.prototype.pow = Ke, a.prototype.gcd = Xe, a.prototype.isProbablePrime = Je
  }, function (e, t, r) {
    function a() {
      o = String.fromCharCode(128), o += i.util.fillString(String.fromCharCode(0), 64), c = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9], u = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], l = new Array(64);
      for (var e = 0; e < 64; ++e) l[e] = Math.floor(4294967296 * Math.abs(Math.sin(e + 1)));
      p = !0
    }

    function n(e, t, r) {
      for (var a, n, i, s, o, p, h, f, d = r.length(); d >= 64;) {
        for (n = e.h0, i = e.h1, s = e.h2, o = e.h3, f = 0; f < 16; ++f) t[f] = r.getInt32Le(), p = o ^ i & (s ^ o), a = n + p + l[f] + t[f], h = u[f], n = o, o = s, s = i, i += a << h | a >>> 32 - h;
        for (; f < 32; ++f) p = s ^ o & (i ^ s), a = n + p + l[f] + t[c[f]], h = u[f], n = o, o = s, s = i, i += a << h | a >>> 32 - h;
        for (; f < 48; ++f) p = i ^ s ^ o, a = n + p + l[f] + t[c[f]], h = u[f], n = o, o = s, s = i, i += a << h | a >>> 32 - h;
        for (; f < 64; ++f) p = s ^ (i | ~o), a = n + p + l[f] + t[c[f]], h = u[f], n = o, o = s, s = i, i += a << h | a >>> 32 - h;
        e.h0 = e.h0 + n | 0, e.h1 = e.h1 + i | 0, e.h2 = e.h2 + s | 0, e.h3 = e.h3 + o | 0, d -= 64
      }
    }
    var i = r(0);
    r(4), r(1);
    var s = e.exports = i.md5 = i.md5 || {};
    i.md.md5 = i.md.algorithms.md5 = s, s.create = function () {
      p || a();
      var e = null,
        t = i.util.createBuffer(),
        r = new Array(16),
        s = {
          algorithm: "md5",
          blockLength: 64,
          digestLength: 16,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 8
        };
      return s.start = function () {
        s.messageLength = 0, s.fullMessageLength = s.messageLength64 = [];
        for (var r = s.messageLengthSize / 4, a = 0; a < r; ++a) s.fullMessageLength.push(0);
        return t = i.util.createBuffer(), e = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        }, s
      }, s.start(), s.update = function (a, o) {
        "utf8" === o && (a = i.util.encodeUtf8(a));
        var c = a.length;
        s.messageLength += c, c = [c / 4294967296 >>> 0, c >>> 0];
        for (var u = s.fullMessageLength.length - 1; u >= 0; --u) s.fullMessageLength[u] += c[1], c[1] = c[0] + (s.fullMessageLength[u] / 4294967296 >>> 0), s.fullMessageLength[u] = s.fullMessageLength[u] >>> 0, c[0] = c[1] / 4294967296 >>> 0;
        return t.putBytes(a), n(e, r, t), (t.read > 2048 || 0 === t.length()) && t.compact(), s
      }, s.digest = function () {
        var a = i.util.createBuffer();
        a.putBytes(t.bytes());
        var c = s.fullMessageLength[s.fullMessageLength.length - 1] + s.messageLengthSize,
          u = c & s.blockLength - 1;
        a.putBytes(o.substr(0, s.blockLength - u));
        for (var l, p = 0, h = s.fullMessageLength.length - 1; h >= 0; --h) l = 8 * s.fullMessageLength[h] + p, p = l / 4294967296 >>> 0, a.putInt32Le(l >>> 0);
        var f = {
          h0: e.h0,
          h1: e.h1,
          h2: e.h2,
          h3: e.h3
        };
        n(f, r, a);
        var d = i.util.createBuffer();
        return d.putInt32Le(f.h0), d.putInt32Le(f.h1), d.putInt32Le(f.h2), d.putInt32Le(f.h3), d
      }, s
    };
    var o = null,
      c = null,
      u = null,
      l = null,
      p = !1
  }, function (e, t, r) {
    var a = r(0);
    r(8), r(4), r(1);
    var n, i = a.pkcs5 = a.pkcs5 || {};
    a.util.isNodejs && !a.options.usePureJavaScript && (n = r(32)), e.exports = a.pbkdf2 = i.pbkdf2 = function (e, t, r, i, s, o) {
      function c() {
        return C > h ? o(null, m) : (d.start(null, null), d.update(t), d.update(a.util.int32ToBytes(C)), y = v = d.digest().getBytes(), E = 2, void u())
      }

      function u() {
        return E <= r ? (d.start(null, null), d.update(v), g = d.digest().getBytes(), y = a.util.xorBytes(y, g, l), v = g, ++E, a.util.setImmediate(u)) : (m += C < h ? y : y.substr(0, f), ++C, void c())
      }
      if ("function" == typeof s && (o = s, s = null), a.util.isNodejs && !a.options.usePureJavaScript && n.pbkdf2 && (null === s || "object" != typeof s) && (n.pbkdf2Sync.length > 4 || !s || "sha1" === s)) return "string" != typeof s && (s = "sha1"), e = new Buffer(e, "binary"), t = new Buffer(t, "binary"), o ? 4 === n.pbkdf2Sync.length ? n.pbkdf2(e, t, r, i, function (e, t) {
        return e ? o(e) : void o(null, t.toString("binary"))
      }) : n.pbkdf2(e, t, r, i, s, function (e, t) {
        return e ? o(e) : void o(null, t.toString("binary"))
      }) : 4 === n.pbkdf2Sync.length ? n.pbkdf2Sync(e, t, r, i).toString("binary") : n.pbkdf2Sync(e, t, r, i, s).toString("binary");
      if ("undefined" != typeof s && null !== s || (s = "sha1"), "string" == typeof s) {
        if (!(s in a.md.algorithms)) throw new Error("Unknown hash algorithm: " + s);
        s = a.md[s].create()
      }
      var l = s.digestLength;
      if (i > 4294967295 * l) {
        var p = new Error("Derived key is too long.");
        if (o) return o(p);
        throw p
      }
      var h = Math.ceil(i / l),
        f = i - (h - 1) * l,
        d = a.hmac.create();
      d.start(s, e);
      var y, g, v, m = "";
      if (!o) {
        for (var C = 1; C <= h; ++C) {
          d.start(null, null), d.update(t), d.update(a.util.int32ToBytes(C)), y = v = d.digest().getBytes();
          for (var E = 2; E <= r; ++E) d.start(null, null), d.update(v), g = d.digest().getBytes(), y = a.util.xorBytes(y, g, l), v = g;
          m += C < h ? y : y.substr(0, f)
        }
        return m
      }
      var E, C = 1;
      c()
    }
  }, function (e, t, r) {
    var a = r(0);
    r(2), r(1);
    var n = e.exports = a.pss = a.pss || {};
    n.create = function (e) {
      3 === arguments.length && (e = {
        md: arguments[0],
        mgf: arguments[1],
        saltLength: arguments[2]
      });
      var t = e.md,
        r = e.mgf,
        n = t.digestLength,
        i = e.salt || null;
      "string" == typeof i && (i = a.util.createBuffer(i));
      var s;
      if ("saltLength" in e) s = e.saltLength;
      else {
        if (null === i) throw new Error("Salt length not specified or specific salt not given.");
        s = i.length()
      }
      if (null !== i && i.length() !== s) throw new Error("Given salt length does not match length of given salt.");
      var o = e.prng || a.random,
        c = {};
      return c.encode = function (e, c) {
        var u, l = c - 1,
          p = Math.ceil(l / 8),
          h = e.digest().getBytes();
        if (p < n + s + 2) throw new Error("Message is too long to encrypt.");
        var f;
        f = null === i ? o.getBytesSync(s) : i.bytes();
        var d = new a.util.ByteBuffer;
        d.fillWithByte(0, 8), d.putBytes(h), d.putBytes(f), t.start(), t.update(d.getBytes());
        var y = t.digest().getBytes(),
          g = new a.util.ByteBuffer;
        g.fillWithByte(0, p - s - n - 2), g.putByte(1), g.putBytes(f);
        var v = g.getBytes(),
          m = p - n - 1,
          C = r.generate(y, m),
          E = "";
        for (u = 0; u < m; u++) E += String.fromCharCode(v.charCodeAt(u) ^ C.charCodeAt(u));
        var S = 65280 >> 8 * p - l & 255;
        return E = String.fromCharCode(E.charCodeAt(0) & ~S) + E.substr(1), E + y + String.fromCharCode(188)
      }, c.verify = function (e, i, o) {
        var c, u = o - 1,
          l = Math.ceil(u / 8);
        if (i = i.substr(-l), l < n + s + 2) throw new Error("Inconsistent parameters to PSS signature verification.");
        if (188 !== i.charCodeAt(l - 1)) throw new Error("Encoded message does not end in 0xBC.");
        var p = l - n - 1,
          h = i.substr(0, p),
          f = i.substr(p, n),
          d = 65280 >> 8 * l - u & 255;
        if (0 !== (h.charCodeAt(0) & d)) throw new Error("Bits beyond keysize not zero as expected.");
        var y = r.generate(f, p),
          g = "";
        for (c = 0; c < p; c++) g += String.fromCharCode(h.charCodeAt(c) ^ y.charCodeAt(c));
        g = String.fromCharCode(g.charCodeAt(0) & ~d) + g.substr(1);
        var v = l - n - s - 2;
        for (c = 0; c < v; c++)
          if (0 !== g.charCodeAt(c)) throw new Error("Leftmost octets not zero as expected");
        if (1 !== g.charCodeAt(v)) throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        var m = g.substr(-s),
          C = new a.util.ByteBuffer;
        C.fillWithByte(0, 8), C.putBytes(e), C.putBytes(m), t.start(), t.update(C.getBytes());
        var E = t.digest().getBytes();
        return f === E
      }, c
    }
  }, function (e, t, r) {
    function a(e, t) {
      "string" == typeof t && (t = {
        shortName: t
      });
      for (var r, a = null, n = 0; null === a && n < e.attributes.length; ++n) r = e.attributes[n], t.type && t.type === r.type ? a = r : t.name && t.name === r.name ? a = r : t.shortName && t.shortName === r.shortName && (a = r);
      return a
    }

    function n(e) {
      for (var t, r, a = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []), n = e.attributes, i = 0; i < n.length; ++i) {
        t = n[i];
        var s = t.value,
          o = l.Type.PRINTABLESTRING;
        "valueTagClass" in t && (o = t.valueTagClass, o === l.Type.UTF8 && (s = u.util.encodeUtf8(s))), r = l.create(l.Class.UNIVERSAL, l.Type.SET, !0, [l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(t.type).getBytes()), l.create(l.Class.UNIVERSAL, o, !1, s)])]), a.value.push(r)
      }
      return a
    }

    function i(e) {
      for (var t, r = 0; r < e.length; ++r) {
        if (t = e[r], "undefined" == typeof t.name && (t.type && t.type in p.oids ? t.name = p.oids[t.type] : t.shortName && t.shortName in f && (t.name = p.oids[f[t.shortName]])), "undefined" == typeof t.type) {
          if (!(t.name && t.name in p.oids)) {
            var a = new Error("Attribute type not specified.");
            throw a.attribute = t, a
          }
          t.type = p.oids[t.name]
        }
        if ("undefined" == typeof t.shortName && t.name && t.name in f && (t.shortName = f[t.name]), t.type === h.extensionRequest && (t.valueConstructed = !0, t.valueTagClass = l.Type.SEQUENCE, !t.value && t.extensions)) {
          t.value = [];
          for (var n = 0; n < t.extensions.length; ++n) t.value.push(p.certificateExtensionToAsn1(s(t.extensions[n])))
        }
        if ("undefined" == typeof t.value) {
          var a = new Error("Attribute value not specified.");
          throw a.attribute = t, a
        }
      }
    }

    function s(e, t) {
      if (t = t || {}, "undefined" == typeof e.name && e.id && e.id in p.oids && (e.name = p.oids[e.id]), "undefined" == typeof e.id) {
        if (!(e.name && e.name in p.oids)) {
          var r = new Error("Extension ID not specified.");
          throw r.extension = e, r
        }
        e.id = p.oids[e.name]
      }
      if ("undefined" != typeof e.value) return e;
      if ("keyUsage" === e.name) {
        var a = 0,
          i = 0,
          s = 0;
        e.digitalSignature && (i |= 128, a = 7), e.nonRepudiation && (i |= 64, a = 6), e.keyEncipherment && (i |= 32, a = 5), e.dataEncipherment && (i |= 16, a = 4), e.keyAgreement && (i |= 8, a = 3), e.keyCertSign && (i |= 4, a = 2), e.cRLSign && (i |= 2, a = 1), e.encipherOnly && (i |= 1, a = 0), e.decipherOnly && (s |= 128, a = 7);
        var o = String.fromCharCode(a);
        0 !== s ? o += String.fromCharCode(i) + String.fromCharCode(s) : 0 !== i && (o += String.fromCharCode(i)), e.value = l.create(l.Class.UNIVERSAL, l.Type.BITSTRING, !1, o)
      } else if ("basicConstraints" === e.name) e.value = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []), e.cA && e.value.value.push(l.create(l.Class.UNIVERSAL, l.Type.BOOLEAN, !1, String.fromCharCode(255))), "pathLenConstraint" in e && e.value.value.push(l.create(l.Class.UNIVERSAL, l.Type.INTEGER, !1, l.integerToDer(e.pathLenConstraint).getBytes()));
      else if ("extKeyUsage" === e.name) {
        e.value = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []);
        var c = e.value.value;
        for (var f in e) e[f] === !0 && (f in h ? c.push(l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(h[f]).getBytes())) : f.indexOf(".") !== -1 && c.push(l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(f).getBytes())))
      } else if ("nsCertType" === e.name) {
        var a = 0,
          i = 0;
        e.client && (i |= 128, a = 7), e.server && (i |= 64, a = 6), e.email && (i |= 32, a = 5), e.objsign && (i |= 16, a = 4), e.reserved && (i |= 8, a = 3), e.sslCA && (i |= 4, a = 2), e.emailCA && (i |= 2, a = 1), e.objCA && (i |= 1, a = 0);
        var o = String.fromCharCode(a);
        0 !== i && (o += String.fromCharCode(i)), e.value = l.create(l.Class.UNIVERSAL, l.Type.BITSTRING, !1, o)
      } else if ("subjectAltName" === e.name || "issuerAltName" === e.name) {
        e.value = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []);
        for (var d, y = 0; y < e.altNames.length; ++y) {
          d = e.altNames[y];
          var o = d.value;
          if (7 === d.type && d.ip) {
            if (o = u.util.bytesFromIP(d.ip), null === o) {
              var r = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              throw r.extension = e, r
            }
          } else 8 === d.type && (o = d.oid ? l.oidToDer(l.oidToDer(d.oid)) : l.oidToDer(o));
          e.value.value.push(l.create(l.Class.CONTEXT_SPECIFIC, d.type, !1, o))
        }
      } else if ("subjectKeyIdentifier" === e.name && t.cert) {
        var g = t.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = g.toHex(), e.value = l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, g.getBytes())
      } else if ("authorityKeyIdentifier" === e.name && t.cert) {
        e.value = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []);
        var c = e.value.value;
        if (e.keyIdentifier) {
          var v = e.keyIdentifier === !0 ? t.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          c.push(l.create(l.Class.CONTEXT_SPECIFIC, 0, !1, v))
        }
        if (e.authorityCertIssuer) {
          var m = [l.create(l.Class.CONTEXT_SPECIFIC, 4, !0, [n(e.authorityCertIssuer === !0 ? t.cert.issuer : e.authorityCertIssuer)])];
          c.push(l.create(l.Class.CONTEXT_SPECIFIC, 1, !0, m))
        }
        if (e.serialNumber) {
          var C = u.util.hexToBytes(e.serialNumber === !0 ? t.cert.serialNumber : e.serialNumber);
          c.push(l.create(l.Class.CONTEXT_SPECIFIC, 2, !1, C))
        }
      } else if ("cRLDistributionPoints" === e.name) {
        e.value = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []);
        for (var d, c = e.value.value, E = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []), S = l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, []), y = 0; y < e.altNames.length; ++y) {
          d = e.altNames[y];
          var o = d.value;
          if (7 === d.type && d.ip) {
            if (o = u.util.bytesFromIP(d.ip), null === o) {
              var r = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              throw r.extension = e, r
            }
          } else 8 === d.type && (o = d.oid ? l.oidToDer(l.oidToDer(d.oid)) : l.oidToDer(o));
          S.value.push(l.create(l.Class.CONTEXT_SPECIFIC, d.type, !1, o))
        }
        E.value.push(l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [S])), c.push(E)
      }
      if ("undefined" == typeof e.value) {
        var r = new Error("Extension value not specified.");
        throw r.extension = e, r
      }
      return e
    }

    function o(e, t) {
      switch (e) {
        case h["RSASSA-PSS"]:
          var r = [];
          return void 0 !== t.hash.algorithmOid && r.push(l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(t.hash.algorithmOid).getBytes()), l.create(l.Class.UNIVERSAL, l.Type.NULL, !1, "")])])), void 0 !== t.mgf.algorithmOid && r.push(l.create(l.Class.CONTEXT_SPECIFIC, 1, !0, [l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(t.mgf.algorithmOid).getBytes()), l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(t.mgf.hash.algorithmOid).getBytes()), l.create(l.Class.UNIVERSAL, l.Type.NULL, !1, "")])])])), void 0 !== t.saltLength && r.push(l.create(l.Class.CONTEXT_SPECIFIC, 2, !0, [l.create(l.Class.UNIVERSAL, l.Type.INTEGER, !1, l.integerToDer(t.saltLength).getBytes())])), l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, r);
        default:
          return l.create(l.Class.UNIVERSAL, l.Type.NULL, !1, "")
      }
    }

    function c(e) {
      var t = l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, []);
      if (0 === e.attributes.length) return t;
      for (var r = e.attributes, a = 0; a < r.length; ++a) {
        var n = r[a],
          i = n.value,
          s = l.Type.UTF8;
        "valueTagClass" in n && (s = n.valueTagClass), s === l.Type.UTF8 && (i = u.util.encodeUtf8(i));
        var o = !1;
        "valueConstructed" in n && (o = n.valueConstructed);
        var c = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(n.type).getBytes()), l.create(l.Class.UNIVERSAL, l.Type.SET, !0, [l.create(l.Class.UNIVERSAL, s, o, i)])]);
        t.value.push(c)
      }
      return t
    }
    var u = r(0);
    r(5), r(3), r(10), r(4), r(37), r(6), r(7), r(16), r(11), r(1);
    var l = u.asn1,
      p = e.exports = u.pki = u.pki || {},
      h = p.oids,
      f = {};
    f.CN = h.commonName, f.commonName = "CN", f.C = h.countryName, f.countryName = "C", f.L = h.localityName, f.localityName = "L", f.ST = h.stateOrProvinceName, f.stateOrProvinceName = "ST", f.O = h.organizationName, f.organizationName = "O", f.OU = h.organizationalUnitName, f.organizationalUnitName = "OU", f.E = h.emailAddress, f.emailAddress = "E";
    var d = u.pki.rsa.publicKeyValidator,
      y = {
        name: "Certificate",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "Certificate.TBSCertificate",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "tbsCertificate",
          value: [{
            name: "Certificate.TBSCertificate.version",
            tagClass: l.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: !0,
            optional: !0,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.INTEGER,
              constructed: !1,
              capture: "certVersion"
            }]
          }, {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.INTEGER,
            constructed: !1,
            capture: "certSerialNumber"
          }, {
            name: "Certificate.TBSCertificate.signature",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.OID,
              constructed: !1,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: l.Class.UNIVERSAL,
              optional: !0,
              captureAsn1: "certinfoSignatureParams"
            }]
          }, {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: "certIssuer"
          }, {
            name: "Certificate.TBSCertificate.validity",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.UTCTIME,
              constructed: !1,
              optional: !0,
              capture: "certValidity1UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.GENERALIZEDTIME,
              constructed: !1,
              optional: !0,
              capture: "certValidity2GeneralizedTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.UTCTIME,
              constructed: !1,
              optional: !0,
              capture: "certValidity3UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.GENERALIZEDTIME,
              constructed: !1,
              optional: !0,
              capture: "certValidity4GeneralizedTime"
            }]
          }, {
            name: "Certificate.TBSCertificate.subject",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: "certSubject"
          }, d, {
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: l.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: !0,
            optional: !0,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.BITSTRING,
              constructed: !1,
              captureBitStringValue: "certIssuerUniqueId"
            }]
          }, {
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: l.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: !0,
            optional: !0,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.BITSTRING,
              constructed: !1,
              captureBitStringValue: "certSubjectUniqueId"
            }]
          }, {
            name: "Certificate.TBSCertificate.extensions",
            tagClass: l.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: !0,
            captureAsn1: "certExtensions",
            optional: !0
          }]
        }, {
          name: "Certificate.signatureAlgorithm",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "Certificate.signatureAlgorithm.algorithm",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.OID,
            constructed: !1,
            capture: "certSignatureOid"
          }, {
            name: "Certificate.TBSCertificate.signature.parameters",
            tagClass: l.Class.UNIVERSAL,
            optional: !0,
            captureAsn1: "certSignatureParams"
          }]
        }, {
          name: "Certificate.signatureValue",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.BITSTRING,
          constructed: !1,
          captureBitStringValue: "certSignature"
        }]
      },
      g = {
        name: "rsapss",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "rsapss.hashAlgorithm",
          tagClass: l.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
            tagClass: l.Class.UNIVERSAL,
            type: l.Class.SEQUENCE,
            constructed: !0,
            optional: !0,
            value: [{
              name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.OID,
              constructed: !1,
              capture: "hashOid"
            }]
          }]
        }, {
          name: "rsapss.maskGenAlgorithm",
          tagClass: l.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: !0,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
            tagClass: l.Class.UNIVERSAL,
            type: l.Class.SEQUENCE,
            constructed: !0,
            optional: !0,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.OID,
              constructed: !1,
              capture: "maskGenOid"
            }, {
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.SEQUENCE,
              constructed: !0,
              value: [{
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                tagClass: l.Class.UNIVERSAL,
                type: l.Type.OID,
                constructed: !1,
                capture: "maskGenHashOid"
              }]
            }]
          }]
        }, {
          name: "rsapss.saltLength",
          tagClass: l.Class.CONTEXT_SPECIFIC,
          type: 2,
          optional: !0,
          value: [{
            name: "rsapss.saltLength.saltLength",
            tagClass: l.Class.UNIVERSAL,
            type: l.Class.INTEGER,
            constructed: !1,
            capture: "saltLength"
          }]
        }, {
          name: "rsapss.trailerField",
          tagClass: l.Class.CONTEXT_SPECIFIC,
          type: 3,
          optional: !0,
          value: [{
            name: "rsapss.trailer.trailer",
            tagClass: l.Class.UNIVERSAL,
            type: l.Class.INTEGER,
            constructed: !1,
            capture: "trailer"
          }]
        }]
      },
      v = {
        name: "CertificationRequestInfo",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certificationRequestInfo",
        value: [{
          name: "CertificationRequestInfo.integer",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.INTEGER,
          constructed: !1,
          capture: "certificationRequestInfoVersion"
        }, {
          name: "CertificationRequestInfo.subject",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "certificationRequestInfoSubject"
        }, d, {
          name: "CertificationRequestInfo.attributes",
          tagClass: l.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          optional: !0,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.OID,
              constructed: !1
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.SET,
              constructed: !0
            }]
          }]
        }]
      },
      m = {
        name: "CertificationRequest",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "csr",
        value: [v, {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.OID,
            constructed: !1,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: l.Class.UNIVERSAL,
            optional: !0,
            captureAsn1: "csrSignatureParams"
          }]
        }, {
          name: "CertificationRequest.signature",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.BITSTRING,
          constructed: !1,
          captureBitStringValue: "csrSignature"
        }]
      };
    p.RDNAttributesAsArray = function (e, t) {
      for (var r, a, n, i = [], s = 0; s < e.value.length; ++s) {
        r = e.value[s];
        for (var o = 0; o < r.value.length; ++o) n = {}, a = r.value[o], n.type = l.derToOid(a.value[0].value), n.value = a.value[1].value, n.valueTagClass = a.value[1].type, n.type in h && (n.name = h[n.type], n.name in f && (n.shortName = f[n.name])), t && (t.update(n.type), t.update(n.value)), i.push(n)
      }
      return i
    }, p.CRIAttributesAsArray = function (e) {
      for (var t = [], r = 0; r < e.length; ++r)
        for (var a = e[r], n = l.derToOid(a.value[0].value), i = a.value[1].value, s = 0; s < i.length; ++s) {
          var o = {};
          if (o.type = n, o.value = i[s].value, o.valueTagClass = i[s].type, o.type in h && (o.name = h[o.type], o.name in f && (o.shortName = f[o.name])), o.type === h.extensionRequest) {
            o.extensions = [];
            for (var c = 0; c < o.value.length; ++c) o.extensions.push(p.certificateExtensionFromAsn1(o.value[c]))
          }
          t.push(o)
        }
      return t
    };
    var C = function (e, t, r) {
      var a = {};
      if (e !== h["RSASSA-PSS"]) return a;
      r && (a = {
        hash: {
          algorithmOid: h.sha1
        },
        mgf: {
          algorithmOid: h.mgf1,
          hash: {
            algorithmOid: h.sha1
          }
        },
        saltLength: 20
      });
      var n = {},
        i = [];
      if (!l.validate(t, g, n, i)) {
        var s = new Error("Cannot read RSASSA-PSS parameter block.");
        throw s.errors = i, s
      }
      return void 0 !== n.hashOid && (a.hash = a.hash || {}, a.hash.algorithmOid = l.derToOid(n.hashOid)), void 0 !== n.maskGenOid && (a.mgf = a.mgf || {}, a.mgf.algorithmOid = l.derToOid(n.maskGenOid), a.mgf.hash = a.mgf.hash || {}, a.mgf.hash.algorithmOid = l.derToOid(n.maskGenHashOid)), void 0 !== n.saltLength && (a.saltLength = n.saltLength.charCodeAt(0)), a
    };
    p.certificateFromPem = function (e, t, r) {
      var a = u.pem.decode(e)[0];
      if ("CERTIFICATE" !== a.type && "X509 CERTIFICATE" !== a.type && "TRUSTED CERTIFICATE" !== a.type) {
        var n = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
        throw n.headerType = a.type, n
      }
      if (a.procType && "ENCRYPTED" === a.procType.type) throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
      var i = l.fromDer(a.body, r);
      return p.certificateFromAsn1(i, t)
    }, p.certificateToPem = function (e, t) {
      var r = {
        type: "CERTIFICATE",
        body: l.toDer(p.certificateToAsn1(e)).getBytes()
      };
      return u.pem.encode(r, {
        maxline: t
      })
    }, p.publicKeyFromPem = function (e) {
      var t = u.pem.decode(e)[0];
      if ("PUBLIC KEY" !== t.type && "RSA PUBLIC KEY" !== t.type) {
        var r = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        throw r.headerType = t.type, r
      }
      if (t.procType && "ENCRYPTED" === t.procType.type) throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      var a = l.fromDer(t.body);
      return p.publicKeyFromAsn1(a)
    }, p.publicKeyToPem = function (e, t) {
      var r = {
        type: "PUBLIC KEY",
        body: l.toDer(p.publicKeyToAsn1(e)).getBytes()
      };
      return u.pem.encode(r, {
        maxline: t
      })
    }, p.publicKeyToRSAPublicKeyPem = function (e, t) {
      var r = {
        type: "RSA PUBLIC KEY",
        body: l.toDer(p.publicKeyToRSAPublicKey(e)).getBytes()
      };
      return u.pem.encode(r, {
        maxline: t
      })
    }, p.getPublicKeyFingerprint = function (e, t) {
      t = t || {};
      var r, a = t.md || u.md.sha1.create(),
        n = t.type || "RSAPublicKey";
      switch (n) {
        case "RSAPublicKey":
          r = l.toDer(p.publicKeyToRSAPublicKey(e)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          r = l.toDer(p.publicKeyToAsn1(e)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + t.type + '".')
      }
      a.start(), a.update(r);
      var i = a.digest();
      if ("hex" === t.encoding) {
        var s = i.toHex();
        return t.delimiter ? s.match(/.{2}/g).join(t.delimiter) : s
      }
      if ("binary" === t.encoding) return i.getBytes();
      if (t.encoding) throw new Error('Unknown encoding "' + t.encoding + '".');
      return i
    }, p.certificationRequestFromPem = function (e, t, r) {
      var a = u.pem.decode(e)[0];
      if ("CERTIFICATE REQUEST" !== a.type) {
        var n = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        throw n.headerType = a.type, n
      }
      if (a.procType && "ENCRYPTED" === a.procType.type) throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      var i = l.fromDer(a.body, r);
      return p.certificationRequestFromAsn1(i, t)
    }, p.certificationRequestToPem = function (e, t) {
      var r = {
        type: "CERTIFICATE REQUEST",
        body: l.toDer(p.certificationRequestToAsn1(e)).getBytes()
      };
      return u.pem.encode(r, {
        maxline: t
      })
    }, p.createCertificate = function () {
      var e = {};
      return e.version = 2, e.serialNumber = "00", e.signatureOid = null, e.signature = null, e.siginfo = {}, e.siginfo.algorithmOid = null, e.validity = {}, e.validity.notBefore = new Date, e.validity.notAfter = new Date, e.issuer = {}, e.issuer.getField = function (t) {
        return a(e.issuer, t)
      }, e.issuer.addField = function (t) {
        i([t]), e.issuer.attributes.push(t)
      }, e.issuer.attributes = [], e.issuer.hash = null, e.subject = {}, e.subject.getField = function (t) {
        return a(e.subject, t)
      }, e.subject.addField = function (t) {
        i([t]), e.subject.attributes.push(t)
      }, e.subject.attributes = [], e.subject.hash = null, e.extensions = [], e.publicKey = null, e.md = null, e.setSubject = function (t, r) {
        i(t), e.subject.attributes = t, delete e.subject.uniqueId, r && (e.subject.uniqueId = r), e.subject.hash = null
      }, e.setIssuer = function (t, r) {
        i(t), e.issuer.attributes = t, delete e.issuer.uniqueId, r && (e.issuer.uniqueId = r), e.issuer.hash = null
      }, e.setExtensions = function (t) {
        for (var r = 0; r < t.length; ++r) s(t[r], {
          cert: e
        });
        e.extensions = t
      }, e.getExtension = function (t) {
        "string" == typeof t && (t = {
          name: t
        });
        for (var r, a = null, n = 0; null === a && n < e.extensions.length; ++n) r = e.extensions[n], t.id && r.id === t.id ? a = r : t.name && r.name === t.name && (a = r);
        return a
      }, e.sign = function (t, r) {
        e.md = r || u.md.sha1.create();
        var a = h[e.md.algorithm + "WithRSAEncryption"];
        if (!a) {
          var n = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          throw n.algorithm = e.md.algorithm, n
        }
        e.signatureOid = e.siginfo.algorithmOid = a, e.tbsCertificate = p.getTBSCertificate(e);
        var i = l.toDer(e.tbsCertificate);
        e.md.update(i.getBytes()), e.signature = t.sign(e.md)
      }, e.verify = function (t) {
        var r = !1;
        if (!e.issued(t)) {
          var a = t.issuer,
            n = e.subject,
            i = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
          throw i.expectedIssuer = a.attributes, i.actualIssuer = n.attributes, i
        }
        var s = t.md;
        if (null === s) {
          if (t.signatureOid in h) {
            var o = h[t.signatureOid];
            switch (o) {
              case "sha1WithRSAEncryption":
                s = u.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                s = u.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                s = u.md.sha256.create();
                break;
              case "sha512WithRSAEncryption":
                s = u.md.sha512.create();
                break;
              case "RSASSA-PSS":
                s = u.md.sha256.create()
            }
          }
          if (null === s) {
            var i = new Error("Could not compute certificate digest. Unknown signature OID.");
            throw i.signatureOid = t.signatureOid, i
          }
          var c = t.tbsCertificate || p.getTBSCertificate(t),
            f = l.toDer(c);
          s.update(f.getBytes())
        }
        if (null !== s) {
          var d;
          switch (t.signatureOid) {
            case h.sha1WithRSAEncryption:
              d = void 0;
              break;
            case h["RSASSA-PSS"]:
              var y, g;
              if (y = h[t.signatureParameters.mgf.hash.algorithmOid], void 0 === y || void 0 === u.md[y]) {
                var i = new Error("Unsupported MGF hash function.");
                throw i.oid = t.signatureParameters.mgf.hash.algorithmOid, i.name = y, i
              }
              if (g = h[t.signatureParameters.mgf.algorithmOid], void 0 === g || void 0 === u.mgf[g]) {
                var i = new Error("Unsupported MGF function.");
                throw i.oid = t.signatureParameters.mgf.algorithmOid, i.name = g, i
              }
              if (g = u.mgf[g].create(u.md[y].create()), y = h[t.signatureParameters.hash.algorithmOid], void 0 === y || void 0 === u.md[y]) throw {
                message: "Unsupported RSASSA-PSS hash function.",
                oid: t.signatureParameters.hash.algorithmOid,
                name: y
              };
              d = u.pss.create(u.md[y].create(), g, t.signatureParameters.saltLength)
          }
          r = e.publicKey.verify(s.digest().getBytes(), t.signature, d)
        }
        return r
      }, e.isIssuer = function (t) {
        var r = !1,
          a = e.issuer,
          n = t.subject;
        if (a.hash && n.hash) r = a.hash === n.hash;
        else if (a.attributes.length === n.attributes.length) {
          r = !0;
          for (var i, s, o = 0; r && o < a.attributes.length; ++o) i = a.attributes[o], s = n.attributes[o], i.type === s.type && i.value === s.value || (r = !1)
        }
        return r
      }, e.issued = function (t) {
        return t.isIssuer(e)
      }, e.generateSubjectKeyIdentifier = function () {
        return p.getPublicKeyFingerprint(e.publicKey, {
          type: "RSAPublicKey"
        })
      }, e.verifySubjectKeyIdentifier = function () {
        for (var t = h.subjectKeyIdentifier, r = 0; r < e.extensions.length; ++r) {
          var a = e.extensions[r];
          if (a.id === t) {
            var n = e.generateSubjectKeyIdentifier().getBytes();
            return u.util.hexToBytes(a.subjectKeyIdentifier) === n
          }
        }
        return !1
      }, e
    }, p.certificateFromAsn1 = function (e, t) {
      var r = {},
        n = [];
      if (!l.validate(e, y, r, n)) {
        var s = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        throw s.errors = n, s
      }
      var o = l.derToOid(r.publicKeyOid);
      if (o !== p.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
      var c = p.createCertificate();
      c.version = r.certVersion ? r.certVersion.charCodeAt(0) : 0;
      var f = u.util.createBuffer(r.certSerialNumber);
      c.serialNumber = f.toHex(), c.signatureOid = u.asn1.derToOid(r.certSignatureOid), c.signatureParameters = C(c.signatureOid, r.certSignatureParams, !0), c.siginfo.algorithmOid = u.asn1.derToOid(r.certinfoSignatureOid), c.siginfo.parameters = C(c.siginfo.algorithmOid, r.certinfoSignatureParams, !1), c.signature = r.certSignature;
      var d = [];
      if (void 0 !== r.certValidity1UTCTime && d.push(l.utcTimeToDate(r.certValidity1UTCTime)), void 0 !== r.certValidity2GeneralizedTime && d.push(l.generalizedTimeToDate(r.certValidity2GeneralizedTime)), void 0 !== r.certValidity3UTCTime && d.push(l.utcTimeToDate(r.certValidity3UTCTime)), void 0 !== r.certValidity4GeneralizedTime && d.push(l.generalizedTimeToDate(r.certValidity4GeneralizedTime)), d.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      if (d.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      if (c.validity.notBefore = d[0], c.validity.notAfter = d[1], c.tbsCertificate = r.tbsCertificate, t) {
        if (c.md = null, c.signatureOid in h) {
          var o = h[c.signatureOid];
          switch (o) {
            case "sha1WithRSAEncryption":
              c.md = u.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              c.md = u.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              c.md = u.md.sha256.create();
              break;
            case "sha512WithRSAEncryption":
              c.md = u.md.sha512.create();
              break;
            case "RSASSA-PSS":
              c.md = u.md.sha256.create()
          }
        }
        if (null === c.md) {
          var s = new Error("Could not compute certificate digest. Unknown signature OID.");
          throw s.signatureOid = c.signatureOid, s
        }
        var g = l.toDer(c.tbsCertificate);
        c.md.update(g.getBytes())
      }
      var v = u.md.sha1.create();
      c.issuer.getField = function (e) {
        return a(c.issuer, e)
      }, c.issuer.addField = function (e) {
        i([e]), c.issuer.attributes.push(e)
      }, c.issuer.attributes = p.RDNAttributesAsArray(r.certIssuer, v), r.certIssuerUniqueId && (c.issuer.uniqueId = r.certIssuerUniqueId), c.issuer.hash = v.digest().toHex();
      var m = u.md.sha1.create();
      return c.subject.getField = function (e) {
        return a(c.subject, e)
      }, c.subject.addField = function (e) {
        i([e]), c.subject.attributes.push(e)
      }, c.subject.attributes = p.RDNAttributesAsArray(r.certSubject, m), r.certSubjectUniqueId && (c.subject.uniqueId = r.certSubjectUniqueId), c.subject.hash = m.digest().toHex(), r.certExtensions ? c.extensions = p.certificateExtensionsFromAsn1(r.certExtensions) : c.extensions = [], c.publicKey = p.publicKeyFromAsn1(r.subjectPublicKeyInfo), c
    }, p.certificateExtensionsFromAsn1 = function (e) {
      for (var t = [], r = 0; r < e.value.length; ++r)
        for (var a = e.value[r], n = 0; n < a.value.length; ++n) t.push(p.certificateExtensionFromAsn1(a.value[n]));
      return t
    }, p.certificateExtensionFromAsn1 = function (e) {
      var t = {};
      if (t.id = l.derToOid(e.value[0].value), t.critical = !1, e.value[1].type === l.Type.BOOLEAN ? (t.critical = 0 !== e.value[1].value.charCodeAt(0), t.value = e.value[2].value) : t.value = e.value[1].value, t.id in h)
        if (t.name = h[t.id], "keyUsage" === t.name) {
          var r = l.fromDer(t.value),
            a = 0,
            n = 0;
          r.value.length > 1 && (a = r.value.charCodeAt(1), n = r.value.length > 2 ? r.value.charCodeAt(2) : 0), t.digitalSignature = 128 === (128 & a), t.nonRepudiation = 64 === (64 & a), t.keyEncipherment = 32 === (32 & a), t.dataEncipherment = 16 === (16 & a), t.keyAgreement = 8 === (8 & a), t.keyCertSign = 4 === (4 & a), t.cRLSign = 2 === (2 & a), t.encipherOnly = 1 === (1 & a), t.decipherOnly = 128 === (128 & n)
        } else if ("basicConstraints" === t.name) {
        var r = l.fromDer(t.value);
        r.value.length > 0 && r.value[0].type === l.Type.BOOLEAN ? t.cA = 0 !== r.value[0].value.charCodeAt(0) : t.cA = !1;
        var i = null;
        r.value.length > 0 && r.value[0].type === l.Type.INTEGER ? i = r.value[0].value : r.value.length > 1 && (i = r.value[1].value), null !== i && (t.pathLenConstraint = l.derToInteger(i))
      } else if ("extKeyUsage" === t.name)
        for (var r = l.fromDer(t.value), s = 0; s < r.value.length; ++s) {
          var o = l.derToOid(r.value[s].value);
          o in h ? t[h[o]] = !0 : t[o] = !0
        } else if ("nsCertType" === t.name) {
          var r = l.fromDer(t.value),
            a = 0;
          r.value.length > 1 && (a = r.value.charCodeAt(1)), t.client = 128 === (128 & a), t.server = 64 === (64 & a), t.email = 32 === (32 & a), t.objsign = 16 === (16 & a), t.reserved = 8 === (8 & a), t.sslCA = 4 === (4 & a), t.emailCA = 2 === (2 & a), t.objCA = 1 === (1 & a)
        } else if ("subjectAltName" === t.name || "issuerAltName" === t.name) {
        t.altNames = [];
        for (var c, r = l.fromDer(t.value), p = 0; p < r.value.length; ++p) {
          c = r.value[p];
          var f = {
            type: c.type,
            value: c.value
          };
          switch (t.altNames.push(f), c.type) {
            case 1:
            case 2:
            case 6:
              break;
            case 7:
              f.ip = u.util.bytesToIP(c.value);
              break;
            case 8:
              f.oid = l.derToOid(c.value)
          }
        }
      } else if ("subjectKeyIdentifier" === t.name) {
        var r = l.fromDer(t.value);
        t.subjectKeyIdentifier = u.util.bytesToHex(r.value)
      }
      return t
    }, p.certificationRequestFromAsn1 = function (e, t) {
      var r = {},
        n = [];
      if (!l.validate(e, m, r, n)) {
        var s = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        throw s.errors = n, s
      }
      var o = l.derToOid(r.publicKeyOid);
      if (o !== p.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
      var c = p.createCertificationRequest();
      if (c.version = r.csrVersion ? r.csrVersion.charCodeAt(0) : 0, c.signatureOid = u.asn1.derToOid(r.csrSignatureOid), c.signatureParameters = C(c.signatureOid, r.csrSignatureParams, !0), c.siginfo.algorithmOid = u.asn1.derToOid(r.csrSignatureOid), c.siginfo.parameters = C(c.siginfo.algorithmOid, r.csrSignatureParams, !1), c.signature = r.csrSignature, c.certificationRequestInfo = r.certificationRequestInfo, t) {
        if (c.md = null, c.signatureOid in h) {
          var o = h[c.signatureOid];
          switch (o) {
            case "sha1WithRSAEncryption":
              c.md = u.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              c.md = u.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              c.md = u.md.sha256.create();
              break;
            case "sha512WithRSAEncryption":
              c.md = u.md.sha512.create();
              break;
            case "RSASSA-PSS":
              c.md = u.md.sha256.create()
          }
        }
        if (null === c.md) {
          var s = new Error("Could not compute certification request digest. Unknown signature OID.");
          throw s.signatureOid = c.signatureOid, s
        }
        var f = l.toDer(c.certificationRequestInfo);
        c.md.update(f.getBytes())
      }
      var d = u.md.sha1.create();
      return c.subject.getField = function (e) {
        return a(c.subject, e)
      }, c.subject.addField = function (e) {
        i([e]), c.subject.attributes.push(e)
      }, c.subject.attributes = p.RDNAttributesAsArray(r.certificationRequestInfoSubject, d), c.subject.hash = d.digest().toHex(), c.publicKey = p.publicKeyFromAsn1(r.subjectPublicKeyInfo), c.getAttribute = function (e) {
        return a(c, e)
      }, c.addAttribute = function (e) {
        i([e]), c.attributes.push(e)
      }, c.attributes = p.CRIAttributesAsArray(r.certificationRequestInfoAttributes || []), c
    }, p.createCertificationRequest = function () {
      var e = {};
      return e.version = 0, e.signatureOid = null, e.signature = null, e.siginfo = {}, e.siginfo.algorithmOid = null, e.subject = {}, e.subject.getField = function (t) {
        return a(e.subject, t)
      }, e.subject.addField = function (t) {
        i([t]), e.subject.attributes.push(t)
      }, e.subject.attributes = [], e.subject.hash = null, e.publicKey = null, e.attributes = [], e.getAttribute = function (t) {
        return a(e, t)
      }, e.addAttribute = function (t) {
        i([t]), e.attributes.push(t)
      }, e.md = null, e.setSubject = function (t) {
        i(t), e.subject.attributes = t, e.subject.hash = null
      }, e.setAttributes = function (t) {
        i(t), e.attributes = t
      }, e.sign = function (t, r) {
        e.md = r || u.md.sha1.create();
        var a = h[e.md.algorithm + "WithRSAEncryption"];
        if (!a) {
          var n = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          throw n.algorithm = e.md.algorithm, n
        }
        e.signatureOid = e.siginfo.algorithmOid = a, e.certificationRequestInfo = p.getCertificationRequestInfo(e);
        var i = l.toDer(e.certificationRequestInfo);
        e.md.update(i.getBytes()), e.signature = t.sign(e.md)
      }, e.verify = function () {
        var t = !1,
          r = e.md;
        if (null === r) {
          if (e.signatureOid in h) {
            var a = h[e.signatureOid];
            switch (a) {
              case "sha1WithRSAEncryption":
                r = u.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                r = u.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                r = u.md.sha256.create();
                break;
              case "sha512WithRSAEncryption":
                r = u.md.sha512.create();
                break;
              case "RSASSA-PSS":
                r = u.md.sha256.create()
            }
          }
          if (null === r) {
            var n = new Error("Could not compute certification request digest. Unknown signature OID.");
            throw n.signatureOid = e.signatureOid, n
          }
          var i = e.certificationRequestInfo || p.getCertificationRequestInfo(e),
            s = l.toDer(i);
          r.update(s.getBytes())
        }
        if (null !== r) {
          var o;
          switch (e.signatureOid) {
            case h.sha1WithRSAEncryption:
              break;
            case h["RSASSA-PSS"]:
              var c, f;
              if (c = h[e.signatureParameters.mgf.hash.algorithmOid], void 0 === c || void 0 === u.md[c]) {
                var n = new Error("Unsupported MGF hash function.");
                throw n.oid = e.signatureParameters.mgf.hash.algorithmOid, n.name = c, n
              }
              if (f = h[e.signatureParameters.mgf.algorithmOid], void 0 === f || void 0 === u.mgf[f]) {
                var n = new Error("Unsupported MGF function.");
                throw n.oid = e.signatureParameters.mgf.algorithmOid, n.name = f, n
              }
              if (f = u.mgf[f].create(u.md[c].create()), c = h[e.signatureParameters.hash.algorithmOid], void 0 === c || void 0 === u.md[c]) {
                var n = new Error("Unsupported RSASSA-PSS hash function.");
                throw n.oid = e.signatureParameters.hash.algorithmOid, n.name = c, n
              }
              o = u.pss.create(u.md[c].create(), f, e.signatureParameters.saltLength)
          }
          t = e.publicKey.verify(r.digest().getBytes(), e.signature, o)
        }
        return t
      }, e
    }, p.getTBSCertificate = function (e) {
      var t = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [l.create(l.Class.UNIVERSAL, l.Type.INTEGER, !1, l.integerToDer(e.version).getBytes())]), l.create(l.Class.UNIVERSAL, l.Type.INTEGER, !1, u.util.hexToBytes(e.serialNumber)), l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(e.siginfo.algorithmOid).getBytes()), o(e.siginfo.algorithmOid, e.siginfo.parameters)]), n(e.issuer), l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.UTCTIME, !1, l.dateToUtcTime(e.validity.notBefore)), l.create(l.Class.UNIVERSAL, l.Type.UTCTIME, !1, l.dateToUtcTime(e.validity.notAfter))]), n(e.subject), p.publicKeyToAsn1(e.publicKey)]);
      return e.issuer.uniqueId && t.value.push(l.create(l.Class.CONTEXT_SPECIFIC, 1, !0, [l.create(l.Class.UNIVERSAL, l.Type.BITSTRING, !1, String.fromCharCode(0) + e.issuer.uniqueId)])), e.subject.uniqueId && t.value.push(l.create(l.Class.CONTEXT_SPECIFIC, 2, !0, [l.create(l.Class.UNIVERSAL, l.Type.BITSTRING, !1, String.fromCharCode(0) + e.subject.uniqueId)])), e.extensions.length > 0 && t.value.push(p.certificateExtensionsToAsn1(e.extensions)), t
    }, p.getCertificationRequestInfo = function (e) {
      var t = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.INTEGER, !1, l.integerToDer(e.version).getBytes()), n(e.subject), p.publicKeyToAsn1(e.publicKey), c(e)]);
      return t
    }, p.distinguishedNameToAsn1 = function (e) {
      return n(e)
    }, p.certificateToAsn1 = function (e) {
      var t = e.tbsCertificate || p.getTBSCertificate(e);
      return l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [t, l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(e.signatureOid).getBytes()), o(e.signatureOid, e.signatureParameters)]), l.create(l.Class.UNIVERSAL, l.Type.BITSTRING, !1, String.fromCharCode(0) + e.signature)])
    }, p.certificateExtensionsToAsn1 = function (e) {
      var t = l.create(l.Class.CONTEXT_SPECIFIC, 3, !0, []),
        r = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []);
      t.value.push(r);
      for (var a = 0; a < e.length; ++a) r.value.push(p.certificateExtensionToAsn1(e[a]));
      return t
    }, p.certificateExtensionToAsn1 = function (e) {
      var t = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, []);
      t.value.push(l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(e.id).getBytes())), e.critical && t.value.push(l.create(l.Class.UNIVERSAL, l.Type.BOOLEAN, !1, String.fromCharCode(255)));
      var r = e.value;
      return "string" != typeof e.value && (r = l.toDer(r).getBytes()), t.value.push(l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, r)), t
    }, p.certificationRequestToAsn1 = function (e) {
      var t = e.certificationRequestInfo || p.getCertificationRequestInfo(e);
      return l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [t, l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(e.signatureOid).getBytes()), o(e.signatureOid, e.signatureParameters)]), l.create(l.Class.UNIVERSAL, l.Type.BITSTRING, !1, String.fromCharCode(0) + e.signature)])
    }, p.createCaStore = function (e) {
      function t(e) {
        return r(e), a.certs[e.hash] || null
      }

      function r(e) {
        if (!e.hash) {
          var t = u.md.sha1.create();
          e.attributes = p.RDNAttributesAsArray(n(e), t), e.hash = t.digest().toHex()
        }
      }
      var a = {
        certs: {}
      };
      if (a.getIssuer = function (e) {
          var r = t(e.issuer);
          return r
        }, a.addCertificate = function (e) {
          if ("string" == typeof e && (e = u.pki.certificateFromPem(e)), r(e.subject), !a.hasCertificate(e))
            if (e.subject.hash in a.certs) {
              var t = a.certs[e.subject.hash];
              u.util.isArray(t) || (t = [t]), t.push(e), a.certs[e.subject.hash] = t
            } else a.certs[e.subject.hash] = e
        }, a.hasCertificate = function (e) {
          "string" == typeof e && (e = u.pki.certificateFromPem(e));
          var r = t(e.subject);
          if (!r) return !1;
          u.util.isArray(r) || (r = [r]);
          for (var a = l.toDer(p.certificateToAsn1(e)).getBytes(), n = 0; n < r.length; ++n) {
            var i = l.toDer(p.certificateToAsn1(r[n])).getBytes();
            if (a === i) return !0
          }
          return !1
        }, a.listAllCertificates = function () {
          var e = [];
          for (var t in a.certs)
            if (a.certs.hasOwnProperty(t)) {
              var r = a.certs[t];
              if (u.util.isArray(r))
                for (var n = 0; n < r.length; ++n) e.push(r[n]);
              else e.push(r)
            } return e
        }, a.removeCertificate = function (e) {
          var n;
          if ("string" == typeof e && (e = u.pki.certificateFromPem(e)), r(e.subject), !a.hasCertificate(e)) return null;
          var i = t(e.subject);
          if (!u.util.isArray(i)) return n = a.certs[e.subject.hash], delete a.certs[e.subject.hash], n;
          for (var s = l.toDer(p.certificateToAsn1(e)).getBytes(), o = 0; o < i.length; ++o) {
            var c = l.toDer(p.certificateToAsn1(i[o])).getBytes();
            s === c && (n = i[o], i.splice(o, 1))
          }
          return 0 === i.length && delete a.certs[e.subject.hash], n
        }, e)
        for (var i = 0; i < e.length; ++i) {
          var s = e[i];
          a.addCertificate(s)
        }
      return a
    }, p.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    }, p.verifyCertificateChain = function (e, t, r) {
      t = t.slice(0);
      var a = t.slice(0),
        n = new Date,
        i = !0,
        s = null,
        o = 0;
      do {
        var c = t.shift(),
          l = null,
          h = !1;
        if ((n < c.validity.notBefore || n > c.validity.notAfter) && (s = {
            message: "Certificate is not valid yet or has expired.",
            error: p.certificateError.certificate_expired,
            notBefore: c.validity.notBefore,
            notAfter: c.validity.notAfter,
            now: n
          }), null === s) {
          if (l = t[0] || e.getIssuer(c), null === l && c.isIssuer(c) && (h = !0, l = c), l) {
            var f = l;
            u.util.isArray(f) || (f = [f]);
            for (var d = !1; !d && f.length > 0;) {
              l = f.shift();
              try {
                d = l.verify(c)
              } catch (e) {}
            }
            d || (s = {
              message: "Certificate signature is invalid.",
              error: p.certificateError.bad_certificate
            })
          }
          null !== s || l && !h || e.hasCertificate(c) || (s = {
            message: "Certificate is not trusted.",
            error: p.certificateError.unknown_ca
          })
        }
        if (null === s && l && !c.isIssuer(l) && (s = {
            message: "Certificate issuer is invalid.",
            error: p.certificateError.bad_certificate
          }), null === s)
          for (var y = {
              keyUsage: !0,
              basicConstraints: !0
            }, g = 0; null === s && g < c.extensions.length; ++g) {
            var v = c.extensions[g];
            !v.critical || v.name in y || (s = {
              message: "Certificate has an unsupported critical extension.",
              error: p.certificateError.unsupported_certificate
            })
          }
        if (null === s && (!i || 0 === t.length && (!l || h))) {
          var m = c.getExtension("basicConstraints"),
            C = c.getExtension("keyUsage");
          if (null !== C && (C.keyCertSign && null !== m || (s = {
              message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
              error: p.certificateError.bad_certificate
            })), null !== s || null === m || m.cA || (s = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: p.certificateError.bad_certificate
            }), null === s && null !== C && "pathLenConstraint" in m) {
            var E = o - 1;
            E > m.pathLenConstraint && (s = {
              message: "Certificate basicConstraints pathLenConstraint violated.",
              error: p.certificateError.bad_certificate
            })
          }
        }
        var S = null === s || s.error,
          T = r ? r(S, o, a) : S;
        if (T !== !0) throw S === !0 && (s = {
          message: "The application rejected the certificate.",
          error: p.certificateError.bad_certificate
        }), (T || 0 === T) && ("object" != typeof T || u.util.isArray(T) ? "string" == typeof T && (s.error = T) : (T.message && (s.message = T.message), T.error && (s.error = T.error))), s;
        s = null, i = !1, ++o
      } while (t.length > 0);
      return !0
    }
  }, function (e, t, r) {
    function a(e) {
      if ("string" == typeof e && (e = s.util.createBuffer(e)), s.util.isArray(e) && e.length > 4) {
        var t = e;
        e = s.util.createBuffer();
        for (var r = 0; r < t.length; ++r) e.putByte(t[r])
      }
      return s.util.isArray(e) || (e = [e.getInt32(), e.getInt32(), e.getInt32(), e.getInt32()]), e
    }

    function n(e) {
      e[e.length - 1] = e[e.length - 1] + 1 & 4294967295
    }

    function i(e) {
      return [e / 4294967296 | 0, 4294967295 & e]
    }
    var s = r(0);
    r(1), s.cipher = s.cipher || {};
    var o = e.exports = s.cipher.modes = s.cipher.modes || {};
    o.ecb = function (e) {
      e = e || {}, this.name = "ECB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints)
    }, o.ecb.prototype.start = function (e) {}, o.ecb.prototype.encrypt = function (e, t, r) {
      if (e.length() < this.blockSize && !(r && e.length() > 0)) return !0;
      for (var a = 0; a < this._ints; ++a) this._inBlock[a] = e.getInt32();
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var a = 0; a < this._ints; ++a) t.putInt32(this._outBlock[a])
    }, o.ecb.prototype.decrypt = function (e, t, r) {
      if (e.length() < this.blockSize && !(r && e.length() > 0)) return !0;
      for (var a = 0; a < this._ints; ++a) this._inBlock[a] = e.getInt32();
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var a = 0; a < this._ints; ++a) t.putInt32(this._outBlock[a])
    }, o.ecb.prototype.pad = function (e, t) {
      var r = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length();
      return e.fillWithByte(r, r), !0
    }, o.ecb.prototype.unpad = function (e, t) {
      if (t.overflow > 0) return !1;
      var r = e.length(),
        a = e.at(r - 1);
      return !(a > this.blockSize << 2) && (e.truncate(a), !0)
    }, o.cbc = function (e) {
      e = e || {}, this.name = "CBC", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints)
    }, o.cbc.prototype.start = function (e) {
      if (null === e.iv) {
        if (!this._prev) throw new Error("Invalid IV parameter.");
        this._iv = this._prev.slice(0)
      } else {
        if (!("iv" in e)) throw new Error("Invalid IV parameter.");
        this._iv = a(e.iv), this._prev = this._iv.slice(0)
      }
    }, o.cbc.prototype.encrypt = function (e, t, r) {
      if (e.length() < this.blockSize && !(r && e.length() > 0)) return !0;
      for (var a = 0; a < this._ints; ++a) this._inBlock[a] = this._prev[a] ^ e.getInt32();
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var a = 0; a < this._ints; ++a) t.putInt32(this._outBlock[a]);
      this._prev = this._outBlock
    }, o.cbc.prototype.decrypt = function (e, t, r) {
      if (e.length() < this.blockSize && !(r && e.length() > 0)) return !0;
      for (var a = 0; a < this._ints; ++a) this._inBlock[a] = e.getInt32();
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var a = 0; a < this._ints; ++a) t.putInt32(this._prev[a] ^ this._outBlock[a]);
      this._prev = this._inBlock.slice(0)
    }, o.cbc.prototype.pad = function (e, t) {
      var r = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length();
      return e.fillWithByte(r, r), !0
    }, o.cbc.prototype.unpad = function (e, t) {
      if (t.overflow > 0) return !1;
      var r = e.length(),
        a = e.at(r - 1);
      return !(a > this.blockSize << 2) && (e.truncate(a), !0)
    }, o.cfb = function (e) {
      e = e || {}, this.name = "CFB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = s.util.createBuffer(), this._partialBytes = 0
    }, o.cfb.prototype.start = function (e) {
      if (!("iv" in e)) throw new Error("Invalid IV parameter.");
      this._iv = a(e.iv), this._inBlock = this._iv.slice(0), this._partialBytes = 0
    }, o.cfb.prototype.encrypt = function (e, t, r) {
      var a = e.length();
      if (0 === a) return !0;
      if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && a >= this.blockSize)
        for (var n = 0; n < this._ints; ++n) this._inBlock[n] = e.getInt32() ^ this._outBlock[n], t.putInt32(this._inBlock[n]);
      else {
        var i = (this.blockSize - a) % this.blockSize;
        i > 0 && (i = this.blockSize - i), this._partialOutput.clear();
        for (var n = 0; n < this._ints; ++n) this._partialBlock[n] = e.getInt32() ^ this._outBlock[n], this._partialOutput.putInt32(this._partialBlock[n]);
        if (i > 0) e.read -= this.blockSize;
        else
          for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._partialBlock[n];
        if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), i > 0 && !r) return t.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = i, !0;
        t.putBytes(this._partialOutput.getBytes(a - this._partialBytes)), this._partialBytes = 0
      }
    }, o.cfb.prototype.decrypt = function (e, t, r) {
      var a = e.length();
      if (0 === a) return !0;
      if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && a >= this.blockSize)
        for (var n = 0; n < this._ints; ++n) this._inBlock[n] = e.getInt32(), t.putInt32(this._inBlock[n] ^ this._outBlock[n]);
      else {
        var i = (this.blockSize - a) % this.blockSize;
        i > 0 && (i = this.blockSize - i), this._partialOutput.clear();
        for (var n = 0; n < this._ints; ++n) this._partialBlock[n] = e.getInt32(), this._partialOutput.putInt32(this._partialBlock[n] ^ this._outBlock[n]);
        if (i > 0) e.read -= this.blockSize;
        else
          for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._partialBlock[n];
        if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), i > 0 && !r) return t.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = i, !0;
        t.putBytes(this._partialOutput.getBytes(a - this._partialBytes)), this._partialBytes = 0
      }
    }, o.ofb = function (e) {
      e = e || {}, this.name = "OFB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = s.util.createBuffer(), this._partialBytes = 0
    }, o.ofb.prototype.start = function (e) {
      if (!("iv" in e)) throw new Error("Invalid IV parameter.");
      this._iv = a(e.iv), this._inBlock = this._iv.slice(0), this._partialBytes = 0
    }, o.ofb.prototype.encrypt = function (e, t, r) {
      var a = e.length();
      if (0 === e.length()) return !0;
      if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && a >= this.blockSize)
        for (var n = 0; n < this._ints; ++n) t.putInt32(e.getInt32() ^ this._outBlock[n]), this._inBlock[n] = this._outBlock[n];
      else {
        var i = (this.blockSize - a) % this.blockSize;
        i > 0 && (i = this.blockSize - i), this._partialOutput.clear();
        for (var n = 0; n < this._ints; ++n) this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[n]);
        if (i > 0) e.read -= this.blockSize;
        else
          for (var n = 0; n < this._ints; ++n) this._inBlock[n] = this._outBlock[n];
        if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), i > 0 && !r) return t.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = i, !0;
        t.putBytes(this._partialOutput.getBytes(a - this._partialBytes)), this._partialBytes = 0
      }
    }, o.ofb.prototype.decrypt = o.ofb.prototype.encrypt, o.ctr = function (e) {
      e = e || {}, this.name = "CTR", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = s.util.createBuffer(), this._partialBytes = 0
    }, o.ctr.prototype.start = function (e) {
      if (!("iv" in e)) throw new Error("Invalid IV parameter.");
      this._iv = a(e.iv), this._inBlock = this._iv.slice(0), this._partialBytes = 0
    }, o.ctr.prototype.encrypt = function (e, t, r) {
      var a = e.length();
      if (0 === a) return !0;
      if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && a >= this.blockSize)
        for (var i = 0; i < this._ints; ++i) t.putInt32(e.getInt32() ^ this._outBlock[i]);
      else {
        var s = (this.blockSize - a) % this.blockSize;
        s > 0 && (s = this.blockSize - s), this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[i]);
        if (s > 0 && (e.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r) return t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
        t.putBytes(this._partialOutput.getBytes(a - this._partialBytes)), this._partialBytes = 0
      }
      n(this._inBlock)
    }, o.ctr.prototype.decrypt = o.ctr.prototype.encrypt, o.gcm = function (e) {
      e = e || {}, this.name = "GCM", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = s.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600
    }, o.gcm.prototype.start = function (e) {
      if (!("iv" in e)) throw new Error("Invalid IV parameter.");
      var t = s.util.createBuffer(e.iv);
      this._cipherLength = 0;
      var r;
      if (r = "additionalData" in e ? s.util.createBuffer(e.additionalData) : s.util.createBuffer(), "tagLength" in e ? this._tagLength = e.tagLength : this._tagLength = 128, this._tag = null, e.decrypt && (this._tag = s.util.createBuffer(e.tag).getBytes(), this._tag.length !== this._tagLength / 8)) throw new Error("Authentication tag does not match tag length.");
      this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var a = t.length();
      if (12 === a) this._j0 = [t.getInt32(), t.getInt32(), t.getInt32(), 1];
      else {
        for (this._j0 = [0, 0, 0, 0]; t.length() > 0;) this._j0 = this.ghash(this._hashSubkey, this._j0, [t.getInt32(), t.getInt32(), t.getInt32(), t.getInt32()]);
        this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(i(8 * a)))
      }
      this._inBlock = this._j0.slice(0), n(this._inBlock), this._partialBytes = 0, r = s.util.createBuffer(r), this._aDataLength = i(8 * r.length());
      var o = r.length() % this.blockSize;
      for (o && r.fillWithByte(0, this.blockSize - o), this._s = [0, 0, 0, 0]; r.length() > 0;) this._s = this.ghash(this._hashSubkey, this._s, [r.getInt32(), r.getInt32(), r.getInt32(), r.getInt32()])
    }, o.gcm.prototype.encrypt = function (e, t, r) {
      var a = e.length();
      if (0 === a) return !0;
      if (this.cipher.encrypt(this._inBlock, this._outBlock), 0 === this._partialBytes && a >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) t.putInt32(this._outBlock[i] ^= e.getInt32());
        this._cipherLength += this.blockSize
      } else {
        var s = (this.blockSize - a) % this.blockSize;
        s > 0 && (s = this.blockSize - s), this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[i]);
        if (0 === s || r) {
          if (r) {
            var o = a % this.blockSize;
            this._cipherLength += o, this._partialOutput.truncate(this.blockSize - o)
          } else this._cipherLength += this.blockSize;
          for (var i = 0; i < this._ints; ++i) this._outBlock[i] = this._partialOutput.getInt32();
          this._partialOutput.read -= this.blockSize
        }
        if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), s > 0 && !r) return e.read -= this.blockSize, t.putBytes(this._partialOutput.getBytes(s - this._partialBytes)), this._partialBytes = s, !0;
        t.putBytes(this._partialOutput.getBytes(a - this._partialBytes)), this._partialBytes = 0
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), n(this._inBlock)
    }, o.gcm.prototype.decrypt = function (e, t, r) {
      var a = e.length();
      if (a < this.blockSize && !(r && a > 0)) return !0;
      this.cipher.encrypt(this._inBlock, this._outBlock), n(this._inBlock), this._hashBlock[0] = e.getInt32(), this._hashBlock[1] = e.getInt32(), this._hashBlock[2] = e.getInt32(), this._hashBlock[3] = e.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) t.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      a < this.blockSize ? this._cipherLength += a % this.blockSize : this._cipherLength += this.blockSize
    }, o.gcm.prototype.afterFinish = function (e, t) {
      var r = !0;
      t.decrypt && t.overflow && e.truncate(this.blockSize - t.overflow), this.tag = s.util.createBuffer();
      var a = this._aDataLength.concat(i(8 * this._cipherLength));
      this._s = this.ghash(this._hashSubkey, this._s, a);
      var n = [];
      this.cipher.encrypt(this._j0, n);
      for (var o = 0; o < this._ints; ++o) this.tag.putInt32(this._s[o] ^ n[o]);
      return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), t.decrypt && this.tag.bytes() !== this._tag && (r = !1), r
    }, o.gcm.prototype.multiply = function (e, t) {
      for (var r = [0, 0, 0, 0], a = t.slice(0), n = 0; n < 128; ++n) {
        var i = e[n / 32 | 0] & 1 << 31 - n % 32;
        i && (r[0] ^= a[0], r[1] ^= a[1], r[2] ^= a[2], r[3] ^= a[3]), this.pow(a, a)
      }
      return r
    }, o.gcm.prototype.pow = function (e, t) {
      for (var r = 1 & e[3], a = 3; a > 0; --a) t[a] = e[a] >>> 1 | (1 & e[a - 1]) << 31;
      t[0] = e[0] >>> 1, r && (t[0] ^= this._R)
    }, o.gcm.prototype.tableMultiply = function (e) {
      for (var t = [0, 0, 0, 0], r = 0; r < 32; ++r) {
        var a = r / 8 | 0,
          n = e[a] >>> 4 * (7 - r % 8) & 15,
          i = this._m[r][n];
        t[0] ^= i[0], t[1] ^= i[1], t[2] ^= i[2], t[3] ^= i[3]
      }
      return t
    }, o.gcm.prototype.ghash = function (e, t, r) {
      return t[0] ^= r[0], t[1] ^= r[1], t[2] ^= r[2], t[3] ^= r[3], this.tableMultiply(t)
    }, o.gcm.prototype.generateHashTable = function (e, t) {
      for (var r = 8 / t, a = 4 * r, n = 16 * r, i = new Array(n), s = 0; s < n; ++s) {
        var o = [0, 0, 0, 0],
          c = s / a | 0,
          u = (a - 1 - s % a) * t;
        o[c] = 1 << t - 1 << u, i[s] = this.generateSubHashTable(this.multiply(o, e), t)
      }
      return i
    }, o.gcm.prototype.generateSubHashTable = function (e, t) {
      var r = 1 << t,
        a = r >>> 1,
        n = new Array(r);
      n[a] = e.slice(0);
      for (var i = a >>> 1; i > 0;) this.pow(n[2 * i], n[i] = []), i >>= 1;
      for (i = 2; i < a;) {
        for (var s = 1; s < i; ++s) {
          var o = n[i],
            c = n[s];
          n[i + s] = [o[0] ^ c[0], o[1] ^ c[1], o[2] ^ c[2], o[3] ^ c[3]]
        }
        i *= 2
      }
      for (n[0] = [0, 0, 0, 0], i = a + 1; i < r; ++i) {
        var u = n[i ^ a];
        n[i] = [e[0] ^ u[0], e[1] ^ u[1], e[2] ^ u[2], e[3] ^ u[3]]
      }
      return n
    }
  }, function (e, t, r) {
    var a = r(0);
    e.exports = a.debug = a.debug || {}, a.debug.storage = {}, a.debug.get = function (e, t) {
      var r;
      return "undefined" == typeof e ? r = a.debug.storage : e in a.debug.storage && (r = "undefined" == typeof t ? a.debug.storage[e] : a.debug.storage[e][t]), r
    }, a.debug.set = function (e, t, r) {
      e in a.debug.storage || (a.debug.storage[e] = {}), a.debug.storage[e][t] = r
    }, a.debug.clear = function (e, t) {
      "undefined" == typeof e ? a.debug.storage = {} : e in a.debug.storage && ("undefined" == typeof t ? delete a.debug.storage[e] : delete a.debug.storage[e][t])
    }
  }, function (e, t, r) {
    var a = r(0);
    r(1), e.exports = a.log = a.log || {}, a.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"];
    var n = {},
      i = [],
      s = null;
    a.log.LEVEL_LOCKED = 2, a.log.NO_LEVEL_CHECK = 4, a.log.INTERPOLATE = 8;
    for (var o = 0; o < a.log.levels.length; ++o) {
      var c = a.log.levels[o];
      n[c] = {
        index: o,
        name: c.toUpperCase()
      }
    }
    a.log.logMessage = function (e) {
      for (var t = n[e.level].index, r = 0; r < i.length; ++r) {
        var s = i[r];
        if (s.flags & a.log.NO_LEVEL_CHECK) s.f(e);
        else {
          var o = n[s.level].index;
          t <= o && s.f(s, e)
        }
      }
    }, a.log.prepareStandard = function (e) {
      "standard" in e || (e.standard = n[e.level].name + " [" + e.category + "] " + e.message)
    }, a.log.prepareFull = function (e) {
      if (!("full" in e)) {
        var t = [e.message];
        t = t.concat([] || e.arguments), e.full = a.util.format.apply(this, t)
      }
    }, a.log.prepareStandardFull = function (e) {
      "standardFull" in e || (a.log.prepareStandard(e), e.standardFull = e.standard)
    };
    for (var u = ["error", "warning", "info", "debug", "verbose"], o = 0; o < u.length; ++o) ! function (e) {
      a.log[e] = function (t, r) {
        var n = Array.prototype.slice.call(arguments).slice(2),
          i = {
            timestamp: new Date,
            level: e,
            category: t,
            message: r,
            arguments: n
          };
        a.log.logMessage(i)
      }
    }(u[o]);
    if (a.log.makeLogger = function (e) {
        var t = {
          flags: 0,
          f: e
        };
        return a.log.setLevel(t, "none"), t
      }, a.log.setLevel = function (e, t) {
        var r = !1;
        if (e && !(e.flags & a.log.LEVEL_LOCKED))
          for (var n = 0; n < a.log.levels.length; ++n) {
            var i = a.log.levels[n];
            if (t == i) {
              e.level = t, r = !0;
              break
            }
          }
        return r
      }, a.log.lock = function (e, t) {
        "undefined" == typeof t || t ? e.flags |= a.log.LEVEL_LOCKED : e.flags &= ~a.log.LEVEL_LOCKED
      }, a.log.addLogger = function (e) {
        i.push(e)
      }, "undefined" != typeof console && "log" in console) {
      var l;
      if (console.error && console.warn && console.info && console.debug) {
        var p = {
            error: console.error,
            warning: console.warn,
            info: console.info,
            debug: console.debug,
            verbose: console.debug
          },
          h = function (e, t) {
            a.log.prepareStandard(t);
            var r = p[t.level],
              n = [t.standard];
            n = n.concat(t.arguments.slice()), r.apply(console, n)
          };
        l = a.log.makeLogger(h)
      } else {
        var h = function (e, t) {
          a.log.prepareStandardFull(t), console.log(t.standardFull)
        };
        l = a.log.makeLogger(h)
      }
      a.log.setLevel(l, "debug"), a.log.addLogger(l), s = l
    } else console = {
      log: function () {}
    };
    if (null !== s) {
      var f = a.util.getQueryVariables();
      if ("console.level" in f && a.log.setLevel(s, f["console.level"].slice(-1)[0]), "console.lock" in f) {
        var d = f["console.lock"].slice(-1)[0];
        "true" == d && a.log.lock(s)
      }
    }
    a.log.consoleLogger = s
  }, function (e, t, r) {
    var a = r(0);
    r(1), a.mgf = a.mgf || {};
    var n = e.exports = a.mgf.mgf1 = a.mgf1 = a.mgf1 || {};
    n.create = function (e) {
      var t = {
        generate: function (t, r) {
          for (var n = new a.util.ByteBuffer, i = Math.ceil(r / e.digestLength), s = 0; s < i; s++) {
            var o = new a.util.ByteBuffer;
            o.putInt32(s), e.start(), e.update(t + o.getBytes()), n.putBuffer(e.digest())
          }
          return n.truncate(n.length() - r), n.getBytes()
        }
      };
      return t
    }
  }, function (e, t, r) {
    function a(e, t) {
      return e.start().update(t).digest().getBytes()
    }

    function n(e) {
      var t;
      if (e) {
        if (t = l.oids[u.derToOid(e)], !t) {
          var r = new Error("Unsupported PRF OID.");
          throw r.oid = e, r.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], r
        }
      } else t = "hmacWithSHA1";
      return i(t)
    }

    function i(e) {
      var t = o.md;
      switch (e) {
        case "hmacWithSHA224":
          t = o.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          e = e.substr(8).toLowerCase();
          break;
        default:
          var r = new Error("Unsupported PRF algorithm.");
          throw r.algorithm = e, r.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], r
      }
      if (!(t && e in t)) throw new Error("Unknown hash algorithm: " + e);
      return t[e].create()
    }

    function s(e, t, r, a) {
      var n = u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [u.create(u.Class.UNIVERSAL, u.Type.OCTETSTRING, !1, e), u.create(u.Class.UNIVERSAL, u.Type.INTEGER, !1, t.getBytes())]);
      return "hmacWithSHA1" !== a && n.value.push(u.create(u.Class.UNIVERSAL, u.Type.INTEGER, !1, o.util.hexToBytes(r.toString(16))), u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [u.create(u.Class.UNIVERSAL, u.Type.OID, !1, u.oidToDer(l.oids[a]).getBytes()), u.create(u.Class.UNIVERSAL, u.Type.NULL, !1, "")])), n
    }
    var o = r(0);
    if (r(5), r(3), r(10), r(4), r(6), r(15), r(7), r(2), r(29), r(11), r(1), "undefined" == typeof c) var c = o.jsbn.BigInteger;
    var u = o.asn1,
      l = o.pki = o.pki || {};
    e.exports = l.pbe = o.pbe = o.pbe || {};
    var p = l.oids,
      h = {
        name: "EncryptedPrivateKeyInfo",
        tagClass: u.Class.UNIVERSAL,
        type: u.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
          tagClass: u.Class.UNIVERSAL,
          type: u.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: u.Class.UNIVERSAL,
            type: u.Type.OID,
            constructed: !1,
            capture: "encryptionOid"
          }, {
            name: "AlgorithmIdentifier.parameters",
            tagClass: u.Class.UNIVERSAL,
            type: u.Type.SEQUENCE,
            constructed: !0,
            captureAsn1: "encryptionParams"
          }]
        }, {
          name: "EncryptedPrivateKeyInfo.encryptedData",
          tagClass: u.Class.UNIVERSAL,
          type: u.Type.OCTETSTRING,
          constructed: !1,
          capture: "encryptedData"
        }]
      },
      f = {
        name: "PBES2Algorithms",
        tagClass: u.Class.UNIVERSAL,
        type: u.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc",
          tagClass: u.Class.UNIVERSAL,
          type: u.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "PBES2Algorithms.keyDerivationFunc.oid",
            tagClass: u.Class.UNIVERSAL,
            type: u.Type.OID,
            constructed: !1,
            capture: "kdfOid"
          }, {
            name: "PBES2Algorithms.params",
            tagClass: u.Class.UNIVERSAL,
            type: u.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "PBES2Algorithms.params.salt",
              tagClass: u.Class.UNIVERSAL,
              type: u.Type.OCTETSTRING,
              constructed: !1,
              capture: "kdfSalt"
            }, {
              name: "PBES2Algorithms.params.iterationCount",
              tagClass: u.Class.UNIVERSAL,
              type: u.Type.INTEGER,
              constructed: !1,
              capture: "kdfIterationCount"
            }, {
              name: "PBES2Algorithms.params.keyLength",
              tagClass: u.Class.UNIVERSAL,
              type: u.Type.INTEGER,
              constructed: !1,
              optional: !0,
              capture: "keyLength"
            }, {
              name: "PBES2Algorithms.params.prf",
              tagClass: u.Class.UNIVERSAL,
              type: u.Type.SEQUENCE,
              constructed: !0,
              optional: !0,
              value: [{
                name: "PBES2Algorithms.params.prf.algorithm",
                tagClass: u.Class.UNIVERSAL,
                type: u.Type.OID,
                constructed: !1,
                capture: "prfOid"
              }]
            }]
          }]
        }, {
          name: "PBES2Algorithms.encryptionScheme",
          tagClass: u.Class.UNIVERSAL,
          type: u.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "PBES2Algorithms.encryptionScheme.oid",
            tagClass: u.Class.UNIVERSAL,
            type: u.Type.OID,
            constructed: !1,
            capture: "encOid"
          }, {
            name: "PBES2Algorithms.encryptionScheme.iv",
            tagClass: u.Class.UNIVERSAL,
            type: u.Type.OCTETSTRING,
            constructed: !1,
            capture: "encIv"
          }]
        }]
      },
      d = {
        name: "pkcs-12PbeParams",
        tagClass: u.Class.UNIVERSAL,
        type: u.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "pkcs-12PbeParams.salt",
          tagClass: u.Class.UNIVERSAL,
          type: u.Type.OCTETSTRING,
          constructed: !1,
          capture: "salt"
        }, {
          name: "pkcs-12PbeParams.iterations",
          tagClass: u.Class.UNIVERSAL,
          type: u.Type.INTEGER,
          constructed: !1,
          capture: "iterations"
        }]
      };
    l.encryptPrivateKeyInfo = function (e, t, r) {
      r = r || {}, r.saltSize = r.saltSize || 8, r.count = r.count || 2048, r.algorithm = r.algorithm || "aes128", r.prfAlgorithm = r.prfAlgorithm || "sha1";
      var a, n, c, h = o.random.getBytesSync(r.saltSize),
        f = r.count,
        d = u.integerToDer(f);
      if (0 === r.algorithm.indexOf("aes") || "des" === r.algorithm) {
        var y, g, v;
        switch (r.algorithm) {
          case "aes128":
            a = 16, y = 16, g = p["aes128-CBC"], v = o.aes.createEncryptionCipher;
            break;
          case "aes192":
            a = 24, y = 16, g = p["aes192-CBC"], v = o.aes.createEncryptionCipher;
            break;
          case "aes256":
            a = 32, y = 16, g = p["aes256-CBC"], v = o.aes.createEncryptionCipher;
            break;
          case "des":
            a = 8, y = 8, g = p.desCBC, v = o.des.createEncryptionCipher;
            break;
          default:
            var m = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            throw m.algorithm = r.algorithm, m
        }
        var C = "hmacWith" + r.prfAlgorithm.toUpperCase(),
          E = i(C),
          S = o.pkcs5.pbkdf2(t, h, f, a, E),
          T = o.random.getBytesSync(y),
          I = v(S);
        I.start(T), I.update(u.toDer(e)), I.finish(), c = I.output.getBytes();
        var A = s(h, d, a, C);
        n = u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [u.create(u.Class.UNIVERSAL, u.Type.OID, !1, u.oidToDer(p.pkcs5PBES2).getBytes()), u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [u.create(u.Class.UNIVERSAL, u.Type.OID, !1, u.oidToDer(p.pkcs5PBKDF2).getBytes()), A]), u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [u.create(u.Class.UNIVERSAL, u.Type.OID, !1, u.oidToDer(g).getBytes()), u.create(u.Class.UNIVERSAL, u.Type.OCTETSTRING, !1, T)])])])
      } else {
        if ("3des" !== r.algorithm) {
          var m = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          throw m.algorithm = r.algorithm, m
        }
        a = 24;
        var b = new o.util.ByteBuffer(h),
          S = l.pbe.generatePkcs12Key(t, b, 1, f, a),
          T = l.pbe.generatePkcs12Key(t, b, 2, f, a),
          I = o.des.createEncryptionCipher(S);
        I.start(T), I.update(u.toDer(e)), I.finish(), c = I.output.getBytes(), n = u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [u.create(u.Class.UNIVERSAL, u.Type.OID, !1, u.oidToDer(p["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [u.create(u.Class.UNIVERSAL, u.Type.OCTETSTRING, !1, h), u.create(u.Class.UNIVERSAL, u.Type.INTEGER, !1, d.getBytes())])])
      }
      var B = u.create(u.Class.UNIVERSAL, u.Type.SEQUENCE, !0, [n, u.create(u.Class.UNIVERSAL, u.Type.OCTETSTRING, !1, c)]);
      return B
    }, l.decryptPrivateKeyInfo = function (e, t) {
      var r = null,
        a = {},
        n = [];
      if (!u.validate(e, h, a, n)) {
        var i = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        throw i.errors = n, i
      }
      var s = u.derToOid(a.encryptionOid),
        c = l.pbe.getCipher(s, a.encryptionParams, t),
        p = o.util.createBuffer(a.encryptedData);
      return c.update(p), c.finish() && (r = u.fromDer(c.output)), r
    }, l.encryptedPrivateKeyToPem = function (e, t) {
      var r = {
        type: "ENCRYPTED PRIVATE KEY",
        body: u.toDer(e).getBytes()
      };
      return o.pem.encode(r, {
        maxline: t
      })
    }, l.encryptedPrivateKeyFromPem = function (e) {
      var t = o.pem.decode(e)[0];
      if ("ENCRYPTED PRIVATE KEY" !== t.type) {
        var r = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        throw r.headerType = t.type, r
      }
      if (t.procType && "ENCRYPTED" === t.procType.type) throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      return u.fromDer(t.body)
    }, l.encryptRsaPrivateKey = function (e, t, r) {
      if (r = r || {}, !r.legacy) {
        var a = l.wrapRsaPrivateKey(l.privateKeyToAsn1(e));
        return a = l.encryptPrivateKeyInfo(a, t, r), l.encryptedPrivateKeyToPem(a)
      }
      var n, i, s, c;
      switch (r.algorithm) {
        case "aes128":
          n = "AES-128-CBC", s = 16, i = o.random.getBytesSync(16), c = o.aes.createEncryptionCipher;
          break;
        case "aes192":
          n = "AES-192-CBC", s = 24, i = o.random.getBytesSync(16), c = o.aes.createEncryptionCipher;
          break;
        case "aes256":
          n = "AES-256-CBC", s = 32, i = o.random.getBytesSync(16), c = o.aes.createEncryptionCipher;
          break;
        case "3des":
          n = "DES-EDE3-CBC", s = 24, i = o.random.getBytesSync(8), c = o.des.createEncryptionCipher;
          break;
        case "des":
          n = "DES-CBC", s = 8, i = o.random.getBytesSync(8), c = o.des.createEncryptionCipher;
          break;
        default:
          var p = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + r.algorithm + '".');
          throw p.algorithm = r.algorithm, p
      }
      var h = o.pbe.opensslDeriveBytes(t, i.substr(0, 8), s),
        f = c(h);
      f.start(i), f.update(u.toDer(l.privateKeyToAsn1(e))), f.finish();
      var d = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm: n,
          parameters: o.util.bytesToHex(i).toUpperCase()
        },
        body: f.output.getBytes()
      };
      return o.pem.encode(d)
    }, l.decryptRsaPrivateKey = function (e, t) {
      var r = null,
        a = o.pem.decode(e)[0];
      if ("ENCRYPTED PRIVATE KEY" !== a.type && "PRIVATE KEY" !== a.type && "RSA PRIVATE KEY" !== a.type) {
        var n = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        throw n.headerType = n, n
      }
      if (a.procType && "ENCRYPTED" === a.procType.type) {
        var i, s;
        switch (a.dekInfo.algorithm) {
          case "DES-CBC":
            i = 8, s = o.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            i = 24, s = o.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            i = 16, s = o.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            i = 24, s = o.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            i = 32, s = o.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            i = 5, s = function (e) {
              return o.rc2.createDecryptionCipher(e, 40)
            };
            break;
          case "RC2-64-CBC":
            i = 8, s = function (e) {
              return o.rc2.createDecryptionCipher(e, 64)
            };
            break;
          case "RC2-128-CBC":
            i = 16, s = function (e) {
              return o.rc2.createDecryptionCipher(e, 128)
            };
            break;
          default:
            var n = new Error('Could not decrypt private key; unsupported encryption algorithm "' + a.dekInfo.algorithm + '".');
            throw n.algorithm = a.dekInfo.algorithm, n
        }
        var c = o.util.hexToBytes(a.dekInfo.parameters),
          p = o.pbe.opensslDeriveBytes(t, c.substr(0, 8), i),
          h = s(p);
        if (h.start(c), h.update(o.util.createBuffer(a.body)), !h.finish()) return r;
        r = h.output.getBytes()
      } else r = a.body;
      return r = "ENCRYPTED PRIVATE KEY" === a.type ? l.decryptPrivateKeyInfo(u.fromDer(r), t) : u.fromDer(r), null !== r && (r = l.privateKeyFromAsn1(r)), r
    }, l.pbe.generatePkcs12Key = function (e, t, r, a, n, i) {
      var s, c;
      if ("undefined" == typeof i || null === i) {
        if (!("sha1" in o.md)) throw new Error('"sha1" hash algorithm unavailable.');
        i = o.md.sha1.create()
      }
      var u = i.digestLength,
        l = i.blockLength,
        p = new o.util.ByteBuffer,
        h = new o.util.ByteBuffer;
      if (null !== e && void 0 !== e) {
        for (c = 0; c < e.length; c++) h.putInt16(e.charCodeAt(c));
        h.putInt16(0)
      }
      var f = h.length(),
        d = t.length(),
        y = new o.util.ByteBuffer;
      y.fillWithByte(r, l);
      var g = l * Math.ceil(d / l),
        v = new o.util.ByteBuffer;
      for (c = 0; c < g; c++) v.putByte(t.at(c % d));
      var m = l * Math.ceil(f / l),
        C = new o.util.ByteBuffer;
      for (c = 0; c < m; c++) C.putByte(h.at(c % f));
      var E = v;
      E.putBuffer(C);
      for (var S = Math.ceil(n / u), T = 1; T <= S; T++) {
        var I = new o.util.ByteBuffer;
        I.putBytes(y.bytes()), I.putBytes(E.bytes());
        for (var A = 0; A < a; A++) i.start(), i.update(I.getBytes()), I = i.digest();
        var b = new o.util.ByteBuffer;
        for (c = 0; c < l; c++) b.putByte(I.at(c % u));
        var B = Math.ceil(d / l) + Math.ceil(f / l),
          N = new o.util.ByteBuffer;
        for (s = 0; s < B; s++) {
          var k = new o.util.ByteBuffer(E.getBytes(l)),
            R = 511;
          for (c = b.length() - 1; c >= 0; c--) R >>= 8, R += b.at(c) + k.at(c), k.setAt(c, 255 & R);
          N.putBuffer(k)
        }
        E = N, p.putBuffer(I)
      }
      return p.truncate(p.length() - n), p
    }, l.pbe.getCipher = function (e, t, r) {
      switch (e) {
        case l.oids.pkcs5PBES2:
          return l.pbe.getCipherForPBES2(e, t, r);
        case l.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case l.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return l.pbe.getCipherForPKCS12PBE(e, t, r);
        default:
          var a = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          throw a.oid = e, a.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], a
      }
    }, l.pbe.getCipherForPBES2 = function (e, t, r) {
      var a = {},
        i = [];
      if (!u.validate(t, f, a, i)) {
        var s = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        throw s.errors = i, s
      }
      if (e = u.derToOid(a.kdfOid), e !== l.oids.pkcs5PBKDF2) {
        var s = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        throw s.oid = e, s.supportedOids = ["pkcs5PBKDF2"], s
      }
      if (e = u.derToOid(a.encOid), e !== l.oids["aes128-CBC"] && e !== l.oids["aes192-CBC"] && e !== l.oids["aes256-CBC"] && e !== l.oids["des-EDE3-CBC"] && e !== l.oids.desCBC) {
        var s = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        throw s.oid = e, s.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], s
      }
      var c = a.kdfSalt,
        p = o.util.createBuffer(a.kdfIterationCount);
      p = p.getInt(p.length() << 3);
      var h, d;
      switch (l.oids[e]) {
        case "aes128-CBC":
          h = 16, d = o.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          h = 24, d = o.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          h = 32, d = o.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          h = 24, d = o.des.createDecryptionCipher;
          break;
        case "desCBC":
          h = 8, d = o.des.createDecryptionCipher
      }
      var y = n(a.prfOid),
        g = o.pkcs5.pbkdf2(r, c, p, h, y),
        v = a.encIv,
        m = d(g);
      return m.start(v), m
    }, l.pbe.getCipherForPKCS12PBE = function (e, t, r) {
      var a = {},
        i = [];
      if (!u.validate(t, d, a, i)) {
        var s = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        throw s.errors = i, s
      }
      var c = o.util.createBuffer(a.salt),
        p = o.util.createBuffer(a.iterations);
      p = p.getInt(p.length() << 3);
      var h, f, y;
      switch (e) {
        case l.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          h = 24, f = 8, y = o.des.startDecrypting;
          break;
        case l.oids["pbewithSHAAnd40BitRC2-CBC"]:
          h = 5, f = 8, y = function (e, t) {
            var r = o.rc2.createDecryptionCipher(e, 40);
            return r.start(t, null), r
          };
          break;
        default:
          var s = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          throw s.oid = e, s
      }
      var g = n(a.prfOid),
        v = l.pbe.generatePkcs12Key(r, c, 1, p, h, g);
      g.start();
      var m = l.pbe.generatePkcs12Key(r, c, 2, p, f, g);
      return y(v, m)
    }, l.pbe.opensslDeriveBytes = function (e, t, r, n) {
      if ("undefined" == typeof n || null === n) {
        if (!("md5" in o.md)) throw new Error('"md5" hash algorithm unavailable.');
        n = o.md.md5.create()
      }
      null === t && (t = "");
      for (var i = [a(n, e + t)], s = 16, c = 1; s < r; ++c, s += 16) i.push(a(n, i[c - 1] + e + t));
      return i.join("").substr(0, r)
    }
  }, function (e, t, r) {
    function a(e, t, r) {
      r || (r = n.md.sha1.create());
      for (var a = "", i = Math.ceil(t / r.digestLength), s = 0; s < i; ++s) {
        var o = String.fromCharCode(s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, 255 & s);
        r.start(), r.update(e + o), a += r.digest().getBytes()
      }
      return a.substring(0, t)
    }
    var n = r(0);
    r(1), r(2), r(9);
    var i = e.exports = n.pkcs1 = n.pkcs1 || {};
    i.encode_rsa_oaep = function (e, t, r) {
      var i, s, o, c;
      "string" == typeof r ? (i = r, s = arguments[3] || void 0, o = arguments[4] || void 0) : r && (i = r.label || void 0, s = r.seed || void 0, o = r.md || void 0, r.mgf1 && r.mgf1.md && (c = r.mgf1.md)), o ? o.start() : o = n.md.sha1.create(), c || (c = o);
      var u = Math.ceil(e.n.bitLength() / 8),
        l = u - 2 * o.digestLength - 2;
      if (t.length > l) {
        var p = new Error("RSAES-OAEP input message length is too long.");
        throw p.length = t.length, p.maxLength = l, p
      }
      i || (i = ""), o.update(i, "raw");
      for (var h = o.digest(), f = "", d = l - t.length, y = 0; y < d; y++) f += "\0";
      var g = h.getBytes() + f + "" + t;
      if (s) {
        if (s.length !== o.digestLength) {
          var p = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
          throw p.seedLength = s.length, p.digestLength = o.digestLength, p
        }
      } else s = n.random.getBytes(o.digestLength);
      var v = a(s, u - o.digestLength - 1, c),
        m = n.util.xorBytes(g, v, g.length),
        C = a(m, o.digestLength, c),
        E = n.util.xorBytes(s, C, s.length);
      return "\0" + E + m
    }, i.decode_rsa_oaep = function (e, t, r) {
      var i, s, o;
      "string" == typeof r ? (i = r, s = arguments[3] || void 0) : r && (i = r.label || void 0, s = r.md || void 0, r.mgf1 && r.mgf1.md && (o = r.mgf1.md));
      var c = Math.ceil(e.n.bitLength() / 8);
      if (t.length !== c) {
        var u = new Error("RSAES-OAEP encoded message length is invalid.");
        throw u.length = t.length, u.expectedLength = c, u
      }
      if (void 0 === s ? s = n.md.sha1.create() : s.start(), o || (o = s), c < 2 * s.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
      i || (i = ""), s.update(i, "raw");
      for (var l = s.digest().getBytes(), p = t.charAt(0), h = t.substring(1, s.digestLength + 1), f = t.substring(1 + s.digestLength), d = a(f, s.digestLength, o), y = n.util.xorBytes(h, d, h.length), g = a(y, c - s.digestLength - 1, o), v = n.util.xorBytes(f, g, f.length), m = v.substring(0, s.digestLength), u = "\0" !== p, C = 0; C < s.digestLength; ++C) u |= l.charAt(C) !== m.charAt(C);
      for (var E = 1, S = s.digestLength, T = s.digestLength; T < v.length; T++) {
        var I = v.charCodeAt(T),
          A = 1 & I ^ 1,
          b = E ? 65534 : 0;
        u |= I & b, E &= A, S += E
      }
      if (u || 1 !== v.charCodeAt(S)) throw new Error("Invalid RSAES-OAEP padding.");
      return v.substring(S + 1)
    }
  }, function (e, t, r) {
    function a(e, t, r, a) {
      for (var n = [], i = 0; i < e.length; i++)
        for (var s = 0; s < e[i].safeBags.length; s++) {
          var o = e[i].safeBags[s];
          void 0 !== a && o.type !== a || (null !== t ? void 0 !== o.attributes[t] && o.attributes[t].indexOf(r) >= 0 && n.push(o) : n.push(o))
        }
      return n
    }

    function n(e) {
      if (e.composed || e.constructed) {
        for (var t = u.util.createBuffer(), r = 0; r < e.value.length; ++r) t.putBytes(e.value[r].value);
        e.composed = e.constructed = !1, e.value = t.getBytes()
      }
      return e
    }

    function i(e, t, r, a) {
      if (t = l.fromDer(t, r), t.tagClass !== l.Class.UNIVERSAL || t.type !== l.Type.SEQUENCE || t.constructed !== !0) throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      for (var i = 0; i < t.value.length; i++) {
        var c = t.value[i],
          u = {},
          h = [];
        if (!l.validate(c, f, u, h)) {
          var d = new Error("Cannot read ContentInfo.");
          throw d.errors = h, d
        }
        var y = {
            encrypted: !1
          },
          g = null,
          v = u.content.value[0];
        switch (l.derToOid(u.contentType)) {
          case p.oids.data:
            if (v.tagClass !== l.Class.UNIVERSAL || v.type !== l.Type.OCTETSTRING) throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            g = n(v).value;
            break;
          case p.oids.encryptedData:
            g = s(v, a), y.encrypted = !0;
            break;
          default:
            var d = new Error("Unsupported PKCS#12 contentType.");
            throw d.contentType = l.derToOid(u.contentType), d
        }
        y.safeBags = o(g, r, a), e.safeContents.push(y)
      }
    }

    function s(e, t) {
      var r = {},
        a = [];
      if (!l.validate(e, u.pkcs7.asn1.encryptedDataValidator, r, a)) {
        var i = new Error("Cannot read EncryptedContentInfo.");
        throw i.errors = a, i
      }
      var s = l.derToOid(r.contentType);
      if (s !== p.oids.data) {
        var i = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
        throw i.oid = s, i
      }
      s = l.derToOid(r.encAlgorithm);
      var o = p.pbe.getCipher(s, r.encParameter, t),
        c = n(r.encryptedContentAsn1),
        h = u.util.createBuffer(c.value);
      if (o.update(h), !o.finish()) throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      return o.output.getBytes()
    }

    function o(e, t, r) {
      if (!t && 0 === e.length) return [];
      if (e = l.fromDer(e, t), e.tagClass !== l.Class.UNIVERSAL || e.type !== l.Type.SEQUENCE || e.constructed !== !0) throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
      for (var a = [], n = 0; n < e.value.length; n++) {
        var i = e.value[n],
          s = {},
          o = [];
        if (!l.validate(i, y, s, o)) {
          var u = new Error("Cannot read SafeBag.");
          throw u.errors = o, u
        }
        var h = {
          type: l.derToOid(s.bagId),
          attributes: c(s.bagAttributes)
        };
        a.push(h);
        var f, d, g = s.bagValue.value[0];
        switch (h.type) {
          case p.oids.pkcs8ShroudedKeyBag:
            if (g = p.decryptPrivateKeyInfo(g, r), null === g) throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
          case p.oids.keyBag:
            try {
              h.key = p.privateKeyFromAsn1(g)
            } catch (e) {
              h.key = null, h.asn1 = g
            }
            continue;
          case p.oids.certBag:
            f = v, d = function () {
              if (l.derToOid(s.certId) !== p.oids.x509Certificate) {
                var e = new Error("Unsupported certificate type, only X.509 supported.");
                throw e.oid = l.derToOid(s.certId), e
              }
              var r = l.fromDer(s.cert, t);
              try {
                h.cert = p.certificateFromAsn1(r, !0)
              } catch (e) {
                h.cert = null, h.asn1 = r
              }
            };
            break;
          default:
            var u = new Error("Unsupported PKCS#12 SafeBag type.");
            throw u.oid = h.type, u
        }
        if (void 0 !== f && !l.validate(g, f, s, o)) {
          var u = new Error("Cannot read PKCS#12 " + f.name);
          throw u.errors = o, u
        }
        d()
      }
      return a
    }

    function c(e) {
      var t = {};
      if (void 0 !== e)
        for (var r = 0; r < e.length; ++r) {
          var a = {},
            n = [];
          if (!l.validate(e[r], g, a, n)) {
            var i = new Error("Cannot read PKCS#12 BagAttribute.");
            throw i.errors = n, i
          }
          var s = l.derToOid(a.oid);
          if (void 0 !== p.oids[s]) {
            t[p.oids[s]] = [];
            for (var o = 0; o < a.values.length; ++o) t[p.oids[s]].push(a.values[o].value)
          }
        }
      return t
    }
    var u = r(0);
    r(3), r(8), r(6), r(25), r(22), r(2), r(11), r(9), r(1), r(17);
    var l = u.asn1,
      p = u.pki,
      h = e.exports = u.pkcs12 = u.pkcs12 || {},
      f = {
        name: "ContentInfo",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "ContentInfo.contentType",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.OID,
          constructed: !1,
          capture: "contentType"
        }, {
          name: "ContentInfo.content",
          tagClass: l.Class.CONTEXT_SPECIFIC,
          constructed: !0,
          captureAsn1: "content"
        }]
      },
      d = {
        name: "PFX",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PFX.version",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.INTEGER,
          constructed: !1,
          capture: "version"
        }, f, {
          name: "PFX.macData",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.SEQUENCE,
          constructed: !0,
          optional: !0,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.SEQUENCE,
              constructed: !0,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: l.Class.UNIVERSAL,
                type: l.Type.OID,
                constructed: !1,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: l.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: l.Class.UNIVERSAL,
              type: l.Type.OCTETSTRING,
              constructed: !1,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.OCTETSTRING,
            constructed: !1,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: l.Class.UNIVERSAL,
            type: l.Type.INTEGER,
            constructed: !1,
            optional: !0,
            capture: "macIterations"
          }]
        }]
      },
      y = {
        name: "SafeBag",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "SafeBag.bagId",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.OID,
          constructed: !1,
          capture: "bagId"
        }, {
          name: "SafeBag.bagValue",
          tagClass: l.Class.CONTEXT_SPECIFIC,
          constructed: !0,
          captureAsn1: "bagValue"
        }, {
          name: "SafeBag.bagAttributes",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.SET,
          constructed: !0,
          optional: !0,
          capture: "bagAttributes"
        }]
      },
      g = {
        name: "Attribute",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "Attribute.attrId",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.OID,
          constructed: !1,
          capture: "oid"
        }, {
          name: "Attribute.attrValues",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.SET,
          constructed: !0,
          capture: "values"
        }]
      },
      v = {
        name: "CertBag",
        tagClass: l.Class.UNIVERSAL,
        type: l.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "CertBag.certId",
          tagClass: l.Class.UNIVERSAL,
          type: l.Type.OID,
          constructed: !1,
          capture: "certId"
        }, {
          name: "CertBag.certValue",
          tagClass: l.Class.CONTEXT_SPECIFIC,
          constructed: !0,
          value: [{
            name: "CertBag.certValue[0]",
            tagClass: l.Class.UNIVERSAL,
            type: l.Class.OCTETSTRING,
            constructed: !1,
            capture: "cert"
          }]
        }]
      };
    h.pkcs12FromAsn1 = function (e, t, r) {
      "string" == typeof t ? (r = t, t = !0) : void 0 === t && (t = !0);
      var s = {},
        o = [];
      if (!l.validate(e, d, s, o)) {
        var c = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        throw c.errors = c, c
      }
      var f = {
        version: s.version.charCodeAt(0),
        safeContents: [],
        getBags: function (e) {
          var t, r = {};
          return "localKeyId" in e ? t = e.localKeyId : "localKeyIdHex" in e && (t = u.util.hexToBytes(e.localKeyIdHex)), void 0 === t && !("friendlyName" in e) && "bagType" in e && (r[e.bagType] = a(f.safeContents, null, null, e.bagType)), void 0 !== t && (r.localKeyId = a(f.safeContents, "localKeyId", t, e.bagType)), "friendlyName" in e && (r.friendlyName = a(f.safeContents, "friendlyName", e.friendlyName, e.bagType)), r
        },
        getBagsByFriendlyName: function (e, t) {
          return a(f.safeContents, "friendlyName", e, t)
        },
        getBagsByLocalKeyId: function (e, t) {
          return a(f.safeContents, "localKeyId", e, t)
        }
      };
      if (3 !== s.version.charCodeAt(0)) {
        var c = new Error("PKCS#12 PFX of version other than 3 not supported.");
        throw c.version = s.version.charCodeAt(0), c
      }
      if (l.derToOid(s.contentType) !== p.oids.data) {
        var c = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        throw c.oid = l.derToOid(s.contentType), c
      }
      var y = s.content.value[0];
      if (y.tagClass !== l.Class.UNIVERSAL || y.type !== l.Type.OCTETSTRING) throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      if (y = n(y), s.mac) {
        var g = null,
          v = 0,
          m = l.derToOid(s.macAlgorithm);
        switch (m) {
          case p.oids.sha1:
            g = u.md.sha1.create(), v = 20;
            break;
          case p.oids.sha256:
            g = u.md.sha256.create(), v = 32;
            break;
          case p.oids.sha384:
            g = u.md.sha384.create(), v = 48;
            break;
          case p.oids.sha512:
            g = u.md.sha512.create(), v = 64;
            break;
          case p.oids.md5:
            g = u.md.md5.create(), v = 16
        }
        if (null === g) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + m);
        var C = new u.util.ByteBuffer(s.macSalt),
          E = "macIterations" in s ? parseInt(u.util.bytesToHex(s.macIterations), 16) : 1,
          S = h.generateKey(r, C, 3, E, v, g),
          T = u.hmac.create();
        T.start(g, S), T.update(y.value);
        var I = T.getMac();
        if (I.getBytes() !== s.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?")
      }
      return i(f, y.value, t, r), f
    }, h.toPkcs12Asn1 = function (e, t, r, a) {
      a = a || {}, a.saltSize = a.saltSize || 8, a.count = a.count || 2048, a.algorithm = a.algorithm || a.encAlgorithm || "aes128", "useMac" in a || (a.useMac = !0), "localKeyId" in a || (a.localKeyId = null), "generateLocalKeyId" in a || (a.generateLocalKeyId = !0);
      var n, i = a.localKeyId;
      if (null !== i) i = u.util.hexToBytes(i);
      else if (a.generateLocalKeyId)
        if (t) {
          var s = u.util.isArray(t) ? t[0] : t;
          "string" == typeof s && (s = p.certificateFromPem(s));
          var o = u.md.sha1.create();
          o.update(l.toDer(p.certificateToAsn1(s)).getBytes()), i = o.digest().getBytes()
        } else i = u.random.getBytes(20);
      var c = [];
      null !== i && c.push(l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.localKeyId).getBytes()), l.create(l.Class.UNIVERSAL, l.Type.SET, !0, [l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, i)])])), "friendlyName" in a && c.push(l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.friendlyName).getBytes()), l.create(l.Class.UNIVERSAL, l.Type.SET, !0, [l.create(l.Class.UNIVERSAL, l.Type.BMPSTRING, !1, a.friendlyName)])])), c.length > 0 && (n = l.create(l.Class.UNIVERSAL, l.Type.SET, !0, c));
      var f = [],
        d = [];
      null !== t && (d = u.util.isArray(t) ? t : [t]);
      for (var y = [], g = 0; g < d.length; ++g) {
        t = d[g], "string" == typeof t && (t = p.certificateFromPem(t));
        var v = 0 === g ? n : void 0,
          m = p.certificateToAsn1(t),
          C = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.certBag).getBytes()), l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.x509Certificate).getBytes()), l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, l.toDer(m).getBytes())])])]), v]);
        y.push(C)
      }
      if (y.length > 0) {
        var E = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, y),
          S = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.data).getBytes()), l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, l.toDer(E).getBytes())])]);
        f.push(S)
      }
      var T = null;
      if (null !== e) {
        var I = p.wrapRsaPrivateKey(p.privateKeyToAsn1(e));
        T = null === r ? l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.keyBag).getBytes()), l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [I]), n]) : l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.pkcs8ShroudedKeyBag).getBytes()), l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [p.encryptPrivateKeyInfo(I, r, a)]), n]);
        var A = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [T]),
          b = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.data).getBytes()), l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, l.toDer(A).getBytes())])]);
        f.push(b)
      }
      var B, N = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, f);
      if (a.useMac) {
        var o = u.md.sha1.create(),
          k = new u.util.ByteBuffer(u.random.getBytes(a.saltSize)),
          R = a.count,
          e = h.generateKey(r, k, 3, R, 20),
          w = u.hmac.create();
        w.start(o, e), w.update(l.toDer(N).getBytes());
        var L = w.getMac();
        B = l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.sha1).getBytes()), l.create(l.Class.UNIVERSAL, l.Type.NULL, !1, "")]), l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, L.getBytes())]), l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, k.getBytes()), l.create(l.Class.UNIVERSAL, l.Type.INTEGER, !1, l.integerToDer(R).getBytes())])
      }
      return l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.INTEGER, !1, l.integerToDer(3).getBytes()), l.create(l.Class.UNIVERSAL, l.Type.SEQUENCE, !0, [l.create(l.Class.UNIVERSAL, l.Type.OID, !1, l.oidToDer(p.oids.data).getBytes()), l.create(l.Class.CONTEXT_SPECIFIC, 0, !0, [l.create(l.Class.UNIVERSAL, l.Type.OCTETSTRING, !1, l.toDer(N).getBytes())])]), B])
    }, h.generateKey = u.pbe.generatePkcs12Key
  }, function (e, t, r) {
    var a = r(0);
    r(3), r(1);
    var n = a.asn1,
      i = e.exports = a.pkcs7asn1 = a.pkcs7asn1 || {};
    a.pkcs7 = a.pkcs7 || {}, a.pkcs7.asn1 = i;
    var s = {
      name: "ContentInfo",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.OID,
        constructed: !1,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: n.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        captureAsn1: "content"
      }]
    };
    i.contentInfoValidator = s;
    var o = {
      name: "EncryptedContentInfo",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.OID,
        constructed: !1,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.OID,
          constructed: !1,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: n.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: n.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    i.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.INTEGER,
        constructed: !1,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SET,
        constructed: !0,
        captureAsn1: "recipientInfos"
      }].concat(o)
    }, i.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "EncryptedData.Version",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.INTEGER,
        constructed: !1,
        capture: "version"
      }].concat(o)
    };
    var c = {
      name: "SignerInfo",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "SignerInfo.version",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.INTEGER,
        constructed: !1
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.INTEGER,
          constructed: !1,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.OID,
          constructed: !1,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: n.Class.UNIVERSAL,
          constructed: !1,
          captureAsn1: "digestParameter",
          optional: !0
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: n.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.OCTETSTRING,
        constructed: !1,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: n.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: !0,
        optional: !0,
        capture: "unauthenticatedAttributes"
      }]
    };
    i.signedDataValidator = {
      name: "SignedData",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "SignedData.Version",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.INTEGER,
        constructed: !1,
        capture: "version"
      }, {
        name: "SignedData.DigestAlgorithms",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SET,
        constructed: !0,
        captureAsn1: "digestAlgorithms"
      }, s, {
        name: "SignedData.Certificates",
        tagClass: n.Class.CONTEXT_SPECIFIC,
        type: 0,
        optional: !0,
        captureAsn1: "certificates"
      }, {
        name: "SignedData.CertificateRevocationLists",
        tagClass: n.Class.CONTEXT_SPECIFIC,
        type: 1,
        optional: !0,
        captureAsn1: "crls"
      }, {
        name: "SignedData.SignerInfos",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SET,
        capture: "signerInfos",
        optional: !0,
        value: [c]
      }]
    }, i.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: n.Class.UNIVERSAL,
      type: n.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RecipientInfo.version",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.INTEGER,
        constructed: !1,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.INTEGER,
          constructed: !1,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.OID,
          constructed: !1,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: n.Class.UNIVERSAL,
          constructed: !1,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.OCTETSTRING,
        constructed: !1,
        capture: "encKey"
      }]
    }
  }, function (e, t, r) {
    var a = r(0);
    r(3), r(6), r(22), r(7), r(15), r(24), r(16), r(11), r(1), r(17);
    var n = a.asn1,
      i = e.exports = a.pki = a.pki || {};
    i.pemToDer = function (e) {
      var t = a.pem.decode(e)[0];
      if (t.procType && "ENCRYPTED" === t.procType.type) throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      return a.util.createBuffer(t.body)
    }, i.privateKeyFromPem = function (e) {
      var t = a.pem.decode(e)[0];
      if ("PRIVATE KEY" !== t.type && "RSA PRIVATE KEY" !== t.type) {
        var r = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        throw r.headerType = t.type, r
      }
      if (t.procType && "ENCRYPTED" === t.procType.type) throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      var s = n.fromDer(t.body);
      return i.privateKeyFromAsn1(s)
    }, i.privateKeyToPem = function (e, t) {
      var r = {
        type: "RSA PRIVATE KEY",
        body: n.toDer(i.privateKeyToAsn1(e)).getBytes()
      };
      return a.pem.encode(r, {
        maxline: t
      })
    }, i.privateKeyInfoToPem = function (e, t) {
      var r = {
        type: "PRIVATE KEY",
        body: n.toDer(e).getBytes()
      };
      return a.pem.encode(r, {
        maxline: t
      })
    }
  }, function (e, t, r) {
    var a = r(0);
    r(1), r(13), r(2),
      function () {
        function t(e, t, a, n) {
          return "workers" in a ? i(e, t, a, n) : r(e, t, a, n)
        }

        function r(e, t, r, a) {
          var i = s(e, t),
            c = 0,
            u = o(i.bitLength());
          "millerRabinTests" in r && (u = r.millerRabinTests);
          var l = 10;
          "maxBlockTime" in r && (l = r.maxBlockTime), n(i, e, t, c, u, l, a)
        }

        function n(e, t, r, i, o, c, u) {
          var p = +new Date;
          do {
            if (e.bitLength() > t && (e = s(t, r)), e.isProbablePrime(o)) return u(null, e);
            e.dAddOffset(l[i++ % 8], 0)
          } while (c < 0 || +new Date - p < c);
          a.util.setImmediate(function () {
            n(e, t, r, i, o, c, u)
          })
        }

        function i(e, t, n, i) {
          function o() {
            function r(r) {
              if (!d) {
                --o;
                var n = r.data;
                if (n.found) {
                  for (var l = 0; l < a.length; ++l) a[l].terminate();
                  return d = !0, i(null, new u(n.prime, 16))
                }
                c.bitLength() > e && (c = s(e, t));
                var f = c.toString(16);
                r.target.postMessage({
                  hex: f,
                  workLoad: p
                }), c.dAddOffset(h, 0)
              }
            }
            l = Math.max(1, l);
            for (var a = [], n = 0; n < l; ++n) a[n] = new Worker(f);
            for (var o = l, n = 0; n < l; ++n) a[n].addEventListener("message", r);
            var d = !1
          }
          if ("undefined" == typeof Worker) return r(e, t, n, i);
          var c = s(e, t),
            l = n.workers,
            p = n.workLoad || 100,
            h = 30 * p / 8,
            f = n.workerScript || "forge/prime.worker.js";
          return l === -1 ? a.util.estimateCores(function (e, t) {
            e && (t = 2), l = t - 1, o()
          }) : void o()
        }

        function s(e, t) {
          var r = new u(e, t),
            a = e - 1;
          return r.testBit(a) || r.bitwiseTo(u.ONE.shiftLeft(a), h, r), r.dAddOffset(31 - r.mod(p).byteValue(), 0), r
        }

        function o(e) {
          return e <= 100 ? 27 : e <= 150 ? 18 : e <= 200 ? 15 : e <= 250 ? 12 : e <= 300 ? 9 : e <= 350 ? 8 : e <= 400 ? 7 : e <= 500 ? 6 : e <= 600 ? 5 : e <= 800 ? 4 : e <= 1250 ? 3 : 2
        }
        if (a.prime) return void(e.exports = a.prime);
        var c = e.exports = a.prime = a.prime || {},
          u = a.jsbn.BigInteger,
          l = [6, 4, 2, 4, 2, 4, 6, 2],
          p = new u(null);
        p.fromInt(30);
        var h = function (e, t) {
          return e | t
        };
        c.generateProbablePrime = function (e, r, n) {
          "function" == typeof r && (n = r, r = {}), r = r || {};
          var i = r.algorithm || "PRIMEINC";
          "string" == typeof i && (i = {
            name: i
          }), i.options = i.options || {};
          var s = r.prng || a.random,
            o = {
              nextBytes: function (e) {
                for (var t = s.getBytesSync(e.length), r = 0; r < e.length; ++r) e[r] = t.charCodeAt(r)
              }
            };
          if ("PRIMEINC" === i.name) return t(e, o, i.options, n);
          throw new Error("Invalid prime generation algorithm: " + i.name)
        }
      }()
  }, function (e, t, r) {
    var a = r(0);
    r(1);
    var n = null;
    !a.util.isNodejs || a.options.usePureJavaScript || process.versions["node-webkit"] || (n = r(32));
    var i = e.exports = a.prng = a.prng || {};
    i.create = function (e) {
      function t(e) {
        if (o.pools[0].messageLength >= 32) return i(), e();
        var t = 32 - o.pools[0].messageLength << 5;
        o.seedFile(t, function (t, r) {
          return t ? e(t) : (o.collect(r), i(), void e())
        })
      }

      function r() {
        if (o.pools[0].messageLength >= 32) return i();
        var e = 32 - o.pools[0].messageLength << 5;
        o.collect(o.seedFileSync(e)), i()
      }

      function i() {
        var e = o.plugin.md.create();
        e.update(o.pools[0].digest().getBytes()), o.pools[0].start();
        for (var t = 1, r = 1; r < 32; ++r) t = 31 === t ? 2147483648 : t << 2, t % o.reseeds === 0 && (e.update(o.pools[r].digest().getBytes()), o.pools[r].start());
        var a = e.digest().getBytes();
        e.start(), e.update(a);
        var n = e.digest().getBytes();
        o.key = o.plugin.formatKey(a), o.seed = o.plugin.formatSeed(n), o.reseeds = 4294967295 === o.reseeds ? 0 : o.reseeds + 1, o.generated = 0
      }

      function s(e) {
        var t = null;
        if ("undefined" != typeof window) {
          var r = window.crypto || window.msCrypto;
          r && r.getRandomValues && (t = function (e) {
            return r.getRandomValues(e)
          })
        }
        var n = a.util.createBuffer();
        if (t)
          for (; n.length() < e;) {
            var i = Math.max(1, Math.min(e - n.length(), 65536) / 4),
              s = new Uint32Array(Math.floor(i));
            try {
              t(s);
              for (var o = 0; o < s.length; ++o) n.putInt32(s[o])
            } catch (e) {
              if (!("undefined" != typeof QuotaExceededError && e instanceof QuotaExceededError)) throw e
            }
          }
        if (n.length() < e)
          for (var c, u, l, p = Math.floor(65536 * Math.random()); n.length() < e;) {
            u = 16807 * (65535 & p), c = 16807 * (p >> 16), u += (32767 & c) << 16, u += c >> 15, u = (2147483647 & u) + (u >> 31), p = 4294967295 & u;
            for (var o = 0; o < 3; ++o) l = p >>> (o << 3), l ^= Math.floor(256 * Math.random()), n.putByte(String.fromCharCode(255 & l))
          }
        return n.getBytes(e)
      }
      for (var o = {
          plugin: e,
          key: null,
          seed: null,
          time: null,
          reseeds: 0,
          generated: 0
        }, c = e.md, u = new Array(32), l = 0; l < 32; ++l) u[l] = c.create();
      return o.pools = u, o.pool = 0, o.generate = function (e, r) {
        function n(p) {
          if (p) return r(p);
          if (l.length() >= e) return r(null, l.getBytes(e));
          if (o.generated > 1048575 && (o.key = null), null === o.key) return a.util.nextTick(function () {
            t(n)
          });
          var h = i(o.key, o.seed);
          o.generated += h.length, l.putBytes(h), o.key = c(i(o.key, s(o.seed))), o.seed = u(i(o.key, o.seed)), a.util.setImmediate(n)
        }
        if (!r) return o.generateSync(e);
        var i = o.plugin.cipher,
          s = o.plugin.increment,
          c = o.plugin.formatKey,
          u = o.plugin.formatSeed,
          l = a.util.createBuffer();
        o.key = null, n()
      }, o.generateSync = function (e) {
        var t = o.plugin.cipher,
          n = o.plugin.increment,
          i = o.plugin.formatKey,
          s = o.plugin.formatSeed;
        o.key = null;
        for (var c = a.util.createBuffer(); c.length() < e;) {
          o.generated > 1048575 && (o.key = null), null === o.key && r();
          var u = t(o.key, o.seed);
          o.generated += u.length, c.putBytes(u), o.key = i(t(o.key, n(o.seed))), o.seed = s(t(o.key, o.seed))
        }
        return c.getBytes(e)
      }, n ? (o.seedFile = function (e, t) {
        n.randomBytes(e, function (e, r) {
          return e ? t(e) : void t(null, r.toString())
        })
      }, o.seedFileSync = function (e) {
        return n.randomBytes(e).toString()
      }) : (o.seedFile = function (e, t) {
        try {
          t(null, s(e))
        } catch (e) {
          t(e)
        }
      }, o.seedFileSync = s), o.collect = function (e) {
        for (var t = e.length, r = 0; r < t; ++r) o.pools[o.pool].update(e.substr(r, 1)), o.pool = 31 === o.pool ? 0 : o.pool + 1
      }, o.collectInt = function (e, t) {
        for (var r = "", a = 0; a < t; a += 8) r += String.fromCharCode(e >> a & 255);
        o.collect(r)
      }, o.registerWorker = function (e) {
        if (e === self) o.seedFile = function (e, t) {
          function r(e) {
            var a = e.data;
            a.forge && a.forge.prng && (self.removeEventListener("message", r), t(a.forge.prng.err, a.forge.prng.bytes))
          }
          self.addEventListener("message", r), self.postMessage({
            forge: {
              prng: {
                needed: e
              }
            }
          })
        };
        else {
          var t = function (t) {
            var r = t.data;
            r.forge && r.forge.prng && o.seedFile(r.forge.prng.needed, function (t, r) {
              e.postMessage({
                forge: {
                  prng: {
                    err: t,
                    bytes: r
                  }
                }
              })
            })
          };
          e.addEventListener("message", t)
        }
      }, o
    }
  }, function (e, t, r) {
    var a = r(0);
    r(1);
    var n = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173],
      i = [1, 2, 3, 5],
      s = function (e, t) {
        return e << t & 65535 | (65535 & e) >> 16 - t
      },
      o = function (e, t) {
        return (65535 & e) >> t | e << 16 - t & 65535
      };
    e.exports = a.rc2 = a.rc2 || {}, a.rc2.expandKey = function (e, t) {
      "string" == typeof e && (e = a.util.createBuffer(e)), t = t || 128;
      var r, i = e,
        s = e.length(),
        o = t,
        c = Math.ceil(o / 8),
        u = 255 >> (7 & o);
      for (r = s; r < 128; r++) i.putByte(n[i.at(r - 1) + i.at(r - s) & 255]);
      for (i.setAt(128 - c, n[i.at(128 - c) & u]), r = 127 - c; r >= 0; r--) i.setAt(r, n[i.at(r + 1) ^ i.at(r + c)]);
      return i
    };
    var c = function (e, t, r) {
      var n, c, u, l, p = !1,
        h = null,
        f = null,
        d = null,
        y = [];
      for (e = a.rc2.expandKey(e, t), u = 0; u < 64; u++) y.push(e.getInt16Le());
      r ? (n = function (e) {
        for (u = 0; u < 4; u++) e[u] += y[l] + (e[(u + 3) % 4] & e[(u + 2) % 4]) + (~e[(u + 3) % 4] & e[(u + 1) % 4]), e[u] = s(e[u], i[u]), l++
      }, c = function (e) {
        for (u = 0; u < 4; u++) e[u] += y[63 & e[(u + 3) % 4]]
      }) : (n = function (e) {
        for (u = 3; u >= 0; u--) e[u] = o(e[u], i[u]), e[u] -= y[l] + (e[(u + 3) % 4] & e[(u + 2) % 4]) + (~e[(u + 3) % 4] & e[(u + 1) % 4]), l--
      }, c = function (e) {
        for (u = 3; u >= 0; u--) e[u] -= y[63 & e[(u + 3) % 4]]
      });
      var g = function (e) {
          var t = [];
          for (u = 0; u < 4; u++) {
            var a = h.getInt16Le();
            null !== d && (r ? a ^= d.getInt16Le() : d.putInt16Le(a)), t.push(65535 & a)
          }
          l = r ? 0 : 63;
          for (var n = 0; n < e.length; n++)
            for (var i = 0; i < e[n][0]; i++) e[n][1](t);
          for (u = 0; u < 4; u++) null !== d && (r ? d.putInt16Le(t[u]) : t[u] ^= d.getInt16Le()), f.putInt16Le(t[u])
        },
        v = null;
      return v = {
        start: function (e, t) {
          e && "string" == typeof e && (e = a.util.createBuffer(e)), p = !1, h = a.util.createBuffer(), f = t || new a.util.createBuffer, d = e, v.output = f
        },
        update: function (e) {
          for (p || h.putBuffer(e); h.length() >= 8;) g([
            [5, n],
            [1, c],
            [6, n],
            [1, c],
            [5, n]
          ])
        },
        finish: function (e) {
          var t = !0;
          if (r)
            if (e) t = e(8, h, !r);
            else {
              var a = 8 === h.length() ? 8 : 8 - h.length();
              h.fillWithByte(a, a)
            } if (t && (p = !0, v.update()), !r && (t = 0 === h.length()))
            if (e) t = e(8, f, !r);
            else {
              var n = f.length(),
                i = f.at(n - 1);
              i > n ? t = !1 : f.truncate(i)
            } return t
        }
      }
    };
    a.rc2.startEncrypting = function (e, t, r) {
      var n = a.rc2.createEncryptionCipher(e, 128);
      return n.start(t, r), n
    }, a.rc2.createEncryptionCipher = function (e, t) {
      return c(e, t, !0)
    }, a.rc2.startDecrypting = function (e, t, r) {
      var n = a.rc2.createDecryptionCipher(e, 128);
      return n.start(t, r), n
    }, a.rc2.createDecryptionCipher = function (e, t) {
      return c(e, t, !1)
    }
  }, function (e, t, r) {
    function a() {
      o = String.fromCharCode(128), o += i.util.fillString(String.fromCharCode(0), 64), u = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], c = !0
    }

    function n(e, t, r) {
      for (var a, n, i, s, o, c, l, p, h, f, d, y, g, v, m, C = r.length(); C >= 64;) {
        for (l = 0; l < 16; ++l) t[l] = r.getInt32();
        for (; l < 64; ++l) a = t[l - 2], a = (a >>> 17 | a << 15) ^ (a >>> 19 | a << 13) ^ a >>> 10, n = t[l - 15], n = (n >>> 7 | n << 25) ^ (n >>> 18 | n << 14) ^ n >>> 3, t[l] = a + t[l - 7] + n + t[l - 16] | 0;
        for (p = e.h0, h = e.h1, f = e.h2, d = e.h3, y = e.h4, g = e.h5, v = e.h6, m = e.h7, l = 0; l < 64; ++l) s = (y >>> 6 | y << 26) ^ (y >>> 11 | y << 21) ^ (y >>> 25 | y << 7), o = v ^ y & (g ^ v), i = (p >>> 2 | p << 30) ^ (p >>> 13 | p << 19) ^ (p >>> 22 | p << 10), c = p & h | f & (p ^ h), a = m + s + o + u[l] + t[l], n = i + c, m = v, v = g, g = y, y = d + a >>> 0, d = f, f = h, h = p, p = a + n >>> 0;
        e.h0 = e.h0 + p | 0, e.h1 = e.h1 + h | 0, e.h2 = e.h2 + f | 0, e.h3 = e.h3 + d | 0, e.h4 = e.h4 + y | 0, e.h5 = e.h5 + g | 0, e.h6 = e.h6 + v | 0, e.h7 = e.h7 + m | 0, C -= 64
      }
    }
    var i = r(0);
    r(4), r(1);
    var s = e.exports = i.sha256 = i.sha256 || {};
    i.md.sha256 = i.md.algorithms.sha256 = s, s.create = function () {
      c || a();
      var e = null,
        t = i.util.createBuffer(),
        r = new Array(64),
        s = {
          algorithm: "sha256",
          blockLength: 64,
          digestLength: 32,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 8
        };
      return s.start = function () {
        s.messageLength = 0, s.fullMessageLength = s.messageLength64 = [];
        for (var r = s.messageLengthSize / 4, a = 0; a < r; ++a) s.fullMessageLength.push(0);
        return t = i.util.createBuffer(), e = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        }, s
      }, s.start(), s.update = function (a, o) {
        "utf8" === o && (a = i.util.encodeUtf8(a));
        var c = a.length;
        s.messageLength += c, c = [c / 4294967296 >>> 0, c >>> 0];
        for (var u = s.fullMessageLength.length - 1; u >= 0; --u) s.fullMessageLength[u] += c[1], c[1] = c[0] + (s.fullMessageLength[u] / 4294967296 >>> 0), s.fullMessageLength[u] = s.fullMessageLength[u] >>> 0, c[0] = c[1] / 4294967296 >>> 0;
        return t.putBytes(a), n(e, r, t), (t.read > 2048 || 0 === t.length()) && t.compact(), s
      }, s.digest = function () {
        var a = i.util.createBuffer();
        a.putBytes(t.bytes());
        var c = s.fullMessageLength[s.fullMessageLength.length - 1] + s.messageLengthSize,
          u = c & s.blockLength - 1;
        a.putBytes(o.substr(0, s.blockLength - u));
        for (var l, p, h = 8 * s.fullMessageLength[0], f = 0; f < s.fullMessageLength.length - 1; ++f) l = 8 * s.fullMessageLength[f + 1], p = l / 4294967296 >>> 0, h += p, a.putInt32(h >>> 0), h = l >>> 0;
        a.putInt32(h);
        var d = {
          h0: e.h0,
          h1: e.h1,
          h2: e.h2,
          h3: e.h3,
          h4: e.h4,
          h5: e.h5,
          h6: e.h6,
          h7: e.h7
        };
        n(d, r, a);
        var y = i.util.createBuffer();
        return y.putInt32(d.h0), y.putInt32(d.h1), y.putInt32(d.h2), y.putInt32(d.h3), y.putInt32(d.h4), y.putInt32(d.h5), y.putInt32(d.h6), y.putInt32(d.h7), y
      }, s
    };
    var o = null,
      c = !1,
      u = null
  }, function (e, t, r) {
    var a = r(0);
    r(3), r(8), r(14), r(7), r(26), r(2), r(9), r(1);
    var n = function (e, t, r, n) {
        var i = a.util.createBuffer(),
          s = e.length >> 1,
          o = s + (1 & e.length),
          c = e.substr(0, o),
          u = e.substr(s, o),
          l = a.util.createBuffer(),
          p = a.hmac.create();
        r = t + r;
        var h = Math.ceil(n / 16),
          f = Math.ceil(n / 20);
        p.start("MD5", c);
        var d = a.util.createBuffer();
        l.putBytes(r);
        for (var y = 0; y < h; ++y) p.start(null, null), p.update(l.getBytes()), l.putBuffer(p.digest()), p.start(null, null), p.update(l.bytes() + r), d.putBuffer(p.digest());
        p.start("SHA1", u);
        var g = a.util.createBuffer();
        l.clear(), l.putBytes(r);
        for (var y = 0; y < f; ++y) p.start(null, null), p.update(l.getBytes()), l.putBuffer(p.digest()), p.start(null, null), p.update(l.bytes() + r), g.putBuffer(p.digest());
        return i.putBytes(a.util.xorBytes(d.getBytes(), g.getBytes(), n)), i
      },
      i = function (e, t, r) {
        var n = a.hmac.create();
        n.start("SHA1", e);
        var i = a.util.createBuffer();
        return i.putInt32(t[0]), i.putInt32(t[1]), i.putByte(r.type), i.putByte(r.version.major), i.putByte(r.version.minor), i.putInt16(r.length), i.putBytes(r.fragment.bytes()), n.update(i.getBytes()), n.digest().getBytes()
      },
      s = function (e, t, r) {
        var n = !1;
        try {
          var i = e.deflate(t.fragment.getBytes());
          t.fragment = a.util.createBuffer(i), t.length = i.length, n = !0
        } catch (e) {}
        return n
      },
      o = function (e, t, r) {
        var n = !1;
        try {
          var i = e.inflate(t.fragment.getBytes());
          t.fragment = a.util.createBuffer(i), t.length = i.length, n = !0
        } catch (e) {}
        return n
      },
      c = function (e, t) {
        var r = 0;
        switch (t) {
          case 1:
            r = e.getByte();
            break;
          case 2:
            r = e.getInt16();
            break;
          case 3:
            r = e.getInt24();
            break;
          case 4:
            r = e.getInt32()
        }
        return a.util.createBuffer(e.getBytes(r))
      },
      u = function (e, t, r) {
        e.putInt(r.length(), t << 3), e.putBuffer(r)
      },
      l = {};
    l.Versions = {
      TLS_1_0: {
        major: 3,
        minor: 1
      },
      TLS_1_1: {
        major: 3,
        minor: 2
      },
      TLS_1_2: {
        major: 3,
        minor: 3
      }
    }, l.SupportedVersions = [l.Versions.TLS_1_1, l.Versions.TLS_1_0], l.Version = l.SupportedVersions[0], l.MaxFragment = 15360, l.ConnectionEnd = {
      server: 0,
      client: 1
    }, l.PRFAlgorithm = {
      tls_prf_sha256: 0
    }, l.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    }, l.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    }, l.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    }, l.CompressionMethod = {
      none: 0,
      deflate: 1
    }, l.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    }, l.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    }, l.Alert = {}, l.Alert.Level = {
      warning: 1,
      fatal: 2
    }, l.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    }, l.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    }, l.CipherSuites = {}, l.getCipherSuite = function (e) {
      var t = null;
      for (var r in l.CipherSuites) {
        var a = l.CipherSuites[r];
        if (a.id[0] === e.charCodeAt(0) && a.id[1] === e.charCodeAt(1)) {
          t = a;
          break
        }
      }
      return t
    }, l.handleUnexpected = function (e, t) {
      var r = !e.open && e.entity === l.ConnectionEnd.client;
      r || e.error(e, {
        message: "Unexpected message. Received TLS record out of order.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.unexpected_message
        }
      })
    }, l.handleHelloRequest = function (e, t, r) {
      !e.handshaking && e.handshakes > 0 && (l.queue(e, l.createAlert(e, {
        level: l.Alert.Level.warning,
        description: l.Alert.Description.no_renegotiation
      })), l.flush(e)), e.process()
    }, l.parseHelloMessage = function (e, t, r) {
      var n = null,
        i = e.entity === l.ConnectionEnd.client;
      if (r < 38) e.error(e, {
        message: i ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.illegal_parameter
        }
      });
      else {
        var s = t.fragment,
          o = s.length();
        if (n = {
            version: {
              major: s.getByte(),
              minor: s.getByte()
            },
            random: a.util.createBuffer(s.getBytes(32)),
            session_id: c(s, 1),
            extensions: []
          }, i ? (n.cipher_suite = s.getBytes(2), n.compression_method = s.getByte()) : (n.cipher_suites = c(s, 2), n.compression_methods = c(s, 1)), o = r - (o - s.length()), o > 0) {
          for (var u = c(s, 2); u.length() > 0;) n.extensions.push({
            type: [u.getByte(), u.getByte()],
            data: c(u, 2)
          });
          if (!i)
            for (var p = 0; p < n.extensions.length; ++p) {
              var h = n.extensions[p];
              if (0 === h.type[0] && 0 === h.type[1])
                for (var f = c(h.data, 2); f.length() > 0;) {
                  var d = f.getByte();
                  if (0 !== d) break;
                  e.session.extensions.server_name.serverNameList.push(c(f, 2).getBytes())
                }
            }
        }
        if (e.session.version && (n.version.major !== e.session.version.major || n.version.minor !== e.session.version.minor)) return e.error(e, {
          message: "TLS version change is disallowed during renegotiation.",
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: l.Alert.Description.protocol_version
          }
        });
        if (i) e.session.cipherSuite = l.getCipherSuite(n.cipher_suite);
        else
          for (var y = a.util.createBuffer(n.cipher_suites.bytes()); y.length() > 0 && (e.session.cipherSuite = l.getCipherSuite(y.getBytes(2)), null === e.session.cipherSuite););
        if (null === e.session.cipherSuite) return e.error(e, {
          message: "No cipher suites in common.",
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: l.Alert.Description.handshake_failure
          },
          cipherSuite: a.util.bytesToHex(n.cipher_suite)
        });
        i ? e.session.compressionMethod = n.compression_method : e.session.compressionMethod = l.CompressionMethod.none
      }
      return n
    }, l.createSecurityParameters = function (e, t) {
      var r = e.entity === l.ConnectionEnd.client,
        a = t.random.bytes(),
        n = r ? e.session.sp.client_random : a,
        i = r ? a : l.createRandom().getBytes();
      e.session.sp = {
        entity: e.entity,
        prf_algorithm: l.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: e.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: n,
        server_random: i
      }
    }, l.handleServerHello = function (e, t, r) {
      var a = l.parseHelloMessage(e, t, r);
      if (!e.fail) {
        if (!(a.version.minor <= e.version.minor)) return e.error(e, {
          message: "Incompatible TLS version.",
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: l.Alert.Description.protocol_version
          }
        });
        e.version.minor = a.version.minor, e.session.version = e.version;
        var n = a.session_id.bytes();
        n.length > 0 && n === e.session.id ? (e.expect = g, e.session.resuming = !0, e.session.sp.server_random = a.random.bytes()) : (e.expect = h, e.session.resuming = !1, l.createSecurityParameters(e, a)), e.session.id = n, e.process()
      }
    }, l.handleClientHello = function (e, t, r) {
      var n = l.parseHelloMessage(e, t, r);
      if (!e.fail) {
        var i = n.session_id.bytes(),
          s = null;
        if (e.sessionCache && (s = e.sessionCache.getSession(i), null === s ? i = "" : (s.version.major !== n.version.major || s.version.minor > n.version.minor) && (s = null, i = "")), 0 === i.length && (i = a.random.getBytes(32)), e.session.id = i, e.session.clientHelloVersion = n.version, e.session.sp = {}, s) e.version = e.session.version = s.version, e.session.sp = s.sp;
        else {
          for (var o, c = 1; c < l.SupportedVersions.length && (o = l.SupportedVersions[c], !(o.minor <= n.version.minor)); ++c);
          e.version = {
            major: o.major,
            minor: o.minor
          }, e.session.version = e.version
        }
        null !== s ? (e.expect = A, e.session.resuming = !0, e.session.sp.client_random = n.random.bytes()) : (e.expect = e.verifyClient !== !1 ? S : T, e.session.resuming = !1, l.createSecurityParameters(e, n)), e.open = !0, l.queue(e, l.createRecord(e, {
          type: l.ContentType.handshake,
          data: l.createServerHello(e)
        })), e.session.resuming ? (l.queue(e, l.createRecord(e, {
          type: l.ContentType.change_cipher_spec,
          data: l.createChangeCipherSpec()
        })), e.state.pending = l.createConnectionState(e), e.state.current.write = e.state.pending.write, l.queue(e, l.createRecord(e, {
          type: l.ContentType.handshake,
          data: l.createFinished(e)
        }))) : (l.queue(e, l.createRecord(e, {
          type: l.ContentType.handshake,
          data: l.createCertificate(e)
        })), e.fail || (l.queue(e, l.createRecord(e, {
          type: l.ContentType.handshake,
          data: l.createServerKeyExchange(e)
        })), e.verifyClient !== !1 && l.queue(e, l.createRecord(e, {
          type: l.ContentType.handshake,
          data: l.createCertificateRequest(e)
        })), l.queue(e, l.createRecord(e, {
          type: l.ContentType.handshake,
          data: l.createServerHelloDone(e)
        })))), l.flush(e), e.process()
      }
    }, l.handleCertificate = function (e, t, r) {
      if (r < 3) return e.error(e, {
        message: "Invalid Certificate message. Message too short.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.illegal_parameter
        }
      });
      var n, i, s = t.fragment,
        o = {
          certificate_list: c(s, 3)
        },
        u = [];
      try {
        for (; o.certificate_list.length() > 0;) n = c(o.certificate_list, 3), i = a.asn1.fromDer(n), n = a.pki.certificateFromAsn1(i, !0), u.push(n)
      } catch (t) {
        return e.error(e, {
          message: "Could not parse certificate list.",
          cause: t,
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: l.Alert.Description.bad_certificate
          }
        })
      }
      var p = e.entity === l.ConnectionEnd.client;
      !p && e.verifyClient !== !0 || 0 !== u.length ? 0 === u.length ? e.expect = p ? f : T : (p ? e.session.serverCertificate = u[0] : e.session.clientCertificate = u[0], l.verifyCertificateChain(e, u) && (e.expect = p ? f : T)) : e.error(e, {
        message: p ? "No server certificate provided." : "No client certificate provided.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.illegal_parameter
        }
      }), e.process()
    }, l.handleServerKeyExchange = function (e, t, r) {
      return r > 0 ? e.error(e, {
        message: "Invalid key parameters. Only RSA is supported.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.unsupported_certificate
        }
      }) : (e.expect = d, void e.process())
    }, l.handleClientKeyExchange = function (e, t, r) {
      if (r < 48) return e.error(e, {
        message: "Invalid key parameters. Only RSA is supported.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.unsupported_certificate
        }
      });
      var n = t.fragment,
        i = {
          enc_pre_master_secret: c(n, 2).getBytes()
        },
        s = null;
      if (e.getPrivateKey) try {
        s = e.getPrivateKey(e, e.session.serverCertificate), s = a.pki.privateKeyFromPem(s)
      } catch (t) {
        e.error(e, {
          message: "Could not get private key.",
          cause: t,
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: l.Alert.Description.internal_error
          }
        })
      }
      if (null === s) return e.error(e, {
        message: "No private key set.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.internal_error
        }
      });
      try {
        var o = e.session.sp;
        o.pre_master_secret = s.decrypt(i.enc_pre_master_secret);
        var u = e.session.clientHelloVersion;
        if (u.major !== o.pre_master_secret.charCodeAt(0) || u.minor !== o.pre_master_secret.charCodeAt(1)) throw new Error("TLS version rollback attack detected.")
      } catch (e) {
        o.pre_master_secret = a.random.getBytes(48)
      }
      e.expect = A, null !== e.session.clientCertificate && (e.expect = I), e.process()
    }, l.handleCertificateRequest = function (e, t, r) {
      if (r < 3) return e.error(e, {
        message: "Invalid CertificateRequest. Message too short.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.illegal_parameter
        }
      });
      var a = t.fragment,
        n = {
          certificate_types: c(a, 1),
          certificate_authorities: c(a, 2)
        };
      e.session.certificateRequest = n, e.expect = y, e.process()
    }, l.handleCertificateVerify = function (e, t, r) {
      if (r < 2) return e.error(e, {
        message: "Invalid CertificateVerify. Message too short.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.illegal_parameter
        }
      });
      var n = t.fragment;
      n.read -= 4;
      var i = n.bytes();
      n.read += 4;
      var s = {
          signature: c(n, 2).getBytes()
        },
        o = a.util.createBuffer();
      o.putBuffer(e.session.md5.digest()), o.putBuffer(e.session.sha1.digest()), o = o.getBytes();
      try {
        var u = e.session.clientCertificate;
        if (!u.publicKey.verify(o, s.signature, "NONE")) throw new Error("CertificateVerify signature does not match.");
        e.session.md5.update(i), e.session.sha1.update(i)
      } catch (t) {
        return e.error(e, {
          message: "Bad signature in CertificateVerify.",
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: l.Alert.Description.handshake_failure
          }
        })
      }
      e.expect = A, e.process()
    }, l.handleServerHelloDone = function (e, t, r) {
      if (r > 0) return e.error(e, {
        message: "Invalid ServerHelloDone message. Invalid length.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.record_overflow
        }
      });
      if (null === e.serverCertificate) {
        var n = {
            message: "No server certificate provided. Not enough security.",
            send: !0,
            alert: {
              level: l.Alert.Level.fatal,
              description: l.Alert.Description.insufficient_security
            }
          },
          i = 0,
          s = e.verify(e, n.alert.description, i, []);
        if (s !== !0) return (s || 0 === s) && ("object" != typeof s || a.util.isArray(s) ? "number" == typeof s && (n.alert.description = s) : (s.message && (n.message = s.message), s.alert && (n.alert.description = s.alert))), e.error(e, n)
      }
      null !== e.session.certificateRequest && (t = l.createRecord(e, {
        type: l.ContentType.handshake,
        data: l.createCertificate(e)
      }), l.queue(e, t)), t = l.createRecord(e, {
        type: l.ContentType.handshake,
        data: l.createClientKeyExchange(e)
      }), l.queue(e, t), e.expect = C;
      var o = function (e, t) {
        null !== e.session.certificateRequest && null !== e.session.clientCertificate && l.queue(e, l.createRecord(e, {
          type: l.ContentType.handshake,
          data: l.createCertificateVerify(e, t)
        })), l.queue(e, l.createRecord(e, {
          type: l.ContentType.change_cipher_spec,
          data: l.createChangeCipherSpec()
        })), e.state.pending = l.createConnectionState(e), e.state.current.write = e.state.pending.write, l.queue(e, l.createRecord(e, {
          type: l.ContentType.handshake,
          data: l.createFinished(e)
        })), e.expect = g, l.flush(e), e.process()
      };
      return null === e.session.certificateRequest || null === e.session.clientCertificate ? o(e, null) : void l.getClientSignature(e, o)
    }, l.handleChangeCipherSpec = function (e, t) {
      if (1 !== t.fragment.getByte()) return e.error(e, {
        message: "Invalid ChangeCipherSpec message received.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.illegal_parameter
        }
      });
      var r = e.entity === l.ConnectionEnd.client;
      (e.session.resuming && r || !e.session.resuming && !r) && (e.state.pending = l.createConnectionState(e)), e.state.current.read = e.state.pending.read, (!e.session.resuming && r || e.session.resuming && !r) && (e.state.pending = null), e.expect = r ? v : b, e.process()
    }, l.handleFinished = function (e, t, r) {
      var i = t.fragment;
      i.read -= 4;
      var s = i.bytes();
      i.read += 4;
      var o = t.fragment.getBytes();
      i = a.util.createBuffer(), i.putBuffer(e.session.md5.digest()), i.putBuffer(e.session.sha1.digest());
      var c = e.entity === l.ConnectionEnd.client,
        u = c ? "server finished" : "client finished",
        p = e.session.sp,
        h = 12,
        f = n;
      return i = f(p.master_secret, u, i.getBytes(), h), i.getBytes() !== o ? e.error(e, {
        message: "Invalid verify_data in Finished message.",
        send: !0,
        alert: {
          level: l.Alert.Level.fatal,
          description: l.Alert.Description.decrypt_error
        }
      }) : (e.session.md5.update(s), e.session.sha1.update(s), (e.session.resuming && c || !e.session.resuming && !c) && (l.queue(e, l.createRecord(e, {
        type: l.ContentType.change_cipher_spec,
        data: l.createChangeCipherSpec()
      })), e.state.current.write = e.state.pending.write, e.state.pending = null, l.queue(e, l.createRecord(e, {
        type: l.ContentType.handshake,
        data: l.createFinished(e)
      }))), e.expect = c ? m : B, e.handshaking = !1, ++e.handshakes, e.peerCertificate = c ? e.session.serverCertificate : e.session.clientCertificate, l.flush(e), e.isConnected = !0, e.connected(e), void e.process())
    }, l.handleAlert = function (e, t) {
      var r, a = t.fragment,
        n = {
          level: a.getByte(),
          description: a.getByte()
        };
      switch (n.description) {
        case l.Alert.Description.close_notify:
          r = "Connection closed.";
          break;
        case l.Alert.Description.unexpected_message:
          r = "Unexpected message.";
          break;
        case l.Alert.Description.bad_record_mac:
          r = "Bad record MAC.";
          break;
        case l.Alert.Description.decryption_failed:
          r = "Decryption failed.";
          break;
        case l.Alert.Description.record_overflow:
          r = "Record overflow.";
          break;
        case l.Alert.Description.decompression_failure:
          r = "Decompression failed.";
          break;
        case l.Alert.Description.handshake_failure:
          r = "Handshake failure.";
          break;
        case l.Alert.Description.bad_certificate:
          r = "Bad certificate.";
          break;
        case l.Alert.Description.unsupported_certificate:
          r = "Unsupported certificate.";
          break;
        case l.Alert.Description.certificate_revoked:
          r = "Certificate revoked.";
          break;
        case l.Alert.Description.certificate_expired:
          r = "Certificate expired.";
          break;
        case l.Alert.Description.certificate_unknown:
          r = "Certificate unknown.";
          break;
        case l.Alert.Description.illegal_parameter:
          r = "Illegal parameter.";
          break;
        case l.Alert.Description.unknown_ca:
          r = "Unknown certificate authority.";
          break;
        case l.Alert.Description.access_denied:
          r = "Access denied.";
          break;
        case l.Alert.Description.decode_error:
          r = "Decode error.";
          break;
        case l.Alert.Description.decrypt_error:
          r = "Decrypt error.";
          break;
        case l.Alert.Description.export_restriction:
          r = "Export restriction.";
          break;
        case l.Alert.Description.protocol_version:
          r = "Unsupported protocol version.";
          break;
        case l.Alert.Description.insufficient_security:
          r = "Insufficient security.";
          break;
        case l.Alert.Description.internal_error:
          r = "Internal error.";
          break;
        case l.Alert.Description.user_canceled:
          r = "User canceled.";
          break;
        case l.Alert.Description.no_renegotiation:
          r = "Renegotiation not supported.";
          break;
        default:
          r = "Unknown error."
      }
      return n.description === l.Alert.Description.close_notify ? e.close() : (e.error(e, {
        message: r,
        send: !1,
        origin: e.entity === l.ConnectionEnd.client ? "server" : "client",
        alert: n
      }), void e.process())
    }, l.handleHandshake = function (e, t) {
      var r = t.fragment,
        n = r.getByte(),
        i = r.getInt24();
      if (i > r.length()) return e.fragmented = t, t.fragment = a.util.createBuffer(), r.read -= 4, e.process();
      e.fragmented = null, r.read -= 4;
      var s = r.bytes(i + 4);
      r.read += 4, n in F[e.entity][e.expect] ? (e.entity !== l.ConnectionEnd.server || e.open || e.fail || (e.handshaking = !0, e.session = {
        version: null,
        extensions: {
          server_name: {
            serverNameList: []
          }
        },
        cipherSuite: null,
        compressionMethod: null,
        serverCertificate: null,
        clientCertificate: null,
        md5: a.md.md5.create(),
        sha1: a.md.sha1.create()
      }), n !== l.HandshakeType.hello_request && n !== l.HandshakeType.certificate_verify && n !== l.HandshakeType.finished && (e.session.md5.update(s), e.session.sha1.update(s)), F[e.entity][e.expect][n](e, t, i)) : l.handleUnexpected(e, t)
    }, l.handleApplicationData = function (e, t) {
      e.data.putBuffer(t.fragment), e.dataReady(e), e.process()
    }, l.handleHeartbeat = function (e, t) {
      var r = t.fragment,
        n = r.getByte(),
        i = r.getInt16(),
        s = r.getBytes(i);
      if (n === l.HeartbeatMessageType.heartbeat_request) {
        if (e.handshaking || i > s.length) return e.process();
        l.queue(e, l.createRecord(e, {
          type: l.ContentType.heartbeat,
          data: l.createHeartbeat(l.HeartbeatMessageType.heartbeat_response, s)
        })), l.flush(e)
      } else if (n === l.HeartbeatMessageType.heartbeat_response) {
        if (s !== e.expectedHeartbeatPayload) return e.process();
        e.heartbeatReceived && e.heartbeatReceived(e, a.util.createBuffer(s))
      }
      e.process()
    };
    var p = 0,
      h = 1,
      f = 2,
      d = 3,
      y = 4,
      g = 5,
      v = 6,
      m = 7,
      C = 8,
      E = 0,
      S = 1,
      T = 2,
      I = 3,
      A = 4,
      b = 5,
      B = 6,
      N = l.handleUnexpected,
      k = l.handleChangeCipherSpec,
      R = l.handleAlert,
      w = l.handleHandshake,
      L = l.handleApplicationData,
      _ = l.handleHeartbeat,
      U = [];
    U[l.ConnectionEnd.client] = [
      [N, R, w, N, _],
      [N, R, w, N, _],
      [N, R, w, N, _],
      [N, R, w, N, _],
      [N, R, w, N, _],
      [k, R, N, N, _],
      [N, R, w, N, _],
      [N, R, w, L, _],
      [N, R, w, N, _]
    ], U[l.ConnectionEnd.server] = [
      [N, R, w, N, _],
      [N, R, w, N, _],
      [N, R, w, N, _],
      [N, R, w, N, _],
      [k, R, N, N, _],
      [N, R, w, N, _],
      [N, R, w, L, _],
      [N, R, w, N, _]
    ];
    var D = l.handleHelloRequest,
      P = l.handleServerHello,
      V = l.handleCertificate,
      O = l.handleServerKeyExchange,
      x = l.handleCertificateRequest,
      K = l.handleServerHelloDone,
      M = l.handleFinished,
      F = [];
    F[l.ConnectionEnd.client] = [
      [N, N, P, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
      [D, N, N, N, N, N, N, N, N, N, N, V, O, x, K, N, N, N, N, N, N],
      [D, N, N, N, N, N, N, N, N, N, N, N, O, x, K, N, N, N, N, N, N],
      [D, N, N, N, N, N, N, N, N, N, N, N, N, x, K, N, N, N, N, N, N],
      [D, N, N, N, N, N, N, N, N, N, N, N, N, N, K, N, N, N, N, N, N],
      [D, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
      [D, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, M],
      [D, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
      [D, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N]
    ];
    var q = l.handleClientHello,
      j = l.handleClientKeyExchange,
      H = l.handleCertificateVerify;
    F[l.ConnectionEnd.server] = [
      [N, q, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
      [N, N, N, N, N, N, N, N, N, N, N, V, N, N, N, N, N, N, N, N, N],
      [N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, j, N, N, N, N],
      [N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, H, N, N, N, N, N],
      [N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
      [N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, M],
      [N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
      [N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N]
    ], l.generateKeys = function (e, t) {
      var r = n,
        a = t.client_random + t.server_random;
      e.session.resuming || (t.master_secret = r(t.pre_master_secret, "master secret", a, 48).bytes(), t.pre_master_secret = null), a = t.server_random + t.client_random;
      var i = 2 * t.mac_key_length + 2 * t.enc_key_length,
        s = e.version.major === l.Versions.TLS_1_0.major && e.version.minor === l.Versions.TLS_1_0.minor;
      s && (i += 2 * t.fixed_iv_length);
      var o = r(t.master_secret, "key expansion", a, i),
        c = {
          client_write_MAC_key: o.getBytes(t.mac_key_length),
          server_write_MAC_key: o.getBytes(t.mac_key_length),
          client_write_key: o.getBytes(t.enc_key_length),
          server_write_key: o.getBytes(t.enc_key_length)
        };
      return s && (c.client_write_IV = o.getBytes(t.fixed_iv_length), c.server_write_IV = o.getBytes(t.fixed_iv_length)), c
    }, l.createConnectionState = function (e) {
      var t = e.entity === l.ConnectionEnd.client,
        r = function () {
          var e = {
            sequenceNumber: [0, 0],
            macKey: null,
            macLength: 0,
            macFunction: null,
            cipherState: null,
            cipherFunction: function (e) {
              return !0
            },
            compressionState: null,
            compressFunction: function (e) {
              return !0
            },
            updateSequenceNumber: function () {
              4294967295 === e.sequenceNumber[1] ? (e.sequenceNumber[1] = 0, ++e.sequenceNumber[0]) : ++e.sequenceNumber[1]
            }
          };
          return e
        },
        a = {
          read: r(),
          write: r()
        };
      if (a.read.update = function (e, t) {
          return a.read.cipherFunction(t, a.read) ? a.read.compressFunction(e, t, a.read) || e.error(e, {
            message: "Could not decompress record.",
            send: !0,
            alert: {
              level: l.Alert.Level.fatal,
              description: l.Alert.Description.decompression_failure
            }
          }) : e.error(e, {
            message: "Could not decrypt record or bad MAC.",
            send: !0,
            alert: {
              level: l.Alert.Level.fatal,
              description: l.Alert.Description.bad_record_mac
            }
          }), !e.fail
        }, a.write.update = function (e, t) {
          return a.write.compressFunction(e, t, a.write) ? a.write.cipherFunction(t, a.write) || e.error(e, {
            message: "Could not encrypt record.",
            send: !1,
            alert: {
              level: l.Alert.Level.fatal,
              description: l.Alert.Description.internal_error
            }
          }) : e.error(e, {
            message: "Could not compress record.",
            send: !1,
            alert: {
              level: l.Alert.Level.fatal,
              description: l.Alert.Description.internal_error
            }
          }), !e.fail
        }, e.session) {
        var n = e.session.sp;
        switch (e.session.cipherSuite.initSecurityParameters(n), n.keys = l.generateKeys(e, n), a.read.macKey = t ? n.keys.server_write_MAC_key : n.keys.client_write_MAC_key, a.write.macKey = t ? n.keys.client_write_MAC_key : n.keys.server_write_MAC_key, e.session.cipherSuite.initConnectionState(a, e, n), n.compression_algorithm) {
          case l.CompressionMethod.none:
            break;
          case l.CompressionMethod.deflate:
            a.read.compressFunction = o, a.write.compressFunction = s;
            break;
          default:
            throw new Error("Unsupported compression algorithm.")
        }
      }
      return a
    }, l.createRandom = function () {
      var e = new Date,
        t = +e + 6e4 * e.getTimezoneOffset(),
        r = a.util.createBuffer();
      return r.putInt32(t), r.putBytes(a.random.getBytes(28)), r
    }, l.createRecord = function (e, t) {
      if (!t.data) return null;
      var r = {
        type: t.type,
        version: {
          major: e.version.major,
          minor: e.version.minor
        },
        length: t.data.length(),
        fragment: t.data
      };
      return r
    }, l.createAlert = function (e, t) {
      var r = a.util.createBuffer();
      return r.putByte(t.level), r.putByte(t.description), l.createRecord(e, {
        type: l.ContentType.alert,
        data: r
      })
    }, l.createClientHello = function (e) {
      e.session.clientHelloVersion = {
        major: e.version.major,
        minor: e.version.minor
      };
      for (var t = a.util.createBuffer(), r = 0; r < e.cipherSuites.length; ++r) {
        var n = e.cipherSuites[r];
        t.putByte(n.id[0]), t.putByte(n.id[1])
      }
      var i = t.length(),
        s = a.util.createBuffer();
      s.putByte(l.CompressionMethod.none);
      var o = s.length(),
        c = a.util.createBuffer();
      if (e.virtualHost) {
        var p = a.util.createBuffer();
        p.putByte(0), p.putByte(0);
        var h = a.util.createBuffer();
        h.putByte(0), u(h, 2, a.util.createBuffer(e.virtualHost));
        var f = a.util.createBuffer();
        u(f, 2, h), u(p, 2, f), c.putBuffer(p)
      }
      var d = c.length();
      d > 0 && (d += 2);
      var y = e.session.id,
        g = y.length + 1 + 2 + 4 + 28 + 2 + i + 1 + o + d,
        v = a.util.createBuffer();
      return v.putByte(l.HandshakeType.client_hello), v.putInt24(g), v.putByte(e.version.major), v.putByte(e.version.minor), v.putBytes(e.session.sp.client_random), u(v, 1, a.util.createBuffer(y)), u(v, 2, t), u(v, 1, s), d > 0 && u(v, 2, c), v
    }, l.createServerHello = function (e) {
      var t = e.session.id,
        r = t.length + 1 + 2 + 4 + 28 + 2 + 1,
        n = a.util.createBuffer();
      return n.putByte(l.HandshakeType.server_hello), n.putInt24(r), n.putByte(e.version.major), n.putByte(e.version.minor), n.putBytes(e.session.sp.server_random), u(n, 1, a.util.createBuffer(t)), n.putByte(e.session.cipherSuite.id[0]), n.putByte(e.session.cipherSuite.id[1]), n.putByte(e.session.compressionMethod), n
    }, l.createCertificate = function (e) {
      var t = e.entity === l.ConnectionEnd.client,
        r = null;
      if (e.getCertificate) {
        var n;
        n = t ? e.session.certificateRequest : e.session.extensions.server_name.serverNameList, r = e.getCertificate(e, n)
      }
      var i = a.util.createBuffer();
      if (null !== r) try {
        a.util.isArray(r) || (r = [r]);
        for (var s = null, o = 0; o < r.length; ++o) {
          var c = a.pem.decode(r[o])[0];
          if ("CERTIFICATE" !== c.type && "X509 CERTIFICATE" !== c.type && "TRUSTED CERTIFICATE" !== c.type) {
            var p = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
            throw p.headerType = c.type, p
          }
          if (c.procType && "ENCRYPTED" === c.procType.type) throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
          var h = a.util.createBuffer(c.body);
          null === s && (s = a.asn1.fromDer(h.bytes(), !1));
          var f = a.util.createBuffer();
          u(f, 3, h), i.putBuffer(f)
        }
        r = a.pki.certificateFromAsn1(s), t ? e.session.clientCertificate = r : e.session.serverCertificate = r
      } catch (t) {
        return e.error(e, {
          message: "Could not send certificate list.",
          cause: t,
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: l.Alert.Description.bad_certificate
          }
        })
      }
      var d = 3 + i.length(),
        y = a.util.createBuffer();
      return y.putByte(l.HandshakeType.certificate), y.putInt24(d), u(y, 3, i), y
    }, l.createClientKeyExchange = function (e) {
      var t = a.util.createBuffer();
      t.putByte(e.session.clientHelloVersion.major), t.putByte(e.session.clientHelloVersion.minor), t.putBytes(a.random.getBytes(46));
      var r = e.session.sp;
      r.pre_master_secret = t.getBytes();
      var n = e.session.serverCertificate.publicKey;
      t = n.encrypt(r.pre_master_secret);
      var i = t.length + 2,
        s = a.util.createBuffer();
      return s.putByte(l.HandshakeType.client_key_exchange), s.putInt24(i), s.putInt16(t.length), s.putBytes(t), s
    }, l.createServerKeyExchange = function (e) {
      var t = 0,
        r = a.util.createBuffer();
      return t > 0 && (r.putByte(l.HandshakeType.server_key_exchange), r.putInt24(t)), r
    }, l.getClientSignature = function (e, t) {
      var r = a.util.createBuffer();
      r.putBuffer(e.session.md5.digest()), r.putBuffer(e.session.sha1.digest()), r = r.getBytes(), e.getSignature = e.getSignature || function (e, t, r) {
        var n = null;
        if (e.getPrivateKey) try {
          n = e.getPrivateKey(e, e.session.clientCertificate), n = a.pki.privateKeyFromPem(n)
        } catch (t) {
          e.error(e, {
            message: "Could not get private key.",
            cause: t,
            send: !0,
            alert: {
              level: l.Alert.Level.fatal,
              description: l.Alert.Description.internal_error
            }
          })
        }
        null === n ? e.error(e, {
          message: "No private key set.",
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: l.Alert.Description.internal_error
          }
        }) : t = n.sign(t, null), r(e, t)
      }, e.getSignature(e, r, t)
    }, l.createCertificateVerify = function (e, t) {
      var r = t.length + 2,
        n = a.util.createBuffer();
      return n.putByte(l.HandshakeType.certificate_verify), n.putInt24(r), n.putInt16(t.length), n.putBytes(t), n
    }, l.createCertificateRequest = function (e) {
      var t = a.util.createBuffer();
      t.putByte(1);
      var r = a.util.createBuffer();
      for (var n in e.caStore.certs) {
        var i = e.caStore.certs[n],
          s = a.pki.distinguishedNameToAsn1(i.subject),
          o = a.asn1.toDer(s);
        r.putInt16(o.length()), r.putBuffer(o)
      }
      var c = 1 + t.length() + 2 + r.length(),
        p = a.util.createBuffer();
      return p.putByte(l.HandshakeType.certificate_request), p.putInt24(c), u(p, 1, t), u(p, 2, r), p
    }, l.createServerHelloDone = function (e) {
      var t = a.util.createBuffer();
      return t.putByte(l.HandshakeType.server_hello_done), t.putInt24(0), t
    }, l.createChangeCipherSpec = function () {
      var e = a.util.createBuffer();
      return e.putByte(1), e
    }, l.createFinished = function (e) {
      var t = a.util.createBuffer();
      t.putBuffer(e.session.md5.digest()), t.putBuffer(e.session.sha1.digest());
      var r = e.entity === l.ConnectionEnd.client,
        i = e.session.sp,
        s = 12,
        o = n,
        c = r ? "client finished" : "server finished";
      t = o(i.master_secret, c, t.getBytes(), s);
      var u = a.util.createBuffer();
      return u.putByte(l.HandshakeType.finished), u.putInt24(t.length()), u.putBuffer(t), u
    }, l.createHeartbeat = function (e, t, r) {
      "undefined" == typeof r && (r = t.length);
      var n = a.util.createBuffer();
      n.putByte(e), n.putInt16(r), n.putBytes(t);
      var i = n.length(),
        s = Math.max(16, i - r - 3);
      return n.putBytes(a.random.getBytes(s)), n
    }, l.queue = function (e, t) {
      if (t && (0 !== t.fragment.length() || t.type !== l.ContentType.handshake && t.type !== l.ContentType.alert && t.type !== l.ContentType.change_cipher_spec)) {
        if (t.type === l.ContentType.handshake) {
          var r = t.fragment.bytes();
          e.session.md5.update(r), e.session.sha1.update(r), r = null
        }
        var n;
        if (t.fragment.length() <= l.MaxFragment) n = [t];
        else {
          n = [];
          for (var i = t.fragment.bytes(); i.length > l.MaxFragment;) n.push(l.createRecord(e, {
            type: t.type,
            data: a.util.createBuffer(i.slice(0, l.MaxFragment))
          })), i = i.slice(l.MaxFragment);
          i.length > 0 && n.push(l.createRecord(e, {
            type: t.type,
            data: a.util.createBuffer(i)
          }))
        }
        for (var s = 0; s < n.length && !e.fail; ++s) {
          var o = n[s],
            c = e.state.current.write;
          c.update(e, o) && e.records.push(o)
        }
      }
    }, l.flush = function (e) {
      for (var t = 0; t < e.records.length; ++t) {
        var r = e.records[t];
        e.tlsData.putByte(r.type), e.tlsData.putByte(r.version.major), e.tlsData.putByte(r.version.minor), e.tlsData.putInt16(r.fragment.length()), e.tlsData.putBuffer(e.records[t].fragment)
      }
      return e.records = [], e.tlsDataReady(e)
    };
    var G = function (e) {
        switch (e) {
          case !0:
            return !0;
          case a.pki.certificateError.bad_certificate:
            return l.Alert.Description.bad_certificate;
          case a.pki.certificateError.unsupported_certificate:
            return l.Alert.Description.unsupported_certificate;
          case a.pki.certificateError.certificate_revoked:
            return l.Alert.Description.certificate_revoked;
          case a.pki.certificateError.certificate_expired:
            return l.Alert.Description.certificate_expired;
          case a.pki.certificateError.certificate_unknown:
            return l.Alert.Description.certificate_unknown;
          case a.pki.certificateError.unknown_ca:
            return l.Alert.Description.unknown_ca;
          default:
            return l.Alert.Description.bad_certificate
        }
      },
      Q = function (e) {
        switch (e) {
          case !0:
            return !0;
          case l.Alert.Description.bad_certificate:
            return a.pki.certificateError.bad_certificate;
          case l.Alert.Description.unsupported_certificate:
            return a.pki.certificateError.unsupported_certificate;
          case l.Alert.Description.certificate_revoked:
            return a.pki.certificateError.certificate_revoked;
          case l.Alert.Description.certificate_expired:
            return a.pki.certificateError.certificate_expired;
          case l.Alert.Description.certificate_unknown:
            return a.pki.certificateError.certificate_unknown;
          case l.Alert.Description.unknown_ca:
            return a.pki.certificateError.unknown_ca;
          default:
            return a.pki.certificateError.bad_certificate
        }
      };
    l.verifyCertificateChain = function (e, t) {
      try {
        a.pki.verifyCertificateChain(e.caStore, t, function (t, r, n) {
          var i = (G(t), e.verify(e, t, r, n));
          if (i !== !0) {
            if ("object" == typeof i && !a.util.isArray(i)) {
              var s = new Error("The application rejected the certificate.");
              throw s.send = !0, s.alert = {
                level: l.Alert.Level.fatal,
                description: l.Alert.Description.bad_certificate
              }, i.message && (s.message = i.message), i.alert && (s.alert.description = i.alert), s
            }
            i !== t && (i = Q(i))
          }
          return i
        })
      } catch (t) {
        var r = t;
        ("object" != typeof r || a.util.isArray(r)) && (r = {
          send: !0,
          alert: {
            level: l.Alert.Level.fatal,
            description: G(t)
          }
        }), "send" in r || (r.send = !0), "alert" in r || (r.alert = {
          level: l.Alert.Level.fatal,
          description: G(r.error)
        }), e.error(e, r)
      }
      return !e.fail
    }, l.createSessionCache = function (e, t) {
      var r = null;
      if (e && e.getSession && e.setSession && e.order) r = e;
      else {
        r = {}, r.cache = e || {}, r.capacity = Math.max(t || 100, 1), r.order = [];
        for (var n in e) r.order.length <= t ? r.order.push(n) : delete e[n];
        r.getSession = function (e) {
          var t = null,
            n = null;
          if (e ? n = a.util.bytesToHex(e) : r.order.length > 0 && (n = r.order[0]), null !== n && n in r.cache) {
            t = r.cache[n], delete r.cache[n];
            for (var i in r.order)
              if (r.order[i] === n) {
                r.order.splice(i, 1);
                break
              }
          }
          return t
        }, r.setSession = function (e, t) {
          if (r.order.length === r.capacity) {
            var n = r.order.shift();
            delete r.cache[n]
          }
          var n = a.util.bytesToHex(e);
          r.order.push(n), r.cache[n] = t
        }
      }
      return r
    }, l.createConnection = function (e) {
      var t = null;
      t = e.caStore ? a.util.isArray(e.caStore) ? a.pki.createCaStore(e.caStore) : e.caStore : a.pki.createCaStore();
      var r = e.cipherSuites || null;
      if (null === r) {
        r = [];
        for (var n in l.CipherSuites) r.push(l.CipherSuites[n])
      }
      var i = e.server ? l.ConnectionEnd.server : l.ConnectionEnd.client,
        s = e.sessionCache ? l.createSessionCache(e.sessionCache) : null,
        o = {
          version: {
            major: l.Version.major,
            minor: l.Version.minor
          },
          entity: i,
          sessionId: e.sessionId,
          caStore: t,
          sessionCache: s,
          cipherSuites: r,
          connected: e.connected,
          virtualHost: e.virtualHost || null,
          verifyClient: e.verifyClient || !1,
          verify: e.verify || function (e, t, r, a) {
            return t
          },
          getCertificate: e.getCertificate || null,
          getPrivateKey: e.getPrivateKey || null,
          getSignature: e.getSignature || null,
          input: a.util.createBuffer(),
          tlsData: a.util.createBuffer(),
          data: a.util.createBuffer(),
          tlsDataReady: e.tlsDataReady,
          dataReady: e.dataReady,
          heartbeatReceived: e.heartbeatReceived,
          closed: e.closed,
          error: function (t, r) {
            r.origin = r.origin || (t.entity === l.ConnectionEnd.client ? "client" : "server"), r.send && (l.queue(t, l.createAlert(t, r.alert)), l.flush(t));
            var a = r.fatal !== !1;
            a && (t.fail = !0), e.error(t, r), a && t.close(!1)
          },
          deflate: e.deflate || null,
          inflate: e.inflate || null
        };
      o.reset = function (e) {
        o.version = {
          major: l.Version.major,
          minor: l.Version.minor
        }, o.record = null, o.session = null, o.peerCertificate = null, o.state = {
          pending: null,
          current: null
        }, o.expect = o.entity === l.ConnectionEnd.client ? p : E, o.fragmented = null, o.records = [], o.open = !1, o.handshakes = 0, o.handshaking = !1, o.isConnected = !1, o.fail = !(e || "undefined" == typeof e), o.input.clear(), o.tlsData.clear(), o.data.clear(), o.state.current = l.createConnectionState(o)
      }, o.reset();
      var c = function (e, t) {
          var r = t.type - l.ContentType.change_cipher_spec,
            a = U[e.entity][e.expect];
          r in a ? a[r](e, t) : l.handleUnexpected(e, t)
        },
        u = function (e) {
          var t = 0,
            r = e.input,
            n = r.length();
          if (n < 5) t = 5 - n;
          else {
            e.record = {
              type: r.getByte(),
              version: {
                major: r.getByte(),
                minor: r.getByte()
              },
              length: r.getInt16(),
              fragment: a.util.createBuffer(),
              ready: !1
            };
            var i = e.record.version.major === e.version.major;
            i && e.session && e.session.version && (i = e.record.version.minor === e.version.minor), i || e.error(e, {
              message: "Incompatible TLS version.",
              send: !0,
              alert: {
                level: l.Alert.Level.fatal,
                description: l.Alert.Description.protocol_version
              }
            })
          }
          return t
        },
        h = function (e) {
          var t = 0,
            r = e.input,
            a = r.length();
          if (a < e.record.length) t = e.record.length - a;
          else {
            e.record.fragment.putBytes(r.getBytes(e.record.length)), r.compact();
            var n = e.state.current.read;
            n.update(e, e.record) && (null !== e.fragmented && (e.fragmented.type === e.record.type ? (e.fragmented.fragment.putBuffer(e.record.fragment), e.record = e.fragmented) : e.error(e, {
              message: "Invalid fragmented record.",
              send: !0,
              alert: {
                level: l.Alert.Level.fatal,
                description: l.Alert.Description.unexpected_message
              }
            })), e.record.ready = !0)
          }
          return t
        };
      return o.handshake = function (e) {
        if (o.entity !== l.ConnectionEnd.client) o.error(o, {
          message: "Cannot initiate handshake as a server.",
          fatal: !1
        });
        else if (o.handshaking) o.error(o, {
          message: "Handshake already in progress.",
          fatal: !1
        });
        else {
          o.fail && !o.open && 0 === o.handshakes && (o.fail = !1), o.handshaking = !0, e = e || "";
          var t = null;
          e.length > 0 && (o.sessionCache && (t = o.sessionCache.getSession(e)), null === t && (e = "")), 0 === e.length && o.sessionCache && (t = o.sessionCache.getSession(), null !== t && (e = t.id)), o.session = {
            id: e,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: a.md.md5.create(),
            sha1: a.md.sha1.create()
          }, t && (o.version = t.version, o.session.sp = t.sp), o.session.sp.client_random = l.createRandom().getBytes(), o.open = !0, l.queue(o, l.createRecord(o, {
            type: l.ContentType.handshake,
            data: l.createClientHello(o)
          })), l.flush(o)
        }
      }, o.process = function (e) {
        var t = 0;
        return e && o.input.putBytes(e), o.fail || (null !== o.record && o.record.ready && o.record.fragment.isEmpty() && (o.record = null), null === o.record && (t = u(o)), o.fail || null === o.record || o.record.ready || (t = h(o)), !o.fail && null !== o.record && o.record.ready && c(o, o.record)), t
      }, o.prepare = function (e) {
        return l.queue(o, l.createRecord(o, {
          type: l.ContentType.application_data,
          data: a.util.createBuffer(e)
        })), l.flush(o)
      }, o.prepareHeartbeatRequest = function (e, t) {
        return e instanceof a.util.ByteBuffer && (e = e.bytes()), "undefined" == typeof t && (t = e.length), o.expectedHeartbeatPayload = e, l.queue(o, l.createRecord(o, {
          type: l.ContentType.heartbeat,
          data: l.createHeartbeat(l.HeartbeatMessageType.heartbeat_request, e, t)
        })), l.flush(o)
      }, o.close = function (e) {
        if (!o.fail && o.sessionCache && o.session) {
          var t = {
            id: o.session.id,
            version: o.session.version,
            sp: o.session.sp
          };
          t.sp.keys = null, o.sessionCache.setSession(t.id, t)
        }
        o.open && (o.open = !1, o.input.clear(), (o.isConnected || o.handshaking) && (o.isConnected = o.handshaking = !1, l.queue(o, l.createAlert(o, {
          level: l.Alert.Level.warning,
          description: l.Alert.Description.close_notify
        })), l.flush(o)), o.closed(o)), o.reset(e)
      }, o
    }, e.exports = a.tls = a.tls || {};
    for (var z in l) "function" != typeof l[z] && (a.tls[z] = l[z]);
    a.tls.prf_tls1 = n, a.tls.hmac_sha1 = i, a.tls.createSessionCache = l.createSessionCache, a.tls.createConnection = l.createConnection
  }, function (e, t) {}, function (e, t, r) {
    e.exports = r(0), r(5), r(34), r(3), r(12), r(19), r(10), r(8), r(35), r(20), r(36), r(21), r(15), r(7), r(23), r(24), r(38), r(26), r(27), r(28), r(16), r(2), r(29), r(40), r(41), r(31), r(1)
  }, function (e, t, r) {
    function a(e, t, r) {
      var a = t.entity === u.tls.ConnectionEnd.client;
      e.read.cipherState = {
        init: !1,
        cipher: u.cipher.createDecipher("AES-CBC", a ? r.keys.server_write_key : r.keys.client_write_key),
        iv: a ? r.keys.server_write_IV : r.keys.client_write_IV
      }, e.write.cipherState = {
        init: !1,
        cipher: u.cipher.createCipher("AES-CBC", a ? r.keys.client_write_key : r.keys.server_write_key),
        iv: a ? r.keys.client_write_IV : r.keys.server_write_IV
      }, e.read.cipherFunction = o, e.write.cipherFunction = n, e.read.macLength = e.write.macLength = r.mac_length, e.read.macFunction = e.write.macFunction = l.hmac_sha1
    }

    function n(e, t) {
      var r = !1,
        a = t.macFunction(t.macKey, t.sequenceNumber, e);
      e.fragment.putBytes(a), t.updateSequenceNumber();
      var n;
      n = e.version.minor === l.Versions.TLS_1_0.minor ? t.cipherState.init ? null : t.cipherState.iv : u.random.getBytesSync(16), t.cipherState.init = !0;
      var s = t.cipherState.cipher;
      return s.start({
        iv: n
      }), e.version.minor >= l.Versions.TLS_1_1.minor && s.output.putBytes(n), s.update(e.fragment), s.finish(i) && (e.fragment = s.output, e.length = e.fragment.length(), r = !0), r
    }

    function i(e, t, r) {
      if (!r) {
        var a = e - t.length() % e;
        t.fillWithByte(a - 1, a)
      }
      return !0
    }

    function s(e, t, r) {
      var a = !0;
      if (r) {
        for (var n = t.length(), i = t.last(), s = n - 1 - i; s < n - 1; ++s) a = a && t.at(s) == i;
        a && t.truncate(i + 1)
      }
      return a
    }

    function o(e, t) {
      var r = !1;
      ++p;
      var a;
      a = e.version.minor === l.Versions.TLS_1_0.minor ? t.cipherState.init ? null : t.cipherState.iv : e.fragment.getBytes(16), t.cipherState.init = !0;
      var n = t.cipherState.cipher;
      n.start({
        iv: a
      }), n.update(e.fragment), r = n.finish(s);
      var i = t.macLength,
        o = u.random.getBytesSync(i),
        h = n.output.length();
      h >= i ? (e.fragment = n.output.getBytes(h - i), o = n.output.getBytes(i)) : e.fragment = n.output.getBytes(), e.fragment = u.util.createBuffer(e.fragment), e.length = e.fragment.length();
      var f = t.macFunction(t.macKey, t.sequenceNumber, e);
      return t.updateSequenceNumber(), r = c(t.macKey, o, f) && r
    }

    function c(e, t, r) {
      var a = u.hmac.create();
      return a.start("SHA1", e), a.update(t), t = a.digest().getBytes(), a.start(null, null), a.update(r), r = a.digest().getBytes(), t === r
    }
    var u = r(0);
    r(5), r(31);
    var l = e.exports = u.tls;
    l.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: function (e) {
        e.bulk_cipher_algorithm = l.BulkCipherAlgorithm.aes, e.cipher_type = l.CipherType.block, e.enc_key_length = 16, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = l.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20
      },
      initConnectionState: a
    }, l.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: function (e) {
        e.bulk_cipher_algorithm = l.BulkCipherAlgorithm.aes, e.cipher_type = l.CipherType.block, e.enc_key_length = 32, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = l.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20
      },
      initConnectionState: a
    };
    var p = 0
  }, function (e, t, r) {
    function a(e, t, r, a) {
      e.generate = function (e, i) {
        for (var s = new n.util.ByteBuffer, o = Math.ceil(i / a) + r, c = new n.util.ByteBuffer, u = r; u < o; ++u) {
          c.putInt32(u), t.start(), t.update(e + c.getBytes());
          var l = t.digest();
          s.putBytes(l.getBytes(a))
        }
        return s.truncate(s.length() - i), s.getBytes()
      }
    }
    var n = r(0);
    r(1), r(2), r(13), e.exports = n.kem = n.kem || {};
    var i = n.jsbn.BigInteger;
    n.kem.rsa = {}, n.kem.rsa.create = function (e, t) {
      t = t || {};
      var r = t.prng || n.random,
        a = {};
      return a.encrypt = function (t, a) {
        var s, o = Math.ceil(t.n.bitLength() / 8);
        do s = new i(n.util.bytesToHex(r.getBytesSync(o)), 16).mod(t.n); while (s.equals(i.ZERO));
        s = n.util.hexToBytes(s.toString(16));
        var c = o - s.length;
        c > 0 && (s = n.util.fillString(String.fromCharCode(0), c) + s);
        var u = t.encrypt(s, "NONE"),
          l = e.generate(s, a);
        return {
          encapsulation: u,
          key: l
        }
      }, a.decrypt = function (t, r, a) {
        var n = t.decrypt(r, "NONE");
        return e.generate(n, a)
      }, a
    }, n.kem.kdf1 = function (e, t) {
      a(this, e, 0, t || e.digestLength)
    }, n.kem.kdf2 = function (e, t) {
      a(this, e, 1, t || e.digestLength)
    }
  }, function (e, t, r) {
    e.exports = r(4), r(14), r(9), r(30), r(39)
  }, function (e, t, r) {
    var a = r(0);
    r(21), e.exports = a.mgf = a.mgf || {}, a.mgf.mgf1 = a.mgf1
  }, function (e, t, r) {
    function a(e) {
      var t = {},
        r = [];
      if (!d.validate(e, y.asn1.recipientInfoValidator, t, r)) {
        var a = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        throw a.errors = r, a
      }
      return {
        version: t.version.charCodeAt(0),
        issuer: f.pki.RDNAttributesAsArray(t.issuer),
        serialNumber: f.util.createBuffer(t.serial).toHex(),
        encryptedContent: {
          algorithm: d.derToOid(t.encAlgorithm),
          parameter: t.encParameter.value,
          content: t.encKey
        }
      }
    }

    function n(e) {
      return d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.INTEGER, !1, d.integerToDer(e.version).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [f.pki.distinguishedNameToAsn1({
        attributes: e.issuer
      }), d.create(d.Class.UNIVERSAL, d.Type.INTEGER, !1, f.util.hexToBytes(e.serialNumber))]), d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(e.encryptedContent.algorithm).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.NULL, !1, "")]), d.create(d.Class.UNIVERSAL, d.Type.OCTETSTRING, !1, e.encryptedContent.content)])
    }

    function i(e) {
      for (var t = [], r = 0; r < e.length; ++r) t.push(a(e[r]));
      return t
    }

    function s(e) {
      for (var t = [], r = 0; r < e.length; ++r) t.push(n(e[r]));
      return t
    }

    function o(e) {
      var t = d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.INTEGER, !1, d.integerToDer(e.version).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [f.pki.distinguishedNameToAsn1({
        attributes: e.issuer
      }), d.create(d.Class.UNIVERSAL, d.Type.INTEGER, !1, f.util.hexToBytes(e.serialNumber))]), d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(e.digestAlgorithm).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.NULL, !1, "")])]);
      if (e.authenticatedAttributesAsn1 && t.value.push(e.authenticatedAttributesAsn1), t.value.push(d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(e.signatureAlgorithm).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.NULL, !1, "")])), t.value.push(d.create(d.Class.UNIVERSAL, d.Type.OCTETSTRING, !1, e.signature)), e.unauthenticatedAttributes.length > 0) {
        for (var r = d.create(d.Class.CONTEXT_SPECIFIC, 1, !0, []), a = 0; a < e.unauthenticatedAttributes.length; ++a) {
          var n = e.unauthenticatedAttributes[a];
          r.values.push(u(n))
        }
        t.value.push(r)
      }
      return t
    }

    function c(e) {
      for (var t = [], r = 0; r < e.length; ++r) t.push(o(e[r]));
      return t
    }

    function u(e) {
      var t;
      if (e.type === f.pki.oids.contentType) t = d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(e.value).getBytes());
      else if (e.type === f.pki.oids.messageDigest) t = d.create(d.Class.UNIVERSAL, d.Type.OCTETSTRING, !1, e.value.bytes());
      else if (e.type === f.pki.oids.signingTime) {
        var r = new Date("1950-01-01T00:00:00Z"),
          a = new Date("2050-01-01T00:00:00Z"),
          n = e.value;
        if ("string" == typeof n) {
          var i = Date.parse(n);
          n = isNaN(i) ? 13 === n.length ? d.utcTimeToDate(n) : d.generalizedTimeToDate(n) : new Date(i)
        }
        t = n >= r && n < a ? d.create(d.Class.UNIVERSAL, d.Type.UTCTIME, !1, d.dateToUtcTime(n)) : d.create(d.Class.UNIVERSAL, d.Type.GENERALIZEDTIME, !1, d.dateToGeneralizedTime(n))
      }
      return d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(e.type).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.SET, !0, [t])])
    }

    function l(e) {
      return [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(f.pki.oids.data).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(e.algorithm).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.OCTETSTRING, !1, e.parameter.getBytes())]), d.create(d.Class.CONTEXT_SPECIFIC, 0, !0, [d.create(d.Class.UNIVERSAL, d.Type.OCTETSTRING, !1, e.content.getBytes())])]
    }

    function p(e, t, r) {
      var a = {},
        n = [];
      if (!d.validate(t, r, a, n)) {
        var i = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        throw i.errors = i, i
      }
      var s = d.derToOid(a.contentType);
      if (s !== f.pki.oids.data) throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      if (a.encryptedContent) {
        var o = "";
        if (f.util.isArray(a.encryptedContent))
          for (var c = 0; c < a.encryptedContent.length; ++c) {
            if (a.encryptedContent[c].type !== d.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            o += a.encryptedContent[c].value
          } else o = a.encryptedContent;
        e.encryptedContent = {
          algorithm: d.derToOid(a.encAlgorithm),
          parameter: f.util.createBuffer(a.encParameter.value),
          content: f.util.createBuffer(o)
        }
      }
      if (a.content) {
        var o = "";
        if (f.util.isArray(a.content))
          for (var c = 0; c < a.content.length; ++c) {
            if (a.content[c].type !== d.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            o += a.content[c].value
          } else o = a.content;
        e.content = f.util.createBuffer(o)
      }
      return e.version = a.version.charCodeAt(0), e.rawCapture = a, a
    }

    function h(e) {
      if (void 0 === e.encryptedContent.key) throw new Error("Symmetric key not available.");
      if (void 0 === e.content) {
        var t;
        switch (e.encryptedContent.algorithm) {
          case f.pki.oids["aes128-CBC"]:
          case f.pki.oids["aes192-CBC"]:
          case f.pki.oids["aes256-CBC"]:
            t = f.aes.createDecryptionCipher(e.encryptedContent.key);
            break;
          case f.pki.oids.desCBC:
          case f.pki.oids["des-EDE3-CBC"]:
            t = f.des.createDecryptionCipher(e.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + e.encryptedContent.algorithm)
        }
        if (t.start(e.encryptedContent.parameter), t.update(e.encryptedContent.content), !t.finish()) throw new Error("Symmetric decryption failed.");
        e.content = t.output
      }
    }
    var f = r(0);
    r(5), r(3), r(10), r(6), r(7), r(25), r(2), r(1), r(17);
    var d = f.asn1,
      y = e.exports = f.pkcs7 = f.pkcs7 || {};
    y.messageFromPem = function (e) {
      var t = f.pem.decode(e)[0];
      if ("PKCS7" !== t.type) {
        var r = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        throw r.headerType = t.type, r
      }
      if (t.procType && "ENCRYPTED" === t.procType.type) throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      var a = d.fromDer(t.body);
      return y.messageFromAsn1(a)
    }, y.messageToPem = function (e, t) {
      var r = {
        type: "PKCS7",
        body: d.toDer(e.toAsn1()).getBytes()
      };
      return f.pem.encode(r, {
        maxline: t
      })
    }, y.messageFromAsn1 = function (e) {
      var t = {},
        r = [];
      if (!d.validate(e, y.asn1.contentInfoValidator, t, r)) {
        var a = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        throw a.errors = r, a
      }
      var n, i = d.derToOid(t.contentType);
      switch (i) {
        case f.pki.oids.envelopedData:
          n = y.createEnvelopedData();
          break;
        case f.pki.oids.encryptedData:
          n = y.createEncryptedData();
          break;
        case f.pki.oids.signedData:
          n = y.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + i + " is not (yet) supported.")
      }
      return n.fromAsn1(t.content.value[0]), n
    }, y.createSignedData = function () {
      function e() {
        for (var e = {}, t = 0; t < r.signers.length; ++t) {
          var a = r.signers[t],
            n = a.digestAlgorithm;
          n in e || (e[n] = f.md[f.pki.oids[n]].create()), 0 === a.authenticatedAttributes.length ? a.md = e[n] : a.md = f.md[f.pki.oids[n]].create()
        }
        r.digestAlgorithmIdentifiers = [];
        for (var n in e) r.digestAlgorithmIdentifiers.push(d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(n).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.NULL, !1, "")]));
        return e
      }

      function t(e) {
        if (r.contentInfo.value.length < 2) throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
        var t = d.derToOid(r.contentInfo.value[0].value),
          a = r.contentInfo.value[1];
        a = a.value[0];
        var n = d.toDer(a);
        n.getByte(), d.getBerValueLength(n), n = n.getBytes();
        for (var i in e) e[i].start().update(n);
        for (var s = new Date, o = 0; o < r.signers.length; ++o) {
          var l = r.signers[o];
          if (0 === l.authenticatedAttributes.length) {
            if (t !== f.pki.oids.data) throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.")
          } else {
            l.authenticatedAttributesAsn1 = d.create(d.Class.CONTEXT_SPECIFIC, 0, !0, []);
            for (var p = d.create(d.Class.UNIVERSAL, d.Type.SET, !0, []), h = 0; h < l.authenticatedAttributes.length; ++h) {
              var y = l.authenticatedAttributes[h];
              y.type === f.pki.oids.messageDigest ? y.value = e[l.digestAlgorithm].digest() : y.type === f.pki.oids.signingTime && (y.value || (y.value = s)), p.value.push(u(y)), l.authenticatedAttributesAsn1.value.push(u(y))
            }
            n = d.toDer(p).getBytes(), l.md.start().update(n)
          }
          l.signature = l.key.sign(l.md, "RSASSA-PKCS1-V1_5")
        }
        r.signerInfos = c(r.signers)
      }
      var r = null;
      return r = {
        type: f.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function (e) {
          p(r, e, y.asn1.signedDataValidator), r.certificates = [], r.crls = [], r.digestAlgorithmIdentifiers = [], r.contentInfo = null, r.signerInfos = [];
          for (var t = r.rawCapture.certificates.value, a = 0; a < t.length; ++a) r.certificates.push(f.pki.certificateFromAsn1(t[a]))
        },
        toAsn1: function () {
          r.contentInfo || r.sign();
          for (var e = [], t = 0; t < r.certificates.length; ++t) e.push(f.pki.certificateToAsn1(r.certificates[t]));
          var a = [],
            n = d.create(d.Class.CONTEXT_SPECIFIC, 0, !0, [d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.INTEGER, !1, d.integerToDer(r.version).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.SET, !0, r.digestAlgorithmIdentifiers), r.contentInfo])]);
          return e.length > 0 && n.value[0].value.push(d.create(d.Class.CONTEXT_SPECIFIC, 0, !0, e)), a.length > 0 && n.value[0].value.push(d.create(d.Class.CONTEXT_SPECIFIC, 1, !0, a)), n.value[0].value.push(d.create(d.Class.UNIVERSAL, d.Type.SET, !0, r.signerInfos)), d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(r.type).getBytes()), n])
        },
        addSigner: function (e) {
          var t = e.issuer,
            a = e.serialNumber;
          if (e.certificate) {
            var n = e.certificate;
            "string" == typeof n && (n = f.pki.certificateFromPem(n)), t = n.issuer.attributes, a = n.serialNumber
          }
          var i = e.key;
          if (!i) throw new Error("Could not add PKCS#7 signer; no private key specified.");
          "string" == typeof i && (i = f.pki.privateKeyFromPem(i));
          var s = e.digestAlgorithm || f.pki.oids.sha1;
          switch (s) {
            case f.pki.oids.sha1:
            case f.pki.oids.sha256:
            case f.pki.oids.sha384:
            case f.pki.oids.sha512:
            case f.pki.oids.md5:
              break;
            default:
              throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + s)
          }
          var o = e.authenticatedAttributes || [];
          if (o.length > 0) {
            for (var c = !1, u = !1, l = 0; l < o.length; ++l) {
              var p = o[l];
              if (c || p.type !== f.pki.oids.contentType) {
                if (u || p.type !== f.pki.oids.messageDigest);
                else if (u = !0, c) break
              } else if (c = !0, u) break
            }
            if (!c || !u) throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.")
          }
          r.signers.push({
            key: i,
            version: 1,
            issuer: t,
            serialNumber: a,
            digestAlgorithm: s,
            signatureAlgorithm: f.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes: o,
            unauthenticatedAttributes: []
          })
        },
        sign: function () {
          if (("object" != typeof r.content || null === r.contentInfo) && (r.contentInfo = d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(f.pki.oids.data).getBytes())]), "content" in r)) {
            var a;
            r.content instanceof f.util.ByteBuffer ? a = r.content.bytes() : "string" == typeof r.content && (a = f.util.encodeUtf8(r.content)), r.contentInfo.value.push(d.create(d.Class.CONTEXT_SPECIFIC, 0, !0, [d.create(d.Class.UNIVERSAL, d.Type.OCTETSTRING, !1, a)]))
          }
          if (0 !== r.signers.length) {
            var n = e();
            t(n)
          }
        },
        verify: function () {
          throw new Error("PKCS#7 signature verification not yet implemented.")
        },
        addCertificate: function (e) {
          "string" == typeof e && (e = f.pki.certificateFromPem(e)), r.certificates.push(e)
        },
        addCertificateRevokationList: function (e) {
          throw new Error("PKCS#7 CRL support not yet implemented.")
        }
      }
    }, y.createEncryptedData = function () {
      var e = null;
      return e = {
        type: f.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: f.pki.oids["aes256-CBC"]
        },
        fromAsn1: function (t) {
          p(e, t, y.asn1.encryptedDataValidator)
        },
        decrypt: function (t) {
          void 0 !== t && (e.encryptedContent.key = t), h(e)
        }
      }
    }, y.createEnvelopedData = function () {
      var e = null;
      return e = {
        type: f.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: f.pki.oids["aes256-CBC"]
        },
        fromAsn1: function (t) {
          var r = p(e, t, y.asn1.envelopedDataValidator);
          e.recipients = i(r.recipientInfos.value)
        },
        toAsn1: function () {
          return d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.OID, !1, d.oidToDer(e.type).getBytes()), d.create(d.Class.CONTEXT_SPECIFIC, 0, !0, [d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, [d.create(d.Class.UNIVERSAL, d.Type.INTEGER, !1, d.integerToDer(e.version).getBytes()), d.create(d.Class.UNIVERSAL, d.Type.SET, !0, s(e.recipients)), d.create(d.Class.UNIVERSAL, d.Type.SEQUENCE, !0, l(e.encryptedContent))])])]);
        },
        findRecipient: function (t) {
          for (var r = t.issuer.attributes, a = 0; a < e.recipients.length; ++a) {
            var n = e.recipients[a],
              i = n.issuer;
            if (n.serialNumber === t.serialNumber && i.length === r.length) {
              for (var s = !0, o = 0; o < r.length; ++o)
                if (i[o].type !== r[o].type || i[o].value !== r[o].value) {
                  s = !1;
                  break
                } if (s) return n
            }
          }
          return null
        },
        decrypt: function (t, r) {
          if (void 0 === e.encryptedContent.key && void 0 !== t && void 0 !== r) switch (t.encryptedContent.algorithm) {
            case f.pki.oids.rsaEncryption:
            case f.pki.oids.desCBC:
              var a = r.decrypt(t.encryptedContent.content);
              e.encryptedContent.key = f.util.createBuffer(a);
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + t.encryptedContent.algorithm)
          }
          h(e)
        },
        addRecipient: function (t) {
          e.recipients.push({
            version: 0,
            issuer: t.issuer.attributes,
            serialNumber: t.serialNumber,
            encryptedContent: {
              algorithm: f.pki.oids.rsaEncryption,
              key: t.publicKey
            }
          })
        },
        encrypt: function (t, r) {
          if (void 0 === e.encryptedContent.content) {
            r = r || e.encryptedContent.algorithm, t = t || e.encryptedContent.key;
            var a, n, i;
            switch (r) {
              case f.pki.oids["aes128-CBC"]:
                a = 16, n = 16, i = f.aes.createEncryptionCipher;
                break;
              case f.pki.oids["aes192-CBC"]:
                a = 24, n = 16, i = f.aes.createEncryptionCipher;
                break;
              case f.pki.oids["aes256-CBC"]:
                a = 32, n = 16, i = f.aes.createEncryptionCipher;
                break;
              case f.pki.oids["des-EDE3-CBC"]:
                a = 24, n = 8, i = f.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + r)
            }
            if (void 0 === t) t = f.util.createBuffer(f.random.getBytes(a));
            else if (t.length() != a) throw new Error("Symmetric key has wrong length; got " + t.length() + " bytes, expected " + a + ".");
            e.encryptedContent.algorithm = r, e.encryptedContent.key = t, e.encryptedContent.parameter = f.util.createBuffer(f.random.getBytes(n));
            var s = i(t);
            if (s.start(e.encryptedContent.parameter.copy()), s.update(e.content), !s.finish()) throw new Error("Symmetric encryption failed.");
            e.encryptedContent.content = s.output
          }
          for (var o = 0; o < e.recipients.length; ++o) {
            var c = e.recipients[o];
            if (void 0 === c.encryptedContent.content) switch (c.encryptedContent.algorithm) {
              case f.pki.oids.rsaEncryption:
                c.encryptedContent.content = c.encryptedContent.key.encrypt(e.encryptedContent.key.data);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + c.encryptedContent.algorithm)
            }
          }
        }
      }
    }
  }, function (e, t, r) {
    function a() {
      c = String.fromCharCode(128), c += i.util.fillString(String.fromCharCode(0), 128), l = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ], p = {}, p["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ], p["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ], p["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ], p["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ], u = !0
    }

    function n(e, t, r) {
      for (var a, n, i, s, o, c, u, p, h, f, d, y, g, v, m, C, E, S, T, I, A, b, B, N, k, R, w, L, _, U, D, P, V, O, x, K = r.length(); K >= 128;) {
        for (_ = 0; _ < 16; ++_) t[_][0] = r.getInt32() >>> 0, t[_][1] = r.getInt32() >>> 0;
        for (; _ < 80; ++_) P = t[_ - 2], U = P[0], D = P[1], a = ((U >>> 19 | D << 13) ^ (D >>> 29 | U << 3) ^ U >>> 6) >>> 0, n = ((U << 13 | D >>> 19) ^ (D << 3 | U >>> 29) ^ (U << 26 | D >>> 6)) >>> 0, O = t[_ - 15], U = O[0], D = O[1], i = ((U >>> 1 | D << 31) ^ (U >>> 8 | D << 24) ^ U >>> 7) >>> 0, s = ((U << 31 | D >>> 1) ^ (U << 24 | D >>> 8) ^ (U << 25 | D >>> 7)) >>> 0, V = t[_ - 7], x = t[_ - 16], D = n + V[1] + s + x[1], t[_][0] = a + V[0] + i + x[0] + (D / 4294967296 >>> 0) >>> 0, t[_][1] = D >>> 0;
        for (g = e[0][0], v = e[0][1], m = e[1][0], C = e[1][1], E = e[2][0], S = e[2][1], T = e[3][0], I = e[3][1], A = e[4][0], b = e[4][1], B = e[5][0], N = e[5][1], k = e[6][0], R = e[6][1], w = e[7][0], L = e[7][1], _ = 0; _ < 80; ++_) u = ((A >>> 14 | b << 18) ^ (A >>> 18 | b << 14) ^ (b >>> 9 | A << 23)) >>> 0, p = ((A << 18 | b >>> 14) ^ (A << 14 | b >>> 18) ^ (b << 23 | A >>> 9)) >>> 0, h = (k ^ A & (B ^ k)) >>> 0, f = (R ^ b & (N ^ R)) >>> 0, o = ((g >>> 28 | v << 4) ^ (v >>> 2 | g << 30) ^ (v >>> 7 | g << 25)) >>> 0, c = ((g << 4 | v >>> 28) ^ (v << 30 | g >>> 2) ^ (v << 25 | g >>> 7)) >>> 0, d = (g & m | E & (g ^ m)) >>> 0, y = (v & C | S & (v ^ C)) >>> 0, D = L + p + f + l[_][1] + t[_][1], a = w + u + h + l[_][0] + t[_][0] + (D / 4294967296 >>> 0) >>> 0, n = D >>> 0, D = c + y, i = o + d + (D / 4294967296 >>> 0) >>> 0, s = D >>> 0, w = k, L = R, k = B, R = N, B = A, N = b, D = I + n, A = T + a + (D / 4294967296 >>> 0) >>> 0, b = D >>> 0, T = E, I = S, E = m, S = C, m = g, C = v, D = n + s, g = a + i + (D / 4294967296 >>> 0) >>> 0, v = D >>> 0;
        D = e[0][1] + v, e[0][0] = e[0][0] + g + (D / 4294967296 >>> 0) >>> 0, e[0][1] = D >>> 0, D = e[1][1] + C, e[1][0] = e[1][0] + m + (D / 4294967296 >>> 0) >>> 0, e[1][1] = D >>> 0, D = e[2][1] + S, e[2][0] = e[2][0] + E + (D / 4294967296 >>> 0) >>> 0, e[2][1] = D >>> 0, D = e[3][1] + I, e[3][0] = e[3][0] + T + (D / 4294967296 >>> 0) >>> 0, e[3][1] = D >>> 0, D = e[4][1] + b, e[4][0] = e[4][0] + A + (D / 4294967296 >>> 0) >>> 0, e[4][1] = D >>> 0, D = e[5][1] + N, e[5][0] = e[5][0] + B + (D / 4294967296 >>> 0) >>> 0, e[5][1] = D >>> 0, D = e[6][1] + R, e[6][0] = e[6][0] + k + (D / 4294967296 >>> 0) >>> 0, e[6][1] = D >>> 0, D = e[7][1] + L, e[7][0] = e[7][0] + w + (D / 4294967296 >>> 0) >>> 0, e[7][1] = D >>> 0, K -= 128
      }
    }
    var i = r(0);
    r(4), r(1);
    var s = e.exports = i.sha512 = i.sha512 || {};
    i.md.sha512 = i.md.algorithms.sha512 = s;
    var o = i.sha384 = i.sha512.sha384 = i.sha512.sha384 || {};
    o.create = function () {
      return s.create("SHA-384")
    }, i.md.sha384 = i.md.algorithms.sha384 = o, i.sha512.sha256 = i.sha512.sha256 || {
      create: function () {
        return s.create("SHA-512/256")
      }
    }, i.md["sha512/256"] = i.md.algorithms["sha512/256"] = i.sha512.sha256, i.sha512.sha224 = i.sha512.sha224 || {
      create: function () {
        return s.create("SHA-512/224")
      }
    }, i.md["sha512/224"] = i.md.algorithms["sha512/224"] = i.sha512.sha224, s.create = function (e) {
      if (u || a(), "undefined" == typeof e && (e = "SHA-512"), !(e in p)) throw new Error("Invalid SHA-512 algorithm: " + e);
      for (var t = p[e], r = null, s = i.util.createBuffer(), o = new Array(80), l = 0; l < 80; ++l) o[l] = new Array(2);
      var h = 64;
      switch (e) {
        case "SHA-384":
          h = 48;
          break;
        case "SHA-512/256":
          h = 32;
          break;
        case "SHA-512/224":
          h = 28
      }
      var f = {
        algorithm: e.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength: h,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 16
      };
      return f.start = function () {
        f.messageLength = 0, f.fullMessageLength = f.messageLength128 = [];
        for (var e = f.messageLengthSize / 4, a = 0; a < e; ++a) f.fullMessageLength.push(0);
        s = i.util.createBuffer(), r = new Array(t.length);
        for (var a = 0; a < t.length; ++a) r[a] = t[a].slice(0);
        return f
      }, f.start(), f.update = function (e, t) {
        "utf8" === t && (e = i.util.encodeUtf8(e));
        var a = e.length;
        f.messageLength += a, a = [a / 4294967296 >>> 0, a >>> 0];
        for (var c = f.fullMessageLength.length - 1; c >= 0; --c) f.fullMessageLength[c] += a[1], a[1] = a[0] + (f.fullMessageLength[c] / 4294967296 >>> 0), f.fullMessageLength[c] = f.fullMessageLength[c] >>> 0, a[0] = a[1] / 4294967296 >>> 0;
        return s.putBytes(e), n(r, o, s), (s.read > 2048 || 0 === s.length()) && s.compact(), f
      }, f.digest = function () {
        var t = i.util.createBuffer();
        t.putBytes(s.bytes());
        var a = f.fullMessageLength[f.fullMessageLength.length - 1] + f.messageLengthSize,
          u = a & f.blockLength - 1;
        t.putBytes(c.substr(0, f.blockLength - u));
        for (var l, p, h = 8 * f.fullMessageLength[0], d = 0; d < f.fullMessageLength.length - 1; ++d) l = 8 * f.fullMessageLength[d + 1], p = l / 4294967296 >>> 0, h += p, t.putInt32(h >>> 0), h = l >>> 0;
        t.putInt32(h);
        for (var y = new Array(r.length), d = 0; d < r.length; ++d) y[d] = r[d].slice(0);
        n(y, o, t);
        var g, v = i.util.createBuffer();
        g = "SHA-512" === e ? y.length : "SHA-384" === e ? y.length - 2 : y.length - 4;
        for (var d = 0; d < g; ++d) v.putInt32(y[d][0]), d === g - 1 && "SHA-512/224" === e || v.putInt32(y[d][1]);
        return v
      }, f
    };
    var c = null,
      u = !1,
      l = null,
      p = null
  }, function (e, t, r) {
    function a(e, t) {
      var r = t.toString(16);
      r[0] >= "8" && (r = "00" + r);
      var a = s.util.hexToBytes(r);
      e.putInt32(a.length), e.putBytes(a)
    }

    function n(e, t) {
      e.putInt32(t.length), e.putString(t)
    }

    function i() {
      for (var e = s.md.sha1.create(), t = arguments.length, r = 0; r < t; ++r) e.update(arguments[r]);
      return e.digest()
    }
    var s = r(0);
    r(5), r(8), r(14), r(9), r(1);
    var o = e.exports = s.ssh = s.ssh || {};
    o.privateKeyToPutty = function (e, t, r) {
      r = r || "", t = t || "";
      var o = "ssh-rsa",
        c = "" === t ? "none" : "aes256-cbc",
        u = "PuTTY-User-Key-File-2: " + o + "\r\n";
      u += "Encryption: " + c + "\r\n", u += "Comment: " + r + "\r\n";
      var l = s.util.createBuffer();
      n(l, o), a(l, e.e), a(l, e.n);
      var p = s.util.encode64(l.bytes(), 64),
        h = Math.floor(p.length / 66) + 1;
      u += "Public-Lines: " + h + "\r\n", u += p;
      var f = s.util.createBuffer();
      a(f, e.d), a(f, e.p), a(f, e.q), a(f, e.qInv);
      var d;
      if (t) {
        var y = f.length() + 16 - 1;
        y -= y % 16;
        var g = i(f.bytes());
        g.truncate(g.length() - y + f.length()), f.putBuffer(g);
        var v = s.util.createBuffer();
        v.putBuffer(i("\0\0\0\0", t)), v.putBuffer(i("\0\0\0", t));
        var m = s.aes.createEncryptionCipher(v.truncate(8), "CBC");
        m.start(s.util.createBuffer().fillWithByte(0, 16)), m.update(f.copy()), m.finish();
        var C = m.output;
        C.truncate(16), d = s.util.encode64(C.bytes(), 64)
      } else d = s.util.encode64(f.bytes(), 64);
      h = Math.floor(d.length / 66) + 1, u += "\r\nPrivate-Lines: " + h + "\r\n", u += d;
      var E = i("putty-private-key-file-mac-key", t),
        S = s.util.createBuffer();
      n(S, o), n(S, c), n(S, r), S.putInt32(l.length()), S.putBuffer(l), S.putInt32(f.length()), S.putBuffer(f);
      var T = s.hmac.create();
      return T.start("sha1", E), T.update(S.bytes()), u += "\r\nPrivate-MAC: " + T.digest().toHex() + "\r\n"
    }, o.publicKeyToOpenSSH = function (e, t) {
      var r = "ssh-rsa";
      t = t || "";
      var i = s.util.createBuffer();
      return n(i, r), a(i, e.e), a(i, e.n), r + " " + s.util.encode64(i.bytes()) + " " + t
    }, o.privateKeyToOpenSSH = function (e, t) {
      return t ? s.pki.encryptRsaPrivateKey(e, t, {
        legacy: !0,
        algorithm: "aes128"
      }) : s.pki.privateKeyToPem(e)
    }, o.getPublicKeyFingerprint = function (e, t) {
      t = t || {};
      var r = t.md || s.md.md5.create(),
        i = "ssh-rsa",
        o = s.util.createBuffer();
      n(o, i), a(o, e.e), a(o, e.n), r.start(), r.update(o.getBytes());
      var c = r.digest();
      if ("hex" === t.encoding) {
        var u = c.toHex();
        return t.delimiter ? u.match(/.{2}/g).join(t.delimiter) : u
      }
      if ("binary" === t.encoding) return c.getBytes();
      if (t.encoding) throw new Error('Unknown encoding "' + t.encoding + '".');
      return c
    }
  }, function (e, t, r) {
    var a = r(0);
    r(19), r(20), r(1);
    var n = "forge.task",
      i = 0,
      s = {},
      o = 0;
    a.debug.set(n, "tasks", s);
    var c = {};
    a.debug.set(n, "queues", c);
    var u = "?",
      l = 30,
      p = 20,
      h = "ready",
      f = "running",
      d = "blocked",
      y = "sleeping",
      g = "done",
      v = "error",
      m = "stop",
      C = "start",
      E = "block",
      S = "unblock",
      T = "sleep",
      I = "wakeup",
      A = "cancel",
      b = "fail",
      B = {};
    B[h] = {}, B[h][m] = h, B[h][C] = f, B[h][A] = g, B[h][b] = v, B[f] = {}, B[f][m] = h, B[f][C] = f, B[f][E] = d, B[f][S] = f, B[f][T] = y, B[f][I] = f, B[f][A] = g, B[f][b] = v, B[d] = {}, B[d][m] = d, B[d][C] = d, B[d][E] = d, B[d][S] = d, B[d][T] = d, B[d][I] = d, B[d][A] = g, B[d][b] = v, B[y] = {}, B[y][m] = y, B[y][C] = y, B[y][E] = y, B[y][S] = y, B[y][T] = y, B[y][I] = y, B[y][A] = g, B[y][b] = v, B[g] = {}, B[g][m] = g, B[g][C] = g, B[g][E] = g, B[g][S] = g, B[g][T] = g, B[g][I] = g, B[g][A] = g, B[g][b] = v, B[v] = {}, B[v][m] = v, B[v][C] = v, B[v][E] = v, B[v][S] = v, B[v][T] = v, B[v][I] = v, B[v][A] = v, B[v][b] = v;
    var N = function (e) {
      this.id = -1, this.name = e.name || u, this.parent = e.parent || null, this.run = e.run, this.subtasks = [], this.error = !1, this.state = h, this.blocks = 0, this.timeoutId = null, this.swapTime = null, this.userData = null, this.id = o++, s[this.id] = this, i >= 1 && a.log.verbose(n, "[%s][%s] init", this.id, this.name, this)
    };
    N.prototype.debug = function (e) {
      e = e || "", a.log.debug(n, e, "[%s][%s] task:", this.id, this.name, this, "subtasks:", this.subtasks.length, "queue:", c)
    }, N.prototype.next = function (e, t) {
      "function" == typeof e && (t = e, e = this.name);
      var r = new N({
        run: t,
        name: e,
        parent: this
      });
      return r.state = f, r.type = this.type, r.successCallback = this.successCallback || null, r.failureCallback = this.failureCallback || null, this.subtasks.push(r), this
    }, N.prototype.parallel = function (e, t) {
      return a.util.isArray(e) && (t = e, e = this.name), this.next(e, function (r) {
        var n = r;
        n.block(t.length);
        for (var i = function (e, r) {
            a.task.start({
              type: e,
              run: function (e) {
                t[r](e)
              },
              success: function (e) {
                n.unblock()
              },
              failure: function (e) {
                n.unblock()
              }
            })
          }, s = 0; s < t.length; s++) {
          var o = e + "__parallel-" + r.id + "-" + s,
            c = s;
          i(o, c)
        }
      })
    }, N.prototype.stop = function () {
      this.state = B[this.state][m]
    }, N.prototype.start = function () {
      this.error = !1, this.state = B[this.state][C], this.state === f && (this.start = new Date, this.run(this), R(this, 0))
    }, N.prototype.block = function (e) {
      e = "undefined" == typeof e ? 1 : e, this.blocks += e, this.blocks > 0 && (this.state = B[this.state][E])
    }, N.prototype.unblock = function (e) {
      return e = "undefined" == typeof e ? 1 : e, this.blocks -= e, 0 === this.blocks && this.state !== g && (this.state = f, R(this, 0)), this.blocks
    }, N.prototype.sleep = function (e) {
      e = "undefined" == typeof e ? 0 : e, this.state = B[this.state][T];
      var t = this;
      this.timeoutId = setTimeout(function () {
        t.timeoutId = null, t.state = f, R(t, 0)
      }, e)
    }, N.prototype.wait = function (e) {
      e.wait(this)
    }, N.prototype.wakeup = function () {
      this.state === y && (cancelTimeout(this.timeoutId), this.timeoutId = null, this.state = f, R(this, 0))
    }, N.prototype.cancel = function () {
      this.state = B[this.state][A], this.permitsNeeded = 0, null !== this.timeoutId && (cancelTimeout(this.timeoutId), this.timeoutId = null), this.subtasks = []
    }, N.prototype.fail = function (e) {
      if (this.error = !0, w(this, !0), e) e.error = this.error, e.swapTime = this.swapTime, e.userData = this.userData, R(e, 0);
      else {
        if (null !== this.parent) {
          for (var t = this.parent; null !== t.parent;) t.error = this.error, t.swapTime = this.swapTime, t.userData = this.userData, t = t.parent;
          w(t, !0)
        }
        this.failureCallback && this.failureCallback(this)
      }
    };
    var k = function (e) {
        e.error = !1, e.state = B[e.state][C], setTimeout(function () {
          e.state === f && (e.swapTime = +new Date, e.run(e), R(e, 0))
        }, 0)
      },
      R = function (e, t) {
        var r = t > l || +new Date - e.swapTime > p,
          a = function (t) {
            if (t++, e.state === f)
              if (r && (e.swapTime = +new Date), e.subtasks.length > 0) {
                var a = e.subtasks.shift();
                a.error = e.error, a.swapTime = e.swapTime, a.userData = e.userData, a.run(a), a.error || R(a, t)
              } else w(e), e.error || null !== e.parent && (e.parent.error = e.error, e.parent.swapTime = e.swapTime, e.parent.userData = e.userData, R(e.parent, t))
          };
        r ? setTimeout(a, 0) : a(t)
      },
      w = function (e, t) {
        e.state = g, delete s[e.id], i >= 1 && a.log.verbose(n, "[%s][%s] finish", e.id, e.name, e), null === e.parent && (e.type in c ? 0 === c[e.type].length ? a.log.error(n, "[%s][%s] task queue empty [%s]", e.id, e.name, e.type) : c[e.type][0] !== e ? a.log.error(n, "[%s][%s] task not first in queue [%s]", e.id, e.name, e.type) : (c[e.type].shift(), 0 === c[e.type].length ? (i >= 1 && a.log.verbose(n, "[%s][%s] delete queue [%s]", e.id, e.name, e.type), delete c[e.type]) : (i >= 1 && a.log.verbose(n, "[%s][%s] queue start next [%s] remain:%s", e.id, e.name, e.type, c[e.type].length), c[e.type][0].start())) : a.log.error(n, "[%s][%s] task queue missing [%s]", e.id, e.name, e.type), t || (e.error && e.failureCallback ? e.failureCallback(e) : !e.error && e.successCallback && e.successCallback(e)))
      };
    e.exports = a.task = a.task || {}, a.task.start = function (e) {
      var t = new N({
        run: e.run,
        name: e.name || u
      });
      t.type = e.type, t.successCallback = e.success || null, t.failureCallback = e.failure || null, t.type in c ? c[e.type].push(t) : (i >= 1 && a.log.verbose(n, "[%s][%s] create queue [%s]", t.id, t.name, t.type), c[t.type] = [t], k(t))
    }, a.task.cancel = function (e) {
      e in c && (c[e] = [c[e][0]])
    }, a.task.createCondition = function () {
      var e = {
        tasks: {}
      };
      return e.wait = function (t) {
        t.id in e.tasks || (t.block(), e.tasks[t.id] = t)
      }, e.notify = function () {
        var t = e.tasks;
        e.tasks = {};
        for (var r in t) t[r].unblock()
      }, e
    }
  }, function (e, t, r) {
    e.exports = r(33)
  }])
});
//# sourceMappingURL=forge.min.js.map
// @tensorflow/tfjs Copyright 2019 Google
! function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.tf = t.tf || {})
}(this, function (t) {
  "use strict";
  var e = function (t, n) {
    return (e = Object.setPrototypeOf || {
        __proto__: []
      }
      instanceof Array && function (t, e) {
        t.__proto__ = e
      } || function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
      })(t, n)
  };

  function n(t, n) {
    function r() {
      this.constructor = t
    }
    e(t, n), t.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
  }

  function r(t, e, n, r) {
    return new(n || (n = Promise))(function (a, i) {
      function o(t) {
        try {
          u(r.next(t))
        } catch (t) {
          i(t)
        }
      }

      function s(t) {
        try {
          u(r.throw(t))
        } catch (t) {
          i(t)
        }
      }

      function u(t) {
        t.done ? a(t.value) : new n(function (e) {
          e(t.value)
        }).then(o, s)
      }
      u((r = r.apply(t, e || [])).next())
    })
  }

  function a(t, e) {
    var n, r, a, i, o = {
      label: 0,
      sent: function () {
        if (1 & a[0]) throw a[1];
        return a[1]
      },
      trys: [],
      ops: []
    };
    return i = {
      next: s(0),
      throw: s(1),
      return: s(2)
    }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
      return this
    }), i;

    function s(i) {
      return function (s) {
        return function (i) {
          if (n) throw new TypeError("Generator is already executing.");
          for (; o;) try {
            if (n = 1, r && (a = 2 & i[0] ? r.return : i[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, i[1])).done) return a;
            switch (r = 0, a && (i = [2 & i[0], a.value]), i[0]) {
              case 0:
              case 1:
                a = i;
                break;
              case 4:
                return o.label++, {
                  value: i[1],
                  done: !1
                };
              case 5:
                o.label++, r = i[1], i = [0];
                continue;
              case 7:
                i = o.ops.pop(), o.trys.pop();
                continue;
              default:
                if (!(a = (a = o.trys).length > 0 && a[a.length - 1]) && (6 === i[0] || 2 === i[0])) {
                  o = 0;
                  continue
                }
                if (3 === i[0] && (!a || i[1] > a[0] && i[1] < a[3])) {
                  o.label = i[1];
                  break
                }
                if (6 === i[0] && o.label < a[1]) {
                  o.label = a[1], a = i;
                  break
                }
                if (a && o.label < a[2]) {
                  o.label = a[2], o.ops.push(i);
                  break
                }
                a[2] && o.ops.pop(), o.trys.pop();
                continue
            }
            i = e.call(t, o)
          } catch (t) {
            i = [6, t], r = 0
          } finally {
            n = a = 0
          }
          if (5 & i[0]) throw i[1];
          return {
            value: i[0] ? i[1] : void 0,
            done: !0
          }
        }([i, s])
      }
    }
  }
  var i = function () {
    function t(t) {
      this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags()
    }
    return t.prototype.setPlatform = function (t, e) {
      null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e + "."), this.platformName = t, this.platform = e
    }, t.prototype.registerFlag = function (t, e, n) {
      if (this.flagRegistry[t] = {
          evaluationFn: e,
          setHook: n
        }, null != this.urlFlags[t]) {
        var r = this.urlFlags[t];
        console.warn("Setting feature override from URL " + t + ": " + r + "."), this.set(t, r)
      }
    }, t.prototype.get = function (t) {
      return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t])
    }, t.prototype.getNumber = function (t) {
      return this.get(t)
    }, t.prototype.getBool = function (t) {
      return this.get(t)
    }, t.prototype.getFlags = function () {
      return this.flags
    }, Object.defineProperty(t.prototype, "features", {
      get: function () {
        return this.flags
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.set = function (t, e) {
      if (null == this.flagRegistry[t]) throw new Error("Cannot set flag " + t + " as it has not been registered.");
      this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e)
    }, t.prototype.evaluateFlag = function (t) {
      if (null == this.flagRegistry[t]) throw new Error("Cannot evaluate flag '" + t + "': no evaluation function found.");
      return this.flagRegistry[t].evaluationFn()
    }, t.prototype.setFlags = function (t) {
      this.flags = Object.assign({}, t)
    }, t.prototype.reset = function () {
      this.flags = {}, this.urlFlags = {}, this.populateURLFlags()
    }, t.prototype.populateURLFlags = function () {
      var t = this;
      if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
        var e, n, r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (t) {
          for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
          return function (t, e, n) {
            t[decodeURIComponent(e)] = decodeURIComponent(n || "")
          }(n, e[0], e[1]), e.join("=")
        }), n);
        "tfjsflags" in r && r.tfjsflags.split(",").forEach(function (e) {
          var n = e.split(":"),
            r = n[0],
            a = n[1];
          t.urlFlags[r] = function (t, e) {
            if ("true" === (e = e.toLowerCase()) || "false" === e) return "true" === e;
            if ("" + +e === e) return +e;
            throw new Error("Could not parse value flag value " + e + " for flag " + t + ".")
          }(r, a)
        })
      }
    }, t
  }();

  function o() {
    return t.ENV
  }
  t.ENV = null;
  var s = new Map,
    u = new Map;

  function l(t, e) {
    var n = d(t, e);
    return s.get(n)
  }

  function c(t) {
    return u.get(t)
  }

  function p(t) {
    for (var e = s.entries(), n = [];;) {
      var r = e.next(),
        a = r.done,
        i = r.value;
      if (a) break;
      var o = i[0],
        u = i[1];
      o.split("_")[0] === t && n.push(u)
    }
    return n
  }

  function h(t) {
    var e = t.kernelName,
      n = t.backendName,
      r = d(e, n);
    if (s.has(r)) throw new Error("The kernel '" + e + "' for backend '" + n + "' is already registered");
    s.set(r, t)
  }

  function f(t) {
    var e = t.kernelName;
    u.has(e) && console.warn("Overriding the gradient for '" + e + "'"), u.set(e, t)
  }

  function d(t, e) {
    return e + "_" + t
  }

  function m(t) {
    for (var e = t.length, n = 0, r = 0; e > 0;) r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n
  }

  function g(t, e, n) {
    return Math.max(t, Math.min(e, n))
  }

  function v(t) {
    return t % 2 == 0 ? t : t + 1
  }

  function y(t) {
    for (var e = 0, n = 0; n < t.length; n++) e += t[n];
    return e
  }

  function b(t, e) {
    if (!t) throw new Error("string" == typeof e ? e : e())
  }

  function x(t, e, n) {
    void 0 === n && (n = ""), b(S(t, e), function () {
      return n + " Shapes " + t + " and " + e + " must match"
    })
  }

  function w(t) {
    b(null != t, function () {
      return "The input to the tensor constructor must be a non-null value."
    })
  }

  function C(t, e, n) {
    if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || B(t) && !n)
      for (var r = 0; r < t.length; ++r) C(t[r], e, n);
    else e.push(t);
    return e
  }

  function N(t) {
    if (0 === t.length) return 1;
    for (var e = t[0], n = 1; n < t.length; n++) e *= t[n];
    return e
  }

  function S(t, e) {
    if (t === e) return !0;
    if (null == t || null == e) return !1;
    if (t.length !== e.length) return !1;
    for (var n = 0; n < t.length; n++)
      if (t[n] !== e[n]) return !1;
    return !0
  }

  function k(t) {
    return t % 1 == 0
  }

  function I(t) {
    if (null != Math.tanh) return Math.tanh(t);
    if (t === 1 / 0) return 1;
    if (t === -1 / 0) return -1;
    var e = Math.exp(2 * t);
    return (e - 1) / (e + 1)
  }

  function E(t) {
    var e = Math.ceil(Math.sqrt(t));
    return [e, Math.ceil(t / e)]
  }

  function A(t, e) {
    return e <= t.length ? t : t + " ".repeat(e - t.length)
  }

  function R(t, e, n) {
    return void 0 === e && (e = function (t) {
      return 0
    }), new Promise(function (r, a) {
      var i = 0,
        o = function () {
          if (t()) r();
          else {
            var s = e(++i);
            null != n && i >= n ? a() : setTimeout(o, s)
          }
        };
      o()
    })
  }

  function T(t, e) {
    for (var n = 1, r = -1, a = 0; a < t.length; ++a)
      if (t[a] >= 0) n *= t[a];
      else if (-1 === t[a]) {
      if (-1 !== r) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + a);
      r = a
    } else if (t[a] < 0) throw Error("Shapes can not be < 0. Found " + t[a] + " at dim " + a);
    if (-1 === r) {
      if (e > 0 && e !== n) throw Error("Size(" + e + ") must match the product of shape " + t);
      return t
    }
    if (0 === n) throw Error("Cannot infer the missing size in [" + t + "] when there are 0 elements");
    if (e % n != 0) throw Error("The implicit shape can't be a fractional number. Got " + e + " / " + n);
    var i = t.slice();
    return i[r] = e / n, i
  }

  function D(t, e) {
    var n = e.length;
    return b((t = null == t ? e.map(function (t, e) {
      return e
    }) : [].concat(t)).every(function (t) {
      return t >= -n && t < n
    }), function () {
      return "All values in axis param must be in range [-" + n + ", " + n + ") but got axis " + t
    }), b(t.every(function (t) {
      return k(t)
    }), function () {
      return "All values in axis param must be integers but got axis " + t
    }), t.map(function (t) {
      return t < 0 ? n + t : t
    })
  }

  function O(t, e) {
    for (var n = [], r = [], a = null != e && Array.isArray(e) && 0 === e.length, i = null == e || a ? null : D(e, t).sort(), o = 0, s = 0; s < t.length; ++s) {
      if (null != i) {
        if (i[o] === s && 1 !== t[s]) throw new Error("Can't squeeze axis " + s + " since its dim '" + t[s] + "' is not 1");
        (null == i[o] || i[o] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), i[o] <= s && o++
      }
      1 !== t[s] && (n.push(t[s]), r.push(s))
    }
    return {
      newShape: n,
      keptDims: r
    }
  }

  function _(t, e) {
    var n = null;
    if (null == t || "float32" === t) n = new Float32Array(e);
    else if ("int32" === t) n = new Int32Array(e);
    else {
      if ("bool" !== t) throw new Error("Unknown data type " + t);
      n = new Uint8Array(e)
    }
    return n
  }

  function F(t, e) {
    var n = null;
    if (null == t || "float32" === t) n = new Float32Array(e);
    else if ("int32" === t) n = new Int32Array(e);
    else if ("bool" === t) n = new Uint8Array(e);
    else {
      if ("string" !== t) throw new Error("Unknown data type " + t);
      n = new Array(e)
    }
    return n
  }

  function M(t, e) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + e + " being uploaded contains " + r + ".")
    }
  }

  function z(t) {
    return "bool" === t || "complex64" === t || "float32" === t || "int32" === t || "string" === t
  }

  function L(t, e) {
    return !("complex64" === e || "float32" === e && "complex64" !== t || "int32" === e && "float32" !== t && "complex64" !== t || "bool" === e && "bool" === t)
  }

  function B(t) {
    return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array
  }

  function P(t) {
    if ("float32" === t || "int32" === t) return 4;
    if ("complex64" === t) return 8;
    if ("bool" === t) return 1;
    throw new Error("Unknown dtype " + t)
  }

  function W(t) {
    if (null == t) return 0;
    var e = 0;
    return t.forEach(function (t) {
      return e += t.length
    }), e
  }

  function V(t) {
    return "string" == typeof t || t instanceof String
  }

  function U(t) {
    return "boolean" == typeof t
  }

  function j(t) {
    return "number" == typeof t
  }

  function G(t) {
    return Array.isArray(t) ? G(t[0]) : t instanceof Float32Array ? "float32" : t instanceof Int32Array || t instanceof Uint8Array ? "int32" : j(t) ? "float32" : V(t) ? "string" : U(t) ? "bool" : "float32"
  }

  function q(t) {
    return !!(t && t.constructor && t.call && t.apply)
  }

  function H(t, e) {
    for (var n = e; n < t; ++n)
      if (t % n == 0) return n;
    return t
  }

  function K(t) {
    var e = t.length;
    if (e < 2) return [];
    var n = new Array(e - 1);
    n[e - 2] = t[e - 1];
    for (var r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];
    return n
  }

  function X(t, e, n) {
    if ("string" === e) throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(t) && (t = C(t)), n && M(t, e), function (t, e) {
        return t instanceof Float32Array && "float32" === e || t instanceof Int32Array && "int32" === e || t instanceof Uint8Array && "bool" === e
      }(t, e)) return t;
    if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
    if ("int32" === e) return new Int32Array(t);
    if ("bool" === e) {
      for (var r = new Uint8Array(t.length), a = 0; a < r.length; ++a) 0 !== Math.round(t[a]) && (r[a] = 1);
      return r
    }
    throw new Error("Unknown data type " + e)
  }

  function $(t, e) {
    if (0 === t.length) return e[0];
    var n = t.reduce(function (t, e) {
      return t * e
    });
    if (0 === n) return [];
    if (n !== e.length) throw new Error("[" + t + "] does not match the input size.");
    return function t(e, n, r) {
      var a = new Array;
      if (1 === n.length)
        for (var i = n[0], o = 0; o < i; o++) a[o] = r[e + o];
      else {
        i = n[0];
        var s = n.slice(1),
          u = s.reduce(function (t, e) {
            return t * e
          });
        for (o = 0; o < i; o++) a[o] = t(e + o * u, s, r)
      }
      return a
    }(0, t, e)
  }

  function Y(t, e) {
    for (var n = J(t, e), r = 0; r < n.length; r++) n[r] = 1;
    return n
  }

  function J(t, e) {
    if (null == e || "float32" === e || "complex64" === e) return new Float32Array(t);
    if ("int32" === e) return new Int32Array(t);
    if ("bool" === e) return new Uint8Array(t);
    throw new Error("Unknown data type " + e)
  }

  function Z() {
    return o().platform.now()
  }

  function Q(t) {
    t.forEach(function (e) {
      b(Number.isInteger(e) && e >= 0, function () {
        return "Tensor must have a shape comprised of positive integers but got shape [" + t + "]."
      })
    })
  }

  function tt(t, e) {
    return void 0 === e && (e = "utf-8"), e = e || "utf-8", o().platform.encode(t, e)
  }

  function et(t, e) {
    return void 0 === e && (e = "utf-8"), e = e || "utf-8", o().platform.decode(t, e)
  }
  var nt = Object.freeze({
      shuffle: m,
      clamp: g,
      nearestLargerEven: v,
      sum: y,
      randUniform: function (t, e) {
        var n = Math.random();
        return e * n + (1 - n) * t
      },
      distSquared: function (t, e) {
        for (var n = 0, r = 0; r < t.length; r++) {
          var a = Number(t[r]) - Number(e[r]);
          n += a * a
        }
        return n
      },
      assert: b,
      assertShapesMatch: x,
      assertNonNull: w,
      flatten: C,
      sizeFromShape: N,
      isScalarShape: function (t) {
        return 0 === t.length
      },
      arraysEqual: S,
      isInt: k,
      tanh: I,
      sizeToSquarishShape: E,
      createShuffledIndices: function (t) {
        for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n;
        return m(e), e
      },
      rightPad: A,
      repeatedTry: R,
      inferFromImplicitShape: T,
      parseAxisParam: D,
      squeezeShape: O,
      getTypedArrayFromDType: _,
      getArrayFromDType: F,
      checkConversionForErrors: M,
      isValidDtype: z,
      hasEncodingLoss: L,
      isTypedArray: B,
      bytesPerElement: P,
      bytesFromStringArray: W,
      isString: V,
      isBoolean: U,
      isNumber: j,
      inferDtype: G,
      isFunction: q,
      nearestDivisor: H,
      computeStrides: K,
      toTypedArray: X,
      toNestedArray: $,
      makeOnesTypedArray: Y,
      makeZerosTypedArray: J,
      now: Z,
      assertNonNegativeIntegerDimensions: Q,
      fetch: function (t, e) {
        return o().platform.fetch(t, e)
      },
      encodeString: tt,
      decodeString: et
    }),
    rt = function () {
      function t(t, e) {
        this.backendTimer = t, this.logger = e, null == e && (this.logger = new at)
      }
      return t.prototype.profileKernel = function (t, e, n) {
        var r, a = this,
          i = this.backendTimer.time(function () {
            r = n()
          });
        return r.forEach(function (n) {
          n.data().then(function (r) {
            ! function (t, e, n) {
              if ("float32" !== e) return !1;
              for (var r = 0; r < t.length; r++) {
                var a = t[r];
                if (isNaN(a) || !isFinite(a)) return console.warn("Found " + a + " in the result of '" + n + "'"), !0
              }
            }(r, n.dtype, t), i.then(function (i) {
              var o = "";
              null != i.getExtraProfileInfo && (o = i.getExtraProfileInfo()), a.logger.logKernelProfile(t, n, r, i.kernelMs, e, o)
            })
          })
        }), r
      }, t
    }(),
    at = function () {
      function t() {}
      return t.prototype.logKernelProfile = function (t, e, n, r, a, i) {
        var o = A(r + "ms", 9),
          s = A(t, 25),
          u = e.rank,
          l = e.size,
          c = A(e.shape.toString(), 14),
          p = "";
        for (var h in a) {
          var f = a[h].shape || e.shape,
            d = f.length;
          p += h + ": " + d + "D " + (d > 0 ? f : "") + " "
        }
        console.log("%c" + s + "\t%c" + o + "\t%c" + u + "D " + c + "\t%c" + l + "\t%c" + p + "\t%c" + i, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue")
      }, t
    }(),
    it = 20,
    ot = 3,
    st = 7;

  function ut(t, e, n) {
    return A(Array.isArray(t) ? parseFloat(t[0].toFixed(st)) + " + " + parseFloat(t[1].toFixed(st)) + "j" : V(t) ? "'" + t + "'" : "bool" === n ? lt(t) : parseFloat(t.toFixed(st)).toString(), e)
  }

  function lt(t) {
    return 0 === t ? "false" : "true"
  }

  function ct(t) {
    for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]]);
    return e
  }
  var pt = function () {
      function t(t, e, n) {
        var r = this;
        if (this.dtype = e, this.shape = t.slice(), this.size = N(t), null != n) {
          var a = n.length;
          b(a === this.size, function () {
            return "Length of values '" + a + "' does not match the size inferred by the shape '" + r.size + "'."
          })
        }
        if ("complex64" === e) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
        this.values = n || F(e, this.size), this.strides = K(t)
      }
      return t.prototype.set = function (t) {
        for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
        0 === n.length && (n = [0]), b(n.length === this.rank, function () {
          return "The number of provided coordinates (" + n.length + ") must match the rank (" + e.rank + ")"
        });
        var a = this.locToIndex(n);
        this.values[a] = t
      }, t.prototype.get = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        0 === t.length && (t = [0]);
        for (var n = 0, r = 0, a = t; r < a.length; r++) {
          var i = a[r];
          if (i < 0 || i >= this.shape[n]) {
            var o = "Requested out of range element at " + t + ".   Buffer shape=" + this.shape;
            throw new Error(o)
          }
          n++
        }
        for (var s = t[t.length - 1], u = 0; u < t.length - 1; ++u) s += this.strides[u] * t[u];
        return this.values[s]
      }, t.prototype.locToIndex = function (t) {
        if (0 === this.rank) return 0;
        if (1 === this.rank) return t[0];
        for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n) e += this.strides[n] * t[n];
        return e
      }, t.prototype.indexToLoc = function (t) {
        if (0 === this.rank) return [];
        if (1 === this.rank) return [t];
        for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n) e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];
        return e[e.length - 1] = t, e
      }, Object.defineProperty(t.prototype, "rank", {
        get: function () {
          return this.shape.length
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.toTensor = function () {
        return ht().makeTensor(this.values, this.shape, this.dtype)
      }, t
    }(),
    ht = null,
    ft = null,
    dt = null,
    mt = function () {
      function t(t, e, n, r) {
        this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || "float32", this.size = N(t), this.strides = K(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : "higher"
      }
      return t.prototype.flatten = function () {
        return this.throwIfDisposed(), this.as1D()
      }, t.prototype.asScalar = function () {
        return this.throwIfDisposed(), b(1 === this.size, function () {
          return "The array must have only 1 element."
        }), this.reshape([])
      }, t.prototype.as1D = function () {
        return this.throwIfDisposed(), this.reshape([this.size])
      }, t.prototype.as2D = function (t, e) {
        return this.throwIfDisposed(), this.reshape([t, e])
      }, t.prototype.as3D = function (t, e, n) {
        return this.throwIfDisposed(), this.reshape([t, e, n])
      }, t.prototype.as4D = function (t, e, n, r) {
        return this.throwIfDisposed(), this.reshape([t, e, n, r])
      }, t.prototype.as5D = function (t, e, n, r, a) {
        return this.throwIfDisposed(), this.reshape([t, e, n, r, a])
      }, t.prototype.asType = function (t) {
        return this.throwIfDisposed(), ft.cast(this, t)
      }, Object.defineProperty(t.prototype, "rank", {
        get: function () {
          return this.shape.length
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.buffer = function () {
        return r(this, void 0, void 0, function () {
          var t;
          return a(this, function (e) {
            switch (e.label) {
              case 0:
                return [4, this.data()];
              case 1:
                return t = e.sent(), [2, ft.buffer(this.shape, this.dtype, t)]
            }
          })
        })
      }, t.prototype.bufferSync = function () {
        return ft.buffer(this.shape, this.dtype, this.dataSync())
      }, t.prototype.array = function () {
        return r(this, void 0, void 0, function () {
          var t;
          return a(this, function (e) {
            switch (e.label) {
              case 0:
                return [4, this.data()];
              case 1:
                return t = e.sent(), [2, $(this.shape, t)]
            }
          })
        })
      }, t.prototype.arraySync = function () {
        return $(this.shape, this.dataSync())
      }, t.prototype.data = function () {
        return r(this, void 0, void 0, function () {
          var t, e;
          return a(this, function (n) {
            switch (n.label) {
              case 0:
                return this.throwIfDisposed(), t = ht().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t];
              case 1:
                e = n.sent();
                try {
                  return [2, e.map(function (t) {
                    return et(t)
                  })]
                } catch (t) {
                  throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                }
                n.label = 2;
              case 2:
                return [2, t]
            }
          })
        })
      }, t.prototype.dataSync = function () {
        this.throwIfDisposed();
        var t = ht().readSync(this.dataId);
        if ("string" === this.dtype) try {
          return t.map(function (t) {
            return et(t)
          })
        } catch (t) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
        }
        return t
      }, t.prototype.bytes = function () {
        return r(this, void 0, void 0, function () {
          var t;
          return a(this, function (e) {
            switch (e.label) {
              case 0:
                return this.throwIfDisposed(), [4, ht().read(this.dataId)];
              case 1:
                return t = e.sent(), "string" === this.dtype ? [2, t] : [2, new Uint8Array(t.buffer)]
            }
          })
        })
      }, t.prototype.dispose = function () {
        this.isDisposed || (ht().disposeTensor(this), this.isDisposedInternal = !0)
      }, Object.defineProperty(t.prototype, "isDisposed", {
        get: function () {
          return this.isDisposedInternal
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.throwIfDisposed = function () {
        if (this.isDisposed) throw new Error("Tensor is disposed.")
      }, t.prototype.toFloat = function () {
        return this.asType("float32")
      }, t.prototype.toInt = function () {
        return this.asType("int32")
      }, t.prototype.toBool = function () {
        return this.asType("bool")
      }, t.prototype.print = function (t) {
        return void 0 === t && (t = !1), ft.print(this, t)
      }, t.prototype.reshape = function (t) {
        return this.throwIfDisposed(), ft.reshape(this, t)
      }, t.prototype.reshapeAs = function (t) {
        return this.throwIfDisposed(), this.reshape(t.shape)
      }, t.prototype.expandDims = function (t) {
        return void 0 === t && (t = 0), ft.expandDims(this, t)
      }, t.prototype.cumsum = function (t, e, n) {
        return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), ft.cumsum(this, t, e, n)
      }, t.prototype.squeeze = function (t) {
        return this.throwIfDisposed(), ft.squeeze(this, t)
      }, t.prototype.clone = function () {
        return this.throwIfDisposed(), ft.clone(this)
      }, t.prototype.oneHot = function (t, e, n) {
        return this.throwIfDisposed(), ft.oneHot(this, t, e, n)
      }, t.prototype.toString = function (t) {
        return void 0 === t && (t = !1),
          function (t, e, n, r) {
            var a = K(e),
              i = function (t, e, n, r) {
                var a = N(e),
                  i = r[r.length - 1],
                  o = new Array(i).fill(0),
                  s = e.length,
                  u = "complex64" === n ? ct(t) : t;
                if (s > 1)
                  for (var l = 0; l < a / i; l++)
                    for (var c = l * i, p = 0; p < i; p++) o[p] = Math.max(o[p], ut(u[c + p], 0, n).length);
                return o
              }(t, e, n, a),
              o = e.length,
              s = function t(e, n, r, a, i, o) {
                void 0 === o && (o = !0);
                var s = "complex64" === r ? 2 : 1,
                  u = n[0],
                  l = n.length;
                if (0 === l) return "complex64" === r ? [ut(ct(e)[0], 0, r)] : "bool" === r ? [lt(e[0])] : [e[0].toString()];
                if (1 === l) {
                  if (u > it) {
                    var c = ot * s,
                      p = Array.from(e.slice(0, c)),
                      h = Array.from(e.slice((u - ot) * s, u * s));
                    return "complex64" === r && (p = ct(p), h = ct(h)), ["[" + p.map(function (t, e) {
                      return ut(t, i[e], r)
                    }).join(", ") + ", ..., " + h.map(function (t, e) {
                      return ut(t, i[u - ot + e], r)
                    }).join(", ") + "]"]
                  }
                  return ["[" + ("complex64" === r ? ct(e) : Array.from(e)).map(function (t, e) {
                    return ut(t, i[e], r)
                  }).join(", ") + "]"]
                }
                var f = n.slice(1),
                  d = a.slice(1),
                  m = a[0] * s,
                  g = [];
                if (u > it) {
                  for (var v = 0; v < ot; v++) {
                    var y = (b = v * m) + m;
                    g.push.apply(g, t(e.slice(b, y), f, r, d, i, !1))
                  }
                  for (g.push("..."), v = u - ot; v < u; v++) y = (b = v * m) + m, g.push.apply(g, t(e.slice(b, y), f, r, d, i, v === u - 1))
                } else
                  for (v = 0; v < u; v++) {
                    var b;
                    y = (b = v * m) + m, g.push.apply(g, t(e.slice(b, y), f, r, d, i, v === u - 1))
                  }
                var x = 2 === l ? "," : "";
                for (g[0] = "[" + g[0] + x, v = 1; v < g.length - 1; v++) g[v] = " " + g[v] + x;
                var w = ",\n";
                for (v = 2; v < l; v++) w += "\n";
                return g[g.length - 1] = " " + g[g.length - 1] + "]" + (o ? "" : w), g
              }(t, e, n, a, i),
              u = ["Tensor"];
            return r && (u.push("  dtype: " + n), u.push("  rank: " + o), u.push("  shape: [" + e + "]"), u.push("  values:")), u.push(s.map(function (t) {
              return "    " + t
            }).join("\n")), u.join("\n")
          }(this.dataSync(), this.shape, this.dtype, t)
      }, t.prototype.tile = function (t) {
        return this.throwIfDisposed(), ft.tile(this, t)
      }, t.prototype.gather = function (t, e) {
        return void 0 === e && (e = 0), this.throwIfDisposed(), ft.gather(this, t, e)
      }, t.prototype.matMul = function (t, e, n) {
        return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), ft.matMul(this, t, e, n)
      }, t.prototype.dot = function (t) {
        return this.throwIfDisposed(), ft.dot(this, t)
      }, t.prototype.norm = function (t, e, n) {
        return void 0 === t && (t = "euclidean"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), ft.norm(this, t, e, n)
      }, t.prototype.slice = function (t, e) {
        return this.throwIfDisposed(), ft.slice(this, t, e)
      }, t.prototype.reverse = function (t) {
        return this.throwIfDisposed(), ft.reverse(this, t)
      }, t.prototype.concat = function (e, n) {
        return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [e]), ft.concat([this].concat(e), n)
      }, t.prototype.split = function (t, e) {
        return void 0 === e && (e = 0), this.throwIfDisposed(), ft.split(this, t, e)
      }, t.prototype.stack = function (t, e) {
        return void 0 === e && (e = 0), ft.stack([this, t], e)
      }, t.prototype.unstack = function (t) {
        return void 0 === t && (t = 0), ft.unstack(this, t)
      }, t.prototype.pad = function (t, e) {
        return void 0 === e && (e = 0), ft.pad(this, t, e)
      }, t.prototype.batchNormalization = function (t, e, n, r, a) {
        return void 0 === n && (n = .001), dt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t, e, a, r, n)
      }, t.prototype.batchNorm = function (t, e, n, r, a) {
        return void 0 === a && (a = .001), this.throwIfDisposed(), ft.batchNorm(this, t, e, n, r, a)
      }, t.prototype.all = function (t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.all(this, t, e)
      }, t.prototype.any = function (t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.any(this, t, e)
      }, t.prototype.logSumExp = function (t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.logSumExp(this, t, e)
      }, t.prototype.sum = function (t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.sum(this, t, e)
      }, t.prototype.prod = function (t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.prod(this, t, e)
      }, t.prototype.mean = function (t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.mean(this, t, e)
      }, t.prototype.min = function (t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.min(this, t, e)
      }, t.prototype.max = function (t, e) {
        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), ft.max(this, t, e)
      }, t.prototype.argMin = function (t) {
        return void 0 === t && (t = null), this.throwIfDisposed(), ft.argMin(this, t)
      }, t.prototype.argMax = function (t) {
        return void 0 === t && (t = null), this.throwIfDisposed(), ft.argMax(this, t)
      }, t.prototype.cast = function (t) {
        return this.throwIfDisposed(), ft.cast(this, t)
      }, t.prototype.add = function (t) {
        return this.throwIfDisposed(), ft.add(this, t)
      }, t.prototype.addStrict = function (t) {
        return this.throwIfDisposed(), ft.addStrict(this, t)
      }, t.prototype.atan2 = function (t) {
        return this.throwIfDisposed(), ft.atan2(this, t)
      }, t.prototype.sub = function (t) {
        return this.throwIfDisposed(), ft.sub(this, t)
      }, t.prototype.subStrict = function (t) {
        return this.throwIfDisposed(), ft.subStrict(this, t)
      }, t.prototype.pow = function (t) {
        return this.throwIfDisposed(), ft.pow(this, t)
      }, t.prototype.powStrict = function (t) {
        return this.throwIfDisposed(), ft.powStrict(this, t)
      }, t.prototype.mul = function (t) {
        return this.throwIfDisposed(), ft.mul(this, t)
      }, t.prototype.mulStrict = function (t) {
        return this.throwIfDisposed(), ft.mulStrict(this, t)
      }, t.prototype.div = function (t) {
        return this.throwIfDisposed(), ft.div(this, t)
      }, t.prototype.divNoNan = function (t) {
        return this.throwIfDisposed(), ft.divNoNan(this, t)
      }, t.prototype.floorDiv = function (t) {
        return this.throwIfDisposed(), ft.floorDiv(this, t)
      }, t.prototype.divStrict = function (t) {
        return this.throwIfDisposed(), ft.divStrict(this, t)
      }, t.prototype.minimum = function (t) {
        return this.throwIfDisposed(), ft.minimum(this, t)
      }, t.prototype.minimumStrict = function (t) {
        return this.throwIfDisposed(), ft.minimumStrict(this, t)
      }, t.prototype.maximum = function (t) {
        return this.throwIfDisposed(), ft.maximum(this, t)
      }, t.prototype.maximumStrict = function (t) {
        return this.throwIfDisposed(), ft.maximumStrict(this, t)
      }, t.prototype.mod = function (t) {
        return this.throwIfDisposed(), ft.mod(this, t)
      }, t.prototype.modStrict = function (t) {
        return this.throwIfDisposed(), ft.modStrict(this, t)
      }, t.prototype.squaredDifference = function (t) {
        return this.throwIfDisposed(), ft.squaredDifference(this, t)
      }, t.prototype.squaredDifferenceStrict = function (t) {
        return this.throwIfDisposed(), ft.squaredDifferenceStrict(this, t)
      }, t.prototype.transpose = function (t) {
        return this.throwIfDisposed(), ft.transpose(this, t)
      }, t.prototype.notEqual = function (t) {
        return this.throwIfDisposed(), ft.notEqual(this, t)
      }, t.prototype.notEqualStrict = function (t) {
        return this.throwIfDisposed(), ft.notEqualStrict(this, t)
      }, t.prototype.less = function (t) {
        return this.throwIfDisposed(), ft.less(this, t)
      }, t.prototype.lessStrict = function (t) {
        return this.throwIfDisposed(), ft.lessStrict(this, t)
      }, t.prototype.equal = function (t) {
        return this.throwIfDisposed(), ft.equal(this, t)
      }, t.prototype.equalStrict = function (t) {
        return this.throwIfDisposed(), ft.equalStrict(this, t)
      }, t.prototype.lessEqual = function (t) {
        return this.throwIfDisposed(), ft.lessEqual(this, t)
      }, t.prototype.lessEqualStrict = function (t) {
        return this.throwIfDisposed(), ft.lessEqualStrict(this, t)
      }, t.prototype.greater = function (t) {
        return this.throwIfDisposed(), ft.greater(this, t)
      }, t.prototype.greaterStrict = function (t) {
        return this.throwIfDisposed(), ft.greaterStrict(this, t)
      }, t.prototype.greaterEqual = function (t) {
        return this.throwIfDisposed(), ft.greaterEqual(this, t)
      }, t.prototype.greaterEqualStrict = function (t) {
        return this.throwIfDisposed(), ft.greaterEqualStrict(this, t)
      }, t.prototype.logicalAnd = function (t) {
        return this.throwIfDisposed(), ft.logicalAnd(this, t)
      }, t.prototype.logicalOr = function (t) {
        return this.throwIfDisposed(), ft.logicalOr(this, t)
      }, t.prototype.logicalNot = function () {
        return this.throwIfDisposed(), ft.logicalNot(this)
      }, t.prototype.logicalXor = function (t) {
        return this.throwIfDisposed(), ft.logicalXor(this, t)
      }, t.prototype.where = function (t, e) {
        return this.throwIfDisposed(), ft.where(t, this, e)
      }, t.prototype.neg = function () {
        return this.throwIfDisposed(), ft.neg(this)
      }, t.prototype.ceil = function () {
        return this.throwIfDisposed(), ft.ceil(this)
      }, t.prototype.floor = function () {
        return this.throwIfDisposed(), ft.floor(this)
      }, t.prototype.sign = function () {
        return this.throwIfDisposed(), ft.sign(this)
      }, t.prototype.isNaN = function () {
        return this.throwIfDisposed(), ft.isNaN(this)
      }, t.prototype.isInf = function () {
        return this.throwIfDisposed(), ft.isInf(this)
      }, t.prototype.isFinite = function () {
        return this.throwIfDisposed(), ft.isFinite(this)
      }, t.prototype.exp = function () {
        return this.throwIfDisposed(), ft.exp(this)
      }, t.prototype.expm1 = function () {
        return this.throwIfDisposed(), ft.expm1(this)
      }, t.prototype.log = function () {
        return this.throwIfDisposed(), ft.log(this)
      }, t.prototype.log1p = function () {
        return this.throwIfDisposed(), ft.log1p(this)
      }, t.prototype.sqrt = function () {
        return this.throwIfDisposed(), ft.sqrt(this)
      }, t.prototype.rsqrt = function () {
        return this.throwIfDisposed(), ft.rsqrt(this)
      }, t.prototype.square = function () {
        return this.throwIfDisposed(), ft.square(this)
      }, t.prototype.reciprocal = function () {
        return this.throwIfDisposed(), ft.reciprocal(this)
      }, t.prototype.abs = function () {
        return this.throwIfDisposed(), ft.abs(this)
      }, t.prototype.clipByValue = function (t, e) {
        return this.throwIfDisposed(), ft.clipByValue(this, t, e)
      }, t.prototype.relu = function () {
        return this.throwIfDisposed(), ft.relu(this)
      }, t.prototype.relu6 = function () {
        return this.throwIfDisposed(), ft.relu6(this)
      }, t.prototype.elu = function () {
        return this.throwIfDisposed(), ft.elu(this)
      }, t.prototype.selu = function () {
        return this.throwIfDisposed(), ft.selu(this)
      }, t.prototype.leakyRelu = function (t) {
        return void 0 === t && (t = .2), this.throwIfDisposed(), ft.leakyRelu(this, t)
      }, t.prototype.prelu = function (t) {
        return this.throwIfDisposed(), ft.prelu(this, t)
      }, t.prototype.sigmoid = function () {
        return this.throwIfDisposed(), ft.sigmoid(this)
      }, t.prototype.logSigmoid = function () {
        return this.throwIfDisposed(), ft.logSigmoid(this)
      }, t.prototype.softplus = function () {
        return this.throwIfDisposed(), ft.softplus(this)
      }, t.prototype.zerosLike = function () {
        return this.throwIfDisposed(), ft.zerosLike(this)
      }, t.prototype.onesLike = function () {
        return this.throwIfDisposed(), ft.onesLike(this)
      }, t.prototype.sin = function () {
        return this.throwIfDisposed(), ft.sin(this)
      }, t.prototype.cos = function () {
        return this.throwIfDisposed(), ft.cos(this)
      }, t.prototype.tan = function () {
        return this.throwIfDisposed(), ft.tan(this)
      }, t.prototype.asin = function () {
        return this.throwIfDisposed(), ft.asin(this)
      }, t.prototype.acos = function () {
        return this.throwIfDisposed(), ft.acos(this)
      }, t.prototype.atan = function () {
        return this.throwIfDisposed(), ft.atan(this)
      }, t.prototype.sinh = function () {
        return this.throwIfDisposed(), ft.sinh(this)
      }, t.prototype.cosh = function () {
        return this.throwIfDisposed(), ft.cosh(this)
      }, t.prototype.tanh = function () {
        return this.throwIfDisposed(), ft.tanh(this)
      }, t.prototype.asinh = function () {
        return this.throwIfDisposed(), ft.asinh(this)
      }, t.prototype.acosh = function () {
        return this.throwIfDisposed(), ft.acosh(this)
      }, t.prototype.atanh = function () {
        return this.throwIfDisposed(), ft.atanh(this)
      }, t.prototype.erf = function () {
        return this.throwIfDisposed(), ft.erf(this)
      }, t.prototype.round = function () {
        return this.throwIfDisposed(), ft.round(this)
      }, t.prototype.step = function (t) {
        return void 0 === t && (t = 0), this.throwIfDisposed(), ft.step(this, t)
      }, t.prototype.softmax = function (t) {
        return void 0 === t && (t = -1), this.throwIfDisposed(), ft.softmax(this, t)
      }, t.prototype.logSoftmax = function (t) {
        return void 0 === t && (t = -1), this.throwIfDisposed(), ft.logSoftmax(this, t)
      }, t.prototype.resizeBilinear = function (t, e) {
        return void 0 === e && (e = !1), this.throwIfDisposed(), ft.image.resizeBilinear(this, t, e)
      }, t.prototype.resizeNearestNeighbor = function (t, e) {
        return void 0 === e && (e = !1), this.throwIfDisposed(), ft.image.resizeNearestNeighbor(this, t, e)
      }, t.prototype.conv1d = function (t, e, n, r, a, i) {
        return void 0 === r && (r = "NWC"), void 0 === a && (a = 1), this.throwIfDisposed(), ft.conv1d(this, t, e, n, r, a, i)
      }, t.prototype.conv2d = function (t, e, n, r, a, i) {
        return void 0 === r && (r = "NHWC"), void 0 === a && (a = [1, 1]), this.throwIfDisposed(), ft.conv2d(this, t, e, n, r, a, i)
      }, t.prototype.conv2dTranspose = function (t, e, n, r, a) {
        return this.throwIfDisposed(), ft.conv2dTranspose(this, t, e, n, r, a)
      }, t.prototype.depthwiseConv2D = function (t, e, n, r, a, i) {
        return void 0 === r && (r = "NHWC"), void 0 === a && (a = [1, 1]), this.throwIfDisposed(), ft.depthwiseConv2d(this, t, e, n, r, a, i)
      }, t.prototype.separableConv2d = function (t, e, n, r, a, i) {
        return void 0 === a && (a = [1, 1]), void 0 === i && (i = "NHWC"), this.throwIfDisposed(), ft.separableConv2d(this, t, e, n, r, a, i)
      }, t.prototype.avgPool = function (t, e, n, r) {
        return this.throwIfDisposed(), ft.avgPool(this, t, e, n, r)
      }, t.prototype.maxPool = function (t, e, n, r) {
        return this.throwIfDisposed(), ft.maxPool(this, t, e, n, r)
      }, t.prototype.localResponseNormalization = function (t, e, n, r) {
        return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), ft.localResponseNormalization(this, t, e, n, r)
      }, t.prototype.pool = function (t, e, n, r, a) {
        return this.throwIfDisposed(), ft.pool(this, t, e, n, r, a)
      }, t.prototype.variable = function (t, e, n) {
        return void 0 === t && (t = !0), this.throwIfDisposed(), ht().makeVariable(this, t, e, n)
      }, t.prototype.unsortedSegmentSum = function (t, e) {
        return this.throwIfDisposed(), ft.unsortedSegmentSum(this, t, e)
      }, t.prototype.batchToSpaceND = function (t, e) {
        return this.throwIfDisposed(), ft.batchToSpaceND(this, t, e)
      }, t.prototype.spaceToBatchND = function (t, e) {
        return this.throwIfDisposed(), ft.spaceToBatchND(this, t, e)
      }, t.prototype.topk = function (t, e) {
        return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), ft.topk(this, t, e)
      }, t.prototype.stridedSlice = function (t, e, n, r, a, i, o, s) {
        return void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), this.throwIfDisposed(), ft.stridedSlice(this, t, e, n, r, a, i, o, s)
      }, t.prototype.depthToSpace = function (t, e) {
        return this.throwIfDisposed(), ft.depthToSpace(this, t, e)
      }, t.prototype.fft = function () {
        return this.throwIfDisposed(), ft.spectral.fft(this)
      }, t.prototype.ifft = function () {
        return this.throwIfDisposed(), ft.spectral.ifft(this)
      }, t.prototype.rfft = function () {
        return this.throwIfDisposed(), ft.spectral.rfft(this)
      }, t.prototype.irfft = function () {
        return this.throwIfDisposed(), ft.spectral.irfft(this)
      }, t
    }();
  Object.defineProperty(mt, Symbol.hasInstance, {
    value: function (t) {
      return !!t && null != t.dataId && null != t.shape && null != t.dtype
    }
  });
  var gt, vt, yt, bt, xt = function (t) {
    function e(e, n, r, a) {
      var i = t.call(this, e.shape, e.dtype, e.dataId, a) || this;
      return i.trainable = n, i.name = r, i
    }
    return n(e, t), e.prototype.assign = function (t) {
      if (t.dtype !== this.dtype) throw new Error("dtype of the new value (" + t.dtype + ") and previous value (" + this.dtype + ") must match");
      if (!S(t.shape, this.shape)) throw new Error("shape of the new value (" + t.shape + ") and previous value (" + this.shape + ") must match");
      ht().disposeTensor(this), this.dataId = t.dataId, ht().incRef(this, null)
    }, e.prototype.dispose = function () {
      ht().disposeVariable(this), this.isDisposedInternal = !0
    }, e
  }(mt);
  Object.defineProperty(xt, Symbol.hasInstance, {
      value: function (t) {
        return t instanceof mt && null != t.assign && t.assign instanceof Function
      }
    }),
    function (t) {
      t.R0 = "R0", t.R1 = "R1", t.R2 = "R2", t.R3 = "R3", t.R4 = "R4", t.R5 = "R5", t.R6 = "R6"
    }(t.Rank || (t.Rank = {})),
    function (t) {
      t.float32 = "float32", t.int32 = "int32", t.bool = "int32", t.complex64 = "complex64"
    }(gt || (gt = {})),
    function (t) {
      t.float32 = "float32", t.int32 = "int32", t.bool = "bool", t.complex64 = "complex64"
    }(vt || (vt = {})),
    function (t) {
      t.float32 = "float32", t.int32 = "float32", t.bool = "float32", t.complex64 = "complex64"
    }(yt || (yt = {})),
    function (t) {
      t.float32 = "complex64", t.int32 = "complex64", t.bool = "complex64", t.complex64 = "complex64"
    }(bt || (bt = {}));
  var wt = {
    float32: yt,
    int32: gt,
    bool: vt,
    complex64: bt
  };

  function Ct(t, e) {
    if ("string" === t || "string" === e) {
      if ("string" === t && "string" === e) return "string";
      throw new Error("Can not upcast " + t + " with " + e)
    }
    return wt[t][e]
  }

  function Nt(t) {
    return Ct(t, "int32")
  }

  function St(t, e) {
    if (t.dtype === e.dtype) return [t, e];
    var n = Ct(t.dtype, e.dtype);
    return [t.cast(n), e.cast(n)]
  }

  function kt(t, e) {
    b(t.dtype === e.dtype, function () {
      return "The dtypes of the first(" + t.dtype + ") and second(" + e.dtype + ") input must match"
    })
  }

  function It(t) {
    var e = [];
    return function t(e, n, r) {
      if (null != e)
        if (e instanceof mt) n.push(e);
        else if (a = e, Array.isArray(a) || "object" == typeof a) {
        var a, i = e;
        for (var o in i) {
          var s = i[o];
          r.has(s) || (r.add(s), t(s, n, r))
        }
      }
    }(t, e, new Set), e
  }
  var Et, At = Object.freeze({
      makeTypesMatch: St,
      assertTypesMatch: kt,
      isTensorInList: function (t, e) {
        for (var n = 0; n < e.length; n++)
          if (e[n].id === t.id) return !0;
        return !1
      },
      getTensorsInContainer: It
    }),
    Rt = function () {
      function t() {
        this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
          newBytes: 0,
          newTensors: 0,
          peakBytes: 0,
          kernels: [],
          result: null
        }
      }
      return t.prototype.dispose = function () {
        for (var t in this.registeredVariables) this.registeredVariables[t].dispose()
      }, t
    }(),
    Tt = function () {
      function t(t) {
        this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Rt
      }
      return t.prototype.ready = function () {
        return r(this, void 0, void 0, function () {
          var t, e, n;
          return a(this, function (r) {
            switch (r.label) {
              case 0:
                if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then(function () {})];
                if (null != this.backendInstance) return [2];
                t = this.getSortedBackends(), e = 0, r.label = 1;
              case 1:
                return e < t.length ? (n = t[e], [4, this.initializeBackend(n).success]) : [3, 5];
              case 2:
                return r.sent() ? [4, this.setBackend(n)] : [3, 4];
              case 3:
                return r.sent(), [2];
              case 4:
                return e++, [3, 1];
              case 5:
                throw new Error("Could not initialize any backends, all backend initializations failed.")
            }
          })
        })
      }, Object.defineProperty(t.prototype, "backend", {
        get: function () {
          if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
          if (null == this.backendInstance) {
            var t = this.initializeBackendsAndReturnBest(),
              e = t.name;
            if (t.asyncInit) throw new Error("The highest priority backend '" + e + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
            this.setBackend(e)
          }
          return this.backendInstance
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.backendNames = function () {
        return Object.keys(this.registryFactory)
      }, t.prototype.findBackend = function (t) {
        if (!(t in this.registry)) {
          if (!(t in this.registryFactory)) return null;
          if (this.initializeBackend(t).asyncInit) return null
        }
        return this.registry[t]
      }, t.prototype.findBackendFactory = function (t) {
        return t in this.registryFactory ? this.registryFactory[t].factory : null
      }, t.prototype.registerBackend = function (t, e, n) {
        return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[t] = {
          factory: e,
          priority: n
        }, !0)
      }, t.prototype.setBackend = function (t) {
        return r(this, void 0, void 0, function () {
          var e, n, r;
          return a(this, function (a) {
            switch (a.label) {
              case 0:
                if (null == this.registryFactory[t]) throw new Error("Backend name '" + t + "' not found in registry");
                return this.backendName = t, null != this.registry[t] ? [3, 4] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [4, n] : [3, 2]);
              case 1:
                return r = a.sent(), [3, 3];
              case 2:
                r = n, a.label = 3;
              case 3:
                if (!r) return [2, !1];
                a.label = 4;
              case 4:
                return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new rt(this.backendInstance), [2, !0]
            }
          })
        })
      }, t.prototype.setupRegisteredKernels = function () {
        var t = this;
        p(this.backendName).forEach(function (e) {
          null != e.setupFunc && e.setupFunc(t.backendInstance)
        })
      }, t.prototype.disposeRegisteredKernels = function (t) {
        var e = this;
        p(t).forEach(function (n) {
          null != n.disposeFunc && n.disposeFunc(e.registry[t])
        })
      }, t.prototype.initializeBackend = function (t) {
        var e = this,
          n = this.registryFactory[t];
        if (null == n) throw new Error("Cannot initialize backend " + t + ", no registration found.");
        try {
          var r = n.factory();
          if (Promise.resolve(r) === r) {
            var a = ++this.pendingBackendInitId,
              i = r.then(function (n) {
                return !(a < e.pendingBackendInitId || (e.registry[t] = n, e.pendingBackendInit = null, 0))
              }).catch(function (n) {
                return !(a < e.pendingBackendInitId || (e.pendingBackendInit = null, console.warn("Initialization of backend " + t + " failed"), console.warn(n.stack || n.message), 1))
              });
            return this.pendingBackendInit = i, {
              success: i,
              asyncInit: !0
            }
          }
          return this.registry[t] = r, {
            success: !0,
            asyncInit: !1
          }
        } catch (e) {
          return console.warn("Initialization of backend " + t + " failed"), console.warn(e.stack || e.message), {
            success: !1,
            asyncInit: !1
          }
        }
      }, t.prototype.removeBackend = function (t) {
        if (!(t in this.registryFactory)) throw new Error(t + " backend not found in registry");
        this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null)
      }, t.prototype.getSortedBackends = function () {
        var t = this;
        if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
        return Object.keys(this.registryFactory).sort(function (e, n) {
          return t.registryFactory[n].priority - t.registryFactory[e].priority
        })
      }, t.prototype.initializeBackendsAndReturnBest = function () {
        for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {
          var n = t[e],
            r = this.initializeBackend(n),
            a = r.success,
            i = r.asyncInit;
          if (i || a) return {
            name: n,
            asyncInit: i
          }
        }
        throw new Error("Could not initialize any backends, all backend initializations failed.")
      }, t.prototype.moveData = function (t, e) {
        var n = this.state.tensorInfo.get(e),
          r = n.backend,
          a = this.readSync(e);
        r.disposeData(e), n.backend = t, t.move(e, a, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
      }, t.prototype.tidy = function (t, e) {
        var n, r = this,
          a = null;
        if (null == e) {
          if ("function" != typeof t) throw new Error("Please provide a function to tidy()");
          e = t
        } else {
          if ("string" != typeof t && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
          if ("function" != typeof e) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
          a = t
        }
        return this.scopedRun(function () {
          return r.startScope(a)
        }, function () {
          return r.endScope(n)
        }, function () {
          return (n = e()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n
        })
      }, t.prototype.scopedRun = function (t, e, n) {
        t();
        try {
          var r = n();
          return e(), r
        } catch (t) {
          throw e(), t
        }
      }, t.prototype.nextTensorId = function () {
        return t.nextTensorId++
      }, t.prototype.nextVariableId = function () {
        return t.nextVariableId++
      }, t.prototype.clone = function (t) {
        var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),
          n = {
            x: t
          };
        return this.addTapeNode(this.state.activeScope.name, n, [e], function (t) {
          return {
            x: function () {
              return t.toFloat()
            }
          }
        }, []), e
      }, t.prototype.runKernel = function (t, e, n, r, a) {
        return this.runKernelFunc(null, e, null, t, n, r, a)
      }, t.prototype.shouldCheckForMemLeaks = function () {
        return this.ENV.getBool("IS_TEST")
      }, t.prototype.checkKernelForMemLeak = function (t, e, n) {
        var r = this.backend.numDataIds(),
          a = 0;
        n.forEach(function (t) {
          a += "complex64" === t.dtype ? 3 : 1
        });
        var i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
          o = r - e - a - i;
        if (o > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + o + " data ids) after running '" + t + "'")
      }, t.prototype.runKernelFunc = function (t, e, n, r, a, i, o) {
        var s, u = this;
        void 0 === i && (i = []), void 0 === o && (o = []);
        var c = [],
          p = this.isTapeOn();
        null == r && (r = null != this.state.activeScope ? this.state.activeScope.name : "");
        var h, f = function (t) {
            p && (c = t.map(function (t) {
              return u.keep(u.clone(t))
            }))
          },
          d = this.state.numBytes,
          m = this.state.numTensors;
        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
        var g, v = l(r, this.backendName);
        return h = null != v ? function () {
          var t = u.backend.numDataIds();
          g = v.kernelFunc({
            inputs: e,
            attrs: a,
            backend: u.backend
          });
          var n = Array.isArray(g) ? g : [g];
          u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, t, n);
          var s = n.map(function (t) {
              var e = t.dataId,
                n = t.shape,
                r = t.dtype;
              return u.makeTensorFromDataId(e, n, r)
            }),
            l = s.filter(function (t, e) {
              return o[e]
            });
          return f((i || []).slice().concat(l)), s
        } : function () {
          var e = u.backend.numDataIds();
          g = u.tidy(function () {
            return t(u.backend, f)
          });
          var n = Array.isArray(g) ? g : [g];
          return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, e, n), n
        }, this.scopedRun(function () {
          return u.state.kernelDepth++
        }, function () {
          return u.state.kernelDepth--
        }, function () {
          s = u.ENV.getBool("DEBUG") ? u.profiler.profileKernel(r, e, function () {
            return h()
          }) : h()
        }), p && this.addTapeNode(r, e, s, n, c), this.state.profiling && this.state.activeProfile.kernels.push({
          name: r,
          bytesAdded: this.state.numBytes - d,
          totalBytesSnapshot: this.state.numBytes,
          tensorsAdded: this.state.numTensors - m,
          totalTensorsSnapshot: this.state.numTensors,
          inputShapes: Object.keys(e).map(function (t) {
            return e[t].shape
          }),
          outputShapes: s.map(function (t) {
            return t.shape
          })
        }), Array.isArray(g) ? s : s[0]
      }, t.prototype.makeTensor = function (t, e, n, r) {
        if (null == t) throw new Error("Values passed to engine.makeTensor() are null");
        n = n || "float32", r = r || this.backend;
        var a = t;
        "string" === n && V(t[0]) && (a = t.map(function (t) {
          return tt(t)
        }));
        var i = r.write(a, e, n),
          o = new mt(e, n, i, this.nextTensorId());
        if (this.incRef(o, r), "string" === n) {
          var s = this.state.tensorInfo.get(i),
            u = W(a);
          this.state.numBytes += u - s.bytes, s.bytes = u
        }
        return o
      }, t.prototype.makeTensorFromDataId = function (t, e, n, r) {
        var a = new mt(e, n = n || "float32", t, this.nextTensorId());
        return this.incRef(a, r), a
      }, t.prototype.makeVariable = function (t, e, n, r) {
        void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));
        var a = new xt(t, e, n, this.nextTensorId());
        if (null != this.state.registeredVariables[a.name]) throw new Error("Variable with name " + a.name + " was already registered");
        return this.state.registeredVariables[a.name] = a, this.incRef(a, this.backend), a
      }, t.prototype.incRef = function (t, e) {
        var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;
        if (this.state.numTensors++, "string" === t.dtype && this.state.numStringTensors++, 0 === n) {
          this.state.numDataBuffers++;
          var r = 0;
          "complex64" !== t.dtype && "string" !== t.dtype && (r = t.size * P(t.dtype)), this.state.tensorInfo.set(t.dataId, {
            backend: e || this.backend,
            dtype: t.dtype,
            shape: t.shape,
            bytes: r,
            refCount: 0
          }), this.state.numBytes += r
        }
        this.state.tensorInfo.get(t.dataId).refCount++, t instanceof xt || this.track(t)
      }, t.prototype.disposeTensor = function (t) {
        if (this.state.tensorInfo.has(t.dataId)) {
          this.state.numTensors--, "string" === t.dtype && this.state.numStringTensors--;
          var e = this.state.tensorInfo.get(t.dataId);
          e.refCount <= 1 ? ("complex64" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--
        }
      }, t.prototype.disposeVariables = function () {
        for (var t in this.state.registeredVariables) {
          var e = this.state.registeredVariables[t];
          this.disposeVariable(e)
        }
      }, t.prototype.disposeVariable = function (t) {
        this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name]
      }, t.prototype.memory = function () {
        var t = this.backend.memory();
        return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t
      }, t.prototype.profile = function (t) {
        return r(this, void 0, void 0, function () {
          var e, n;
          return a(this, function (r) {
            return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function (t) {
              return t.totalBytesSnapshot
            })), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [2, this.state.activeProfile]
          })
        })
      }, t.prototype.isTapeOn = function () {
        return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
      }, t.prototype.addTapeNode = function (t, e, n, r, a) {
        var i = this,
          o = {
            id: this.state.nextTapeNodeId++,
            kernelName: t,
            inputs: e,
            outputs: n,
            saved: a
          },
          s = c(t);
        null != s && (r = s.gradFunc), null != r && (o.gradient = function (t) {
          return t = t.map(function (t, e) {
            if (null == t) {
              var r = n[e],
                a = J(r.size, r.dtype);
              return i.makeTensor(a, r.shape, r.dtype)
            }
            return t
          }), r(t.length > 1 ? t : t[0], a)
        }), this.state.activeTape.push(o)
      }, t.prototype.keep = function (t) {
        return t.kept = !0, t
      }, t.prototype.startTape = function () {
        0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++
      }, t.prototype.endTape = function () {
        this.state.gradientDepth--
      }, t.prototype.startScope = function (t) {
        var e = {
          track: [],
          name: "unnamed scope",
          id: this.state.nextScopeId++
        };
        t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e
      }, t.prototype.endScope = function (t) {
        for (var e = this, n = It(t), r = new Set(n.map(function (t) {
            return t.id
          })), a = 0; a < this.state.activeScope.track.length; a++) {
          var i = this.state.activeScope.track[a];
          i.kept || r.has(i.id) || i.dispose()
        }
        var o = this.state.scopeStack.pop();
        this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach(function (t) {
          t.kept || t.scopeId !== o.id || e.track(t)
        })
      }, t.prototype.gradients = function (t, e, n, r) {
        var a = this;
        if (void 0 === r && (r = !1), b(e.length > 0, function () {
            return "gradients() received an empty list of xs."
          }), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n.dtype + "'");
        var i = this.scopedRun(function () {
          return a.startTape()
        }, function () {
          return a.endTape()
        }, function () {
          return a.tidy("forward", t)
        });
        b(i instanceof mt, function () {
          return "The result y returned by f() must be a tensor."
        });
        var o = function (t, e, n) {
          for (var r = {}, a = {}, i = 0; i < e.length; i++) r[e[i].id] = !0;
          for (i = 0; i < t.length; i++) {
            var o = (d = t[i]).inputs;
            for (var s in o) {
              for (var u = o[s], l = !1, c = 0; c < e.length; c++)
                if (r[u.id]) {
                  d.outputs.forEach(function (t) {
                    return r[t.id] = !0
                  }), l = !0, a[d.id] = !0;
                  break
                } if (l) break
            }
          }
          var p = {};
          p[n.id] = !0;
          var h = {};
          for (i = t.length - 1; i >= 0; i--)
            for (o = (d = t[i]).inputs, c = 0; c < d.outputs.length; c++)
              if (p[d.outputs[c].id]) {
                for (var s in o) p[o[s].id] = !0, h[d.id] = !0;
                break
              } var f = [];
          for (i = 0; i < t.length; i++) {
            var d;
            if (a[(d = t[i]).id] && h[d.id]) {
              var m = {};
              for (var s in d.inputs) {
                var g = d.inputs[s];
                r[g.id] && (m[s] = g)
              }
              var v = Object.assign({}, d);
              v.inputs = m, v.outputs = d.outputs, f.push(v)
            }
          }
          return f
        }(this.state.activeTape, e, i);
        if (!r && 0 === o.length && e.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        return this.tidy("backward", function () {
          var t, r, s = {};
          s[i.id] = null == n ? (r = Y(N(t = i.shape), "float32"), Dt.makeTensor(r, t, "float32")) : n,
            function (t, e, n) {
              for (var r = function (r) {
                  var a = e[r],
                    i = [];
                  if (a.outputs.forEach(function (e) {
                      var n = t[e.id];
                      null != n ? i.push(n) : i.push(null)
                    }), null == a.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + a.kernelName + ".");
                  var o = a.gradient(i),
                    s = function (e) {
                      if (!(e in o)) throw new Error("Cannot backprop through input " + e + ". Available gradients found: " + Object.keys(o) + ".");
                      var r = n(function () {
                        return o[e]()
                      });
                      if ("float32" !== r.dtype) throw new Error("Error in gradient for op " + a.kernelName + ". The gradient of input " + e + " must have 'float32' dtype, but has '" + r.dtype + "'");
                      var i = a.inputs[e];
                      if (!S(r.shape, i.shape)) throw new Error("Error in gradient for op " + a.kernelName + ". The gradient of input '" + e + "' has shape '" + r.shape + "', which does not match the shape of the input '" + i.shape + "'");
                      if (null == t[i.id]) t[i.id] = r;
                      else {
                        var s = t[i.id];
                        t[i.id] = s.add(r), s.dispose()
                      }
                    };
                  for (var u in a.inputs) s(u)
                }, a = e.length - 1; a >= 0; a--) r(a)
            }(s, o, function (t) {
              return a.tidy(t)
            });
          var u = e.map(function (t) {
            return s[t.id]
          });
          return 0 === a.state.gradientDepth && (a.state.activeTape.forEach(function (t) {
            for (var e = 0, n = t.saved; e < n.length; e++) n[e].dispose()
          }), a.state.activeTape = null), {
            value: i,
            grads: u
          }
        })
      }, t.prototype.customGrad = function (t) {
        var e = this;
        return b(q(t), function () {
            return "The f passed in customGrad(f) must be a function."
          }),
          function () {
            for (var n, r = [], a = 0; a < arguments.length; a++) r[a] = arguments[a];
            b(r.every(function (t) {
              return t instanceof mt
            }), function () {
              return "The args passed in customGrad(f)(x1, x2,...) must all be tensors"
            });
            var i = {};
            return r.forEach(function (t, e) {
              i[e] = t
            }), e.runKernelFunc(function (e, a) {
              return b((n = t.apply(void 0, r.concat([a]))).value instanceof mt, function () {
                return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"
              }), b(q(n.gradFunc), function () {
                return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."
              }), n.value
            }, i, function (t, e) {
              var a = n.gradFunc(t, e),
                i = Array.isArray(a) ? a : [a];
              b(i.length === r.length, function () {
                return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."
              }), b(i.every(function (t) {
                return t instanceof mt
              }), function () {
                return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."
              });
              var o = {};
              return i.forEach(function (t, e) {
                o[e] = function () {
                  return t
                }
              }), o
            })
          }
      }, t.prototype.readSync = function (t) {
        return this.state.tensorInfo.get(t).backend.readSync(t)
      }, t.prototype.read = function (t) {
        return this.state.tensorInfo.get(t).backend.read(t)
      }, t.prototype.time = function (t) {
        return r(this, void 0, void 0, function () {
          var e, n;
          return a(this, function (r) {
            switch (r.label) {
              case 0:
                return e = Z(), [4, this.backend.time(t)];
              case 1:
                return (n = r.sent()).wallMs = Z() - e, [2, n]
            }
          })
        })
      }, t.prototype.track = function (t) {
        return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t
      }, Object.defineProperty(t.prototype, "registeredVariables", {
        get: function () {
          return this.state.registeredVariables
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.reset = function () {
        for (var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Rt, this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];
        this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null
      }, t.nextTensorId = 0, t.nextVariableId = 0, t
    }(),
    Dt = function () {
      var e = function () {
        if (null == Et) {
          var t = void 0;
          if ("undefined" != typeof window) t = window;
          else if ("undefined" != typeof global) t = global;
          else if ("undefined" != typeof process) t = process;
          else {
            if ("undefined" == typeof self) throw new Error("Could not find a global object");
            t = self
          }
          Et = t
        }
        return Et
      }();
      if (null == e._tfengine) {
        var n = new i(e);
        e._tfengine = new Tt(n)
      }
      return function (e) {
        t.ENV = e
      }(e._tfengine.ENV), ht = function () {
        return e._tfengine
      }, e._tfengine
    }();

  function Ot() {
    return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope
  }
  var _t = o();
  _t.registerFlag("DEBUG", function () {
    return !1
  }, function (t) {
    t && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")
  }), _t.registerFlag("IS_BROWSER", function () {
    return Ot()
  }), _t.registerFlag("IS_NODE", function () {
    return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node
  }), _t.registerFlag("IS_CHROME", function () {
    return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)
  }), _t.registerFlag("PROD", function () {
    return !1
  }), _t.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function () {
    return _t.getBool("DEBUG")
  }), _t.registerFlag("DEPRECATION_WARNINGS_ENABLED", function () {
    return !0
  }), _t.registerFlag("IS_TEST", function () {
    return !1
  });
  var Ft, Mt, zt, Lt = {},
    Bt = {
      alpha: !1,
      antialias: !1,
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !1,
      depth: !1,
      stencil: !1,
      failIfMajorPerformanceCaveat: !0
    };

  function Pt(t, e) {
    Lt[t] = e
  }

  function Wt(t) {
    t in Lt || (Lt[t] = function (t) {
      if (1 !== t && 2 !== t) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
      var e = function (t) {
        if ("undefined" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);
        if ("undefined" != typeof document) return document.createElement("canvas");
        throw new Error("Cannot create a canvas in this context")
      }(t);
      return e.addEventListener("webglcontextlost", function (e) {
        e.preventDefault(), delete Lt[t]
      }, !1), 1 === t ? e.getContext("webgl", Bt) || e.getContext("experimental-webgl", Bt) : e.getContext("webgl2", Bt)
    }(t));
    var e = Lt[t];
    return e.isContextLost() ? (delete Lt[t], Wt(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), Lt[t])
  }

  function Vt(t, e) {
    return [e, t]
  }

  function Ut(t) {
    var e = N(t);
    return E(Math.ceil(e / 4))
  }

  function jt(t, e) {
    return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))]
  }

  function Gt(t, e) {
    var n, r, a, i, s, u, l, c, p, h = t;
    return 2 === o().getNumber("WEBGL_VERSION") ? (n = h.R32F, r = h.R16F, a = h.RGBA16F, i = h.RGBA32F, s = h.RED, u = 4, l = 1, c = h.HALF_FLOAT, p = h.FLOAT) : (n = t.RGBA, r = t.RGBA, a = t.RGBA, i = h.RGBA, s = t.RGBA, u = 4, l = 4, c = null != e ? e.HALF_FLOAT_OES : null, p = t.FLOAT), {
      internalFormatFloat: n,
      internalFormatHalfFloat: r,
      internalFormatPackedHalfFloat: a,
      internalFormatPackedFloat: i,
      textureFormatFloat: s,
      downloadTextureFormat: t.RGBA,
      downloadUnpackNumChannels: u,
      defaultNumChannels: l,
      textureTypeHalfFloat: c,
      textureTypeFloat: p
    }
  }

  function qt(t, e, n) {
    var r = n();
    return e && function (t) {
      var e = t.getError();
      if (e !== t.NO_ERROR) throw new Error("WebGL Error: " + $t(t, e))
    }(t), r
  }! function (t) {
    t[t.DENSE = 0] = "DENSE", t[t.SHARED_BATCH = 1] = "SHARED_BATCH"
  }(Ft || (Ft = {})),
  function (t) {
    t[t.RENDER = 0] = "RENDER", t[t.UPLOAD = 1] = "UPLOAD", t[t.PIXELS = 2] = "PIXELS", t[t.DOWNLOAD = 3] = "DOWNLOAD"
  }(Mt || (Mt = {})),
  function (t) {
    t[t.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t[t.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t[t.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t[t.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16"
  }(zt || (zt = {}));
  var Ht = 5.96e-8,
    Kt = 65504;

  function Xt(t) {
    return !!(o().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t || Ht < Math.abs(t) && Math.abs(t) < Kt)
  }

  function $t(t, e) {
    switch (e) {
      case t.NO_ERROR:
        return "NO_ERROR";
      case t.INVALID_ENUM:
        return "INVALID_ENUM";
      case t.INVALID_VALUE:
        return "INVALID_VALUE";
      case t.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case t.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case t.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case t.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return "Unknown error code " + e
    }
  }

  function Yt(t, e, n) {
    return be(t, e, function () {
      return t.getExtension(n)
    }, 'Extension "' + n + '" not supported on this browser.')
  }

  function Jt(t, e, n) {
    var r = be(t, e, function () {
      return t.createShader(t.VERTEX_SHADER)
    }, "Unable to create vertex WebGLShader.");
    if (qt(t, e, function () {
        return t.shaderSource(r, n)
      }), qt(t, e, function () {
        return t.compileShader(r)
      }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
    return r
  }

  function Zt(t, e, n) {
    var r = be(t, e, function () {
      return t.createShader(t.FRAGMENT_SHADER)
    }, "Unable to create fragment WebGLShader.");
    if (qt(t, e, function () {
        return t.shaderSource(r, n)
      }), qt(t, e, function () {
        return t.compileShader(r)
      }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function (t, e) {
      var n = ee.exec(e);
      if (null == n) return console.log("Couldn't parse line number in error: " + e), void console.log(t);
      for (var r = +n[1], a = t.split("\n"), i = a.length.toString().length + 2, o = a.map(function (t, e) {
          return A((e + 1).toString(), i) + t
        }), s = 0, u = 0; u < o.length; u++) s = Math.max(o[u].length, s);
      var l = o.slice(0, r - 1),
        c = o.slice(r - 1, r),
        p = o.slice(r);
      console.log(l.join("\n")), console.log(e.split("\n")[0]), console.log("%c " + A(c[0], s), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(p.join("\n"))
    }(n, t.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
    return r
  }
  var Qt, te, ee = /ERROR: [0-9]+:([0-9]+):/g;

  function ne(t, e) {
    return be(t, e, function () {
      return t.createProgram()
    }, "Unable to create WebGLProgram.")
  }

  function re(t, e, n) {
    if (qt(t, e, function () {
        return t.linkProgram(n)
      }), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Failed to link vertex and fragment shaders.")
  }

  function ae(t, e, n) {
    if (qt(t, e, function () {
        return t.validateProgram(n)
      }), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error("Shader program validation failed.")
  }

  function ie(t, e, n) {
    var r = be(t, e, function () {
      return t.createBuffer()
    }, "Unable to create WebGLBuffer");
    return qt(t, e, function () {
      return t.bindBuffer(t.ARRAY_BUFFER, r)
    }), qt(t, e, function () {
      return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW)
    }), r
  }

  function oe(t, e, n) {
    var r = be(t, e, function () {
      return t.createBuffer()
    }, "Unable to create WebGLBuffer");
    return qt(t, e, function () {
      return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r)
    }), qt(t, e, function () {
      return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW)
    }), r
  }

  function se(t, e) {
    return be(t, e, function () {
      return t.createTexture()
    }, "Unable to create WebGLTexture.")
  }

  function ue(t, e) {
    var n = o().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (t <= 0 || e <= 0) {
      var r = "[" + t + "x" + e + "]";
      throw new Error("Requested texture size " + r + " is invalid.")
    }
    if (t > n || e > n) throw r = "[" + t + "x" + e + "]", new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU [" + n + "x" + n + "].")
  }

  function le(t, e) {
    return be(t, e, function () {
      return t.createFramebuffer()
    }, "Unable to create WebGLFramebuffer.")
  }

  function ce(t, e, n, r, a, i, o, s) {
    var u = t.getAttribLocation(n, r);
    return -1 !== u && (qt(t, e, function () {
      return t.bindBuffer(t.ARRAY_BUFFER, a)
    }), qt(t, e, function () {
      return t.vertexAttribPointer(u, i, t.FLOAT, !1, o, s)
    }), qt(t, e, function () {
      return t.enableVertexAttribArray(u)
    }), !0)
  }

  function pe(t, e, n, r) {
    xe(t, r), qt(t, e, function () {
      return t.activeTexture(t.TEXTURE0 + r)
    }), qt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, n)
    })
  }

  function he(t, e, n, r) {
    return be(t, e, function () {
      return t.getUniformLocation(n, r)
    }, 'uniform "' + r + '" not present in program.')
  }

  function fe(t, e, n) {
    return t.getUniformLocation(e, n)
  }

  function de(t, e, n, r, a, i) {
    qt(t, e, function () {
      return pe(t, e, r, i)
    }), qt(t, e, function () {
      return t.uniform1i(a, i)
    })
  }

  function me(t, e, n, r) {
    qt(t, e, function () {
      return t.bindFramebuffer(t.FRAMEBUFFER, r)
    }), qt(t, e, function () {
      return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0)
    })
  }

  function ge(t, e, n) {
    qt(t, e, function () {
      return t.bindFramebuffer(t.FRAMEBUFFER, n)
    }), qt(t, e, function () {
      return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)
    })
  }

  function ve(t) {
    var e = t.checkFramebufferStatus(t.FRAMEBUFFER);
    if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + ye(t, e))
  }

  function ye(t, e) {
    switch (e) {
      case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case t.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return "unknown error " + e
    }
  }

  function be(t, e, n, r) {
    var a = qt(t, e, function () {
      return n()
    });
    if (null == a) throw new Error(r);
    return a
  }

  function xe(t, e) {
    var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
      r = e + t.TEXTURE0;
    if (r < t.TEXTURE0 || r > n) throw new Error("textureUnit must be in [gl.TEXTURE0, gl.TEXTURE" + n + "].")
  }

  function we(t, e) {
    return void 0 === e && (e = 2), N(t.slice(0, t.length - e))
  }

  function Ce(t) {
    if (0 === t.length) throw Error("Cannot get rows and columns of an empty shape array.");
    return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]]
  }

  function Ne(t) {
    var e = [1, 1, 1];
    return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [we(t)].concat(Ce(t))), e
  }

  function Se(t, e) {
    var n;
    void 0 === e && (e = !1);
    var r = o().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e && (r *= 2, 1 === (t = t.map(function (e, n) {
        return n >= t.length - 2 ? v(t[n]) : t[n]
      })).length && (t = [2, t[0]])), 2 !== t.length) {
      var a = O(t);
      t = a.newShape
    }
    var i = N(t);
    if (t.length <= 1 && i <= r) return [1, i];
    if (2 === t.length && t[0] <= r && t[1] <= r) return t;
    if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [t[0] * t[1], t[2]];
    if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [t[0], t[1] * t[2]];
    if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [t[0] * t[1] * t[2], t[3]];
    if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [t[0], t[1] * t[2] * t[3]];
    if (e) {
      var s = we(t),
        u = 2,
        l = 2;
      return t.length && (u = (n = Ce(t))[0], l = n[1]), E(i = s * (u / 2) * (l / 2)).map(function (t) {
        return 2 * t
      })
    }
    return E(i)
  }

  function ke(t) {
    return t % 2 == 0
  }

  function Ie(t, e) {
    if (S(t = t.slice(-2), e = e.slice(-2))) return !0;
    if (!t.length || !e.length) return !0;
    if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;
    if (t.length !== e.length) {
      var n = t.slice(-1)[0],
        r = e.slice(-1)[0];
      if (n === r) return !0;
      if (ke(n) && ke(r) && (1 === t[0] || 1 === e[0])) return !0
    }
    return t[1] === e[1] && ke(t[0]) && ke(e[0])
  }

  function Ee(t) {
    if (null == Qt) {
      var e = Wt(t);
      Qt = e.getParameter(e.MAX_TEXTURE_SIZE)
    }
    return Qt
  }

  function Ae(t) {
    if (null == te) {
      var e = Wt(t);
      te = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
    }
    return Math.min(16, te)
  }

  function Re(t) {
    if (0 === t) return 0;
    var e = Wt(t);
    return Te(e, "EXT_disjoint_timer_query_webgl2") && 2 === t ? 2 : Te(e, "EXT_disjoint_timer_query") ? 1 : 0
  }

  function Te(t, e) {
    return null != t.getExtension(e)
  }

  function De(t) {
    try {
      if (null != Wt(t)) return !0
    } catch (t) {
      return !1
    }
    return !1
  }

  function Oe(t) {
    if (0 === t) return !1;
    var e = Wt(t);
    if (1 === t) {
      if (!Te(e, "OES_texture_float")) return !1
    } else if (!Te(e, "EXT_color_buffer_float")) return !1;
    return Fe(e)
  }

  function _e(t) {
    if (0 === t) return !1;
    var e = Wt(t);
    return 1 !== t ? Te(e, "EXT_color_buffer_float") ? Fe(e) : !!Te(e, "EXT_color_buffer_half_float") && function (t, e) {
      var n = Gt(t, e),
        r = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
      var a = t.createFramebuffer();
      t.bindFramebuffer(t.FRAMEBUFFER, a), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);
      var i = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
      return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(a), i
    }(e, e.getExtension("EXT_color_buffer_half_float")) : !!Te(e, "OES_texture_float") && !!Te(e, "WEBGL_color_buffer_float") && Fe(e)
  }

  function Fe(t) {
    var e = Gt(t),
      n = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);
    var r = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
    var a = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;
    return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), a
  }

  function Me(t) {
    return 2 === t && null != Wt(t).fenceSync
  }
  var ze = Object.freeze({
      callAndCheck: qt,
      canBeRepresented: Xt,
      getWebGLErrorMessage: $t,
      getExtensionOrThrow: Yt,
      createVertexShader: Jt,
      createFragmentShader: Zt,
      createProgram: ne,
      linkProgram: re,
      validateProgram: ae,
      createStaticVertexBuffer: ie,
      createStaticIndexBuffer: oe,
      getNumChannels: function () {
        return 2 === o().getNumber("WEBGL_VERSION") ? 1 : 4
      },
      createTexture: se,
      validateTextureSize: ue,
      createFramebuffer: le,
      bindVertexBufferToProgramAttribute: ce,
      bindTextureUnit: pe,
      unbindTextureUnit: function (t, e, n) {
        xe(t, n), qt(t, e, function () {
          return t.activeTexture(t.TEXTURE0 + n)
        }), qt(t, e, function () {
          return t.bindTexture(t.TEXTURE_2D, null)
        })
      },
      getProgramUniformLocationOrThrow: he,
      getProgramUniformLocation: fe,
      bindTextureToProgramUniformSampler: de,
      bindCanvasToFramebuffer: function (t, e) {
        qt(t, e, function () {
          return t.bindFramebuffer(t.FRAMEBUFFER, null)
        }), qt(t, e, function () {
          return t.viewport(0, 0, t.canvas.width, t.canvas.height)
        }), qt(t, e, function () {
          return t.scissor(0, 0, t.canvas.width, t.canvas.height)
        })
      },
      bindColorTextureToFramebuffer: me,
      unbindColorTextureFromFramebuffer: ge,
      validateFramebuffer: ve,
      getFramebufferErrorMessage: ye,
      getBatchDim: we,
      getRowsCols: Ce,
      getShapeAs3D: Ne,
      getTextureShapeFromLogicalShape: Se,
      isReshapeFree: Ie,
      getWebGLMaxTextureSize: Ee,
      resetMaxTextureSize: function () {
        Qt = null
      },
      resetMaxTexturesInShader: function () {
        te = null
      },
      getMaxTexturesInShader: Ae,
      getWebGLDisjointQueryTimerVersion: Re,
      hasExtension: Te,
      isWebGLVersionEnabled: De,
      isCapableOfRenderingToFloatTexture: Oe,
      isDownloadFloatTextureEnabled: _e,
      isWebGLFenceEnabled: Me
    }),
    Le = o();

  function Be(t) {
    o().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t + " You can disable deprecation warnings with tf.disableDeprecationWarnings().")
  }

  function Pe() {
    return Dt.memory()
  }

  function We(t, e) {
    return Dt.tidy(t, e)
  }

  function Ve(t) {
    It(t).forEach(function (t) {
      return t.dispose()
    })
  }

  function Ue(t) {
    return Dt.keep(t)
  }

  function je() {
    return Dt.backend
  }

  function Ge() {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
    o().getBool("IS_TEST") || console.warn.apply(console, t)
  }

  function qe(t, e) {
    var n = t;
    if (B(t)) return "string" === e ? [] : [t.length];
    if (!Array.isArray(t)) return [];
    for (var r = []; Array.isArray(n) || B(n) && "string" !== e;) r.push(n.length), n = n[0];
    return Array.isArray(t) && o().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t(e, n, r) {
      if (r = r || [], Array.isArray(e) || B(e)) {
        b(n.length > 0, function () {
          return "Element arr[" + r.join("][") + "] should be a primitive, but is an array of " + e.length + " elements"
        }), b(e.length === n[0], function () {
          return "Element arr[" + r.join("][") + "] should have " + n[0] + " elements, but has " + e.length + " elements"
        });
        for (var a = n.slice(1), i = 0; i < e.length; ++i) t(e[i], a, r.concat(i))
      } else b(0 === n.length, function () {
        return "Element arr[" + r.join("][") + "] is a primitive, but should be an array/TypedArray of " + n[0] + " elements"
      })
    }(t, r, []), r
  }

  function He(t, e, n, r) {
    if (null != t && ("numeric" !== t && t !== e || "numeric" === t && "string" === e)) throw new Error("Argument '" + n + "' passed to '" + r + "' must be " + t + " tensor, but got " + e + " tensor")
  }

  function Ke(t, e, n, r) {
    if (void 0 === r && (r = "numeric"), t instanceof mt) return He(r, t.dtype, e, n), t;
    var a = G(t);
    if ("string" !== a && ["bool", "int32", "float32"].indexOf(r) >= 0 && (a = r), He(r, a, e, n), null == t || !B(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) {
      var i = null == t ? "null" : t.constructor.name;
      throw new Error("Argument '" + e + "' passed to '" + n + "' must be a Tensor or TensorLike, but got '" + i + "'")
    }
    var s = qe(t, a);
    B(t) || Array.isArray(t) || (t = [t]);
    var u = "string" !== a ? X(t, a, o().getBool("DEBUG")) : C(t, [], !0);
    return Dt.makeTensor(u, s, a)
  }

  function Xe(t, e, n, r) {
    if (void 0 === r && (r = "numeric"), !Array.isArray(t)) throw new Error("Argument " + e + " passed to " + n + " must be a `Tensor[]` or `TensorLike[]`");
    return t.map(function (t, r) {
      return Ke(t, e + "[" + r + "]", n)
    }, r)
  }

  function $e(t, e) {
    for (var n = 0; n < t.length; ++n)
      if (t[t.length - n - 1] !== e - 1 - n) return !1;
    return !0
  }

  function Ye(t, e, n) {
    for (var r = t.length + e.length, a = [], i = 0, o = 0, s = 0; s < r; s++) - 1 === n.indexOf(s) ? a.push(t[i++]) : a.push(e[o++]);
    return a
  }

  function Je(t, e) {
    for (var n = [], r = t.length, a = 0; a < r; a++) - 1 === e.indexOf(a) && n.push(t[a]);
    return [n, e.map(function (e) {
      return t[e]
    })]
  }

  function Ze(t, e) {
    return Ye(t, e.map(function (t) {
      return 1
    }), e)
  }

  function Qe(t, e, n) {
    b($e(e, n), function () {
      return t + " supports only inner-most axes for now. Got axes " + e + " and rank-" + n + " input."
    })
  }

  function tn(t, e) {
    if ($e(t, e)) return null;
    for (var n = [], r = 0; r < e; ++r) - 1 === t.indexOf(r) && n.push(r);
    return t.forEach(function (t) {
      return n.push(t)
    }), n
  }

  function en(t) {
    return t.map(function (t, e) {
      return [e, t]
    }).sort(function (t, e) {
      return t[1] - e[1]
    }).map(function (t) {
      return t[0]
    })
  }

  function nn(t, e) {
    for (var n = [], r = e - t; r < e; ++r) n.push(r);
    return n
  }

  function rn(t, e) {
    var n = t[0].length;
    t.forEach(function (t, e) {
      b(t.length === n, function () {
        return "Error in concat" + n + "D: rank of tensors[" + e + "] must be the same as the rank of the rest (" + n + ")"
      })
    }), b(e >= 0 && e < n, function () {
      return "Error in concat" + n + "D: axis must be between 0 and " + (n - 1) + "."
    });
    var r = t[0];
    t.forEach(function (t, a) {
      for (var i = 0; i < n; i++) b(i === e || t[i] === r[i], function () {
        return "Error in concat" + n + "D: Shape of tensors[" + a + "] (" + t + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + a + "."
      })
    })
  }

  function an(t, e) {
    for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e];
    return n
  }

  function on(t) {
    var e = Object.keys(t);
    if (1 !== e.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e.length + " keys.");
    var n = e[0],
      r = t[n];
    n.endsWith("_") && (n = n.substring(0, n.length - 1));
    var a = function () {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      Dt.startScope(n);
      try {
        var a = r.apply(void 0, t);
        return a instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Dt.endScope(a), a
      } catch (t) {
        throw Dt.endScope(null), t
      }
    };
    return Object.defineProperty(a, "name", {
      value: n,
      configurable: !0
    }), a
  }
  Le.registerFlag("HAS_WEBGL", function () {
    return Le.getNumber("WEBGL_VERSION") > 0
  }), Le.registerFlag("WEBGL_VERSION", function () {
    return De(2) ? 2 : De(1) ? 1 : 0
  }), Le.registerFlag("WEBGL_BUFFER_SUPPORTED", function () {
    return 2 === Le.get("WEBGL_VERSION")
  }), Le.registerFlag("WEBGL_CPU_FORWARD", function () {
    return !0
  }), Le.registerFlag("WEBGL_FORCE_F16_TEXTURES", function () {
    return !1
  }), Le.registerFlag("WEBGL_PACK", function () {
    return Le.getBool("HAS_WEBGL")
  }), Le.registerFlag("WEBGL_PACK_NORMALIZATION", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_PACK_CLIP", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_PACK_DEPTHWISECONV", function () {
    return !1
  }), Le.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_PACK_REDUCE", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_LAZILY_UNPACK", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_CONV_IM2COL", function () {
    return Le.getBool("WEBGL_PACK")
  }), Le.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function () {
    return Ee(Le.getNumber("WEBGL_VERSION"))
  }), Le.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function () {
    return Ae(Le.getNumber("WEBGL_VERSION"))
  }), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function () {
    var t = Le.getNumber("WEBGL_VERSION");
    return 0 === t ? 0 : Re(t)
  }), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function () {
    return Le.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))));
    var t
  }), Le.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function () {
    return Oe(Le.getNumber("WEBGL_VERSION"))
  }), Le.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function () {
    return !Le.getBool("WEBGL_FORCE_F16_TEXTURES") && Le.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")
  }), Le.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function () {
    return _e(Le.getNumber("WEBGL_VERSION"))
  }), Le.registerFlag("WEBGL_FENCE_API_ENABLED", function () {
    return Me(Le.getNumber("WEBGL_VERSION"))
  }), Le.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function () {
    return Le.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0
  }), dt = Be;
  var sn = on({
      complex_: function (t, e) {
        var n = Ke(t, "real", "complex"),
          r = Ke(e, "imag", "complex");
        return x(n.shape, r.shape, "real and imag shapes, " + n.shape + " and " + r.shape + ", must match in call to tf.complex()."), Dt.runKernelFunc(function (t) {
          return t.complex(n, r)
        }, {
          $real: n,
          $imag: r
        })
      }
    }),
    un = on({
      real_: function (t) {
        var e = Ke(t, "input", "real");
        return Dt.runKernelFunc(function (t) {
          return t.real(e)
        }, {
          $input: e
        })
      }
    }),
    ln = on({
      imag_: function (t) {
        var e = Ke(t, "input", "imag");
        return Dt.runKernelFunc(function (t) {
          return t.imag(e)
        }, {
          $input: e
        })
      }
    });

  function cn(t, e, n) {
    return pn(t, e, qe(t, n), n)
  }

  function pn(t, e, n, r) {
    if (null == r && (r = G(t)), "complex64" === r) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (!B(t) && !Array.isArray(t) && "number" != typeof t && "boolean" != typeof t && "string" != typeof t) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (null != e) {
      Q(e);
      var a = N(e),
        i = N(n);
      b(a === i, function () {
        return "Based on the provided shape, [" + e + "], the tensor should have " + a + " values but has " + i
      });
      for (var s = 0; s < n.length; ++s) {
        var u = n[s],
          l = s !== n.length - 1 || u !== N(e.slice(s));
        b(n[s] === e[s] || !l, function () {
          return "Error creating a new Tensor. Inferred shape (" + n + ") does not match the provided shape (" + e + "). "
        })
      }
    }
    return B(t) || Array.isArray(t) || (t = [t]), e = e || n, t = "string" !== r ? X(t, r, o().getBool("DEBUG")) : C(t, [], !0), Dt.makeTensor(t, e, r)
  }

  function hn(t, e) {
    if ((B(t) && "string" !== e || Array.isArray(t)) && "complex64" !== e) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if ("string" === e && B(t) && !(t instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return pn(t, [], [], e)
  }

  function fn(t, e) {
    w(t);
    var n = qe(t, e);
    if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return pn(t, null, n, e)
  }

  function dn(t, e, n) {
    if (w(t), null != e && 2 !== e.length) throw new Error("tensor2d() requires shape to have two numbers");
    var r = qe(t, n);
    if (2 !== r.length && 1 !== r.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (1 === r.length && null == e) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return pn(t, e, r, n)
  }

  function mn(t, e, n) {
    if (w(t), null != e && 3 !== e.length) throw new Error("tensor3d() requires shape to have three numbers");
    var r = qe(t, n);
    if (3 !== r.length && 1 !== r.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    if (1 === r.length && null == e) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    return pn(t, e, r, n)
  }

  function gn(t, e, n) {
    if (w(t), null != e && 4 !== e.length) throw new Error("tensor4d() requires shape to have four numbers");
    var r = qe(t, n);
    if (4 !== r.length && 1 !== r.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    if (1 === r.length && null == e) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    return pn(t, e, r, n)
  }

  function vn(t, e, n) {
    if (w(t), null != e && 5 !== e.length) throw new Error("tensor5d() requires shape to have five numbers");
    var r = qe(t, n);
    if (5 !== r.length && 1 !== r.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    if (1 === r.length && null == e) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    return pn(t, e, r, n)
  }

  function yn(t, e, n) {
    if (w(t), null != e && 6 !== e.length) throw new Error("tensor6d() requires shape to have six numbers");
    var r = qe(t, n);
    if (6 !== r.length && 1 !== r.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    if (1 === r.length && null == e) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    return pn(t, e = e || r, r, n)
  }

  function bn(t, e, n, r) {
    return void 0 === e && (e = !0), Dt.makeVariable(t, e, n, r)
  }

  function xn(t, e) {
    if (void 0 === e && (e = "float32"), "complex64" === e) {
      var n = xn(t, "float32"),
        r = wn(t, "float32");
      return sn(n, r)
    }
    var a = Y(N(t), e);
    return Dt.makeTensor(a, t, e)
  }

  function wn(t, e) {
    if (void 0 === e && (e = "float32"), "complex64" === e) {
      var n = wn(t, "float32"),
        r = wn(t, "float32");
      return sn(n, r)
    }
    var a = J(N(t), e);
    return Dt.makeTensor(a, t, e)
  }

  function Cn(t, e, n) {
    return Dt.runKernelFunc(function (r) {
      return r.fill(t, e, n)
    }, {})
  }

  function Nn(t, e, n) {
    if (n <= 0) throw new Error("The number of values should be positive.");
    return Dt.runKernelFunc(function (r) {
      return r.linspace(t, e, n)
    }, {})
  }

  function Sn(t, e, n, r) {
    if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), 0 === n) throw new Error("Cannot have a step of zero");
    if (t === e || t < e && n < 0 || e < t && n > 1) return wn([0], r);
    var a = J(Math.abs(Math.ceil((e - t) / n)), r);
    e < t && 1 === n && (n = -1), a[0] = t;
    for (var i = 1; i < a.length; i++) a[i] = a[i - 1] + n;
    return fn(a, r)
  }
  var kn = on({
      onesLike_: function (t) {
        var e = Ke(t, "x", "onesLike");
        if ("complex64" === e.dtype) {
          var n = kn(un(e)),
            r = In(ln(e));
          return sn(n, r)
        }
        return Dt.runKernelFunc(function (t) {
          return t.onesLike(e)
        }, {
          $x: e
        }, function (t, e) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    In = on({
      zerosLike_: function (t) {
        var e = Ke(t, "x", "zerosLike");
        return Dt.runKernelFunc(function (t) {
          return t.zerosLike(e)
        }, {
          $x: e
        }, function (t, e) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    En = on({
      concat_: function (t, e) {
        void 0 === e && (e = 0), b(t.length >= 1, function () {
          return "Pass at least one tensor to concat"
        });
        var n = Xe(t, "tensors", "concat");
        "complex64" === n[0].dtype && n.forEach(function (t) {
          if ("complex64" !== t.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t.dtype + ". ")
        }), e = D(e, n[0].shape)[0];
        var r = an(n.map(function (t) {
          return t.shape
        }), e);
        if (0 === N(r)) return cn([], r);
        if (1 === (n = n.filter(function (t) {
            return t.size > 0
          })).length) return n[0];
        var a = n.map(function (t) {
          return t.shape
        });
        rn(a, e);
        var i = n,
          o = {
            axis: e
          };
        return Dt.runKernelFunc(function (t) {
          return t.concat(n, e)
        }, i, function (t) {
          var n = a.map(function (t) {
            return t[e]
          });
          return On(t, n, e).map(function (t) {
            return function () {
              return t
            }
          })
        }, "Concat", o)
      }
    }),
    An = on({
      concat1d_: function (t) {
        return En(t, 0)
      }
    }),
    Rn = on({
      concat2d_: function (t, e) {
        return En(t, e)
      }
    }),
    Tn = on({
      concat3d_: function (t, e) {
        return En(t, e)
      }
    }),
    Dn = on({
      concat4d_: function (t, e) {
        return En(t, e)
      }
    }),
    On = on({
      split_: function (t, e, n) {
        void 0 === n && (n = 0);
        var r, a = Ke(t, "x", "split");
        return n = D(n, a.shape)[0], "number" == typeof e ? (b(a.shape[n] % e == 0, function () {
          return "Number of splits must evenly divide the axis."
        }), r = new Array(e).fill(a.shape[n] / e)) : (b(a.shape[n] === e.reduce(function (t, e) {
          return t + e
        }), function () {
          return "The sum of sizes must match the size of the axis dimension."
        }), r = e), Dt.runKernelFunc(function (t) {
          return t.split(a, r, n)
        }, {
          $x: a
        }, function (t) {
          return {
            $x: function () {
              return En(t, n)
            }
          }
        })
      }
    });

  function _n(t, e) {
    return t(e = {
      exports: {}
    }, e.exports), e.exports
  }
  var Fn = _n(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e
        }

        function a(t, e) {
          var n = new function (t) {
              var e, n = this,
                r = (e = 4022871197, function (t) {
                  t = t.toString();
                  for (var n = 0; n < t.length; n++) {
                    var r = .02519603282416938 * (e += t.charCodeAt(n));
                    r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e)
                  }
                  return 2.3283064365386963e-10 * (e >>> 0)
                });
              n.next = function () {
                var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
                return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t)
              }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null
            }(t),
            a = e && e.state,
            i = n.next;
          return i.int32 = function () {
            return 4294967296 * n.next() | 0
          }, i.double = function () {
            return i() + 1.1102230246251565e-16 * (2097152 * i() | 0)
          }, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.alea = a
      }(0, t)
    }),
    Mn = _n(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e
        }

        function a(t, e) {
          var n = new function (t) {
              var e = this,
                n = "";
              e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
                var t = e.x ^ e.x << 11;
                return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8
              }, t === (0 | t) ? e.x = t : n += t;
              for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next()
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.xor128 = a
      }(0, t)
    }),
    zn = _n(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e
        }

        function a(t, e) {
          var n = new function (t) {
              var e = this,
                n = "";
              e.next = function () {
                var t = e.x ^ e.x >>> 2;
                return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0
              }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;
              for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next()
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.xorwow = a
      }(0, t)
    }),
    Ln = _n(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.x = t.x.slice(), e.i = t.i, e
        }

        function a(t, e) {
          null == t && (t = +new Date);
          var n = new function (t) {
              var e = this;
              e.next = function () {
                  var t, n, r = e.x,
                    a = e.i;
                  return t = r[a], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[a + 1 & 7]) ^ t >>> 10, n ^= (t = r[a + 3 & 7]) ^ t >>> 3, n ^= (t = r[a + 4 & 7]) ^ t << 7, t = r[a + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[a] = n, e.i = a + 1 & 7, n
                },
                function (t, e) {
                  var n, r = [];
                  if (e === (0 | e)) r[0] = e;
                  else
                    for (e = "" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;
                  for (; r.length < 8;) r.push(0);
                  for (n = 0; n < 8 && 0 === r[n]; ++n);
                  for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next()
                }(e, t)
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && (a.x && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.xorshift7 = a
      }(0, t)
    }),
    Bn = _n(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e
        }

        function a(t, e) {
          null == t && (t = +new Date);
          var n = new function (t) {
              var e = this;
              e.next = function () {
                  var t, n, r = e.w,
                    a = e.X,
                    i = e.i;
                  return e.w = r = r + 1640531527 | 0, n = a[i + 34 & 127], t = a[i = i + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = a[i] = n ^ t, e.i = i, n + (r ^ r >>> 16) | 0
                },
                function (t, e) {
                  var n, r, a, i, o, s = [],
                    u = 128;
                  for (e === (0 | e) ? (r = e, e = null) : (e += "\0", r = 0, u = Math.max(u, e.length)), a = 0, i = -32; i < u; ++i) e && (r ^= e.charCodeAt((i + 32) % e.length)), 0 === i && (o = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, i >= 0 && (o = o + 1640531527 | 0, a = 0 == (n = s[127 & i] ^= r + o) ? a + 1 : 0);
                  for (a >= 128 && (s[127 & (e && e.length || 0)] = -1), a = 127, i = 512; i > 0; --i) r = s[a + 34 & 127], n = s[a = a + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[a] = r ^ n;
                  t.w = o, t.X = s, t.i = a
                }(e, t)
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && (a.X && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.xor4096 = a
      }(0, t)
    }),
    Pn = _n(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e
        }

        function a(t, e) {
          var n = new function (t) {
              var e = this,
                n = "";
              e.next = function () {
                var t = e.b,
                  n = e.c,
                  r = e.d,
                  a = e.a;
                return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ a, a = a - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ a, e.a = a - t | 0
              }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;
              for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next()
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.tychei = a
      }(0, t)
    }),
    Wn = _n(function (t) {
      ! function (e, n) {
        var r, a = this,
          i = 256,
          o = 6,
          s = "random",
          u = n.pow(i, o),
          l = n.pow(2, 52),
          c = 2 * l,
          p = i - 1;

        function h(t, p, h) {
          var v = [],
            y = m(function t(e, n) {
              var r, a = [],
                i = typeof e;
              if (n && "object" == i)
                for (r in e) try {
                  a.push(t(e[r], n - 1))
                } catch (t) {}
              return a.length ? a : "string" == i ? e : e + "\0"
            }((p = 1 == p ? {
              entropy: !0
            } : p || {}).entropy ? [t, g(e)] : null == t ? function () {
              try {
                var t;
                return r && (t = r.randomBytes) ? t = t(i) : (t = new Uint8Array(i), (a.crypto || a.msCrypto).getRandomValues(t)), g(t)
              } catch (t) {
                var n = a.navigator,
                  o = n && n.plugins;
                return [+new Date, a, o, a.screen, g(e)]
              }
            }() : t, 3), v),
            b = new f(v),
            x = function () {
              for (var t = b.g(o), e = u, n = 0; t < l;) t = (t + n) * i, e *= i, n = b.g(1);
              for (; t >= c;) t /= 2, e /= 2, n >>>= 1;
              return (t + n) / e
            };
          return x.int32 = function () {
            return 0 | b.g(4)
          }, x.quick = function () {
            return b.g(4) / 4294967296
          }, x.double = x, m(g(b.S), e), (p.pass || h || function (t, e, r, a) {
            return a && (a.S && d(a, b), t.state = function () {
              return d(b, {})
            }), r ? (n[s] = t, e) : t
          })(x, y, "global" in p ? p.global : this == n, p.state)
        }

        function f(t) {
          var e, n = t.length,
            r = this,
            a = 0,
            o = r.i = r.j = 0,
            s = r.S = [];
          for (n || (t = [n++]); a < i;) s[a] = a++;
          for (a = 0; a < i; a++) s[a] = s[o = p & o + t[a % n] + (e = s[a])], s[o] = e;
          (r.g = function (t) {
            for (var e, n = 0, a = r.i, o = r.j, s = r.S; t--;) e = s[a = p & a + 1], n = n * i + s[p & (s[a] = s[o = p & o + e]) + (s[o] = e)];
            return r.i = a, r.j = o, n
          })(i)
        }

        function d(t, e) {
          return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
        }

        function m(t, e) {
          for (var n, r = t + "", a = 0; a < r.length;) e[p & a] = p & (n ^= 19 * e[p & a]) + r.charCodeAt(a++);
          return g(e)
        }

        function g(t) {
          return String.fromCharCode.apply(0, t)
        }
        if (n["seed" + s] = h, m(n.random(), e), t.exports) {
          t.exports = h;
          try {
            r = require("crypto")
          } catch (t) {}
        }
      }([], Math)
    });
  Wn.alea = Fn, Wn.xor128 = Mn, Wn.xorwow = zn, Wn.xorshift7 = Ln, Wn.xor4096 = Bn, Wn.tychei = Pn;
  var Vn = Wn.alea,
    Un = function () {
      function t(t, e, n, r, a) {
        this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
        var i = a || Math.random();
        this.random = Vn(i.toString())
      }
      return t.prototype.nextValue = function () {
        if (!isNaN(this.nextVal)) {
          var t = this.nextVal;
          return this.nextVal = NaN, t
        }
        for (var e, n, r = !1; !r;) {
          var a = void 0,
            i = void 0,
            o = void 0;
          do {
            o = (a = 2 * this.random() - 1) * a + (i = 2 * this.random() - 1) * i
          } while (o >= 1 || 0 === o);
          var s = Math.sqrt(-2 * Math.log(o) / o);
          e = this.mean + this.stdDev * a * s, n = this.mean + this.stdDev * i * s, this.truncated && !this.isValidTruncated(e) || (r = !0)
        }
        return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e)
      }, t.prototype.convertValue = function (t) {
        return null == this.dtype || "float32" === this.dtype ? t : Math.round(t)
      }, t.prototype.isValidTruncated = function (t) {
        return t <= this.upper && t >= this.lower
      }, t
    }(),
    jn = function () {
      function t(t, e, n, r) {
        this.alpha = t, this.beta = 1 / e, this.dtype = n;
        var a = r || Math.random();
        this.randu = Vn(a.toString()), this.randn = new Un(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d)
      }
      return t.prototype.nextValue = function () {
        for (var t, e, n, r, a, i;;) {
          do {
            r = this.randn.nextValue(), i = 1 + this.c * r
          } while (i <= 0);
          if (i *= i * i, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - i + Math.log(i)), (a = this.randu()) < e || Math.log(a) < n) break
        }
        return i = 1 / this.beta * this.d * i, this.alpha < 1 && (i *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(i)
      }, t.prototype.convertValue = function (t) {
        return "float32" === this.dtype ? t : Math.round(t)
      }, t
    }(),
    Gn = function () {
      function t(t, e, n, r) {
        var a = this;
        if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function () {
            return null == a.dtype || "float32" === a.dtype
          }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), "number" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t + " - " + e + " <= 1 and dtype is not float");
        this.random = Vn(r)
      }
      return t.prototype.convertValue = function (t) {
        return this.canReturnFloat() ? t : Math.round(t)
      }, t.prototype.nextValue = function () {
        return this.convertValue(this.min + this.range * this.random())
      }, t
    }();

  function qn(t, e, n) {
    return void 0 === e && (e = "float32"), e = e || "float32", Q(t), new pt(t, e, n)
  }

  function Hn(t, e) {
    void 0 === e && (e = !1), console.log(t.toString(e))
  }
  var Kn = on({
      batchToSpaceND_: function (t, e, n) {
        var r = Ke(t, "x", "batchToSpaceND"),
          a = e.reduce(function (t, e) {
            return t * e
          });
        return b(r.rank >= 1 + e.length, function () {
          return "input rank is " + r.rank + " but should be > than blockShape.length " + e.length
        }), b(n.length === e.length, function () {
          return "crops.length is " + n.length + " but should be equal to blockShape.length  " + e.length
        }), b(r.shape[0] % a == 0, function () {
          return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + e.join(" * ") + " === " + a
        }), Dt.runKernelFunc(function (t) {
          return t.batchToSpaceND(r, e, n)
        }, {
          $x: r
        }, function (t) {
          return {
            $x: function () {
              return t.spaceToBatchND(e, n)
            }
          }
        })
      }
    }),
    Xn = on({
      broadcastTo_: function (t, e) {
        var n = Ke(t, "broadcastTo", "x"),
          r = n.shape;
        if (e.some(function (t) {
            return !(t > 0) || t % 1 != 0
          })) throw new Error("broadcastTo(): Invalid broadcast shape [" + e + "].");
        if (e.length < n.rank) throw new Error("broadcastTo(): shape.length=" + e.length + " < input.rank=" + n.rank + ".");
        if (e.length > n.rank) {
          for (var a = n.shape.slice(); a.length < e.length;) a.unshift(1);
          n = n.reshape(a)
        }
        for (var i = Array.from(e), o = e.length - 1; o >= 0; o--)
          if (n.shape[o] === e[o]) i[o] = 1;
          else if (1 !== n.shape[o]) throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + e + "].");
        var s = i.map(function (t, e) {
          return t > 1 ? e : -1
        }).filter(function (t) {
          return t >= 0
        });
        return 0 === s.length ? n.clone() : Dt.runKernelFunc(function (t) {
          return t.tile(n, i)
        }, {
          input: n
        }, function (t) {
          return {
            input: function () {
              return t.sum(s, !0)
            }
          }
        })
      }
    }),
    $n = on({
      cast_: function (t, e) {
        var n = Ke(t, "x", "cast");
        if (!z(e)) throw new Error("Failed to cast to unknown dtype " + e);
        if ("string" === e && "string" !== n.dtype || "string" !== e && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
        var r = {
          dtype: e
        };
        return Dt.runKernelFunc(function (t) {
          return t.cast(n, e)
        }, {
          x: n
        }, function (t) {
          return {
            x: function () {
              return t.clone()
            }
          }
        }, "Cast", r)
      }
    }),
    Yn = on({
      clone_: function (t) {
        var e = Ke(t, "x", "clone", null);
        return Dt.runKernelFunc(function () {
          return Dt.makeTensorFromDataId(e.dataId, e.shape, e.dtype)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return t.toFloat()
            }
          }
        })
      }
    }),
    Jn = on({
      cumsum_: function (t, e, n, r) {
        void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);
        var a = Ke(t, "x", "cumsum"),
          i = tn([e |= 0], a.rank),
          o = a;
        null != i && (o = a.transpose(i));
        var s = nn(1, a.rank)[0],
          u = Dt.runKernelFunc(function (t) {
            return t.cumsum(o, s, n, r)
          }, {
            permutedX: o
          }, function (t) {
            return {
              permutedX: function () {
                return t.cumsum(e, n, !r)
              }
            }
          });
        return null != i && (u = u.transpose(i)), u
      }
    }),
    Zn = on({
      depthToSpace_: function (t, e, n) {
        void 0 === n && (n = "NHWC");
        var r = Ke(t, "x", "depthToSpace"),
          a = "NHWC" === n ? r.shape[1] : r.shape[2],
          i = "NHWC" === n ? r.shape[2] : r.shape[3],
          o = "NHWC" === n ? r.shape[3] : r.shape[1];
        return b(a * e >= 0, function () {
          return "Negative dimension size caused by overflow when multiplying\n      " + a + " and " + e + "  for depthToSpace with input shape\n      " + r.shape
        }), b(i * e >= 0, function () {
          return "Negative dimension size caused by overflow when multiplying\n      " + i + " and " + e + " for depthToSpace with input shape\n          " + r.shape
        }), b(o % (e * e) == 0, function () {
          return "Dimension size must be evenly divisible by " + e * e + " but is " + o + " for depthToSpace with input shape " + r.shape
        }), Dt.runKernelFunc(function (t) {
          return t.depthToSpace(r, e, n)
        }, {
          $x: r
        })
      }
    }),
    Qn = on({
      expandDims_: function (t, e) {
        void 0 === e && (e = 0);
        var n = Ke(t, "x", "expandDims", null);
        b(e <= n.rank, function () {
          return "Axis must be <= rank of the tensor"
        });
        var r = n.shape.slice();
        return e < 0 && (b(-(n.rank + 1) <= e, function () {
          return "Axis must be in the interval [" + -(n.rank + 1) + ", " + n.rank + "]"
        }), e = n.rank + e + 1), r.splice(e, 0, 1), hr(n, r)
      }
    }),
    tr = on({
      eye_: function (t, e, n, r) {
        void 0 === r && (r = "float32"), null == e && (e = t);
        for (var a = qn([t, e], r), i = t <= e ? t : e, o = 0; o < i; ++o) a.set(1, o, o);
        var s = a.toTensor().as2D(t, e);
        if (null == n) return s;
        if (1 === n.length) return gr(Qn(s, 0), [n[0], 1, 1]);
        if (2 === n.length) return gr(Qn(Qn(s, 0), 0), [n[0], n[1], 1, 1]);
        if (3 === n.length) return gr(Qn(Qn(Qn(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
        throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n.length + "D.")
      }
    }),
    er = on({
      multinomial_: function (t, e, n, r) {
        void 0 === r && (r = !1);
        var a = Ke(t, "logits", "multinomial"),
          i = a.size,
          o = a.rank;
        if (i < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + i + ".");
        if (o > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + o);
        n = n || Math.random();
        var s = 1 === o ? a.as2D(1, -1) : a,
          u = Dt.runKernelFunc(function (t) {
            return t.multinomial(s, r, e, n)
          }, {
            logits2D: s
          });
        return 1 === o ? u.as1D() : u
      }
    }),
    nr = on({
      oneHot_: function (t, e, n, r) {
        if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e);
        var a = Ke(t, "indices", "oneHot", "int32"),
          i = a.shape.concat([e]);
        return a = a.flatten(), Dt.runKernelFunc(function (t) {
          return t.oneHot(a, e, n, r)
        }, {
          $indices: a
        }, function (t) {
          return {
            $indices: function () {
              return wn(a.shape, "float32")
            }
          }
        }).reshape(i)
      }
    }),
    rr = on({
      pad_: function (t, e, n) {
        void 0 === n && (n = 0);
        var r = Ke(t, "x", "pad");
        if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
        var a = {
          paddings: e,
          constantValue: n
        };
        return Dt.runKernelFunc(function (t) {
          return t.pad(r, e, n)
        }, {
          x: r
        }, function (t) {
          var n = e.map(function (t) {
            return t[0]
          });
          return {
            x: function () {
              return t.slice(n, r.shape)
            }
          }
        }, "PadV2", a)
      }
    }),
    ar = on({
      pad1d_: function (t, e, n) {
        return void 0 === n && (n = 0), b(2 === e.length, function () {
          return "Invalid number of paddings. Must be length of 2."
        }), rr(t, [e], n)
      }
    }),
    ir = on({
      pad2d_: function (t, e, n) {
        return void 0 === n && (n = 0), b(2 === e.length && 2 === e[0].length && 2 === e[1].length, function () {
          return "Invalid number of paddings. Must be length of 2 each."
        }), rr(t, e, n)
      }
    }),
    or = on({
      pad3d_: function (t, e, n) {
        return void 0 === n && (n = 0), b(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, function () {
          return "Invalid number of paddings. Must be length of 2 each."
        }), rr(t, e, n)
      }
    }),
    sr = on({
      pad4d_: function (t, e, n) {
        return void 0 === n && (n = 0), b(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, function () {
          return "Invalid number of paddings. Must be length of 2 each."
        }), rr(t, e, n)
      }
    }),
    ur = on({
      rand_: function (t, e, n) {
        var r = N(t),
          a = null;
        if (null == n || "float32" === n) a = new Float32Array(r);
        else if ("int32" === n) a = new Int32Array(r);
        else {
          if ("bool" !== n) throw new Error("Unknown data type " + n);
          a = new Uint8Array(r)
        }
        for (var i = 0; i < r; i++) a[i] = e();
        return Dt.makeTensor(a, t, n)
      }
    }),
    lr = on({
      randomNormal_: function (t, e, n, r, a) {
        if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);
        for (var i = new Un(e, n, r, !1, a), o = qn(t, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
        return o.toTensor()
      }
    }),
    cr = on({
      randomGamma_: function (t, e, n, r, a) {
        if (void 0 === n && (n = 1), void 0 === r && (r = "float32"), null == n && (n = 1), null == r && (r = "float32"), "float32" !== r && "int32" !== r) throw new Error("Unsupported data type " + r);
        for (var i = new jn(e, n, r, a), o = qn(t, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
        return o.toTensor()
      }
    }),
    pr = on({
      randomUniform_: function (t, e, n, r, a) {
        void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = "float32");
        for (var i = qn(t, r), o = new Gn(e, n, null, a), s = 0; s < i.values.length; s++) i.values[s] = o.nextValue();
        return i.toTensor()
      }
    }),
    hr = on({
      reshape_: function (t, e) {
        var n = Ke(t, "x", "reshape", null);
        e = T(e, n.size), b(n.size === N(e), function () {
          return "new shape and old shape must have the same number of elements."
        });
        var r = {
          shape: e
        };
        return Dt.runKernelFunc(function (t) {
          return t.reshape(n, e)
        }, {
          x: n
        }, function (t) {
          return {
            x: function () {
              return t.reshape(n.shape)
            }
          }
        }, "Reshape", r)
      }
    }),
    fr = on({
      spaceToBatchND_: function (t, e, n) {
        var r = Ke(t, "x", "spaceToBatchND");
        return b(r.rank >= 1 + e.length, function () {
          return "input rank " + r.rank + " should be > than [blockShape] " + e.length
        }), b(n.length === e.length, function () {
          return "paddings.shape[0] " + n.length + " must be equal to [blockShape] " + e.length
        }), b(r.shape.reduce(function (t, r, a) {
          return a > 0 && a <= e.length ? t && (r + n[a - 1][0] + n[a - 1][1]) % e[a - 1] == 0 : t
        }, !0), function () {
          return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + n.toString() + " must be divisible by blockShapes " + e.toString()
        }), Dt.runKernelFunc(function (t) {
          return t.spaceToBatchND(r, e, n)
        }, {
          $x: r
        }, function (t) {
          return {
            $x: function () {
              return t.batchToSpaceND(e, n)
            }
          }
        })
      }
    }),
    dr = on({
      squeeze_: function (t, e) {
        var n = Ke(t, "x", "squeeze");
        return hr(n, O(n.shape, e).newShape)
      }
    }),
    mr = on({
      stack_: function (t, e) {
        void 0 === e && (e = 0);
        var n = Xe(t, "tensors", "stack");
        if (b(n.length >= 1, function () {
            return "Pass at least one tensor to tf.stack"
          }), 1 === n.length) return n[0].expandDims(e);
        var r = n[0].rank,
          a = n[0].shape,
          i = n[0].dtype;
        b(e <= r, function () {
          return "Axis must be <= rank of the tensor"
        }), n.forEach(function (t) {
          x(a, t.shape, "All tensors passed to stack must have matching shapes")
        }), n.forEach(function (t) {
          b(i === t.dtype, function () {
            return "All tensors passed to stack must have matching dtypes"
          })
        });
        var o = n.map(function (t) {
          return t.expandDims(e)
        });
        return En(o, e)
      }
    }),
    gr = on({
      tile_: function (t, e) {
        var n = Ke(t, "x", "tile", null);
        b(n.rank === e.length, function () {
          return "Error in transpose: rank of input " + n.rank + " must match length of reps " + e + "."
        });
        var r = [n],
          a = {
            reps: e
          };
        return Dt.runKernelFunc(function (t, r) {
          var a = t.tile(n, e);
          return r([n]), a
        }, {
          x: n
        }, function (t, n) {
          var r = n[0];
          return {
            x: function () {
              var n = In(r);
              if (1 === r.rank)
                for (var a = 0; a < e[0]; ++a) n = n.add(t.slice([a * r.shape[0]], [r.shape[0]]));
              else if (2 === r.rank)
                for (a = 0; a < e[0]; ++a)
                  for (var i = 0; i < e[1]; ++i) n = n.add(t.slice([a * r.shape[0], i * r.shape[1]], [r.shape[0], r.shape[1]]));
              else if (3 === r.rank)
                for (a = 0; a < e[0]; ++a)
                  for (i = 0; i < e[1]; ++i)
                    for (var o = 0; o < e[2]; ++o) n = n.add(t.slice([a * r.shape[0], i * r.shape[1], o * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));
              else {
                if (4 !== r.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r.rank + " tensors yet.");
                for (a = 0; a < e[0]; ++a)
                  for (i = 0; i < e[1]; ++i)
                    for (o = 0; o < e[2]; ++o)
                      for (var s = 0; s < e[3]; ++s) n = n.add(t.slice([a * r.shape[0], i * r.shape[1], o * r.shape[2], s * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]))
              }
              return n
            }
          }
        }, "Tile", a, r)
      }
    }),
    vr = on({
      truncatedNormal_: function (t, e, n, r, a) {
        if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && "bool" === r) throw new Error("Unsupported data type " + r);
        for (var i = new Un(e, n, r, !0, a), o = qn(t, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
        return o.toTensor()
      }
    }),
    yr = on({
      unstack_: function (t, e) {
        void 0 === e && (e = 0), e = e || 0;
        var n = Ke(t, "x", "unstack");
        b(e >= -n.shape.length && e < n.shape.length, function () {
          return "Axis = " + e + " is not in [-" + n.shape.length + ", " + n.shape.length + ")"
        }), e < 0 && (e += n.shape.length);
        var r = {
          axis: e
        };
        return Dt.runKernelFunc(function (t) {
          return t.unstack(n, e)
        }, {
          x: n
        }, function (t) {
          return {
            x: function () {
              return mr(t, e)
            }
          }
        }, "Unpack", r)
      }
    }),
    br = function (t, e) {
      return r(this, void 0, void 0, function () {
        var n, r, i, o, s, u, l, c, p, h;
        return a(this, function (a) {
          switch (a.label) {
            case 0:
              return n = Ke(t, "x", "setdiff1d"), r = Ke(e, "y", "setdiff1d"), b(n.dtype === r.dtype, function () {
                return "x and y should have the same dtype, but got x (" + n.dtype + ") and y (" + r.dtype + ")."
              }), b(1 === n.rank, function () {
                return "x should be 1D tensor, but got x (" + n.shape + ")."
              }), b(1 === r.rank, function () {
                return "y should be 1D tensor, but got y (" + r.shape + ")."
              }), [4, n.data()];
            case 1:
              return i = a.sent(), [4, r.data()];
            case 2:
              for (o = a.sent(), s = new Set(o), u = 0, p = 0; p < i.length; p++) s.has(i[p]) || u++;
              for (l = new pt([u], n.dtype), c = new pt([u], "int32"), p = 0, h = 0; p < i.length; p++) s.has(i[p]) || (l.values[h] = i[p], c.values[h] = p, h++);
              return [2, [l.toTensor(), c.toTensor()]]
          }
        })
      })
    };

  function xr(t, e, n, r) {
    void 0 === r && (r = !0);
    var a = [];
    if (r)(a = a.concat(e.slice(0))).push(t[0] / n), a = a.concat(t.slice(1));
    else {
      a = a.concat(t[0]);
      for (var i = e.length, o = 0; o < i; ++o) a = a.concat([t[o + 1] / e[o], e[o]]);
      a = a.concat(t.slice(i + 1))
    }
    return a
  }

  function wr(t, e, n) {
    void 0 === n && (n = !0);
    var r = [];
    if (n) {
      r.push(e);
      for (var a = e + 1; a < t; ++a) a <= 2 * e ? (r.push(a), r.push(a - (e + 1))) : r.push(a)
    } else {
      var i = [],
        o = [];
      for (a = 1; a < t; ++a) a >= 2 * e + 1 || a % 2 == 1 ? o.push(a) : i.push(a);
      r.push.apply(r, i), r.push(0), r.push.apply(r, o)
    }
    return r
  }

  function Cr(t, e, n, r) {
    void 0 === r && (r = !0);
    var a = [];
    r ? a.push(t[0] / n) : a.push(t[0] * n);
    for (var i = 1; i < t.length; ++i) i <= e.length ? r ? a.push(e[i - 1] * t[i]) : a.push(t[i] / e[i - 1]) : a.push(t[i]);
    return a
  }

  function Nr(t, e) {
    for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0]);
    return n
  }

  function Sr(t, e, n) {
    for (var r = t.slice(0, 1), a = 0; a < n; ++a) r.push(t[a + 1] - e[a][0] - e[a][1]);
    return r
  }

  function kr(t, e) {
    if (t.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t.rank + ".");
    if (e.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
    if ("int32" !== e.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e.dtype + ".");
    if (e.shape[e.rank - 1] > t.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e.shape[e.rank - 1] + " vs. " + t.rank);
    if (0 === t.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t.shape + ".");
    for (var n = e.shape, r = n[n.length - 1], a = 1, i = 0; i < n.length - 1; ++i) a *= n[i];
    var o = t.shape,
      s = n.slice();
    s.pop();
    var u = 1;
    for (i = r; i < t.rank; ++i) u *= o[i], s.push(o[i]);
    var l = K(t.shape).map(function (t) {
      return t / u
    }).concat([1]).slice(0, r);
    return [s, a, u, l]
  }
  var Ir = 30;

  function Er(t) {
    return t <= Ir ? t : H(t, Math.floor(Math.sqrt(t)))
  }

  function Ar(t, e, n) {
    for (var r = e.rank > 1 ? e.shape[e.rank - 1] : 1, a = n.length, i = 1, o = r; o < a; ++o) i *= n[o];
    var s = r < 1 ? 1 : r;
    return {
      sliceRank: r,
      numUpdates: e.size / s,
      sliceSize: i,
      strides: K(n.slice(0, r)).concat([1]),
      outputSize: N(n)
    }
  }

  function Rr(t, e, n) {
    b(t.rank === e.length, function () {
      return "Error in slice" + t.rank + "D: Length of begin " + e + " must match the rank of the array (" + t.rank + ")."
    }), b(t.rank === n.length, function () {
      return "Error in slice" + t.rank + "D: Length of size " + n + " must match the rank of the array (" + t.rank + ")."
    });
    for (var r = function (r) {
        b(e[r] + n[r] <= t.shape[r], function () {
          return "Error in slice" + t.rank + "D: begin[" + r + "] + size[" + r + "] (" + (e[r] + n[r]) + ") would overflow input.shape[" + r + "] (" + t.shape[r] + ")"
        })
      }, a = 0; a < t.rank; ++a) r(a)
  }

  function Tr(t) {
    for (var e = [], n = 0; t > 0;) 1 & t && e.push(n), t /= 2, n++;
    return e
  }

  function Dr(t, e, n) {
    for (var r = [], a = 0; a < t.length; a++) r[a] = Math.ceil((e[a] - t[a]) / n[a]);
    return r
  }

  function Or(t, e, n, r, a) {
    var i = e[a],
      o = n[a] || 1;
    (t & 1 << a || null == i) && (i = o > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
    var s = r[a];
    return i < 0 && (i += s), g(0, i, s - 1)
  }

  function _r(t, e, n, r, a) {
    var i = e[a],
      o = n[a] || 1;
    (t & 1 << a || null == i) && (i = o > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
    var s = r[a];
    return i < 0 && (i += s), o > 0 ? g(0, i, s) : g(-1, i, s - 1)
  }

  function Fr(t, e, n) {
    for (var r = n.length, a = 0; a < n.length; a++)
      if (n[a] > 1) {
        r = a;
        break
      } for (a = r + 1; a < n.length; a++)
      if (e[a] > 0 || n[a] !== t[a]) return !1;
    return !0
  }

  function Mr(t, e) {
    for (var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++) n += t[r] * e[r];
    return n
  }
  var zr = Object.freeze({
    assertParamsValid: Rr,
    maskToAxes: Tr,
    computeOutShape: Dr,
    startForAxis: Or,
    stopForAxis: _r,
    isSliceContinous: Fr,
    computeFlatOffset: Mr
  });

  function Lr(t, e) {
    b(q(t), function () {
      return "The f passed in variableGrads(f) must be a function"
    }), b(null == e || Array.isArray(e) && e.every(function (t) {
      return t instanceof xt
    }), function () {
      return "The varList passed in variableGrads(f, varList) must be an array of variables"
    });
    var n = null != e;
    if (!n)
      for (var r in e = [], Dt.registeredVariables) e.push(Dt.registeredVariables[r]);
    var a = n ? e.filter(function (t) {
        return !t.trainable
      }) : null,
      i = e.length;
    b((e = e.filter(function (t) {
      return t.trainable
    })).length > 0, function () {
      return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + i + " variables is trainable."
    });
    var o = Dt.gradients(t, e, null, !0),
      s = o.value,
      u = o.grads;
    b(u.some(function (t) {
      return null != t
    }), function () {
      return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."
    }), b(0 === s.rank, function () {
      return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s.rank + " tensor"
    });
    var l = {};
    return e.forEach(function (t, e) {
      null != u[e] && (l[t.name] = u[e])
    }), null != a && a.forEach(function (t) {
      return l[t.name] = null
    }), {
      value: s,
      grads: l
    }
  }

  function Br(t) {
    return Dt.customGrad(t)
  }

  function Pr(t) {
    if (t.filter(function (t) {
        return null == t
      }).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")
  }
  var Wr = on({
      softmax_: function (t, e) {
        void 0 === e && (e = -1);
        var n = Ke(t, "logits", "softmax");
        if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and dim was " + e);
        return Br(function (t, n) {
          var r = t.logSumExp([e], !0),
            a = t.toFloat().sub(r).exp();
          return n([a]), {
            value: a,
            gradFunc: function (t, n) {
              var r = n[0],
                a = t.mul(r);
              return a.sub(a.sum([e], !0).mul(r))
            }
          }
        })(n)
      }
    }),
    Vr = on({
      logSoftmax_: function (t, e) {
        void 0 === e && (e = -1);
        var n = Ke(t, "logits", "logSoftmax");
        if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n.rank + " and axis was " + e);
        return Br(function (t, n) {
          var r = t.max(e, !0),
            a = t.sub(r),
            i = a.toFloat().sub(a.exp().sum(e, !0).log());
          return n([i]), {
            value: i,
            gradFunc: function (t, n) {
              var r = n[0].exp();
              return t.sub(t.sum(e, !0).mul(r))
            }
          }
        })(n)
      }
    }),
    Ur = function () {
      function t(t, e) {
        this.backend = t, this.dataMover = e, this.data = new WeakMap, this.dataIdsCount = 0
      }
      return t.prototype.get = function (t) {
        return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t)
      }, t.prototype.set = function (t, e) {
        this.dataIdsCount++, this.data.set(t, e)
      }, t.prototype.has = function (t) {
        return this.data.has(t)
      }, t.prototype.delete = function (t) {
        return this.dataIdsCount--, this.data.delete(t)
      }, t.prototype.numDataIds = function () {
        return this.dataIdsCount
      }, t
    }(),
    jr = function () {
      function t() {}
      return t.prototype.time = function (t) {
        return Gr("time")
      }, t.prototype.read = function (t) {
        return Gr("read")
      }, t.prototype.readSync = function (t) {
        return Gr("readSync")
      }, t.prototype.numDataIds = function () {
        return Gr("numDataIds")
      }, t.prototype.disposeData = function (t) {
        return Gr("disposeData")
      }, t.prototype.write = function (t, e, n) {
        return Gr("write")
      }, t.prototype.move = function (t, e, n, r) {
        return Gr("move")
      }, t.prototype.memory = function () {
        return Gr("memory")
      }, t.prototype.floatPrecision = function () {
        return Gr("floatPrecision")
      }, t.prototype.epsilon = function () {
        return 32 === this.floatPrecision() ? 1e-7 : 1e-4
      }, t.prototype.batchMatMul = function (t, e, n, r) {
        return Gr("batchMatMul")
      }, t.prototype.fusedBatchMatMul = function (t) {
        return t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights, Gr("fusedBatchMatMul")
      }, t.prototype.slice = function (t, e, n) {
        return Gr("slice")
      }, t.prototype.stridedSlice = function (t, e, n, r) {
        return Gr("stridedSlice")
      }, t.prototype.unstack = function (t, e) {
        return Gr("unstack")
      }, t.prototype.reverse = function (t, e) {
        return Gr("reverse")
      }, t.prototype.concat = function (t, e) {
        return Gr("concat")
      }, t.prototype.neg = function (t) {
        return Gr("neg")
      }, t.prototype.add = function (t, e) {
        return Gr("add")
      }, t.prototype.addN = function (t) {
        return Gr("addN")
      }, t.prototype.subtract = function (t, e) {
        return Gr("subtract")
      }, t.prototype.multiply = function (t, e) {
        return Gr("multiply")
      }, t.prototype.realDivide = function (t, e) {
        return Gr("realDivide")
      }, t.prototype.floorDiv = function (t, e) {
        return Gr("floorDiv")
      }, t.prototype.sum = function (t, e) {
        return Gr("sum")
      }, t.prototype.prod = function (t, e) {
        return Gr("prod")
      }, t.prototype.unsortedSegmentSum = function (t, e, n) {
        return Gr("unsortedSegmentSum")
      }, t.prototype.argMin = function (t, e) {
        return Gr("argMin")
      }, t.prototype.argMax = function (t, e) {
        return Gr("argMax")
      }, t.prototype.equal = function (t, e) {
        return Gr("equal")
      }, t.prototype.notEqual = function (t, e) {
        return Gr("notEqual")
      }, t.prototype.less = function (t, e) {
        return Gr("less")
      }, t.prototype.lessEqual = function (t, e) {
        return Gr("lessEqual")
      }, t.prototype.greater = function (t, e) {
        return Gr("greater")
      }, t.prototype.greaterEqual = function (t, e) {
        return Gr("greaterEqual")
      }, t.prototype.logicalNot = function (t) {
        return Gr("logicalNot")
      }, t.prototype.logicalAnd = function (t, e) {
        return Gr("logicalAnd")
      }, t.prototype.logicalOr = function (t, e) {
        return Gr("logicalOr")
      }, t.prototype.where = function (t) {
        return Gr("where")
      }, t.prototype.select = function (t, e, n) {
        return Gr("select")
      }, t.prototype.topk = function (t, e, n) {
        return Gr("topk")
      }, t.prototype.min = function (t, e) {
        return Gr("min")
      }, t.prototype.minimum = function (t, e) {
        return Gr("minimum")
      }, t.prototype.mod = function (t, e) {
        return Gr("mod")
      }, t.prototype.max = function (t, e) {
        return Gr("max")
      }, t.prototype.maximum = function (t, e) {
        return Gr("maximum")
      }, t.prototype.all = function (t, e) {
        return Gr("all")
      }, t.prototype.any = function (t, e) {
        return Gr("any")
      }, t.prototype.squaredDifference = function (t, e) {
        return Gr("squaredDifference")
      }, t.prototype.ceil = function (t) {
        return Gr("ceil")
      }, t.prototype.floor = function (t) {
        return Gr("floor")
      }, t.prototype.round = function (t) {
        return Gr("round")
      }, t.prototype.sign = function (t) {
        return Gr("sign")
      }, t.prototype.isNaN = function (t) {
        return Gr("isNaN")
      }, t.prototype.isInf = function (t) {
        return Gr("isInf")
      }, t.prototype.isFinite = function (t) {
        return Gr("isFinite")
      }, t.prototype.pow = function (t, e) {
        return Gr("pow")
      }, t.prototype.exp = function (t) {
        return Gr("exp")
      }, t.prototype.expm1 = function (t) {
        return Gr("expm1")
      }, t.prototype.log = function (t) {
        return Gr("log")
      }, t.prototype.log1p = function (t) {
        return Gr("log1p")
      }, t.prototype.sqrt = function (t) {
        return Gr("sqrt")
      }, t.prototype.rsqrt = function (t) {
        return Gr("rsqrt")
      }, t.prototype.square = function (t) {
        return Gr("square")
      }, t.prototype.reciprocal = function (t) {
        return Gr("reciprocal")
      }, t.prototype.relu = function (t) {
        return Gr("relu")
      }, t.prototype.relu6 = function (t) {
        return Gr("relu6")
      }, t.prototype.prelu = function (t, e) {
        return Gr("prelu")
      }, t.prototype.elu = function (t) {
        return Gr("elu")
      }, t.prototype.eluDer = function (t, e) {
        return Gr("eluDer")
      }, t.prototype.selu = function (t) {
        return Gr("selu")
      }, t.prototype.int = function (t) {
        return Gr("int")
      }, t.prototype.clip = function (t, e, n) {
        return Gr("clip")
      }, t.prototype.abs = function (t) {
        return Gr("abs")
      }, t.prototype.complexAbs = function (t) {
        return Gr("complexAbs")
      }, t.prototype.sigmoid = function (t) {
        return Gr("sigmoid")
      }, t.prototype.softplus = function (t) {
        return Gr("softplus")
      }, t.prototype.sin = function (t) {
        return Gr("sin")
      }, t.prototype.cos = function (t) {
        return Gr("cos")
      }, t.prototype.tan = function (t) {
        return Gr("tan")
      }, t.prototype.asin = function (t) {
        return Gr("asin")
      }, t.prototype.acos = function (t) {
        return Gr("acos")
      }, t.prototype.atan = function (t) {
        return Gr("atan")
      }, t.prototype.atan2 = function (t, e) {
        return Gr("atan2")
      }, t.prototype.sinh = function (t) {
        return Gr("sinh")
      }, t.prototype.cosh = function (t) {
        return Gr("cosh")
      }, t.prototype.tanh = function (t) {
        return Gr("tanh")
      }, t.prototype.asinh = function (t) {
        return Gr("asinh")
      }, t.prototype.acosh = function (t) {
        return Gr("acosh")
      }, t.prototype.atanh = function (t) {
        return Gr("atanh")
      }, t.prototype.erf = function (t) {
        return Gr("erf")
      }, t.prototype.step = function (t, e) {
        return Gr("step")
      }, t.prototype.fusedConv2d = function (t) {
        return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, Gr("fusedConv2d")
      }, t.prototype.conv2d = function (t, e, n) {
        return Gr("conv2d")
      }, t.prototype.conv2dDerInput = function (t, e, n) {
        return Gr("conv2dDerInput")
      }, t.prototype.conv2dDerFilter = function (t, e, n) {
        return Gr("conv2dDerFilter")
      }, t.prototype.fusedDepthwiseConv2D = function (t) {
        return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, Gr("fusedDepthwiseConv2D")
      }, t.prototype.depthwiseConv2D = function (t, e, n) {
        return Gr("depthwiseConv2D")
      }, t.prototype.depthwiseConv2DDerInput = function (t, e, n) {
        return Gr("depthwiseConv2DDerInput")
      }, t.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
        return Gr("depthwiseConv2DDerFilter")
      }, t.prototype.conv3d = function (t, e, n) {
        return Gr("conv3d")
      }, t.prototype.conv3dDerInput = function (t, e, n) {
        return Gr("conv3dDerInput")
      }, t.prototype.conv3dDerFilter = function (t, e, n) {
        return Gr("conv3dDerFilter")
      }, t.prototype.maxPool = function (t, e) {
        return Gr("maxPool")
      }, t.prototype.maxPoolBackprop = function (t, e, n, r) {
        return Gr("maxPoolBackprop")
      }, t.prototype.avgPool = function (t, e) {
        return Gr("avgPool")
      }, t.prototype.avgPoolBackprop = function (t, e, n) {
        return Gr("avgPoolBackprop")
      }, t.prototype.avgPool3d = function (t, e) {
        return Gr("avgPool3d")
      }, t.prototype.avgPool3dBackprop = function (t, e, n) {
        return Gr("avgPool3dBackprop")
      }, t.prototype.maxPool3d = function (t, e) {
        return Gr("maxPool3d")
      }, t.prototype.maxPool3dBackprop = function (t, e, n, r) {
        return Gr("maxPool3dBackprop")
      }, t.prototype.reshape = function (t, e) {
        return Gr("reshape")
      }, t.prototype.cast = function (t, e) {
        return Gr("cast")
      }, t.prototype.tile = function (t, e) {
        return Gr("tile")
      }, t.prototype.pad = function (t, e, n) {
        return Gr("pad")
      }, t.prototype.transpose = function (t, e) {
        return Gr("transpose")
      }, t.prototype.gather = function (t, e, n) {
        return Gr("gather")
      }, t.prototype.gatherND = function (t, e) {
        return Gr("gatherND")
      }, t.prototype.scatterND = function (t, e, n) {
        return Gr("scatterND")
      }, t.prototype.batchToSpaceND = function (t, e, n) {
        return Gr("batchToSpaceND")
      }, t.prototype.spaceToBatchND = function (t, e, n) {
        return Gr("spaceToBatchND")
      }, t.prototype.resizeBilinear = function (t, e, n, r) {
        return Gr("resizeBilinear")
      }, t.prototype.resizeBilinearBackprop = function (t, e, n) {
        return Gr("resizeBilinearBackprop")
      }, t.prototype.resizeNearestNeighbor = function (t, e, n, r) {
        return Gr("resizeNearestNeighbor")
      }, t.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
        return Gr("resizeNearestNeighborBackprop")
      }, t.prototype.batchNormalization = function (t, e, n, r, a, i) {
        return Gr("batchNormalization")
      }, t.prototype.localResponseNormalization4D = function (t, e, n, r, a) {
        return Gr("localResponseNormalization4D")
      }, t.prototype.LRNGrad = function (t, e, n, r, a, i, o) {
        return Gr("LRNGrad")
      }, t.prototype.multinomial = function (t, e, n, r) {
        return Gr("multinomial")
      }, t.prototype.oneHot = function (t, e, n, r) {
        return Gr("oneHot")
      }, t.prototype.cumsum = function (t, e, n, r) {
        return Gr("cumsum")
      }, t.prototype.nonMaxSuppression = function (t, e, n, r, a) {
        return Gr("nonMaxSuppression")
      }, t.prototype.fft = function (t) {
        return Gr("fft")
      }, t.prototype.ifft = function (t) {
        return Gr("ifft")
      }, t.prototype.complex = function (t, e) {
        return Gr("complex")
      }, t.prototype.real = function (t) {
        return Gr("real")
      }, t.prototype.imag = function (t) {
        return Gr("imag")
      }, t.prototype.cropAndResize = function (t, e, n, r, a, i) {
        return Gr("cropAndResize")
      }, t.prototype.depthToSpace = function (t, e, n) {
        return Gr("depthToSpace")
      }, t.prototype.split = function (t, e, n) {
        return Gr("split")
      }, t.prototype.sparseToDense = function (t, e, n, r) {
        return Gr("sparseToDense")
      }, t.prototype.diag = function (t) {
        return Gr("diag")
      }, t.prototype.fill = function (t, e, n) {
        return Gr("fill")
      }, t.prototype.onesLike = function (t) {
        return Gr("onesLike")
      }, t.prototype.zerosLike = function (t) {
        return Gr("zerosLike")
      }, t.prototype.linspace = function (t, e, n) {
        return Gr("linspace")
      }, t.prototype.dispose = function () {
        return Gr("dispose")
      }, t
    }();

  function Gr(t) {
    throw new Error("'" + t + "' not yet implemented or not found in the registry. Did you forget to import the kernel?")
  }

  function qr(t, e) {
    for (var n = t.length, r = [], a = 0; a < n; a++) {
      var i = n - 1 - a,
        o = t[i] || 1;
      (e[e.length - 1 - a] || 1) > 1 && 1 === o && r.unshift(i)
    }
    return r
  }

  function Hr(t, e) {
    for (var n = [], r = 0; r < e.length; r++) {
      var a = t[t.length - r - 1],
        i = e.length - r - 1,
        o = e[i];
      (null == a || 1 === a && o > 1) && n.unshift(i)
    }
    return n
  }

  function Kr(t, e) {
    for (var n = [], r = Math.max(t.length, e.length), a = 0; a < r; a++) {
      var i = t[t.length - a - 1];
      null == i && (i = 1);
      var o = e[e.length - a - 1];
      if (null == o && (o = 1), 1 === i) n.unshift(o);
      else if (1 === o) n.unshift(i);
      else {
        if (i !== o) throw Error("Operands could not be broadcast together with shapes " + t + " and " + e + ".");
        n.unshift(i)
      }
    }
    return n
  }

  function Xr(t, e, n, r, a, i, o) {
    void 0 === o && (o = "channelsLast");
    var s, u = Qr(e),
      l = u[0],
      c = u[1];
    if ("channelsLast" === o) s = [l, c, t[3], t[3]];
    else {
      if ("channelsFirst" !== o) throw new Error("Unknown dataFormat " + o);
      s = [l, c, t[1], t[1]]
    }
    return Yr(t, s, n, r, a, i, !1, o)
  }

  function $r(t, e, n, r, a, i, o) {
    void 0 === o && (o = "NDHWC");
    var s, u, l = ta(e),
      c = l[0],
      p = l[1],
      h = l[2];
    if ("NDHWC" === o) u = "channelsLast", s = [c, p, h, t[4], t[4]];
    else {
      if ("NCDHW" !== o) throw new Error("Unknown dataFormat " + o);
      u = "channelsFirst", s = [c, p, h, t[1], t[1]]
    }
    return Jr(t, s, n, r, a, !1, u, i)
  }

  function Yr(t, e, n, r, a, i, o, s) {
    void 0 === o && (o = !1), void 0 === s && (s = "channelsLast");
    var u = [-1, -1, -1, -1],
      l = u[0],
      c = u[1],
      p = u[2],
      h = u[3];
    if ("channelsLast" === s) l = t[0], c = t[1], p = t[2], h = t[3];
    else {
      if ("channelsFirst" !== s) throw new Error("Unknown dataFormat " + s);
      l = t[0], h = t[1], c = t[2], p = t[3]
    }
    var f, d = e[0],
      m = e[1],
      g = e[3],
      v = Qr(n),
      y = v[0],
      x = v[1],
      w = Qr(r),
      C = w[0],
      N = w[1],
      S = ea(d, C),
      I = ea(m, N),
      E = function (t, e, n, r, a, i, o, s) {
        var u, l, c;
        if ("number" == typeof t) {
          u = {
            top: t,
            bottom: t,
            left: t,
            right: t,
            type: 0 === t ? "VALID" : "NUMBER"
          };
          var p = function (t, e, n, r, a) {
            null == r && (r = Zr(t, e, n));
            var i = t[1],
              o = na((t[0] - e + 2 * r) / n + 1, a);
            b(k(o), function () {
              return "The output # of rows (" + o + ") must be an integer. Change the stride and/or zero pad parameters"
            });
            var s = na((i - e + 2 * r) / n + 1, a);
            return b(k(s), function () {
              return "The output # of columns (" + s + ") must be an integer. Change the stride and/or zero pad parameters"
            }), [o, s]
          }([e, n], i, r, t, s);
          l = p[0], c = p[1]
        } else if ("same" === t) {
          l = Math.ceil(e / r), c = Math.ceil(n / a);
          var h = Math.max(0, (l - 1) * r + i - e),
            f = Math.max(0, (c - 1) * a + o - n),
            d = Math.floor(h / 2),
            m = h - d,
            g = Math.floor(f / 2);
          u = {
            top: d,
            bottom: m,
            left: g,
            right: f - g,
            type: "SAME"
          }
        } else {
          if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
          u = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            type: "VALID"
          }, l = Math.ceil((e - i + 1) / r), c = Math.ceil((n - o + 1) / a)
        }
        return {
          padInfo: u,
          outHeight: l,
          outWidth: c
        }
      }(a, c, p, y, x, S, I, i),
      A = E.padInfo,
      R = E.outHeight,
      T = E.outWidth,
      D = o ? g * h : g;
    return "channelsFirst" === s ? f = [l, D, R, T] : "channelsLast" === s && (f = [l, R, T, D]), {
      batchSize: l,
      dataFormat: s,
      inHeight: c,
      inWidth: p,
      inChannels: h,
      outHeight: R,
      outWidth: T,
      outChannels: D,
      padInfo: A,
      strideHeight: y,
      strideWidth: x,
      filterHeight: d,
      filterWidth: m,
      effectiveFilterHeight: S,
      effectiveFilterWidth: I,
      dilationHeight: C,
      dilationWidth: N,
      inShape: t,
      outShape: f,
      filterShape: e
    }
  }

  function Jr(t, e, n, r, a, i, o, s) {
    void 0 === i && (i = !1), void 0 === o && (o = "channelsLast");
    var u = [-1, -1, -1, -1, -1],
      l = u[0],
      c = u[1],
      p = u[2],
      h = u[3],
      f = u[4];
    if ("channelsLast" === o) l = t[0], c = t[1], p = t[2], h = t[3], f = t[4];
    else {
      if ("channelsFirst" !== o) throw new Error("Unknown dataFormat " + o);
      l = t[0], f = t[1], c = t[2], p = t[3], h = t[4]
    }
    var d, m = e[0],
      g = e[1],
      v = e[2],
      y = e[4],
      x = ta(n),
      w = x[0],
      C = x[1],
      N = x[2],
      S = ta(r),
      I = S[0],
      E = S[1],
      A = S[2],
      R = ea(m, I),
      T = ea(g, E),
      D = ea(v, A),
      O = function (t, e, n, r, a, i, o, s, u, l, c) {
        var p, h, f, d;
        if ("number" == typeof t) {
          p = {
            top: t,
            bottom: t,
            left: t,
            right: t,
            front: t,
            back: t,
            type: 0 === t ? "VALID" : "NUMBER"
          };
          var m = function (t, e, n, r, a, i) {
            null == a && (a = Zr(t, e, r));
            var o = t[1],
              s = t[2],
              u = na((t[0] - e + 2 * a) / r + 1, i);
            b(k(u), function () {
              return "The output # of depths (" + u + ") must be an integer. Change the stride and/or zero pad parameters"
            });
            var l = na((o - e + 2 * a) / r + 1, i);
            b(k(l), function () {
              return "The output # of rows (" + l + ") must be an integer. Change the stride and/or zero pad parameters"
            });
            var c = na((s - e + 2 * a) / r + 1, i);
            return b(k(c), function () {
              return "The output # of columns (" + c + ") must be an integer. Change the stride and/or zero pad parameters"
            }), [u, l, c, 1]
          }([e, n, r, 1], s, 0, a, t, c);
          h = m[0], f = m[1], d = m[2]
        } else if ("same" === t) {
          var g = ((h = Math.ceil(e / a)) - 1) * a + s - e,
            v = ((f = Math.ceil(n / i)) - 1) * i + u - n,
            y = ((d = Math.ceil(r / o)) - 1) * o + l - r,
            x = Math.floor(g / 2),
            w = g - x,
            C = Math.floor(v / 2),
            N = v - C,
            S = Math.floor(y / 2);
          p = {
            top: C,
            bottom: N,
            left: S,
            right: y - S,
            front: x,
            back: w,
            type: "SAME"
          }
        } else {
          if ("valid" !== t) throw Error("Unknown padding parameter: " + t);
          p = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            front: 0,
            back: 0,
            type: "VALID"
          }, h = Math.ceil((e - s + 1) / a), f = Math.ceil((n - u + 1) / i), d = Math.ceil((r - l + 1) / o)
        }
        return {
          padInfo: p,
          outDepth: h,
          outHeight: f,
          outWidth: d
        }
      }(a, c, p, h, w, C, N, R, T, D, s),
      _ = O.padInfo,
      F = O.outDepth,
      M = O.outHeight,
      z = O.outWidth,
      L = i ? y * f : y;
    return "channelsFirst" === o ? d = [l, L, F, M, z] : "channelsLast" === o && (d = [l, F, M, z, L]), {
      batchSize: l,
      dataFormat: o,
      inDepth: c,
      inHeight: p,
      inWidth: h,
      inChannels: f,
      outDepth: F,
      outHeight: M,
      outWidth: z,
      outChannels: L,
      padInfo: _,
      strideDepth: w,
      strideHeight: C,
      strideWidth: N,
      filterDepth: m,
      filterHeight: g,
      filterWidth: v,
      effectiveFilterDepth: R,
      effectiveFilterHeight: T,
      effectiveFilterWidth: D,
      dilationDepth: I,
      dilationHeight: E,
      dilationWidth: A,
      inShape: t,
      outShape: d,
      filterShape: e
    }
  }

  function Zr(t, e, n, r) {
    void 0 === r && (r = 1);
    var a = ea(e, r);
    return Math.floor((t[0] * (n - 1) - n + a) / 2)
  }

  function Qr(t) {
    return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t
  }

  function ta(t) {
    return "number" == typeof t ? [t, t, t] : t
  }

  function ea(t, e) {
    return e <= 1 ? t : t + (t - 1) * (e - 1)
  }

  function na(t, e) {
    if (!e) return t;
    switch (e) {
      case "round":
        return Math.round(t);
      case "ceil":
        return Math.ceil(t);
      case "floor":
        return Math.floor(t);
      default:
        throw new Error("Unknown roundingMode " + e)
    }
  }

  function ra(t) {
    var e = Qr(t),
      n = e[0],
      r = e[1],
      a = e[2];
    return 1 === n && 1 === r && 1 === a
  }

  function aa(t, e) {
    return ra(t) || ra(e)
  }

  function ia(t) {
    if ("NHWC" === t) return "channelsLast";
    if ("NCHW" === t) return "channelsFirst";
    throw new Error("Unknown dataFormat " + t)
  }

  function oa(t, e, n) {
    if ("complex64" === e) {
      if ("complex64" === t.dtype) return t.clone();
      var r = wn(t.shape),
        a = t.toFloat(),
        i = n.complex(a, r);
      return r.dispose(), a.dispose(), i
    }
    if (!L(t.dtype, e)) return Dt.makeTensorFromDataId(t.dataId, t.shape, e);
    if ("complex64" === t.dtype) {
      var o = n.real(t);
      return i = o.cast(e), o.dispose(), i
    }
    if ("int32" === e) return n.int(t);
    if ("bool" === e) {
      var s = hn(0, t.dtype);
      return i = n.notEqual(t, s), s.dispose(), i
    }
    throw new Error("Error in Cast: failed to cast " + t.dtype + " to " + e)
  }

  function sa(t, e) {
    return Dt.makeTensorFromDataId(t.dataId, e, t.dtype)
  }

  function ua(t, e, n) {
    var r = (e - t) / (n - 1),
      a = J(n, "float32");
    a[0] = t;
    for (var i = 1; i < a.length; i++) a[i] = a[i - 1] + r;
    return fn(a, "float32")
  }
  var la = Object.freeze({
    castTensor: oa,
    reshapeTensor: sa,
    linspaceImpl: ua,
    upcastType: Ct,
    axesAreInnerMostDims: $e,
    combineLocations: Ye,
    computeOutAndReduceShapes: Je,
    expandShapeToKeepDim: Ze,
    assertAxesAreInnerMostDims: Qe,
    getAxesPermutation: tn,
    getUndoAxesPermutation: en,
    getInnerMostAxes: nn,
    getBroadcastDims: qr,
    getReductionAxes: Hr,
    assertAndGetBroadcastShape: Kr,
    assertParamsConsistent: rn,
    computeOutShape: an,
    computePool2DInfo: Xr,
    computePool3DInfo: $r,
    computeConv2DInfo: Yr,
    computeConv3DInfo: Jr,
    computeDefaultPad: Zr,
    tupleValuesAreOne: ra,
    eitherStridesOrDilationsAreOne: aa,
    convertConv2DDataFormat: ia
  });

  function ca(t, e) {
    if (t.length !== e.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t.length + ", imag: " + e.length + ".");
    for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2) n[r] = t[r / 2], n[r + 1] = e[r / 2];
    return n
  }

  function pa(t, e) {
    return {
      real: t[2 * e],
      imag: t[2 * e + 1]
    }
  }

  function ha(t, e, n, r) {
    t[2 * r] = e, t[2 * r + 1] = n
  }

  function fa(t, e, n) {
    var r = (n ? 2 : -2) * Math.PI * (t / e);
    return {
      real: Math.cos(r),
      imag: Math.sin(r)
    }
  }

  function da(t, e, n) {
    var r = function (t, e, n) {
        return function (t, e, n) {
          for (var r = 0, a = t.length, i = 0, o = !1; r < a;) {
            var s = n(e, t[i = r + (a - r >>> 1)]);
            s > 0 ? r = i + 1 : (a = i, o = !s)
          }
          return o ? r : -r - 1
        }(t, e, n || ma)
      }(t, e, n),
      a = r < 0 ? -(r + 1) : r;
    t.splice(a, 0, e)
  }

  function ma(t, e) {
    return t > e ? 1 : t < e ? -1 : 0
  }

  function ga(t, e, n, r, a) {
    return ya(t, e, n, r, a, 0).selectedIndices
  }

  function va(t, e, n, r, a, i) {
    var o = ya(t, e, n, r, a, i, !0);
    return o.numValidOutputs.dispose(), {
      selectedIndices: o.selectedIndices,
      selectedScores: o.selectedScores
    }
  }

  function ya(t, e, n, r, a, i, o, s) {
    void 0 === o && (o = !1), void 0 === s && (s = !1);
    for (var u = Array.from(e).map(function (t, e) {
        return {
          score: t,
          boxIndex: e,
          suppressBeginIndex: 0
        }
      }).filter(function (t) {
        return t.score > a
      }).sort(wa), l = i > 0 ? -.5 / i : 0, c = [], p = []; c.length < n && u.length > 0;) {
      var h = u.pop(),
        f = h.score,
        d = h.boxIndex,
        m = h.suppressBeginIndex;
      if (f < a) break;
      for (var g = !1, v = c.length - 1; v >= m; --v) {
        var y = ba(t, d, c[v]);
        if (y >= r) {
          g = !0;
          break
        }
        if (h.score = h.score * xa(r, l, y), h.score <= a) break
      }
      h.suppressBeginIndex = c.length, g || (h.score === f ? (c.push(d), p.push(h.score)) : h.score > a && da(u, h, wa))
    }
    var b = c.length;
    return s && (c.fill(0, b), p.fill(0, b)), {
      selectedIndices: fn(c, "int32"),
      selectedScores: fn(p, "float32"),
      numValidOutputs: hn(b, "int32")
    }
  }

  function ba(t, e, n) {
    var r = t.subarray(4 * e, 4 * e + 4),
      a = t.subarray(4 * n, 4 * n + 4),
      i = Math.min(r[0], r[2]),
      o = Math.min(r[1], r[3]),
      s = Math.max(r[0], r[2]),
      u = Math.max(r[1], r[3]),
      l = Math.min(a[0], a[2]),
      c = Math.min(a[1], a[3]),
      p = Math.max(a[0], a[2]),
      h = Math.max(a[1], a[3]),
      f = (s - i) * (u - o),
      d = (p - l) * (h - c);
    if (f <= 0 || d <= 0) return 0;
    var m = Math.max(i, l),
      g = Math.max(o, c),
      v = Math.min(s, p),
      y = Math.min(u, h),
      b = Math.max(v - m, 0) * Math.max(y - g, 0);
    return b / (f + d - b)
  }

  function xa(t, e, n) {
    var r = Math.exp(e * n * n);
    return n <= t ? r : 0
  }

  function wa(t, e) {
    return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex
  }

  function Ca(t, e, n) {
    var r = new Array(t.rank).fill(0),
      a = t.shape.slice();
    return e.map(function (e) {
      a[n] = e;
      var i = t.slice(r, a);
      return r[n] += e, i
    })
  }

  function Na(t, e) {
    for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[r] * e[r];
    var a = qn(n, t.dtype);
    for (r = 0; r < a.values.length; ++r) {
      for (var i = a.indexToLoc(r), o = new Array(t.rank), s = 0; s < o.length; s++) o[s] = i[s] % t.shape[s];
      var u = t.locToIndex(o);
      a.values[r] = t.values[u]
    }
    return a.toTensor()
  }

  function Sa(t, e, n, r, a) {
    for (var i = e[e.length - 1], o = [t.length / i, i], s = o[0], u = o[1], l = _(n, s * r), c = _("int32", s * r), p = 0; p < s; p++) {
      for (var h = p * u, f = t.subarray(h, h + u), d = [], m = 0; m < f.length; m++) d.push({
        value: f[m],
        index: m
      });
      d.sort(function (t, e) {
        return e.value - t.value
      });
      var g = p * r,
        v = l.subarray(g, g + r),
        y = c.subarray(g, g + r);
      for (m = 0; m < r; m++) v[m] = d[m].value, y[m] = d[m].index
    }
    var b = e.slice();
    return b[b.length - 1] = r, [cn(l, b, n), cn(c, b, "int32")]
  }

  function ka(t, e) {
    for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r);
    var a = qn(t, "int32"),
      i = qn([n.length, t.length], "int32");
    for (r = 0; r < n.length; r++) {
      var o = a.indexToLoc(n[r]),
        s = r * t.length;
      i.values.set(o, s)
    }
    return i.toTensor()
  }

  function Ia(t, e) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, e).map(function (e) {
      return t + "." + e
    })
  }

  function Ea(t, e) {
    return 1 === e ? [t] : Ia(t, e)
  }

  function Aa() {
    var t, e, n, r, a, i, s, u, l, c;
    return 2 === o().getNumber("WEBGL_VERSION") ? (t = "#version 300 es", e = "in", n = "out", r = "in", a = "texture", i = "outputColor", s = "out vec4 outputColor;", u = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", l = "", c = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t = "", e = "attribute", n = "varying", r = "varying", a = "texture2D", i = "gl_FragColor", s = "", u = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", l = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", c = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
      version: t,
      attribute: e,
      varyingVs: n,
      varyingFs: r,
      texture2D: a,
      output: i,
      defineOutput: s,
      defineSpecialNaN: u,
      defineSpecialInf: l,
      defineRound: c
    }
  }

  function Ra(t, e, n) {
    void 0 === n && (n = "index");
    var r = K(e);
    return r.map(function (e, a) {
      return "int " + t[a] + " = " + n + " / " + e + "; " + (a === r.length - 1 ? "int " + t[a + 1] + " = " + n + " - " + t[a] + " * " + e : "index -= " + t[a] + " * " + e) + ";"
    }).join("")
  }

  function Ta(t) {
    var e = K(t).map(function (t) {
      return t.toString()
    });
    return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e[0] + " + coords.y * " + e[1] + " + coords.z;\n  }\n"
  }
  var Da = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";

  function Oa(t, e, n, r) {
    var a = [];
    t.forEach(function (t) {
      var e = N(t.shapeInfo.logicalShape);
      t.shapeInfo.isUniform ? a.push("uniform float " + t.name + (e > 1 ? "[" + e + "]" : "") + ";") : (a.push("uniform sampler2D " + t.name + ";"), a.push("uniform int offset" + t.name + ";"))
    });
    var i, o, s = a.join("\n"),
      u = t.map(function (t) {
        return function (t, e, n) {
          void 0 === n && (n = !1);
          var r = "";
          r += n ? function t(e) {
            var n, r, a;
            switch (e.shapeInfo.logicalShape.length) {
              case 0:
                return n = e.name, r = "get" + n.charAt(0).toUpperCase() + n.slice(1), a = Aa(), "\n    vec4 " + r + "() {\n      return " + a.texture2D + "(" + n + ", halfCR);\n    }\n  ";
              case 1:
                return function (t) {
                  var e = t.name,
                    n = "get" + e.charAt(0).toUpperCase() + e.slice(1),
                    r = t.shapeInfo.texShape,
                    a = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],
                    i = Aa();
                  return "\n    vec4 " + n + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + a[0] + ", " + a[1] + ", index);\n      return " + i.texture2D + "(" + e + ", uv);\n    }\n  "
                }(e);
              case 2:
                return function (t) {
                  var e = t.shapeInfo.logicalShape,
                    n = t.name,
                    r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
                    a = t.shapeInfo.texShape,
                    i = a[0],
                    o = a[1],
                    s = Aa();
                  if (null != a && S(e, a)) return "\n      vec4 " + r + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + o + ".0, " + i + ".0);\n\n        return " + s.texture2D + "(" + n + ", uv);\n      }\n    ";
                  var u = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)],
                    l = Math.ceil(e[1] / 2);
                  return "\n    vec4 " + r + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + l + ", " + u[0] + ", " + u[1] + ", row, col);\n      return " + s.texture2D + "(" + n + ", uv);\n    }\n  "
                }(e);
              case 3:
                return function (e) {
                  var n = e.shapeInfo.logicalShape,
                    r = e.name,
                    a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                    i = e.shapeInfo.texShape,
                    o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
                  if (1 === n[0]) {
                    var s = n.slice(1),
                      u = Wa(e, s);
                    return "\n        " + t(u) + "\n        vec4 " + a + "(int b, int row, int col) {\n          return " + a + "(" + Va(["b", "row", "col"], [1, 2]) + ");\n        }\n      "
                  }
                  var l = o[0],
                    c = o[1],
                    p = Math.ceil(n[2] / 2),
                    h = p * Math.ceil(n[1] / 2),
                    f = Aa();
                  return "\n    vec4 " + a + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + l + ", " + c + ", " + h + ", " + p + ", b, row, col);\n      return " + f.texture2D + "(" + r + ", uv);\n    }\n  "
                }(e);
              default:
                return function (t) {
                  for (var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, a = "get" + r.charAt(0).toUpperCase() + r.slice(1), i = t.shapeInfo.texShape, o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)], s = o[0], u = o[1], l = Math.ceil(e[n - 1] / 2), c = l * Math.ceil(e[n - 2] / 2), p = "int b, int row, int col", h = "b * " + c + " + (row / 2) * " + l + " + (col / 2)", f = 2; f < n - 1; f++) p = "int b" + f + ", " + p, c *= e[n - f - 1], h = "b" + f + " * " + c + " + " + h;
                  var d = Aa();
                  return "\n    vec4 " + a + "(" + p + ") {\n      int index = " + h + ";\n      int texR = index / " + u + ";\n      int texC = index - texR * " + u + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u + ", " + s + ");\n      return " + d.texture2D + "(" + r + ", uv);\n    }\n  "
                }(e)
            }
          }(t) : function t(e) {
            var n = e.shapeInfo.logicalShape;
            switch (n.length) {
              case 0:
                return function (t) {
                  var e = t.name,
                    n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
                  if (t.shapeInfo.isUniform) return "float " + n + "() {return " + e + ";}";
                  var r = t.shapeInfo.texShape,
                    a = r[0],
                    i = r[1];
                  if (1 === a && 1 === i) return "\n      float " + n + "() {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
                  var o = t.shapeInfo.texShape,
                    s = o[0],
                    u = o[1],
                    l = La(e);
                  return "\n    float " + n + "() {\n      vec2 uv = uvFromFlat(" + s + ", " + u + ", " + l + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  "
                }(e);
              case 1:
                return function (t) {
                  var e = t.name,
                    n = "get" + e.charAt(0).toUpperCase() + e.slice(1);
                  if (t.shapeInfo.isUniform) return "\n      float " + n + "(int index) {\n        " + Ba(t) + "\n      }\n    ";
                  var r = t.shapeInfo.texShape,
                    a = r[0],
                    i = r[1];
                  if (1 === i && 1 === a) return "\n      float " + n + "(int index) {\n        return sampleTexture(" + e + ", halfCR);\n      }\n    ";
                  var o = La(e);
                  return 1 === i ? "\n      float " + n + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + o + ") + 0.5) / " + a + ".0);\n        return sampleTexture(" + e + ", uv);\n      }\n    " : 1 === a ? "\n      float " + n + "(int index) {\n        vec2 uv = vec2((float(index + " + o + ") + 0.5) / " + i + ".0, 0.5);\n        return sampleTexture(" + e + ", uv);\n      }\n    " : "\n    float " + n + "(int index) {\n      vec2 uv = uvFromFlat(" + a + ", " + i + ", index + " + o + ");\n      return sampleTexture(" + e + ", uv);\n    }\n  "
                }(e);
              case 2:
                return function (e) {
                  var n = e.shapeInfo.logicalShape,
                    r = e.name,
                    a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                    i = e.shapeInfo.texShape;
                  if (null != i && S(n, i)) {
                    var o = i[0],
                      s = i[1];
                    return "\n    float " + a + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + s + ".0, " + o + ".0);\n      return sampleTexture(" + r + ", uv);\n    }\n  "
                  }
                  var u = O(n),
                    l = u.newShape,
                    c = u.keptDims,
                    p = l;
                  if (p.length < n.length) {
                    var h = Wa(e, p);
                    return "\n      " + t(h) + "\n      float " + a + "(int row, int col) {\n        return " + a + "(" + Va(["row", "col"], c) + ");\n      }\n    "
                  }
                  if (e.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + n[1] + ", 1)));\n        " + Ba(e) + "\n      }\n    ";
                  var f = i[0],
                    d = i[1],
                    m = La(r);
                  return 1 === d ? "\n    float " + a + "(int row, int col) {\n      float index = dot(vec3(row, col, " + m + "), vec3(" + n[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f + ".0);\n      return sampleTexture(" + r + ", uv);\n    }\n  " : 1 === f ? "\n    float " + a + "(int row, int col) {\n      float index = dot(vec3(row, col, " + m + "), vec3(" + n[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + d + ".0, 0.5);\n      return sampleTexture(" + r + ", uv);\n    }\n  " : "\n  float " + a + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + n[1] + " + col + " + m + ";\n    vec2 uv = uvFromFlat(" + f + ", " + d + ", index);\n    return sampleTexture(" + r + ", uv);\n  }\n"
                }(e);
              case 3:
                return function (e) {
                  var n = e.shapeInfo.logicalShape,
                    r = e.name,
                    a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                    i = n[1] * n[2],
                    o = n[2],
                    s = O(n),
                    u = s.newShape,
                    l = s.keptDims,
                    c = u;
                  if (c.length < n.length) {
                    var p = Wa(e, c);
                    return "\n        " + t(p) + "\n        float " + a + "(int row, int col, int depth) {\n          return " + a + "(" + Va(["row", "col", "depth"], l) + ");\n        }\n      "
                  }
                  if (e.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + i + ", " + o + ", 1)));\n        " + Ba(e) + "\n      }\n    ";
                  var h = e.shapeInfo.texShape,
                    f = h[0],
                    d = h[1],
                    m = e.shapeInfo.flatOffset;
                  if (d === i && null == m) return "\n        float " + a + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + o + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + d + ".0, " + f + ".0);\n          return sampleTexture(" + r + ", uv);\n        }\n      ";
                  if (d === o && null == m) return "\n    float " + a + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + n[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + d + ".0, " + f + ".0);\n      return sampleTexture(" + r + ", uv);\n    }\n  ";
                  var g = La(r);
                  return "\n      float " + a + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + i + " + col * " + o + " + depth + " + g + ";\n        vec2 uv = uvFromFlat(" + f + ", " + d + ", index);\n        return sampleTexture(" + r + ", uv);\n      }\n  "
                }(e);
              case 4:
                return function (e) {
                  var n = e.shapeInfo.logicalShape,
                    r = e.name,
                    a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                    i = n[3],
                    o = n[2] * i,
                    s = n[1] * o,
                    u = O(n),
                    l = u.newShape,
                    c = u.keptDims;
                  if (l.length < n.length) {
                    var p = Wa(e, l);
                    return "\n      " + t(p) + "\n      float " + a + "(int row, int col, int depth, int depth2) {\n        return " + a + "(" + Va(["row", "col", "depth", "depth2"], c) + ");\n      }\n    "
                  }
                  if (e.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + s + ", " + o + ", " + i + ", 1)));\n        " + Ba(e) + "\n      }\n    ";
                  var h = e.shapeInfo.flatOffset,
                    f = e.shapeInfo.texShape,
                    d = f[0],
                    m = f[1];
                  if (m === s && null == h) return "\n      float " + a + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + o + ", " + i + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m + ".0, " + d + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                  if (m === i && null == h) return "\n      float " + a + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + n[1] * n[2] + ", " + n[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m + ".0, " + d + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                  var g = La(r);
                  return "\n    float " + a + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s + " + col * " + o + " +\n          depth * " + i + " + depth2;\n      vec2 uv = uvFromFlat(" + d + ", " + m + ", index + " + g + ");\n      return sampleTexture(" + r + ", uv);\n    }\n  "
                }(e);
              case 5:
                return function (e) {
                  var n = e.shapeInfo.logicalShape,
                    r = e.name,
                    a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                    i = n[4],
                    o = n[3] * i,
                    s = n[2] * o,
                    u = n[1] * s,
                    l = O(n),
                    c = l.newShape,
                    p = l.keptDims;
                  if (c.length < n.length) {
                    var h = Wa(e, c);
                    return "\n      " + t(h) + "\n      float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + a + "(" + Va(["row", "col", "depth", "depth2", "depth3"], p) + ");\n      }\n    "
                  }
                  if (e.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + u + ", " + s + ", " + o + ", " + i + ")) +\n          depth3;\n        " + Ba(e) + "\n      }\n    ";
                  var f = e.shapeInfo.flatOffset,
                    d = e.shapeInfo.texShape,
                    m = d[0],
                    g = d[1];
                  if (g === u && null == f) return "\n      float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + s + ", " + o + ", " + i + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + g + ".0, " + m + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                  if (g === i && null == f) return "\n      float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + n[1] * n[2] * n[3] + ",\n               " + n[2] * n[3] + ", " + n[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + g + ".0, " + m + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                  var v = La(r);
                  return "\n    float " + a + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + u + " + col * " + s + " + depth * " + o + " +\n          depth2 * " + i + " + depth3 + " + v + ";\n      vec2 uv = uvFromFlat(" + m + ", " + g + ", index);\n      return sampleTexture(" + r + ", uv);\n    }\n  "
                }(e);
              case 6:
                return function (e) {
                  var n = e.shapeInfo.logicalShape,
                    r = e.name,
                    a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                    i = O(n),
                    o = i.newShape,
                    s = i.keptDims;
                  if (o.length < n.length) {
                    var u = Wa(e, o);
                    return "\n      " + t(u) + "\n      float " + a + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + a + "(" + Va(["row", "col", "depth", "depth2", "depth3", "depth4"], s) + ");\n      }\n    "
                  }
                  var l = n[5],
                    c = n[4] * l,
                    p = n[3] * c,
                    h = n[2] * p,
                    f = n[1] * h;
                  if (e.shapeInfo.isUniform) return "\n      float " + a + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f + ", " + h + ", " + p + ", " + c + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + l + ", 1)));\n        " + Ba(e) + "\n      }\n    ";
                  var d = e.shapeInfo.flatOffset,
                    m = e.shapeInfo.texShape,
                    g = m[0],
                    v = m[1];
                  if (v === f && null == d) return "\n      float " + a + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h + ", " + p + ", " + c + ", " + l + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v + ".0, " + g + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                  if (v === l && null == d) return "\n      float " + a + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + n[1] * n[2] * n[3] * n[4] + ",\n               " + n[2] * n[3] * n[4] + ",\n               " + n[3] * n[4] + ",\n               " + n[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v + ".0, " + g + ".0);\n        return sampleTexture(" + r + ", uv);\n      }\n    ";
                  var y = La(r);
                  return "\n    float " + a + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f + " + col * " + h + " + depth * " + p + " +\n          depth2 * " + c + " + depth3 * " + l + " + depth4 + " + y + ";\n      vec2 uv = uvFromFlat(" + g + ", " + v + ", index);\n      return sampleTexture(" + r + ", uv);\n    }\n  "
                }(e);
              default:
                throw new Error(n.length + "-D input sampling is not yet supported")
            }
          }(t);
          var a = t.shapeInfo.logicalShape,
            i = e.logicalShape;
          return a.length <= i.length && (r += n ? function (t, e) {
            var n, r = t.name,
              a = r.charAt(0).toUpperCase() + r.slice(1),
              i = "get" + a + "AtOutCoords",
              o = t.shapeInfo.logicalShape.length,
              s = e.logicalShape.length,
              u = qr(t.shapeInfo.logicalShape, e.logicalShape),
              l = Pa(s),
              c = s - o,
              p = ["x", "y", "z", "w", "u", "v"];
            n = 0 === o ? "" : s < 2 && u.length >= 1 ? "coords = 0;" : u.map(function (t) {
              return "coords." + p[t + c] + " = 0;"
            }).join("\n");
            var h;
            h = s < 2 && o > 0 ? "coords" : t.shapeInfo.logicalShape.map(function (t, e) {
              return "coords." + p[e + c]
            }).join(", ");
            var f = "return outputValue;",
              d = 1 === N(t.shapeInfo.logicalShape),
              m = 1 === N(e.logicalShape);
            if (1 !== o || d || m) {
              if (d && !m) f = 1 === s ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
              else if (u.length) {
                var g = o - 2,
                  v = o - 1;
                u.indexOf(g) > -1 && u.indexOf(v) > -1 ? f = "return vec4(outputValue.x);" : u.indexOf(g) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u.indexOf(v) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);")
              }
            } else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
            return "\n    vec4 " + i + "() {\n      " + l + " coords = getOutputCoords();\n      " + n + "\n      vec4 outputValue = get" + a + "(" + h + ");\n      " + f + "\n    }\n  "
          }(t, e) : function (t, e) {
            var n = t.name,
              r = n.charAt(0).toUpperCase() + n.slice(1),
              a = "get" + r + "AtOutCoords",
              i = e.texShape,
              o = t.shapeInfo.texShape,
              s = t.shapeInfo.logicalShape.length,
              u = e.logicalShape.length;
            if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && S(o, i)) return "\n      float " + a + "() {\n        return sampleTexture(" + n + ", resultUV);\n      }\n    ";
            var l = Pa(u),
              c = qr(t.shapeInfo.logicalShape, e.logicalShape),
              p = u - s,
              h = ["x", "y", "z", "w", "u", "v"];
            return "\n    float " + a + "() {\n      " + l + " coords = getOutputCoords();\n      " + (0 === s ? "" : u < 2 && c.length >= 1 ? "coords = 0;" : c.map(function (t) {
              return "coords." + h[t + p] + " = 0;"
            }).join("\n")) + "\n      return get" + r + "(" + (u < 2 && s > 0 ? "coords" : t.shapeInfo.logicalShape.map(function (t, e) {
              return "coords." + h[e + p]
            }).join(", ")) + ");\n    }\n  "
          }(t, e)), r
        }(t, e, r)
      }).join("\n"),
      l = e.texShape,
      c = Aa(),
      p = "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + c.texture2D + "(textureSampler, uv).r;\n    }\n  ",
      h = function (t) {
        return t.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t.varyingFs + " vec2 resultUV;\n    " + t.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t.defineSpecialNaN + "\n    " + t.defineSpecialInf + "\n    " + t.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + _a + "\n    " + Fa + "\n    " + Ma + "\n  "
      }(c);
    return e.isPacked ? (i = function (t, e) {
      switch (t.length) {
        case 0:
          return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
        case 1:
          return function (t, e) {
            var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
            return 1 === n[0] ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n[1] + ".0);\n      }\n    " : 1 === n[1] ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n[0] + ".0);\n      }\n    " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      return 2 * (resTexRC.x * " + n[1] + " + resTexRC.y);\n    }\n  "
          }(0, e);
        case 2:
          return function (t, e) {
            var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];
            if (S(t, e)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n[0] + ", " + n[1] + "));\n      }\n    ";
            var r = Math.ceil(t[1] / 2);
            return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec2(r, c);\n    }\n  "
          }(t, e);
        case 3:
          return n = t, r = e, a = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], o = (i = Math.ceil(n[2] / 2)) * Math.ceil(n[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + a[0] + ", " + a[1] + "));\n      int index = resTexRC.x * " + a[1] + " + resTexRC.y;\n\n      int b = index / " + o + ";\n      index -= b * " + o + ";\n\n      int r = 2 * (index / " + i + ");\n      int c = imod(index, " + i + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
        default:
          return function (t, e) {
            for (var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], r = Math.ceil(t[t.length - 1] / 2), a = r * Math.ceil(t[t.length - 2] / 2), i = a, o = "", s = "b, r, c", u = 2; u < t.length - 1; u++) o = "\n      int b" + u + " = index / " + (i *= t[t.length - u - 1]) + ";\n      index -= b" + u + " * " + i + ";\n    " + o, s = "b" + u + ", " + s;
            return "\n    ivec" + t.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n\n      " + o + "\n\n      int b = index / " + a + ";\n      index -= b * " + a + ";\n\n      int r = 2 * (index / " + r + ");\n      int c = imod(index, " + r + ") * 2;\n\n      return ivec" + t.length + "(" + s + ");\n    }\n  "
          }(t, e)
      }
      var n, r, a, i, o
    }(e.logicalShape, l), o = "\n    void setOutput(vec4 val) {\n      " + c.output + " = val;\n    }\n  ") : (i = function (t, e) {
      switch (t.length) {
        case 0:
          return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
        case 1:
          return function (t, e) {
            return 1 === e[0] ? "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e[1] + ".0);\n      }\n    " : 1 === e[1] ? "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e[0] + ".0);\n      }\n    " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      return resTexRC.x * " + e[1] + " + resTexRC.y;\n    }\n  "
          }(0, e);
        case 2:
          return function (t, e) {
            return S(t, e) ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e[0] + ", " + e[1] + "));\n      }\n    " : 1 === t[1] ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : 1 === t[0] ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e[0] + ", " + e[1] + "));\n        int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      int r = index / " + t[1] + ";\n      int c = index - r * " + t[1] + ";\n      return ivec2(r, c);\n    }\n  "
          }(t, e);
        case 3:
          return n = e, r = Ra(["r", "c", "d"], t), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n[0] + ", " + n[1] + "));\n      int index = resTexRC.x * " + n[1] + " + resTexRC.y;\n      " + r + "\n      return ivec3(r, c, d);\n    }\n  ";
        case 4:
          return function (t, e) {
            var n = Ra(["r", "c", "d", "d2"], t);
            return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n      " + n + "\n      return ivec4(r, c, d, d2);\n    }\n  "
          }(t, e);
        case 5:
          return function (t, e) {
            var n = Ra(["r", "c", "d", "d2", "d3"], t);
            return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e[0] + ",\n                             " + e[1] + "));\n\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "
          }(t, e);
        case 6:
          return function (t, e) {
            var n = Ra(["r", "c", "d", "d2", "d3", "d4"], t);
            return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e[0] + ", " + e[1] + "));\n      int index = resTexRC.x * " + e[1] + " + resTexRC.y;\n\n      " + n + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "
          }(t, e);
        default:
          throw new Error(t.length + "-D output sampling is not yet supported")
      }
      var n, r
    }(e.logicalShape, l), o = "\n    void setOutput(float val) {\n      " + c.output + " = vec4(val, 0, 0, 0);\n    }\n  "), r && (h += za), [h, p, o, s, i, u, n].join("\n")
  }
  var _a = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Fa = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    Ma = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
    za = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

  function La(t) {
    return "offset" + t
  }

  function Ba(t) {
    var e = t.name,
      n = N(t.shapeInfo.logicalShape);
    return n < 2 ? "return " + e + ";" : "\n    for (int i = 0; i < " + n + "; i++) {\n      if (i == index) {\n        return " + e + "[i];\n      }\n    }\n  "
  }

  function Pa(t) {
    if (t <= 1) return "int";
    if (2 === t) return "ivec2";
    if (3 === t) return "ivec3";
    if (4 === t) return "ivec4";
    if (5 === t) return "ivec5";
    if (6 === t) return "ivec6";
    throw Error("GPU for rank " + t + " is not yet supported")
  }

  function Wa(t, e) {
    var n = JSON.parse(JSON.stringify(t));
    return n.shapeInfo.logicalShape = e, n
  }

  function Va(t, e) {
    return e.map(function (e) {
      return t[e]
    }).join(", ")
  }
  var Ua = function (t, e, n) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = Kr(e, n), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "
    },
    ja = "return a + b;",
    Ga = "return a - b;",
    qa = "return a * b;",
    Ha = "return (a < 0.) ? b * a : a;",
    Ka = function (t, e, n) {
      this.variableNames = ["A", "B"], this.outputShape = Kr(e, n), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "
    },
    Xa = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",
    $a = function (t, e, n, r) {
      void 0 === r && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Kr(e, n);
      var a = this.outputShape.length,
        i = "";
      if (r)
        if (0 === a || 1 === N(this.outputShape)) i = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
        else if (i = "\n          " + Pa(a) + " coords = getOutputCoords();\n        ", 1 === a) i += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
      else {
        var o = Ea("coords", a);
        i += "\n            bool nextRowOutOfBounds =\n              (" + o[a - 2] + " + 1) >= " + this.outputShape[a - 2] + ";\n            bool nextColOutOfBounds =\n              (" + o[a - 1] + " + 1) >= " + this.outputShape[a - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "
      }
      this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + i + "\n\n        setOutput(result);\n      }\n    "
    },
    Ya = function () {
      function t(t) {
        this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "
      }
      return t.prototype.getCustomSetupFunc = function (t, e) {
        var n = this;
        return function (r, a) {
          null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(a, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(a, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e)
        }
      }, t
    }(),
    Ja = function () {
      function t(t) {
        this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "
      }
      return t.prototype.getCustomSetupFunc = function (t, e) {
        var n = this;
        return function (r, a) {
          null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(a, "minVal"), n.maxLoc = r.getUniformLocationNoThrow(a, "maxVal")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e)
        }
      }, t
    }();

  function Za(t, e, n) {
    var r = t.indexOf(e);
    return t.map(function (t, e) {
      return e === r ? t + " - " + n : t
    }).join()
  }
  var Qa = function (t, e, n, r) {
      void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
      var a = t.padInfo.top,
        i = t.padInfo.left,
        o = t.strideHeight,
        s = t.strideWidth,
        u = t.dilationHeight,
        l = t.dilationWidth,
        c = t.filterHeight,
        p = t.filterWidth,
        h = 4 * Math.floor(t.inChannels / 4),
        f = t.inChannels % 4,
        d = "channelsLast" === t.dataFormat,
        m = d ? 1 : 2,
        g = d ? 2 : 3,
        v = d ? 3 : 1,
        y = "",
        b = "";
      n && (y = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", b = "result = activation(result);");
      var x = e ? "result += getBiasAtOutCoords();" : "";
      e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y + "\n\n      const ivec2 strides = ivec2(" + o + ", " + s + ");\n      const ivec2 pads = ivec2(" + a + ", " + i + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + v + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + m + "], coords[" + g + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + c + "; wR++) {\n          int xR = xRCorner + wR * " + u + ";\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + p + "; wC++) {\n            int xC = xCCorner + wC * " + l + ";\n\n            if (xC < 0 || xC >= " + t.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + h + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + d + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === f) + ") {\n\n              if (" + d + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + h + ") *\n                    getW(wR, wC, " + h + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + h + ", xR, xC) *\n                    getW(wR, wC, " + h + ", d2);\n              }\n\n            } else if (" + (2 === f) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + h + ", d2),\n                getW(wR, wC, " + h + " + 1, d2)\n              );\n\n              if (" + d + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + h + "),\n                  getX(batch, xR, xC, " + h + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + h + ", xR, xC),\n                  getX(batch, " + h + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === f) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + h + ", d2),\n                getW(wR, wC, " + h + " + 1, d2),\n                getW(wR, wC, " + h + " + 2, d2)\n              );\n\n              if (" + d + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + h + "),\n                  getX(batch, xR, xC, " + h + " + 1),\n                  getX(batch, xR, xC, " + h + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + h + ", xR, xC),\n                  getX(batch, " + h + " + 1, xR, xC),\n                  getX(batch, " + h + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + x + "\n        " + b + "\n        setOutput(result);\n      }\n    "
    },
    ti = function (t, e, n, r) {
      void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
      var a = t.inHeight,
        i = t.inWidth,
        o = t.padInfo.top,
        s = t.padInfo.left,
        u = t.strideHeight,
        l = t.strideWidth,
        c = t.dilationHeight,
        p = t.dilationWidth,
        h = t.filterHeight,
        f = t.filterWidth,
        d = t.outChannels / t.inChannels,
        m = "",
        g = "";
      n && (m = r ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "\n          float activation(float x) {\n            " + n + "\n          }\n        ", g = "result = activation(result);");
      var v = e ? "result += getBiasAtOutCoords();" : "";
      e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + m + "\n\n      const ivec2 strides = ivec2(" + u + ", " + l + ");\n      const ivec2 pads = ivec2(" + o + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + d + ";\n        int q = d2 - d1 * " + d + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + h + "; wR++) {\n          int xR = xRCorner + wR * " + c + ";\n\n          if (xR < 0 || xR >= " + a + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + f + "; wC++) {\n            int xC = xCCorner + wC * " + p + ";\n\n            if (xC < 0 || xC >= " + i + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + v + "\n        " + g + "\n        setOutput(result);\n      }\n    "
    },
    ei = function (t, e, n, r) {
      void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;
      for (var a = t.inHeight, i = t.inWidth, o = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, l = t.strideWidth, c = t.dilationHeight, p = t.dilationWidth, h = t.filterHeight, f = t.filterWidth, d = f, m = "int xR; int xC; int xCOffset;", g = 0; g < h; g++)
        for (var y = 0; y < f; y++) m += "\n          vec4 xTexelR" + g + "C" + 2 * y + " = vec4(0.);\n          vec4 wR" + g + "C" + y + " = vec4(0.);\n          vec4 xR" + g + "C" + y + " = vec4(0.);";
      for (g = 0; g < h; g++)
        for (var b = 0; b < d; b++) {
          if (m += "\n          xR = xRCorner + " + g * c + ";\n          xC = xCCorner + " + (y = 2 * b) * p + ";\n        ", 1 === l) {
            if (y < f && (m += s % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + a + " && xCOffset >= 0 && xCOffset < " + i + ") {\n                  xTexelR" + g + "C" + y + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g + "C" + y + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + a + " && xCOffset >= 0 && xCOffset < " + i + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR" + g + "C" + y + " = vec4(previous.zw, xTexelR" + g + "C" + y + ".xy);\n                } else {\n                  xR" + g + "C" + y + " = vec4(0, 0, xTexelR" + g + "C" + y + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + a + " && xC >= 0 && xC < " + i + ") {\n                  xTexelR" + g + "C" + y + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g + "C" + y + " = vec4(0.);\n                }\n\n                xR" + g + "C" + y + " = xTexelR" + g + "C" + y + ";\n              ", y + 1 < f)) {
              var x = s % 2 == 0 ? v(p) : p;
              p % 2 == 0 && s % 2 == 1 || p % 2 != 0 && s % 2 != 1 ? (m += "\n                  xCOffset = xC + " + s % 2 + " + " + x + ";\n\n                  if(xR >= 0 && xR < " + a + " &&\n                    xCOffset >= 0 && xCOffset < " + i + ") {\n                    xTexelR" + g + "C" + (y + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", p > 1 && (m += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + a + " &&\n                      xCOffset >= 0 && xCOffset < " + i + ") {\n                      xTexelR" + g + "C" + y + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + g + "C" + y + " = vec4(0.);\n                    }\n                  "), m += "\n                  xR" + g + "C" + (y + 1) + " = vec4(\n                    xTexelR" + g + "C" + y + ".zw, xTexelR" + g + "C" + (y + 2) + ".xy);\n                ") : m += "\n                  xCOffset = xC + " + x + ";\n\n                  if(xR >= 0 && xR < " + a + " &&\n                    xCOffset >= 0 && xCOffset < " + i + ") {\n                    xTexelR" + g + "C" + (y + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + g + "C" + (y + 1) + " = xTexelR" + g + "C" + (y + 2) + ";\n                "
            }
          } else y < f && (m += "\n              if(xR >= 0 && xR < " + a + ") {\n            ", s % 2 == 1 ? (m += "\n                xCOffset = xC + 1 - " + l + ";\n                if(xCOffset >= 0 && xCOffset < " + i + ") {\n                  xTexelR" + g + "C" + y + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g + "C" + y + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + i + ") {\n                  xTexelR" + g + "C" + (y + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + g + "C" + (y + 2) + " = vec4(0.);\n                }\n\n                xR" + g + "C" + y + " = vec4(\n                  xTexelR" + g + "C" + y + ".zw, xTexelR" + g + "C" + (y + 2) + ".zw);\n              ", y + 1 < f && (m += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + l + ";\n                  if(xCOffset >= 0 && xCOffset < " + i + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + g + "C" + (y + 1) + " = vec4(xTexelR" + g + "C" + (y + 2) + ".xy, final.xy);\n                ")) : (m += "\n                if(xC >= 0 && xC < " + i + ") {\n                  xTexelR" + g + "C" + y + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g + "C" + y + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + l + ";\n                if(xCOffset >= 0 && xCOffset < " + i + ") {\n                  xTexelR" + g + "C" + (y + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g + "C" + (y + 2) + " = vec4(0.);\n                }\n\n                xR" + g + "C" + y + " = vec4(\n                  xTexelR" + g + "C" + y + ".xy, xTexelR" + g + "C" + (y + 2) + ".xy);\n              ", y + 1 < f && (m += "\n                  xR" + g + "C" + (y + 1) + " = vec4(\n                    xTexelR" + g + "C" + y + ".zw, xTexelR" + g + "C" + (y + 2) + ".zw);\n                ")), m += "}");
          y < f && (m += "\n            vec4 wTexelR" + g + "C" + y + " = getW(" + g + ", " + y + ", d1, q);\n            wR" + g + "C" + y + " = vec4(wTexelR" + g + "C" + y + ".xz, wTexelR" + g + "C" + y + ".xz);\n          ", y + 1 < f && (m += "\n              vec4 wTexelR" + g + "C" + (y + 1) + " = getW(" + g + ", " + (y + 1) + ", d1, q);\n              wR" + g + "C" + (y + 1) + " =\n                vec4(wTexelR" + g + "C" + (y + 1) + ".xz, wTexelR" + g + "C" + (y + 1) + ".xz);"))
        }
      for (g = 0; g < h; g++)
        for (y = 0; y < f; y++) m += "dotProd += xR" + g + "C" + y + " * wR" + g + "C" + y + ";";
      var w = "",
        C = "";
      n && (w = r ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n + "\n        }" : "vec4 activation(vec4 x) {\n          " + n + "\n        }", C = "result = activation(result);");
      var N = e ? "result += getBiasAtOutCoords();" : "";
      e && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w + "\n\n      const ivec2 strides = ivec2(" + u + ", " + l + ");\n      const ivec2 pads = ivec2(" + o + ", " + s + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + m + "\n\n        vec4 result = dotProd;\n        " + N + "\n        " + C + "\n        setOutput(result);\n      }\n    "
    };

  function ni(t, e) {
    if (1 === t) return "" + e;
    if (2 === t) return e + ".y";
    if (3 === t) return e + ".z";
    if (4 === t) return e + ".w";
    throw Error("Cumulative sum for rank " + t + " is not yet supported")
  }
  var ri = function () {
      function t(t, e, n) {
        this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e + ";\n      int offset_h = imod(h, " + e + ");\n      int in_w = w / " + e + ";\n      int offset_w = imod(w, " + e + ");\n      int offset_d = (offset_h * " + e + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  "
      }
      return t.prototype.getHeightCoordString = function () {
        return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]"
      }, t.prototype.getWidthCoordString = function () {
        return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]"
      }, t.prototype.getDepthCoordString = function () {
        return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]"
      }, t.prototype.getOutputDepthSize = function () {
        return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
      }, t.prototype.getInputSamplingString = function () {
        return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)"
      }, t
    }(),
    ai = function (t, e, n) {
      this.variableNames = ["real", "imag"];
      var r = e[1];
      this.outputShape = e;
      var a = n ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI,
        i = n ? r + ".0" : "1.0";
      this.userCode = "\n      const float exponentMultiplier = " + a + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + i + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "
    },
    ii = function () {
      function t(t, e) {
        this.outputShape = [], this.variableNames = ["x"], this.outputShape = t, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "
      }
      return t.prototype.getCustomSetupFunc = function (t) {
        var e = this;
        return function (n, r) {
          null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, "value")), n.gl.uniform1f(e.valueLoc, t)
        }
      }, t
    }();

  function oi(t, e) {
    var n = Aa();
    return Jt(t, e, n.version + "\n    precision highp float;\n    " + n.attribute + " vec3 clipSpacePos;\n    " + n.attribute + " vec2 uv;\n    " + n.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")
  }

  function si(t, e) {
    return ie(t, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]))
  }

  function ui(t, e) {
    return oe(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]))
  }

  function li(t, e, n, r, a, i, o) {
    ue(n, r);
    var s = se(t, e),
      u = t.TEXTURE_2D;
    return qt(t, e, function () {
      return t.bindTexture(u, s)
    }), qt(t, e, function () {
      return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE)
    }), qt(t, e, function () {
      return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)
    }), qt(t, e, function () {
      return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST)
    }), qt(t, e, function () {
      return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST)
    }), qt(t, e, function () {
      return t.texImage2D(u, 0, a, n, r, 0, i, o, null)
    }), qt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, null)
    }), s
  }

  function ci(t, e, n, r, a) {
    var i = Vt(n, r);
    return li(t, e, i[0], i[1], a.internalFormatFloat, a.textureFormatFloat, t.FLOAT)
  }

  function pi(t, e, n, r, a) {
    var i = Vt(n, r);
    return li(t, e, i[0], i[1], a.internalFormatHalfFloat, a.textureFormatFloat, a.textureTypeHalfFloat)
  }

  function hi(t, e, n, r, a) {
    var i = Vt(n, r);
    return li(t, e, i[0], i[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE)
  }

  function fi(t, e, n, r, a) {
    var i = jt(n, r);
    return li(t, e, i[0], i[1], a.internalFormatPackedFloat, t.RGBA, t.FLOAT)
  }

  function di(t, e, n, r, a) {
    var i = jt(n, r);
    return li(t, e, i[0], i[1], a.internalFormatPackedHalfFloat, t.RGBA, a.textureTypeHalfFloat)
  }

  function mi(t, e, n, r) {
    return qt(t, e, function () {
      return t.bindBuffer(t.ARRAY_BUFFER, r)
    }), ce(t, e, n, "clipSpacePos", r, 3, 20, 0) && ce(t, e, n, "uv", r, 2, 20, 12)
  }

  function gi(t, e, n, r, a, i, o) {
    var s, u, l;
    qt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, n)
    }), i instanceof Uint8Array ? (s = new Uint8Array(r * a * 4), u = t.UNSIGNED_BYTE, l = t.RGBA) : (s = new Float32Array(r * a * 4), u = t.FLOAT, l = o.internalFormatPackedFloat), s.set(i), qt(t, e, function () {
      return t.texImage2D(t.TEXTURE_2D, 0, l, r, a, 0, t.RGBA, u, s)
    }), qt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, null)
    })
  }

  function vi(t, e, n, r) {
    qt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, n)
    }), r.data instanceof Uint8Array ? qt(t, e, function () {
      return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data)
    }) : qt(t, e, function () {
      return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r)
    }), qt(t, e, function () {
      return t.bindTexture(t.TEXTURE_2D, null)
    })
  }

  function yi(t, e, n, r, a) {
    var i = t.createBuffer();
    qt(t, e, function () {
      return t.bindBuffer(t.PIXEL_PACK_BUFFER, i)
    });
    var o = 16 * n * r;
    return qt(t, e, function () {
      return t.bufferData(t.PIXEL_PACK_BUFFER, o, t.STREAM_READ)
    }), qt(t, e, function () {
      return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0)
    }), qt(t, e, function () {
      return t.bindBuffer(t.PIXEL_PACK_BUFFER, null)
    }), i
  }

  function bi(t, e, n) {
    var r = t,
      a = new Float32Array(n);
    return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, a), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), a
  }

  function xi(t, e, n, r, a) {
    var i = Vt(n, r),
      o = i[0],
      s = i[1],
      u = new Uint8Array(n * r * 4);
    return qt(t, e, function () {
      return t.readPixels(0, 0, o, s, a.downloadTextureFormat, t.UNSIGNED_BYTE, u)
    }), new Float32Array(u.buffer)
  }

  function wi(t, e, n, r, a, i, o, s) {
    var u = t,
      l = new Float32Array(function (t, e) {
        var n = jt(i, o);
        return n[0] * n[1] * 4
      }());
    return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, l), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), l
  }

  function Ci(t, e, n, r) {
    var a = new Float32Array(n * r * 4);
    return qt(t, e, function () {
      return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, a)
    }), a
  }
  var Ni = Object.freeze({
      createVertexShader: oi,
      createVertexBuffer: si,
      createIndexBuffer: ui,
      createFloat32MatrixTexture: ci,
      createFloat16MatrixTexture: pi,
      createUnsignedBytesMatrixTexture: hi,
      createPackedMatrixTexture: fi,
      createFloat16PackedMatrixTexture: di,
      bindVertexProgramAttributeStreams: mi,
      uploadDenseMatrixToTexture: gi,
      uploadPixelDataToTexture: vi,
      createBufferFromOutputTexture: yi,
      downloadFloat32MatrixFromBuffer: bi,
      downloadByteEncodedFloatMatrixFromOutputTexture: xi,
      downloadPackedMatrixFromBuffer: wi,
      downloadMatrixFromPackedOutputTexture: Ci
    }),
    Si = function () {
      function t(t) {
        this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
        var e = o().getNumber("WEBGL_VERSION");
        null != t ? (this.gl = t, Pt(e, t)) : this.gl = Wt(e);
        var n = "WEBGL_color_buffer_float";
        if (1 === o().getNumber("WEBGL_VERSION")) {
          if (this.textureFloatExtension = Yt(this.gl, this.debug, "OES_texture_float"), Te(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = Yt(this.gl, this.debug, "OES_texture_half_float");
          else if (o().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
          if (this.colorBufferFloatExtension = this.gl.getExtension(n), Te(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = Yt(this.gl, this.debug, "EXT_color_buffer_half_float");
          else if (o().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")
        } else if (n = "EXT_color_buffer_float", Te(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);
        else {
          if (!Te(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
          this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float")
        }
        this.vertexBuffer = si(this.gl, this.debug), this.indexBuffer = ui(this.gl, this.debug), this.framebuffer = le(this.gl, this.debug), this.textureConfig = Gt(this.gl, this.textureHalfFloatExtension)
      }
      return Object.defineProperty(t.prototype, "debug", {
        get: function () {
          return o().getBool("DEBUG")
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.dispose = function () {
        var t = this;
        if (!this.disposed) {
          null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
          var e = this.gl;
          qt(e, this.debug, function () {
            return e.finish()
          }), qt(e, this.debug, function () {
            return e.bindFramebuffer(e.FRAMEBUFFER, null)
          }), qt(e, this.debug, function () {
            return e.deleteFramebuffer(t.framebuffer)
          }), qt(e, this.debug, function () {
            return e.bindBuffer(e.ARRAY_BUFFER, null)
          }), qt(e, this.debug, function () {
            return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)
          }), qt(e, this.debug, function () {
            return e.deleteBuffer(t.indexBuffer)
          }), this.disposed = !0
        }
      }, t.prototype.createFloat32MatrixTexture = function (t, e) {
        return this.throwIfDisposed(), ci(this.gl, this.debug, t, e, this.textureConfig)
      }, t.prototype.createFloat16MatrixTexture = function (t, e) {
        return this.throwIfDisposed(), pi(this.gl, this.debug, t, e, this.textureConfig)
      }, t.prototype.createUnsignedBytesMatrixTexture = function (t, e) {
        return this.throwIfDisposed(), hi(this.gl, this.debug, t, e, this.textureConfig)
      }, t.prototype.uploadPixelDataToTexture = function (t, e) {
        this.throwIfDisposed(), vi(this.gl, this.debug, t, e)
      }, t.prototype.uploadDenseMatrixToTexture = function (t, e, n, r) {
        this.throwIfDisposed(), gi(this.gl, this.debug, t, e, n, r, this.textureConfig)
      }, t.prototype.createFloat16PackedMatrixTexture = function (t, e) {
        return this.throwIfDisposed(), di(this.gl, this.debug, t, e, this.textureConfig)
      }, t.prototype.createPackedMatrixTexture = function (t, e) {
        return this.throwIfDisposed(), fi(this.gl, this.debug, t, e, this.textureConfig)
      }, t.prototype.deleteMatrixTexture = function (t) {
        var e = this;
        this.throwIfDisposed(), this.outputTexture === t && (ge(this.gl, this.debug, this.framebuffer), this.outputTexture = null), qt(this.gl, this.debug, function () {
          return e.gl.deleteTexture(t)
        })
      }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (t, e, n) {
        var r = this;
        return this.downloadMatrixDriver(t, function () {
          return xi(r.gl, r.debug, e, n, r.textureConfig)
        })
      }, t.prototype.downloadPackedMatrixFromBuffer = function (t, e, n, r, a, i) {
        return wi(this.gl, t, 0, 0, 0, a, i, this.textureConfig)
      }, t.prototype.downloadFloat32MatrixFromBuffer = function (t, e) {
        return bi(this.gl, t, e)
      }, t.prototype.createBufferFromTexture = function (t, e, n) {
        this.bindTextureToFrameBuffer(t);
        var r = yi(this.gl, this.debug, e, n, this.textureConfig);
        return this.unbindTextureToFrameBuffer(), r
      }, t.prototype.createAndWaitForFence = function () {
        var t = this.createFence(this.gl);
        return this.pollFence(t)
      }, t.prototype.createFence = function (t) {
        var e, n, r = this;
        if (o().getBool("WEBGL_FENCE_API_ENABLED")) {
          var a = t,
            i = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
          t.flush(), n = function () {
            var t = a.clientWaitSync(i, 0, 0);
            return t === a.ALREADY_SIGNALED || t === a.CONDITION_SATISFIED
          }, e = i
        } else o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function () {
          return r.isQueryAvailable(e, o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
        }) : n = function () {
          return !0
        };
        return {
          query: e,
          isFencePassed: n
        }
      }, t.prototype.downloadMatrixFromPackedTexture = function (t, e, n) {
        var r = this;
        return this.downloadMatrixDriver(t, function () {
          return Ci(r.gl, r.debug, e, n)
        })
      }, t.prototype.createProgram = function (t) {
        this.throwIfDisposed();
        var e = this.gl,
          n = Zt(e, this.debug, t),
          r = oi(e, this.debug),
          a = ne(e, this.debug);
        return qt(e, this.debug, function () {
          return e.attachShader(a, r)
        }), qt(e, this.debug, function () {
          return e.attachShader(a, n)
        }), re(e, this.debug, a), this.debug && ae(e, this.debug, a), this.vertexAttrsAreBound || (this.setProgram(a), this.vertexAttrsAreBound = mi(e, this.debug, this.program, this.vertexBuffer)), a
      }, t.prototype.deleteProgram = function (t) {
        var e = this;
        this.throwIfDisposed(), t === this.program && (this.program = null), null != t && qt(this.gl, this.debug, function () {
          return e.gl.deleteProgram(t)
        })
      }, t.prototype.setProgram = function (t) {
        var e = this;
        this.throwIfDisposed(), this.program = t, null != this.program && this.debug && ae(this.gl, this.debug, this.program), qt(this.gl, this.debug, function () {
          return e.gl.useProgram(t)
        })
      }, t.prototype.getUniformLocation = function (t, e, n) {
        return void 0 === n && (n = !0), this.throwIfDisposed(), n ? he(this.gl, this.debug, t, e) : fe(this.gl, t, e)
      }, t.prototype.getAttributeLocation = function (t, e) {
        var n = this;
        return this.throwIfDisposed(), qt(this.gl, this.debug, function () {
          return n.gl.getAttribLocation(t, e)
        })
      }, t.prototype.getUniformLocationNoThrow = function (t, e) {
        return this.throwIfDisposed(), this.gl.getUniformLocation(t, e)
      }, t.prototype.setInputMatrixTexture = function (t, e, n) {
        this.throwIfDisposed(), this.throwIfNoProgram(), de(this.gl, this.debug, this.program, t, e, n)
      }, t.prototype.setOutputMatrixTexture = function (t, e, n) {
        this.setOutputMatrixTextureDriver(t, n, e)
      }, t.prototype.setOutputPackedMatrixTexture = function (t, e, n) {
        this.throwIfDisposed();
        var r = jt(e, n),
          a = r[0],
          i = r[1];
        this.setOutputMatrixTextureDriver(t, a, i)
      }, t.prototype.setOutputMatrixWriteRegion = function (t, e, n, r) {
        this.setOutputMatrixWriteRegionDriver(n, t, r, e)
      }, t.prototype.setOutputPackedMatrixWriteRegion = function (t, e, n, r) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
      }, t.prototype.debugValidate = function () {
        null != this.program && ae(this.gl, this.debug, this.program), ve(this.gl)
      }, t.prototype.executeProgram = function () {
        this.throwIfDisposed(), this.throwIfNoProgram();
        var t = this.gl;
        this.debug && this.debugValidate(), qt(t, this.debug, function () {
          return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0)
        })
      }, t.prototype.blockUntilAllProgramsCompleted = function () {
        var t = this;
        this.throwIfDisposed(), qt(this.gl, this.debug, function () {
          return t.gl.finish()
        })
      }, t.prototype.getQueryTimerExtension = function () {
        return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = Yt(this.gl, this.debug, 2 === o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension
      }, t.prototype.getQueryTimerExtensionWebGL2 = function () {
        return this.getQueryTimerExtension()
      }, t.prototype.getQueryTimerExtensionWebGL1 = function () {
        return this.getQueryTimerExtension()
      }, t.prototype.beginQuery = function () {
        if (2 === o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
          var t = this.gl,
            e = this.getQueryTimerExtensionWebGL2(),
            n = t.createQuery();
          return t.beginQuery(e.TIME_ELAPSED_EXT, n), n
        }
        var r = this.getQueryTimerExtensionWebGL1(),
          a = r.createQueryEXT();
        return r.beginQueryEXT(r.TIME_ELAPSED_EXT, a), a
      }, t.prototype.endQuery = function () {
        if (2 !== o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
          var t = this.getQueryTimerExtensionWebGL1();
          t.endQueryEXT(t.TIME_ELAPSED_EXT)
        } else {
          var e = this.gl,
            n = this.getQueryTimerExtensionWebGL2();
          e.endQuery(n.TIME_ELAPSED_EXT)
        }
      }, t.prototype.waitForQueryAndGetTime = function (t) {
        return r(this, void 0, void 0, function () {
          var e = this;
          return a(this, function (n) {
            switch (n.label) {
              case 0:
                return [4, R(function () {
                  return e.disposed || e.isQueryAvailable(t, o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
                })];
              case 1:
                return n.sent(), [2, this.getQueryTime(t, o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]
            }
          })
        })
      }, t.prototype.getQueryTime = function (t, e) {
        if (0 === e) return null;
        if (2 === e) {
          var n = this.gl;
          return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6
        }
        var r = this.getQueryTimerExtensionWebGL1();
        return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6
      }, t.prototype.isQueryAvailable = function (t, e) {
        if (0 === e) return !0;
        if (2 === e) {
          var n = this.gl,
            r = this.getQueryTimerExtensionWebGL2(),
            a = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);
          return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), a && !this.disjoint
        }
        return a = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT), null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), a && !this.disjoint
      }, t.prototype.pollFence = function (t) {
        var e = this;
        return new Promise(function (n) {
          e.addItemToPoll(function () {
            return t.isFencePassed()
          }, function () {
            return n()
          })
        })
      }, t.prototype.pollItems = function () {
        for (var t = function (t) {
            for (var e = 0; e < t.length && t[e](); ++e);
            return e - 1
          }(this.itemsToPoll.map(function (t) {
            return t.isDoneFn
          })), e = 0; e <= t; ++e)(0, this.itemsToPoll[e].resolveFn)();
        this.itemsToPoll = this.itemsToPoll.slice(t + 1)
      }, t.prototype.addItemToPoll = function (t, e) {
        var n = this;
        this.itemsToPoll.push({
          isDoneFn: t,
          resolveFn: e
        }), this.itemsToPoll.length > 1 || R(function () {
          return n.pollItems(), 0 === n.itemsToPoll.length
        })
      }, t.prototype.bindTextureToFrameBuffer = function (t) {
        this.throwIfDisposed(), me(this.gl, this.debug, t, this.framebuffer), this.debug && ve(this.gl)
      }, t.prototype.unbindTextureToFrameBuffer = function () {
        null != this.outputTexture ? (me(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && ve(this.gl)) : ge(this.gl, this.debug, this.framebuffer)
      }, t.prototype.downloadMatrixDriver = function (t, e) {
        this.bindTextureToFrameBuffer(t);
        var n = e();
        return this.unbindTextureToFrameBuffer(), n
      }, t.prototype.setOutputMatrixTextureDriver = function (t, e, n) {
        this.throwIfDisposed();
        var r = this.gl;
        me(r, this.debug, t, this.framebuffer), this.debug && ve(r), this.outputTexture = t, qt(r, this.debug, function () {
          return r.viewport(0, 0, e, n)
        }), qt(r, this.debug, function () {
          return r.scissor(0, 0, e, n)
        })
      }, t.prototype.setOutputMatrixWriteRegionDriver = function (t, e, n, r) {
        var a = this;
        this.throwIfDisposed(), qt(this.gl, this.debug, function () {
          return a.gl.scissor(t, e, n, r)
        })
      }, t.prototype.throwIfDisposed = function () {
        if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.")
      }, t.prototype.throwIfNoProgram = function () {
        if (null == this.program) throw new Error("No GPU program is currently set.")
      }, t
    }();

  function ki(t, e) {
    if (t.length !== e.length) throw Error("Binary was compiled with " + t.length + " inputs, but was executed with " + e.length + " inputs");
    t.forEach(function (t, n) {
      var r = t.logicalShape,
        a = e[n],
        i = a.shape;
      if (!S(r, i)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r + " and " + i + " must match");
      if (!t.isUniform || !a.isUniform) {
        var o = t.texShape,
          s = a.isUniform ? null : a.texData.texShape;
        if (!S(o, s)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + o + " and " + s + " must match")
      }
    })
  }
  var Ii = function (t, e, n, r, a, i, o) {
      void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === a && (a = !1), void 0 === i && (i = null), void 0 === o && (o = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
      var s = n ? t[1] : t[2],
        u = Math.ceil(s / 2),
        l = n ? "i * 2, rc.y" : "rc.y, i * 2",
        c = r ? "rc.z, i * 2" : "i * 2, rc.z",
        p = n ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
        h = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
        f = "",
        d = "";
      i && (f = o ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + i + "\n        }" : "vec4 activation(vec4 x) {\n          " + i + "\n        }", d = "result = activation(result);");
      var m = a ? "result += getBiasAtOutCoords();" : "";
      a && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + f + "\n\n      const float sharedDimension = " + u + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + u + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + l + ");\n          vec4 b = getMatrixB(rc.x, " + c + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + p[0] + " * " + h[0] + ");\n          result += (" + p[1] + " * " + h[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + m + "\n\n        " + d + "\n\n        setOutput(result);\n      }\n    "
    },
    Ei = function () {
      function t(t, e, n) {
        this.variableNames = ["probs"], this.outputShape = [t, n], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e - 1) + "));\n      }\n    "
      }
      return t.prototype.getCustomSetupFunc = function (t) {
        var e = this;
        return function (n, r) {
          null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, "seed")), n.gl.uniform1f(e.seedLoc, t)
        }
      }, t
    }(),
    Ai = function (t, e, n) {
      if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
      var r = t.filterWidth,
        a = t.strideHeight,
        i = t.strideWidth,
        o = t.dilationHeight,
        s = t.dilationWidth,
        u = t.effectiveFilterHeight,
        l = t.effectiveFilterWidth,
        c = t.padInfo.top,
        p = t.padInfo.left;
      this.outputShape = t.outShape;
      var h = "avg" === e,
        f = "0.0";
      if (h || (f = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec2 strides = ivec2(" + a + ", " + i + ");\n        const ivec2 pads = ivec2(" + c + ", " + p + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + o + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + l + ";\n                wC += " + s + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + l + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
      else {
        var d = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e && (d = "avgValue / count");
        var m = 4 * Math.floor(r / 4),
          g = r % 4,
          v = "\n      if (" + h + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + a + ", " + i + ");\n      const ivec2 pads = ivec2(" + c + ", " + p + ");\n      const float initializationValue = " + f + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + f + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + u + ";\n            wR += " + o + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + m + "; wC += 4) {\n            int xC = xCCorner + wC * " + s + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              getValue(batch, xR, xC + 3 * " + s + ", d)\n            );\n\n            " + v + "\n          }\n\n          int xC = xCCorner + " + m + ";\n          if (" + (1 === g) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + v + "\n          } else if (" + (2 === g) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + v + "\n          } else if (" + (3 === g) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + s + ", d),\n              getValue(batch, xR, xC + 2 * " + s + ", d),\n              initializationValue\n            );\n\n            " + v + "\n          }\n        }\n        setOutput(" + d + ");\n      }\n    "
      }
    },
    Ri = function (t, e, n) {
      if (this.variableNames = ["x"], "avg" === e && n) throw new Error("Cannot compute positions for average pool.");
      var r = t.filterWidth,
        a = t.strideDepth,
        i = t.strideHeight,
        o = t.strideWidth,
        s = t.dilationDepth,
        u = t.dilationHeight,
        l = t.dilationWidth,
        c = t.effectiveFilterDepth,
        p = t.effectiveFilterHeight,
        h = t.effectiveFilterWidth,
        f = t.padInfo.front,
        d = t.padInfo.top,
        m = t.padInfo.left;
      this.outputShape = t.outShape;
      var g = "avg" === e,
        v = "0.0";
      if (g || (v = "-1.0 / 1e-20"), n) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + a + ", " + i + ", " + o + ");\n        const ivec3 pads = ivec3(" + f + ", " + d + ", " + m + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + c + ";\n              wD += " + s + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + p + ";\n                wR += " + u + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + h + ";\n                  wC += " + l + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + p + " * " + h + " +\n                      wR * " + h + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
      else {
        var y = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e && (y = "avgValue / count");
        var b = 4 * Math.floor(r / 4),
          x = r % 4,
          w = "\n      if (" + g + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec3 strides =\n        ivec3(" + a + ", " + i + ", " + o + ");\n      const ivec3 pads = ivec3(" + f + ", " + d + ", " + m + ");\n      const float initializationValue = " + v + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + v + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + c + ";\n            wD += " + s + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + p + ";\n            wR += " + u + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + b + "; wC += 4) {\n              int xC = xCCorner + wC * " + l + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + l + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + l + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + l + ", ch)\n              );\n\n              " + w + "\n            }\n\n            int xC = xCCorner + " + b + ";\n            if (" + (1 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (2 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + l + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w + "\n            } else if (" + (3 === x) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + l + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + l + ", ch),\n                initializationValue\n              );\n\n              " + w + "\n            }\n          }\n          setOutput(" + y + ");\n        }\n      }\n    "
      }
    },
    Ti = function (t, e, n, r, a, i, o) {
      void 0 === o && (o = !0), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = i;
      var s = Pa(a.length),
        u = Pa(i.length),
        l = "";
      1 === n ? l = "i" : 2 === n && (l = "i, j");
      var c = "getIndices(" + l + ")",
        p = "";
      1 === r ? p = "i" : 2 === r && (p = "i, coords[1]");
      var h = "getUpdates(" + p + ")",
        f = e > 1 ? "strides[j]" : "strides";
      this.userCode = "\n        " + s + " strides = " + s + "(" + a + ");\n\n        void main() {\n          " + u + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e + "; j++) {\n              int index = round(" + c + ");\n              flattenedIndex += index * " + f + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + h + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "
    },
    Di = function () {
      function t(t) {
        this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;
        var e, n = Pa(this.rank),
          r = "uniform int start[" + this.rank + "];",
          a = function (t) {
            if (1 === t) return "sourceLoc";
            if (t <= 6) return Oi.slice(0, t).map(function (t) {
              return "sourceLoc." + t
            }).join(",");
            throw Error("Slicing for rank " + t + " is not yet supported")
          }(this.rank);
        e = "\n        " + n + " sourceLoc;\n        " + n + " coords = getOutputCoords();\n        " + t.map(function (t, e) {
          return "sourceLoc." + Oi[e] + " = start[" + e + "] + coords." + Oi[e] + ";"
        }).join("\n") + "\n      ", this.userCode = "\n      " + r + "\n      void main() {\n        " + e + "\n        setOutput(getSource(" + a + "));\n      }\n    "
      }
      return t.prototype.getCustomSetupFunc = function (t) {
        var e = this;
        if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
        return function (n, r) {
          null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t)
        }
      }, t
    }(),
    Oi = ["x", "y", "z", "w", "u", "v"],
    _i = function () {
      function t(t) {
        this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;
        var e = Pa(this.rank),
          n = Ea("coords", this.rank),
          r = Ea("sourceLoc", this.rank),
          a = 1 === this.rank ? "sourceLoc" : "vec2(" + r.slice(-2).join() + ")",
          i = "getChannel(getSource(" + r.join() + "), " + a + ")",
          o = "\n      result.x = " + i + ";\n      if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n        ++" + r[this.rank - 1] + ";\n        result.y = " + i + ";\n        --" + r[this.rank - 1] + ";\n      }\n    ",
          s = 1 === this.rank ? "" : "\n      --" + n[this.rank - 1] + ";\n      if (++" + n[this.rank - 2] + " < " + t[this.rank - 2] + ") {\n        ++" + r[this.rank - 2] + ";\n        result.z = " + i + ";\n        if (++" + n[this.rank - 1] + " < " + t[this.rank - 1] + ") {\n          ++" + r[this.rank - 1] + ";\n          result.w = " + i + ";\n        }\n      }\n    ",
          u = this.rank <= 4 ? "sourceLoc = coords +\n            " + e + "(" + t.map(function (t, e) {
            return "start[" + e + "]"
          }).join() + ");" : t.map(function (t, e) {
            return r[e] + " = " + n[e] + " + start[" + e + "];"
          }).join("\n");
        this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e + " coords = getOutputCoords();\n        " + e + " sourceLoc;\n        " + u + "\n        vec4 result = vec4(0.);\n        " + o + "\n        " + s + "\n        setOutput(result);\n      }\n    "
      }
      return t.prototype.getCustomSetupFunc = function (t) {
        var e = this;
        if (t.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t.length + ")");
        return function (n, r) {
          null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, "start"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t)
        }
      }, t
    }(),
    Fi = function () {
      function t(t) {
        this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {}
      }
      return t.prototype.acquireTexture = function (t, e, n) {
        var r, a = Mi(e, n),
          i = zi(t, a, n);
        if (i in this.freeTextures || (this.freeTextures[i] = []), i in this.usedTextures || (this.usedTextures[i] = []), this.freeTextures[i].length > 0) {
          this.numFreeTextures--, this.numUsedTextures++, this.log();
          var o = this.freeTextures[i].shift();
          return this.usedTextures[i].push(o), o
        }
        return this.numUsedTextures++, this.log(), a === zt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : a === zt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : a === zt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : a === zt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : a === zt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[i].push(r), r
      }, t.prototype.releaseTexture = function (t, e, n, r) {
        if (null != this.freeTextures) {
          var a = zi(e, Mi(n, r), r);
          a in this.freeTextures || (this.freeTextures[a] = []), this.freeTextures[a].push(t), this.numFreeTextures++, this.numUsedTextures--;
          var i = this.usedTextures[a],
            o = i.indexOf(t);
          if (o < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
          i.splice(o, 1), this.log()
        }
      }, t.prototype.log = function () {
        if (this.logEnabled) {
          var t = this.numFreeTextures + this.numUsedTextures;
          console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t + ")")
        }
      }, t.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures
      }, t.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures
      }, t.prototype.dispose = function () {
        var t = this;
        if (null != this.freeTextures) {
          for (var e in this.freeTextures) this.freeTextures[e].forEach(function (e) {
            t.gpgpu.deleteMatrixTexture(e)
          });
          for (var e in this.usedTextures) this.usedTextures[e].forEach(function (e) {
            t.gpgpu.deleteMatrixTexture(e)
          });
          this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0
        }
      }, t
    }();

  function Mi(t, e) {
    if (t === Mt.UPLOAD) return zt.PACKED_2X2_FLOAT32;
    if (t === Mt.RENDER || null == t) return function (t) {
      return o().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? zt.PACKED_2X2_FLOAT32 : zt.UNPACKED_FLOAT32 : t ? zt.PACKED_2X2_FLOAT16 : zt.UNPACKED_FLOAT16
    }(e);
    if (t === Mt.DOWNLOAD || t === Mt.PIXELS) return zt.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error("Unknown logical texture type " + t)
  }

  function zi(t, e, n) {
    return t[0] + "_" + t[1] + "_" + e + "_" + n
  }
  var Li = 1.7580993408473768,
    Bi = 1.0507009873554805,
    Pi = function (t, e) {
      this.variableNames = ["A"], this.outputShape = t, this.userCode = "\n      float unaryOperation(float x) {\n        " + e + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
    },
    Wi = "if (isnan(x)) return x;",
    Vi = "return x;",
    Ui = "return abs(x);",
    ji = Wi + "\n  return (x < 0.0) ? 0.0 : x;\n",
    Gi = Wi + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
    qi = "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    Hi = "return -x;",
    Ki = "return ceil(x);",
    Xi = "return floor(x);",
    $i = "return exp(x);",
    Yi = "return exp(x) - 1.0;",
    Ji = "return x;",
    Zi = "return x;",
    Qi = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    to = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
    eo = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
    no = function (t, e) {
      this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "
    },
    ro = {};

  function ao(t, e) {
    if (void 0 === e && (e = !1), "linear" === t) return e ? Zi : Vi;
    if ("relu" === t) return e ? Qi : ji;
    if ("elu" === t) return e ? eo : qi;
    if ("relu6" === t) return e ? to : Gi;
    if ("prelu" === t) return e ? Xa : Ha;
    throw new Error("Activation " + t + " has not been implemented for the WebGL backend.")
  }
  var io = 600,
    oo = function (t) {
      function e(e) {
        var n, r = t.call(this) || this;
        if (r.pendingRead = new WeakMap, r.pendingDisposal = new WeakSet, r.dataRefCount = new WeakMap, r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !o().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
        if (null == e) {
          var a = Wt(o().getNumber("WEBGL_VERSION"));
          r.binaryCache = (n = o().getNumber("WEBGL_VERSION")) in ro ? ro[n] : (ro[n] = {}, ro[n]), r.gpgpu = new Si(a), r.canvas = a.canvas, r.gpgpuCreatedLocally = !0
        } else r.gpgpu = e, r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;
        return r.textureManager = new Fi(r.gpgpu), r.numMBBeforeWarning = null == o().global.screen ? 1024 : o().global.screen.height * o().global.screen.width * window.devicePixelRatio * io / 1024 / 1024, r.texData = new Ur(r, Dt), r
      }
      return n(e, t), e.prototype.numDataIds = function () {
        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes
      }, e.prototype.write = function (t, e, n) {
        if (o().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === n && null != t) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        var r = {};
        return this.texData.set(r, {
          shape: e,
          dtype: n,
          values: t,
          usage: Mt.UPLOAD
        }), r
      }, e.prototype.move = function (t, e, n, r) {
        if (o().getBool("DEBUG") && this.checkNumericalProblems(e), "complex64" === r) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        this.texData.set(t, {
          shape: n,
          dtype: r,
          values: e,
          usage: Mt.UPLOAD
        })
      }, e.prototype.readSync = function (t) {
        var e = this.texData.get(t),
          n = e.values,
          r = e.dtype,
          a = e.complexTensors,
          i = e.slice,
          o = e.shape,
          s = e.isPacked;
        if (null != i) {
          var u;
          u = s ? new no(o, Ji) : new Pi(o, Ji);
          var l = this.runWebGLProgram(u, [{
              dataId: t,
              shape: o,
              dtype: r
            }], r),
            c = this.readSync(l.dataId);
          return this.disposeData(l.dataId), c
        }
        if (null != n) return this.convertAndCacheOnCPU(t);
        if ("string" === r) return n;
        var p, h, f = null != this.activeTimers;
        return f && (p = Z()), h = "complex64" === r ? ca(a.real.dataSync(), a.imag.dataSync()) : this.getValuesFromTexture(t), f && (this.downloadWaitMs += Z() - p), this.convertAndCacheOnCPU(t, h)
      }, e.prototype.read = function (t) {
        return r(this, void 0, void 0, function () {
          var e, n, r, i, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, C, S, k;
          return a(this, function (a) {
            switch (a.label) {
              case 0:
                if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [2, new Promise(function (t) {
                  return e.push(t)
                })];
                if (n = this.texData.get(t), r = n.values, i = n.shape, s = n.slice, u = n.dtype, l = n.complexTensors, c = n.isPacked, null != s) return p = void 0, p = c ? new no(i, Ji) : new Pi(i, Ji), h = this.runWebGLProgram(p, [{
                  dataId: t,
                  shape: i,
                  dtype: u
                }], u), f = this.read(h.dataId), this.disposeData(h.dataId), [2, f];
                if (null != r) return [2, this.convertAndCacheOnCPU(t)];
                if (!o().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === o().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
                return d = null, "complex64" !== u && o().get("WEBGL_BUFFER_SUPPORTED") && (m = this.decode(t), g = this.texData.get(m.dataId), d = (k = this.gpgpu).createBufferFromTexture.apply(k, [g.texture].concat(Ut(i)))), this.pendingRead.set(t, []), "complex64" === u ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
              case 1:
                a.sent(), a.label = 2;
              case 2:
                return "complex64" !== u ? [3, 4] : [4, Promise.all([l.real.data(), l.imag.data()])];
              case 3:
                return y = a.sent(), b = y[0], x = y[1], v = ca(b, x), [3, 5];
              case 4:
                null == d ? v = this.getValuesFromTexture(t) : (w = N(i), v = this.gpgpu.downloadFloat32MatrixFromBuffer(d, w)), a.label = 5;
              case 5:
                return null != m && this.disposeData(m.dataId), C = this.convertAndCacheOnCPU(t, v), S = this.pendingRead.get(t), this.pendingRead.delete(t), S.forEach(function (t) {
                  return t(C)
                }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, C]
            }
          })
        })
      }, e.prototype.checkNumericalProblems = function (t) {
        if (null != t)
          for (var e = 0; e < t.length; e++) {
            var n = t[e];
            if (!Xt(n)) {
              if (o().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
              throw Error("The value " + n + " cannot be represented on this device.")
            }
          }
      }, e.prototype.getValuesFromTexture = function (t) {
        var e, n = this.texData.get(t),
          r = n.shape,
          a = n.dtype,
          i = n.isPacked,
          s = N(r);
        if (o().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
          var u = this.decode(t),
            l = this.texData.get(u.dataId),
            c = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [l.texture].concat(Ut(r))).subarray(0, s);
          return this.disposeData(u.dataId), c
        }
        var p = o().getBool("WEBGL_PACK") && !0 === i,
          h = p ? Ne(r) : r,
          f = p ? new function (t) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = Mt.DOWNLOAD;
            var e = Aa();
            this.outputShape = t, this.userCode = "\n      " + Da + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e.output + " = encode_float(x);\n      }\n    "
          }(h) : new function (t) {
            this.variableNames = ["A"], this.outTexUsage = Mt.DOWNLOAD;
            var e = Aa();
            this.outputShape = t, this.userCode = "\n      " + Da + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e.output + " = encode_float(x);\n      }\n    "
          }(h),
          d = this.runWebGLProgram(f, [{
            shape: h,
            dtype: a,
            dataId: t
          }], "float32"),
          m = this.texData.get(d.dataId),
          g = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(m.texture, m.texShape[0], m.texShape[1]).subarray(0, s);
        return this.disposeData(d.dataId), g
      }, e.prototype.time = function (t) {
        return r(this, void 0, void 0, function () {
          var e, n, r, i, o, s, u;
          return a(this, function (a) {
            switch (a.label) {
              case 0:
                return e = this.activeTimers, n = [], r = !1, null == this.programTimersStack ? (this.programTimersStack = n, r = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), i = C(this.activeTimers.map(function (t) {
                  return t.query
                })).filter(function (t) {
                  return null != t
                }), o = C(this.activeTimers.map(function (t) {
                  return t.name
                })).filter(function (t) {
                  return null != t
                }), this.activeTimers = e, r && (this.programTimersStack = null), [4, Promise.all(i)];
              case 1:
                return s = a.sent(), u = {
                  uploadWaitMs: this.uploadWaitMs,
                  downloadWaitMs: this.downloadWaitMs,
                  kernelMs: y(s),
                  getExtraProfileInfo: function () {
                    return s.map(function (t, e) {
                      return {
                        name: o[e],
                        ms: t
                      }
                    }).map(function (t) {
                      return t.name + ": " + t.ms
                    }).join(", ")
                  },
                  wallMs: null
                }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, u]
            }
          })
        })
      }, e.prototype.memory = function () {
        return {
          unreliable: !1,
          numBytesInGPU: this.numBytesInGPU
        }
      }, e.prototype.startTimer = function () {
        return o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? this.gpgpu.beginQuery() : {
          startMs: Z(),
          endMs: null
        }
      }, e.prototype.endTimer = function (t) {
        return o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = Z(), t)
      }, e.prototype.getQueryTime = function (t) {
        return r(this, void 0, void 0, function () {
          var e;
          return a(this, function (n) {
            return o().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (e = t).endMs - e.startMs]
          })
        })
      }, e.prototype.disposeData = function (t) {
        if (!this.pendingDisposal.has(t)) {
          if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;
          if (this.texData.has(t)) {
            this.releaseGPUData(t);
            var e = this.texData.get(t).complexTensors;
            null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t)
          }
        }
      }, e.prototype.releaseGPUData = function (t) {
        var e = this.texData.get(t),
          n = e.texture,
          r = e.dtype,
          a = e.texShape,
          i = e.usage,
          o = e.isPacked,
          s = e.slice,
          u = s && s.origDataId || t,
          l = this.dataRefCount.get(u);
        l > 1 ? this.dataRefCount.set(u, l - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(a, r), this.textureManager.releaseTexture(n, a, i, o)));
        var c = this.texData.get(t);
        c.texture = null, c.texShape = null, c.isPacked = !1, c.slice = null
      }, e.prototype.getTexture = function (t) {
        return this.uploadToGPU(t), this.texData.get(t).texture
      }, e.prototype.getDataInfo = function (t) {
        return this.texData.get(t)
      }, e.prototype.getCPUBackend = function () {
        return o().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Dt.findBackend("cpu")), this.cpuBackend) : null
      }, e.prototype.shouldExecuteOnCPU = function (t, e) {
        var n = this;
        return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every(function (t) {
          return null == n.texData.get(t.dataId).texture && t.size < e
        })
      }, e.prototype.getGPGPUContext = function () {
        return this.gpgpu
      }, e.prototype.complex = function (t, e) {
        var n = this.makeOutput(t.shape, "complex64");
        return this.texData.get(n.dataId).complexTensors = {
          real: Dt.keep(t.clone()),
          imag: Dt.keep(e.clone())
        }, n
      }, e.prototype.real = function (t) {
        return this.texData.get(t.dataId).complexTensors.real.clone()
      }, e.prototype.imag = function (t) {
        return this.texData.get(t.dataId).complexTensors.imag.clone()
      }, e.prototype.slice = function (t, e, n) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, e, n);
        if (0 === N(n)) return cn([], n, t.dtype);
        var r = this.texData.get(t.dataId).isPacked,
          a = Fr(t.shape, e, n);
        if (r || !a) {
          var i = o().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new _i(n) : new Di(n),
            s = i.getCustomSetupFunc(e);
          return this.compileAndRun(i, [t], null, s)
        }
        return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n)
      }, e.prototype.shallowSlice = function (t, e, n) {
        var r = this.texData.get(t.dataId),
          a = this.makeOutput(n, t.dtype),
          i = this.texData.get(a.dataId);
        Object.assign(i, r), i.shape = n, i.dtype = t.dtype;
        var o = Mr(e, t.strides);
        r.slice && (o += r.slice.flatOffset), i.slice = {
          flatOffset: o,
          origDataId: r.slice && r.slice.origDataId || t.dataId
        };
        var s = this.dataRefCount.get(i.slice.origDataId) || 1;
        return this.dataRefCount.set(i.slice.origDataId, s + 1), a
      }, e.prototype.stridedSlice = function (t, e, n, r) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, e, n, r);
        var a = Dr(e, n, r);
        if (a.some(function (t) {
            return 0 === t
          })) return cn([], a);
        var i = new function (t, e, n) {
          this.variableNames = ["x"], this.outputShape = n;
          var r = n.length,
            a = Pa(n.length),
            i = Pa(n.length),
            o = "";
          if (1 === r) o = "coords * strides + begin";
          else {
            var s = 0;
            o = n.map(function (t, e) {
              return s++, 1 === n.length ? "coords * strides[" + e + "] + begin[" + e + "]" : "coords[" + (s - 1) + "] * strides[" + e + "] + begin[" + e + "]"
            }).join(",")
          }
          this.userCode = "\n      " + a + " begin = " + a + "(" + t + ");\n      " + a + " strides = " + a + "(" + e + ");\n\n      void main() {\n        " + i + " coords = getOutputCoords();\n        setOutput(getX(" + o + "));\n      }\n    "
        }(e, r, a);
        return this.compileAndRun(i, [t])
      }, e.prototype.reverse = function (t, e) {
        var n = o().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new function (t, e) {
          this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
          var n = t.length;
          if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
          this.outputShape = t;
          var r = Ea("rc", n),
            a = r[n - 1] + " + 1 < " + this.outputShape[n - 1],
            i = r[n - 2] + " + 1 < " + this.outputShape[n - 2],
            o = Pa(n);

          function s(n) {
            var r = t.map(function (r, a) {
              return function (n, r) {
                return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - " + r[n] + " - 1" : "" + r[n]
              }(a, n)
            });
            return "getChannel(getX(" + r.join(",") + "), vec2(" + r.slice(-2).join(",") + "))"
          }
          this.userCode = 1 === n ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t[0] + " - rc - 1),\n            " + t[0] + " - rc - 1);\n          if(" + a + "){\n              result.g = getChannel(getX(" + t[0] + " - (rc  + 1) - 1),\n                " + t[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + o + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + s(r.slice()) + ";\n          if(" + a + "){\n            result.g = " + function (t) {
            return t[n - 1] = "(" + t[n - 1] + " + 1)", s(t)
          }(r.slice()) + ";\n          }\n          if(" + i + ") {\n            result.b = " + function (t) {
            return t[n - 2] = "(" + t[n - 2] + " + 1)", s(t)
          }(r.slice()) + ";\n            if(" + a + ") {\n              result.a = " + function (t) {
            return t[n - 1] = "(" + t[n - 1] + " + 1)", t[n - 2] = "(" + t[n - 2] + " + 1)", s(t)
          }(r.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    "
        }(t.shape, e) : new function (t, e) {
          this.variableNames = ["x"];
          var n = t.length;
          if (n > 4) throw new Error("WebGL backend: Reverse of rank-" + n + " tensor is not yet supported");
          if (this.outputShape = t, 1 !== n) {
            var r = t.map(function (n, r) {
                return function (n) {
                  return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + " - coords[" + n + "] - 1" : "coords[" + n + "]"
                }(r)
              }).join(","),
              a = Pa(n);
            this.userCode = "\n      void main() {\n        " + a + " coords = getOutputCoords();\n        setOutput(getX(" + r + "));\n      }\n    "
          } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t[0] + " - coord - 1));\n        }\n      "
        }(t.shape, e);
        return this.compileAndRun(n, [t])
      }, e.prototype.concat = function (t, e) {
        if ("complex64" === t[0].dtype) {
          var n = t.map(function (t) {
              return un(t)
            }),
            r = t.map(function (t) {
              return ln(t)
            });
          return sn(this.concat(n, e), this.concat(r, e))
        }
        if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);
        if (1 === t.length) return t[0];
        if (t.length > o().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
          var a = Math.floor(t.length / 2),
            i = this.concat(t.slice(0, a), e),
            s = this.concat(t.slice(a), e);
          return this.concat([i, s], e)
        }
        if (o().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
          var u = new function (t, e) {
            this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = an(t, e);
            var n = this.outputShape,
              r = n.length,
              a = Pa(r),
              i = Ea("coords", r),
              o = ["x", "y", "z", "w", "u", "v"].slice(0, r);
            this.variableNames = t.map(function (t, e) {
              return "T" + e
            });
            var s = new Array(t.length - 1);
            s[0] = t[0][e];
            for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + t[u][e];
            var l = o[e],
              c = o.slice(-2),
              p = o.join(),
              h = "if (" + l + " < " + s[0] + ") {\n        return getChannel(\n            getT0(" + p + "), vec2(" + c.join() + "));\n        }";
            for (u = 1; u < s.length; u++) {
              var f = s[u - 1];
              h += "\n        if (" + l + " < " + s[u] + "  && " + l + " >= " + s[u - 1] + ") {\n          return getChannel(\n            getT" + u + "(" + Za(o, l, f) + "),\n            vec2(" + Za(c, l, f) + "));\n        }"
            }
            var d = s.length,
              m = s[s.length - 1];
            h += "\n        return getChannel(\n          getT" + d + "(" + Za(o, l, m) + "),\n          vec2(" + Za(c, l, m) + "));", this.userCode = "\n      float getValue(" + o.map(function (t) {
              return "int " + t
            }) + ") {\n        " + h + "\n      }\n\n      void main() {\n        " + a + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + i + "), 0., 0., 0.);\n\n        " + i[r - 1] + " = " + i[r - 1] + " + 1;\n        if (" + i[r - 1] + " < " + n[r - 1] + ") {\n          result.g = getValue(" + i + ");\n        }\n\n        " + i[r - 2] + " = " + i[r - 2] + " + 1;\n        if (" + i[r - 2] + " < " + n[r - 2] + ") {\n          result.a = getValue(" + i + ");\n        }\n\n        " + i[r - 1] + " = " + i[r - 1] + " - 1;\n        if (" + i[r - 2] + " < " + n[r - 2] + " &&\n            " + i[r - 1] + " < " + n[r - 1] + ") {\n          result.b = getValue(" + i + ");\n        }\n        setOutput(result);\n      }\n    "
          }(t.map(function (t) {
            return t.shape
          }), e);
          return this.compileAndRun(u, t)
        }
        var l = an(t.map(function (t) {
            return t.shape
          }), e),
          c = t.map(function (t) {
            return t.as2D(-1, N(t.shape.slice(e)))
          }),
          p = new function (t) {
            this.outputShape = [], this.outputShape = an(t, 1), this.variableNames = t.map(function (t, e) {
              return "T" + e
            });
            var e = new Array(t.length - 1);
            e[0] = t[0][1];
            for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1];
            var r = ["if (yC < " + e[0] + ") setOutput(getT0(yR, yC));"];
            for (n = 1; n < e.length; n++) {
              var a = e[n - 1];
              r.push("else if (yC < " + e[n] + ") setOutput(getT" + n + "(yR, yC-" + a + "));")
            }
            var i = e.length,
              o = e[e.length - 1];
            r.push("else setOutput(getT" + i + "(yR, yC-" + o + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r.join("\n        ") + "\n      }\n    "
          }(c.map(function (t) {
            return t.shape
          }));
        return this.compileAndRun(p, c).reshape(l)
      }, e.prototype.neg = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
        if (o().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Hi, t.dtype);
        var e = new Pi(t.shape, Hi);
        return this.compileAndRun(e, [t])
      }, e.prototype.batchMatMul = function (t, e, n, r) {
        var a = n ? t.shape[2] : t.shape[1],
          i = r ? e.shape[1] : e.shape[2],
          o = n ? t.shape[1] : t.shape[2],
          s = t.shape[0];
        if ((1 === a || 1 === i) && o > 1e3) {
          n && (t = t.transpose([0, 2, 1])), r && (e = e.transpose([0, 2, 1]));
          var u = 1 === i ? t : t.as3D(s, o, 1),
            l = 1 === i ? 2 : 1,
            c = 1 === i ? e.as3D(s, 1, o) : e;
          return this.multiply(u, c).sum(l, !0)
        }
        var p = Ct(t.dtype, e.dtype),
          h = new Ii(t.shape, [s, a, i], n, r);
        return this.compileAndRun(h, [t, e], p)
      }, e.prototype.fusedBatchMatMul = function (t) {
        var e = t.a,
          n = t.b,
          r = t.transposeA,
          a = t.transposeB,
          i = t.bias,
          o = t.activation,
          s = t.preluActivationWeights,
          u = r ? e.shape[2] : e.shape[1],
          l = a ? n.shape[1] : n.shape[2],
          c = e.shape[0],
          p = Ct(e.dtype, n.dtype),
          h = null != i,
          f = null != s,
          d = o ? ao(o, !0) : null,
          m = new Ii(e.shape, [c, u, l], r, a, h, d, f),
          g = [e, n];
        return i && g.push(i), s && g.push(s), this.compileAndRun(m, g, p)
      }, e.prototype.multiply = function (t, e) {
        if ("complex64" === t.dtype) {
          var n = this.texData.get(t.dataId),
            r = this.texData.get(e.dataId),
            a = new Ua("return areal * breal - aimag * bimag;", t.shape, e.shape),
            i = new Ua("return areal * bimag + aimag * breal;", t.shape, e.shape),
            s = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag), this.makeComplexComponentTensorInfo(e, r.complexTensors.real), this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)],
            u = this.compileAndRun(a, s),
            l = this.compileAndRun(i, s),
            c = this.complex(u, l);
          return u.dispose(), l.dispose(), c
        }
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.multiply(t, e);
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, qa, t.dtype);
        var p = new Ka(qa, t.shape, e.shape);
        return this.compileAndRun(p, [t, e], t.dtype)
      }, e.prototype.batchNormalization = function (t, e, n, r, a, i) {
        var s = [t, e, n],
          u = null;
        null != i && (u = i.shape, s.push(i));
        var l = null;
        if (null != a && (l = a.shape, s.push(a)), o().getBool("WEBGL_PACK_NORMALIZATION")) {
          var c = new function (t, e, n, r, a, i) {
            this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], Kr(t, e), Kr(t, n);
            var o = "vec4(0.0)";
            null != r && (Kr(t, r), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
            var s = "vec4(1.0)";
            null != a && (Kr(t, a), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        vec4 offset = " + o + ";\n        vec4 scale = " + s + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + i + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "
          }(t.shape, e.shape, n.shape, u, l, r);
          return this.compileAndRun(c, s)
        }
        var p = new function (t, e, n, r, a, i) {
          this.outputShape = [], this.variableNames = ["x", "mean", "variance"], Kr(t, e), Kr(t, n);
          var o = "0.0";
          null != r && (Kr(t, r), this.variableNames.push("offset"), o = "getOffsetAtOutCoords()");
          var s = "1.0";
          null != a && (Kr(t, a), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + o + ";\n        float scale = " + s + ";\n        float inv = scale * inversesqrt(variance + float(" + i + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "
        }(t.shape, e.shape, n.shape, u, l, r);
        return this.compileAndRun(p, s)
      }, e.prototype.localResponseNormalization4D = function (t, e, n, r, a) {
        var i = o().getBool("WEBGL_PACK_NORMALIZATION") ? new function (t, e, n, r, a) {
          this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
          var i, o = e,
            s = t[3] - 1;
          this.outputShape = t;
          var u = "float(" + n + ") + float(" + r + ") * sum";
          i = .5 === a ? "inversesqrt(" + u + ")" : 1 === a ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + a + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + o + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + o + "; j <= " + o + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + i + ";\n        setOutput(result);\n      }\n    "
        }(t.shape, e, n, r, a) : new function (t, e, n, r, a) {
          this.variableNames = ["x"], this.outputShape = [];
          var i, o = e,
            s = t[3] - 1;
          this.outputShape = t;
          var u = "float(" + n + ") + float(" + r + ") * sum";
          i = .5 === a ? "inversesqrt(" + u + ")" : 1 === a ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + a + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + o + "; j <= " + o + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + i + ";\n        setOutput(val);\n      }\n    "
        }(t.shape, e, n, r, a);
        return this.compileAndRun(i, [t])
      }, e.prototype.LRNGrad = function (t, e, n, r, a, i, o) {
        var s = new function (t, e, n, r, a) {
          this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = a, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r + ") * norm + float(" + n + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r + ")\n                * float(" + a + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + a + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "
        }(e.shape, r, a, i, o);
        return this.compileAndRun(s, [e, n, t])
      }, e.prototype.tile = function (t, e) {
        if ("string" === t.dtype) {
          var n = this.readSync(t.dataId).map(function (t) {
            return et(t)
          });
          return Na(qn(t.shape, t.dtype, n), e)
        }
        var r = new function (t, e) {
          this.variableNames = ["A"];
          for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[r] * e[r];
          this.outputShape = n, this.rank = n.length;
          var a = Pa(this.rank),
            i = function (t) {
              var e = t.length;
              if (e > 5) throw Error("Tile for rank " + e + " is not yet supported");
              if (1 === e) return "imod(resRC, " + t[0] + ")";
              for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], a = 0; a < t.length; a++) r.push("imod(" + n[a] + ", " + t[a] + ")");
              return r.join()
            }(t);
          this.userCode = "\n      void main() {\n        " + a + " resRC = getOutputCoords();\n        setOutput(getA(" + i + "));\n      }\n    "
        }(t.shape, e);
        return this.compileAndRun(r, [t])
      }, e.prototype.pad = function (t, e, n) {
        var r = o().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new function (t, e, n) {
          this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map(function (e, n) {
            return e[0] + t[n] + e[1]
          });
          for (var r = t.length, a = Pa(r), i = e.map(function (t) {
              return t[0]
            }).join(","), o = e.map(function (e, n) {
              return e[0] + t[n]
            }).join(","), s = Ea("rc", r), u = Ea("source", r), l = s[r - 1] + " < " + this.outputShape[r - 1], c = 1 === r ? "source" : "vec2(" + u.slice(-2).join() + ")", p = [a + " rc = outputLoc;", s[r - 1] + " += 1;\n       if(" + l + ") {\n      ", 1 === r ? "" : "}\n       rc = outputLoc;\n       " + s[r - 2] + " += 1;\n       if(" + s[r - 2] + " < " + this.outputShape[r - 2] + ") {", 1 === r ? "" : "  " + s[r - 1] + " += 1;\n         if(" + l + ") {"], h = 1 === r ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", f = "", d = 0, m = 1 === r ? 2 : 4; d < m; d++) f += "\n        " + p[d] + "\n        if (" + h + ") {\n          result[" + d + "] = float(" + n + ");\n        } else {\n          " + a + " source = rc - start;\n          result[" + d + "] = getChannel(getX(" + u.join() + "), " + c + ");\n        }\n      ";
          f += 1 === r ? "} " : "}}", this.userCode = "\n      const " + a + " start = " + a + "(" + i + ");\n      const " + a + " end = " + a + "(" + o + ");\n\n      void main() {\n        " + a + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + f + "\n        setOutput(result);\n      }\n    "
        }(t.shape, e, n) : new function (t, e, n) {
          this.variableNames = ["x"], this.outputShape = e.map(function (e, n) {
            return e[0] + t[n] + e[1]
          });
          var r = t.length,
            a = Pa(r),
            i = e.map(function (t) {
              return t[0]
            }).join(","),
            o = e.map(function (e, n) {
              return e[0] + t[n]
            }).join(","),
            s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
          this.userCode = 1 !== r ? "\n      " + a + " start = " + a + "(" + i + ");\n      " + a + " end = " + a + "(" + o + ");\n\n      void main() {\n        " + a + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n + "));\n        } else {\n          " + a + " coords = outC - start;\n          setOutput(getX(" + s + "));\n        }\n      }\n    " : "\n        int start = " + i + ";\n        int end = " + o + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "
        }(t.shape, e, n);
        return this.compileAndRun(r, [t])
      }, e.prototype.transpose = function (t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, e);
        var n = o().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new function (t, e) {
          this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
          for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];
          if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
          var a = Pa(this.rank),
            i = Ia("rc", this.rank),
            o = new Array(this.rank);
          for (r = 0; r < e.length; r++) o[e[r]] = i[r];
          var s = "vec2(" + o.slice(-2).join() + ")",
            u = "++" + i[this.rank - 1] + " < " + n[this.rank - 1],
            l = "getChannel(getA(" + o.join() + "), " + s + ")";
          this.userCode = "\n    void main() {\n      " + a + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + l + ";\n      if(" + u + ") {\n        result[1] = " + l + ";\n      }\n      --" + i[this.rank - 1] + ";\n      if(++" + i[this.rank - 2] + " < " + n[this.rank - 2] + ") {\n        result[2] = " + l + ";\n        if(" + u + ") {\n          result[3] = " + l + ";\n        }\n      }\n      setOutput(result);\n    }\n    "
        }(t.shape, e) : new function (t, e) {
          this.variableNames = ["A"];
          for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];
          this.outputShape = n, this.rank = n.length;
          var a = Pa(this.rank),
            i = function (t) {
              var e = t.length;
              if (e > 6) throw Error("Transpose for rank " + e + " is not yet supported");
              for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r = new Array(e), a = 0; a < t.length; a++) r[t[a]] = n[a];
              return r.join()
            }(e);
          this.userCode = "\n    void main() {\n      " + a + " resRC = getOutputCoords();\n      setOutput(getA(" + i + "));\n    }\n    "
        }(t.shape, e);
        return this.compileAndRun(n, [t])
      }, e.prototype.gather = function (t, e, n) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.gather(t, e, n);
        var r = new function (t, e, n) {
          this.variableNames = ["A", "indices"];
          var r = t.slice();
          r[n] = e, this.outputShape = r, this.rank = r.length;
          var a = Pa(this.rank),
            i = function (t, e) {
              var n = t.length;
              if (n > 4) throw Error("Gather for rank " + n + " is not yet supported");
              if (1 === n) return "int(getIndices(resRC))";
              for (var r = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], a = [], i = 0; i < t.length; i++) i === e ? a.push("int(getIndices(" + r[i] + "))") : a.push("" + r[i]);
              return a.join()
            }(t, n);
          this.userCode = "\n      void main() {\n        " + a + " resRC = getOutputCoords();\n        setOutput(getA(" + i + "));\n      }\n    "
        }(t.shape, e.size, n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.batchToSpaceND = function (t, e, n) {
        b(t.rank <= 4, function () {
          return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"
        });
        var r = e.reduce(function (t, e) {
            return t * e
          }),
          a = xr(t.shape, e, r),
          i = wr(a.length, e.length),
          o = Cr(t.shape, e, r),
          s = Nr(n, e.length),
          u = Sr(o, n, e.length);
        return t.reshape(a).transpose(i).reshape(o).slice(s, u)
      }, e.prototype.spaceToBatchND = function (t, e, n) {
        b(t.rank <= 4, function () {
          return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"
        });
        var r = e.reduce(function (t, e) {
            return t * e
          }),
          a = [
            [0, 0]
          ];
        a.push.apply(a, n);
        for (var i = 1 + e.length; i < t.shape.length; ++i) a.push([0, 0]);
        var o = t.pad(a),
          s = xr(o.shape, e, r, !1),
          u = wr(s.length, e.length, !1),
          l = Cr(o.shape, e, r, !1);
        return o.reshape(s).transpose(u).reshape(l)
      }, e.prototype.reduce = function (t, e, n) {
        var r = t.shape[0],
          a = t.shape[1],
          i = new function (t, e) {
            this.variableNames = ["x"];
            var n = t.windowSize,
              r = t.batchSize,
              a = t.inSize,
              i = Math.ceil(a / n);
            this.outputShape = [r, i];
            var o = "0.0",
              s = "";
            "prod" === e ? o = "1.0" : "min" === e ? (o = "1.0 / 1e-20", s = "min") : "max" === e && (o = "-1.0 / 1e-20", s = "max");
            var u = e + "(" + e + "(" + e + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
            "sum" === e ? u = "sumValue" : "prod" === e ? u = "prodValue" : "all" === e ? u = "allValue" : "any" === e && (u = "anyValue");
            var l = 4 * Math.floor(n / 4),
              c = n % 4,
              p = "\n      if (" + ("sum" === e) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s + "(values, minMaxValue);\n      }\n    ",
              h = "vec4";
            "all" === e ? (o = "1.0", p = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", h = "bvec4") : "any" === e && (o = "0.0", p = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", h = "bvec4");
            var f = "";
            a % n > 0 && (f = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + o + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + f + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n + ";\n\n        vec4 minMaxValue = vec4(" + o + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + l + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + h + " values = " + h + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + p + "\n        }\n\n        int inIdx = inOffset + " + l + ";\n        if (" + (1 === c) + ") {\n          " + h + " values = " + h + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + p + "\n        } else if (" + (2 === c) + ") {\n          " + h + " values = " + h + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + p + "\n        } else if (" + (3 === c) + ") {\n          " + h + " values = " + h + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + p + "\n        }\n        setOutput(" + u + ");\n      }\n    "
          }({
            windowSize: Er(a),
            inSize: a,
            batchSize: r
          }, e),
          o = this.compileAndRun(i, [t], n);
        return 1 === o.shape[1] ? o : this.reduce(o, e, n)
      }, e.prototype.argReduce = function (t, e, n) {
        void 0 === n && (n = null);
        var r = t.shape[0],
          a = t.shape[1];
        null != n && (r = n.shape[0], a = n.shape[1]);
        var i = new function (t, e, n) {
            this.variableNames = ["A"];
            var r = t.windowSize,
              a = t.batchSize,
              i = t.inSize,
              o = Math.ceil(i / r);
            n || this.variableNames.push("bestIndicesA"), this.outputShape = [a, o];
            var s = "max" === e ? ">" : "<",
              u = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
            this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r + "; i++) {\n          int inIdx = " + u + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + s + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "
          }({
            windowSize: Er(a),
            inSize: a,
            batchSize: r
          }, e, null == n),
          o = [t];
        null != n && o.push(n);
        var s = this.compileAndRun(i, o, "int32");
        return 1 === s.shape[1] ? s : this.argReduce(t, e, s)
      }, e.prototype.argReducePacked = function (t, e, n) {
        void 0 === n && (n = null);
        var r = null != n ? n.shape : t.shape,
          a = new function (t, e, n, r) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, b(t.length > 2, function () {
              return "Packed arg" + (n.charAt(0).toUpperCase() + n.slice(1)) + " supports only inputs with rank above 2."
            });
            var a = t[t.length - 1],
              i = Math.ceil(a / e);
            this.outputShape = t.slice(0, -1), i > 1 && this.outputShape.push(i), r || this.variableNames.push("bestIndicesA");
            var o, s, u = this.outputShape,
              l = u.length,
              c = Pa(l),
              p = Ea("coords", l);
            if (1 === i) {
              var h = Pa(s = l + 1);
              o = "\n        " + h + " sourceLocR = " + h + "(" + p.join() + ", 0);\n        ++" + p[l - 1] + ";\n        " + h + " sourceLocG = " + h + "(" + p.join() + ", 0);\n        ++" + p[l - 2] + ";\n        " + h + " sourceLocA = " + h + "(" + p.join() + ", 0);\n        --" + p[l - 1] + ";\n        " + h + " sourceLocB = " + h + "(" + p.join() + ", 0);\n        --" + p[l - 2] + ";"
            } else s = l, o = "\n        " + c + " sourceLocR = coords;\n        ++" + p[l - 1] + ";\n        " + c + " sourceLocG = coords;\n        ++" + p[l - 2] + ";\n        " + c + " sourceLocA = coords;\n        --" + p[l - 1] + ";\n        " + c + " sourceLocB = coords;\n        --" + p[l - 2] + ";";
            var f = ["x", "y", "z", "w", "u", "v"].slice(0, s),
              d = "." + f[s - 1],
              m = f.map(function (t) {
                return "int " + t
              }),
              g = Ea("sourceLocR", s - 1).concat("inIdx.r"),
              v = Ea("sourceLocG", s - 1).concat("inIdx.g"),
              y = Ea("sourceLocB", s - 1).concat("inIdx.b"),
              x = Ea("sourceLocA", s - 1).concat("inIdx.a"),
              w = "max" === n ? "greaterThan" : "lessThan",
              C = r ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + g.join() + "),\n                             getBestIndicesAChannel(" + v.join() + "),\n                             getBestIndicesAChannel(" + y.join() + "),\n                             getBestIndicesAChannel(" + x.join() + ")));",
              N = "vec4(\n            getAChannel(" + g.join() + "),\n            hasNextCol ? getAChannel(" + v.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + x.join() + ") : 0.)",
              S = r ? "" : "\n      float getBestIndicesAChannel(" + m.join() + ") {\n        return getChannel(getBestIndicesA(" + f.join() + "),\n                                          vec2(" + f.slice(-2).join() + "));\n      }";
            this.userCode = "\n      float getAChannel(" + m.join() + ") {\n        return getChannel(getA(" + f.join() + "),\n                               vec2(" + f.slice(-2).join() + "));\n      }\n      " + S + "\n      void main() {\n        " + c + " coords = getOutputCoords();\n        bool hasNextCol = " + p[l - 1] + " < " + (u[l - 1] - 1) + ";\n        bool hasNextRow = " + p[l - 2] + " < " + (u[l - 2] - 1) + ";\n        " + o + "\n        ivec4 srcIdx = ivec4(sourceLocR" + d + ", sourceLocG" + d + ",\n          sourceLocB" + d + ", sourceLocA" + d + ") * " + e + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + N + ";\n\n        for (int i = 0; i < " + e + "; i++) {\n          inIdx = srcIdx;\n          " + C + "\n          vec4 candidate = " + N + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + w + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "
          }(r, Er(r[r.length - 1]), e, null == n),
          i = null == n ? [t] : [t, n],
          o = this.compileAndRun(a, i, "int32");
        return o.rank === t.rank ? this.argReducePacked(t, e, o) : o
      }, e.prototype.sum = function (t, e) {
        Qe("sum", e, t.rank);
        var n = Je(t.shape, e),
          r = n[0],
          a = N(n[1]),
          i = t.as2D(-1, a),
          o = Nt(t.dtype);
        return this.reduce(i, "sum", o).reshape(r)
      }, e.prototype.prod = function (t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e);
        var n = Je(t.shape, e),
          r = n[0],
          a = N(n[1]),
          i = t.as2D(-1, a),
          o = Nt(t.dtype);
        return this.reduce(i, "prod", o).reshape(r)
      }, e.prototype.unsortedSegmentSum = function (t, e, n) {
        var r = 0,
          a = tn([r], t.rank),
          i = t;
        null != a && (i = t.transpose(a), r = nn(1, t.rank)[0]);
        var o = function (t, e, n) {
            for (var r = [], a = t.length, i = 0; i < a; i++) i !== e ? r.push(t[i]) : r.push(n);
            return r
          }(i.shape, r, n),
          s = N([i.shape[r]]),
          u = i.as2D(-1, s),
          l = Nt(t.dtype),
          c = this.segOpCompute(u, "unsortedSegmentSum", e, l, n).reshape(o);
        return null != a && (c = c.transpose(en(a))), c
      }, e.prototype.segOpCompute = function (t, e, n, r, a) {
        var i = t.shape[0],
          o = t.shape[1],
          s = function (t, e) {
            var n, r = !1;
            for (t <= Ir ? (n = t, r = !0) : n = H(t, Math.floor(Math.sqrt(t))); !r;) n > e || n === t ? r = !0 : n = H(t, n + 1);
            return n
          }(o, a),
          u = new function (t, e) {
            this.variableNames = ["x", "segmentIds"];
            var n = t.windowSize,
              r = t.batchSize,
              a = t.inSize,
              i = t.numSegments,
              o = i * Math.ceil(a / n);
            this.outputShape = [r, o];
            var s = 4 * Math.floor(n / 4),
              u = n % 4,
              l = "\n        sumValue += dot(values, segFilter);\n    ",
              c = "";
            a % n > 0 && (c = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return initializationValue;\n        }\n      ");
            var p = "";
            a % n > 0 && (p = "\n        if (inIdx < 0 || inIdx >= " + a + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + c + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + p + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + i + ")) * float(" + n + "));\n        int currentSeg = int(mod(float(outIdx), float(" + i + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + l + "\n        }\n\n        int inIdx = inOffset + " + s + ";\n        if (" + (1 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + l + "\n        } else if (" + (2 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + l + "\n        } else if (" + (3 === u) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + l + "\n        }\n        setOutput(sumValue);\n      }\n    "
          }({
            windowSize: s,
            inSize: o,
            batchSize: i,
            numSegments: a
          }, e),
          l = this.compileAndRun(u, [t, n], r);
        return l.shape[1] === a ? l : (n = Sn(0, a).tile([o / s]), this.segOpCompute(l, e, n, r, a))
      }, e.prototype.argMinMaxReduce = function (t, e, n) {
        var r = [e];
        if (Qe("arg" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !o().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
          var a = Je(t.shape, r),
            i = a[0],
            s = N(a[1]),
            u = t.as2D(-1, s);
          return this.argReduce(u, n).reshape(i)
        }
        return this.argReducePacked(t, n)
      }, e.prototype.argMin = function (t, e) {
        return this.argMinMaxReduce(t, e, "min")
      }, e.prototype.argMax = function (t, e) {
        return this.argMinMaxReduce(t, e, "max")
      }, e.prototype.cumsum = function (t, e, n, r) {
        if (e !== t.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
        var a = new function (t, e, n) {
          this.variableNames = ["x"], this.outputShape = t;
          var r = t.length,
            a = t[t.length - 1],
            i = n ? "<" : ">";
          this.userCode = "\n      int getIndex(int i) {\n        " + (n ? "return " + a + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + Pa(r) + " coords = getOutputCoords();\n        int end = " + ni(r, "coords") + ";\n        float val = 0.0;\n        for (int i = " + a + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + i + " end) {\n            continue;\n          }\n          if (idx == end && " + e + ") {\n            continue;\n          }\n          " + ni(r, "coords") + " = idx;\n          val += getX(" + function (t, e) {
            if (1 === t) return "" + e;
            if (2 === t) return e + ".x, " + e + ".y";
            if (3 === t) return e + ".x, " + e + ".y, " + e + ".z";
            if (4 === t) return e + ".x, " + e + ".y, " + e + ".z, " + e + ".w";
            throw Error("Cumulative sum for rank " + t + " is not yet supported")
          }(r, "coords") + ");\n        }\n        setOutput(val);\n      }\n    "
        }(t.shape, n, r);
        return this.compileAndRun(a, [t])
      }, e.prototype.equal = function (t, e) {
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(equal(a, b));\n", "bool");
        var n = new Ka("return float(a == b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
      }, e.prototype.notEqual = function (t, e) {
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(notEqual(a, b));\n", "bool");
        var n = new Ka("return float(a != b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
      }, e.prototype.less = function (t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.less(t, e);
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThan(a, b));\n", "bool");
        var n = new Ka("return float(a < b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
      }, e.prototype.lessEqual = function (t, e) {
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
        var n = new Ka("return float(a <= b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
      }, e.prototype.greater = function (t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.greater(t, e);
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThan(a, b));\n", "bool");
        var n = new Ka("return float(a > b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
      }, e.prototype.greaterEqual = function (t, e) {
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
        var n = new Ka("return float(a >= b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
      }, e.prototype.logicalNot = function (t) {
        var e = new Pi(t.shape, "return float(!(x >= 1.0));");
        return this.compileAndRun(e, [t])
      }, e.prototype.logicalAnd = function (t, e) {
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
        var n = new Ka("return float(a >= 1.0 && b >= 1.0);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
      }, e.prototype.logicalOr = function (t, e) {
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
        var n = new Ka("return float(a >= 1.0 || b >= 1.0);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "bool")
      }, e.prototype.select = function (t, e, n) {
        var r = new function (t, e, n) {
          var r, a;
          if (this.variableNames = ["c", "a", "b"], this.outputShape = e, n > 4) throw Error("Where for rank " + n + " is not yet supported");
          if (1 === n) a = "resRC", r = "resRC";
          else {
            for (var i = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o = [], s = [], u = 0; u < e.length; u++) s.push("" + i[u]), u < t && o.push("" + i[u]);
            r = o.join(), a = s.join()
          }
          var l = Pa(n);
          this.userCode = "\n      void main() {\n        " + l + " resRC = getOutputCoords();\n        float cVal = getC(" + r + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + a + "));\n        } else {\n          setOutput(getB(" + a + "));\n        }\n      }\n    "
        }(t.rank, e.shape, e.rank);
        return this.compileAndRun(r, [t, e, n], Ct(e.dtype, n.dtype))
      }, e.prototype.where = function (t) {
        Ge("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        var e = t.dataSync();
        return ka(t.shape, e)
      }, e.prototype.topk = function (t, e, n) {
        return Sa(t.dataSync(), t.shape, t.dtype, e)
      }, e.prototype.min = function (t, e) {
        Qe("min", e, t.rank);
        var n = Je(t.shape, e),
          r = n[0],
          a = N(n[1]),
          i = t.as2D(-1, a);
        return this.reduce(i, "min", i.dtype).reshape(r)
      }, e.prototype.minimum = function (t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.minimum(t, e);
        var n = o().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new $a("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ka("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
      }, e.prototype.mod = function (t, e) {
        var n = o().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new $a("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ka("if (b == 0.0) return NAN;\n  return mod(a, b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
      }, e.prototype.max = function (t, e) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e);
        Qe("max", e, t.rank);
        var n = Je(t.shape, e),
          r = n[0],
          a = N(n[1]),
          i = t.as2D(-1, a);
        return this.reduce(i, "max", i.dtype).reshape(r)
      }, e.prototype.maximum = function (t, e) {
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.maximum(t, e);
        var n = o().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new $a("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ka("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
      }, e.prototype.all = function (t, e) {
        Qe("all", e, t.rank);
        var n = Je(t.shape, e),
          r = n[0],
          a = N(n[1]),
          i = t.as2D(-1, a);
        return this.reduce(i, "all", i.dtype).reshape(r)
      }, e.prototype.any = function (t, e) {
        Qe("any", e, t.rank);
        var n = Je(t.shape, e),
          r = n[0],
          a = N(n[1]),
          i = t.as2D(-1, a);
        return this.reduce(i, "any", i.dtype).reshape(r)
      }, e.prototype.squaredDifference = function (t, e) {
        var n = o().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new $a("return (a - b) * (a - b);", t.shape, e.shape) : new Ka("return (a - b) * (a - b);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
      }, e.prototype.realDivide = function (t, e) {
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", !0);
        var n = new Ka("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "float32")
      }, e.prototype.floorDiv = function (t, e) {
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
        var n = new Ka("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t.shape, e.shape);
        return this.compileAndRun(n, [t, e], "int32")
      }, e.prototype.add = function (t, e) {
        if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, ja);
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.add(t, e);
        var n = Ct(t.dtype, e.dtype);
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, ja, n);
        var r = new Ka(ja, t.shape, e.shape);
        return this.compileAndRun(r, [t, e], n)
      }, e.prototype.packedUnaryOp = function (t, e, n) {
        var r = new no(t.shape, e);
        return this.compileAndRun(r, [t], n)
      }, e.prototype.packedBinaryOp = function (t, e, n, r, a) {
        void 0 === a && (a = !1);
        var i = new $a(n, t.shape, e.shape, a);
        return this.compileAndRun(i, [t, e], r)
      }, e.prototype.complexSeparableBinaryOp = function (t, e, n) {
        var r = this,
          a = this.texData.get(t.dataId),
          i = this.texData.get(e.dataId),
          o = [
            [a.complexTensors.real, i.complexTensors.real],
            [a.complexTensors.imag, i.complexTensors.imag]
          ].map(function (a) {
            var i = a[0],
              o = a[1],
              s = r.makeComplexComponentTensorInfo(t, i),
              u = r.makeComplexComponentTensorInfo(e, o),
              l = new Ka(n, t.shape, e.shape);
            return r.compileAndRun(l, [s, u], Ct(i.dtype, o.dtype))
          }),
          s = o[0],
          u = o[1],
          l = this.complex(s, u);
        return s.dispose(), u.dispose(), l
      }, e.prototype.makeComplexComponentTensorInfo = function (t, e) {
        return {
          dataId: e.dataId,
          dtype: e.dtype,
          shape: t.shape
        }
      }, e.prototype.addN = function (t) {
        if (1 === t.length) return t[0];
        if (t.length > o().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
          var e = Math.floor(t.length / 2),
            n = this.addN(t.slice(0, e)),
            r = this.addN(t.slice(e));
          return this.addN([n, r])
        }
        var a = t.map(function (t) {
            return t.dtype
          }).reduce(function (t, e) {
            return Ct(t, e)
          }),
          i = t.map(function (t) {
            return t.shape
          }),
          s = o().getBool("WEBGL_PACK") ? new function (t, e) {
            this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map(function (t, e) {
              return "T" + e
            });
            var n = [];
            this.variableNames.forEach(function (t) {
              n.push("vec4 v" + t + " = get" + t + "AtOutCoords();")
            });
            var r = this.variableNames.map(function (t) {
              return "v" + t
            }).join(" + ");
            this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        vec4 result = " + r + ";\n        setOutput(result);\n      }\n    "
          }(t[0].shape, i) : new function (t, e) {
            this.outputShape = [], this.outputShape = t, this.variableNames = e.map(function (t, e) {
              return "T" + e
            });
            var n = [];
            this.variableNames.forEach(function (t) {
              n.push("float v" + t + " = get" + t + "AtOutCoords();")
            });
            var r = this.variableNames.map(function (t) {
              return "v" + t
            }).join(" + ");
            this.userCode = "\n      void main() {\n        " + n.join("\n        ") + "\n\n        float result = " + r + ";\n        setOutput(result);\n      }\n    "
          }(t[0].shape, i);
        return this.compileAndRun(s, t, a)
      }, e.prototype.subtract = function (t, e) {
        if ("complex64" === t.dtype && "complex64" === e.dtype) return this.complexSeparableBinaryOp(t, e, Ga);
        if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.subtract(t, e);
        var n = Ct(t.dtype, e.dtype);
        if (o().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, e, Ga, t.dtype);
        var r = new Ka(Ga, t.shape, e.shape);
        return this.compileAndRun(r, [t, e], n)
      }, e.prototype.pow = function (t, e) {
        var n = o().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new $a("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ka("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t.shape, e.shape),
          r = Ct(t.dtype, e.dtype);
        return this.compileAndRun(n, [t, e], r)
      }, e.prototype.ceil = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
        if (o().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ki, t.dtype);
        var e = new Pi(t.shape, Ki);
        return this.compileAndRun(e, [t])
      }, e.prototype.floor = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
        if (o().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Xi, t.dtype);
        var e = new Pi(t.shape, Xi);
        return this.compileAndRun(e, [t])
      }, e.prototype.sign = function (t) {
        var e = new Pi(t.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.isNaN = function (t) {
        var e = new Pi(t.shape, "return float(isnan(x));");
        return this.compileAndRun(e, [t], "bool")
      }, e.prototype.isInf = function (t) {
        var e = new Pi(t.shape, "return float(isinf(x));");
        return this.compileAndRun(e, [t], "bool")
      }, e.prototype.isFinite = function (t) {
        var e = new Pi(t.shape, "return float(!isnan(x) && !isinf(x));");
        return this.compileAndRun(e, [t], "bool")
      }, e.prototype.round = function (t) {
        var e = new Pi(t.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.exp = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
        if (o().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, $i, t.dtype);
        var e = new Pi(t.shape, $i);
        return this.compileAndRun(e, [t])
      }, e.prototype.expm1 = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
        if (o().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Yi, t.dtype);
        var e = new Pi(t.shape, Yi);
        return this.compileAndRun(e, [t])
      }, e.prototype.log = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
        if (o().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t.dtype);
        var e = new Pi(t.shape, "if (x < 0.0) return NAN;\n  return log(x);");
        return this.compileAndRun(e, [t])
      }, e.prototype.log1p = function (t) {
        var e = new Pi(t.shape, "return log(1.0 + x);");
        return this.compileAndRun(e, [t])
      }, e.prototype.sqrt = function (t) {
        var e = new Pi(t.shape, "return sqrt(x);");
        return this.compileAndRun(e, [t])
      }, e.prototype.rsqrt = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
        var e = new Pi(t.shape, "return inversesqrt(x);");
        return this.compileAndRun(e, [t])
      }, e.prototype.reciprocal = function (t) {
        var e = new Pi(t.shape, "return 1.0 / x;");
        return this.compileAndRun(e, [t])
      }, e.prototype.relu = function (t) {
        var e;
        return e = o().getBool("WEBGL_PACK") ? new no(t.shape, Qi) : new Pi(t.shape, ji), this.compileAndRun(e, [t])
      }, e.prototype.relu6 = function (t) {
        var e;
        return e = o().getBool("WEBGL_PACK") ? new no(t.shape, to) : new Pi(t.shape, Gi), this.compileAndRun(e, [t])
      }, e.prototype.prelu = function (t, e) {
        var n = o().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new $a(Xa, t.shape, e.shape) : new Ka(Ha, t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
      }, e.prototype.elu = function (t) {
        if (o().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, eo, t.dtype);
        var e = new Pi(t.shape, qi);
        return this.compileAndRun(e, [t])
      }, e.prototype.eluDer = function (t, e) {
        var n = o().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new $a("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t.shape, e.shape) : new Ka("return (b >= 1.0) ? a : a * (b + 1.0);", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
      }, e.prototype.selu = function (t) {
        var e = new Pi(t.shape, "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = 1.0507009873554805;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.int = function (t) {
        var e = new Pi(t.shape, "return float(int(x));");
        return this.compileAndRun(e, [t], "int32")
      }, e.prototype.clip = function (t, e, n) {
        var r, a = (r = o().getBool("WEBGL_PACK_CLIP") ? new Ja(t.shape) : new Ya(t.shape)).getCustomSetupFunc(e, n);
        return this.compileAndRun(r, [t], null, a)
      }, e.prototype.abs = function (t) {
        if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
        if (o().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Ui, t.dtype);
        var e = new Pi(t.shape, Ui);
        return this.compileAndRun(e, [t])
      }, e.prototype.complexAbs = function (t) {
        var e = this.texData.get(t.dataId),
          n = new function (t) {
            this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "
          }(t.shape),
          r = [this.makeComplexComponentTensorInfo(t, e.complexTensors.real), this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)];
        return this.compileAndRun(n, r)
      }, e.prototype.sigmoid = function (t) {
        var e = new Pi(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
        return this.compileAndRun(e, [t])
      }, e.prototype.softplus = function (t) {
        var e = new Pi(t.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.sin = function (t) {
        var e = new Pi(t.shape, "if (isnan(x)) return x;\n  return sin(x);\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.cos = function (t) {
        var e = new Pi(t.shape, "if (isnan(x)) return x;\n  return cos(x);\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.tan = function (t) {
        var e = new Pi(t.shape, "return tan(x);");
        return this.compileAndRun(e, [t])
      }, e.prototype.asin = function (t) {
        var e = new Pi(t.shape, "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.acos = function (t) {
        var e = new Pi(t.shape, "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.atan = function (t) {
        var e = new Pi(t.shape, "if (isnan(x)) return x;\n  return atan(x);\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.atan2 = function (t, e) {
        var n = o().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new $a("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t.shape, e.shape) : new Ka("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t.shape, e.shape);
        return this.compileAndRun(n, [t, e])
      }, e.prototype.sinh = function (t) {
        var e = new Pi(t.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.cosh = function (t) {
        var e = new Pi(t.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.tanh = function (t) {
        var e = new Pi(t.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
        return this.compileAndRun(e, [t])
      }, e.prototype.asinh = function (t) {
        var e = new Pi(t.shape, "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");
        return this.compileAndRun(e, [t])
      }, e.prototype.acosh = function (t) {
        var e = new Pi(t.shape, "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");
        return this.compileAndRun(e, [t])
      }, e.prototype.atanh = function (t) {
        var e = new Pi(t.shape, "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");
        return this.compileAndRun(e, [t])
      }, e.prototype.erf = function (t) {
        var e = new Pi(t.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
        return this.compileAndRun(e, [t])
      }, e.prototype.step = function (t, e) {
        var n = new Pi(t.shape, function (t) {
          return void 0 === t && (t = 0), Wi + "\n    return x > 0.0 ? 1.0 : float(" + t + ");\n  "
        }(e));
        return this.compileAndRun(n, [t])
      }, e.prototype.conv2dByMatMul = function (t, e, n, r, a, i) {
        var s = t.shape,
          u = this.texData.get(t.dataId),
          l = n.inChannels,
          c = s[0] * s[1] * s[2],
          p = n.outChannels,
          h = "channelsLast" === n.dataFormat,
          f = (1 === c || 1 === p) && l > 1e3,
          d = s[2] % 2 != 0 && !!u.isPacked;
        if (f || !o().getBool("WEBGL_LAZILY_UNPACK") || !o().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !d) {
          var m = h ? s[0] * s[1] * s[2] : s[0] * s[2] * s[3],
            g = this.reshape(t, [1, m, n.inChannels]),
            v = this.reshape(e, [1, n.inChannels, n.outChannels]);
          return this.reshape(this.fusedBatchMatMul({
            a: g,
            b: v,
            transposeA: !1,
            transposeB: !1,
            bias: r,
            activation: a,
            preluActivationWeights: i
          }), n.outShape)
        }
        var y = h ? s[0] * s[1] * (s[2] + 1) : s[0] * s[2] * (s[3] + 1),
          x = {
            dataId: t.dataId,
            shape: [1, y, n.inChannels],
            dtype: t.dtype
          },
          w = u.shape;
        u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, b(Ie(u.shape, x.shape), function () {
          return "packed reshape " + u.shape + " to " + x.shape + " isn't free"
        });
        var C = this.reshape(e, [1, n.inChannels, n.outChannels]),
          N = this.fusedBatchMatMul({
            a: x,
            b: C,
            transposeA: !1,
            transposeB: !1,
            bias: r,
            activation: a,
            preluActivationWeights: i
          }),
          S = this.texData.get(N.dataId);
        return b(S.isPacked, function () {
          return "batchMatMul result is expected to be packed"
        }), u.shape = w, S.shape = n.outShape, Dt.makeTensorFromDataId(N.dataId, n.outShape, N.dtype)
      }, e.prototype.conv2dWithIm2Row = function (t, e, n, r, a, i) {
        var o = n.filterWidth,
          s = n.filterHeight,
          u = n.inChannels,
          l = n.outWidth,
          c = n.outHeight,
          p = "channelsLast" === n.dataFormat,
          h = o * s * u,
          f = c * l,
          d = [h, f],
          m = t.squeeze([0]),
          g = e.reshape([1, h, -1]),
          v = new function (t, e, n) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;
            for (var r = n.filterWidth, a = n.inChannels, i = n.strideWidth, o = n.strideHeight, s = n.padInfo, u = n.outWidth, l = n.dilationWidth, c = n.dilationHeight, p = n.dataFormat, h = s.left, f = s.top, d = a * r, m = Aa(), g = "channelsLast" === p, v = g ? 0 : 1, y = g ? 1 : 2, b = "", x = 0; x <= 1; x++)
              for (var w = 0; w <= 1; w++) b += "\n          blockIndex = rc.y + " + w + ";\n          pos = rc.x + " + x + ";\n\n          if(blockIndex < " + t[1] + " && pos < " + t[0] + ") {\n            offsetY = int(blockIndex / (" + u + ")) * " + o + " - " + f + ";\n            d0 = offsetY + " + c + " * (pos / " + d + ");\n\n            if(d0 < " + e[v] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u + ".) * " + i + ". - " + h + ".);\n              d1 = offsetX + " + l + " * (int(mod(float(pos), " + d + ".) / " + a + ".));\n\n              if(d1 < " + e[y] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + a + ".));\n\n                if (" + g + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * x + w) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * x + w) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
            this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + b + "\n\n        " + m.output + " = result;\n      }\n    "
          }(d, m.shape, n),
          y = this.compileAndRun(v, [m]).reshape([1, d[0], d[1]]),
          b = null != r,
          x = null != i,
          w = a ? ao(a, !0) : null,
          C = new Ii(y.shape, [1, f, n.outChannels], !0, !1, b, w, x),
          N = [y, g];
        r && N.push(r), x && N.push(i);
        var S = this.compileAndRun(C, N);
        return p ? S.reshape([1, c, l, n.outChannels]) : S.reshape([1, n.outChannels, c, l])
      }, e.prototype.fusedConv2d = function (t) {
        var e = t.input,
          n = t.filter,
          r = t.convInfo,
          a = t.bias,
          i = t.activation,
          s = t.preluActivationWeights;
        if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && ("SAME" === r.padInfo.type || "VALID" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, a, i, s);
        if (o().getBool("WEBGL_CONV_IM2COL") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, a, i, s);
        var u = null != a,
          l = null != s,
          c = i ? ao(i, !1) : null,
          p = new Qa(r, u, c, l),
          h = [e, n];
        return a && h.push(a), s && h.push(s), this.compileAndRun(p, h)
      }, e.prototype.conv2d = function (t, e, n) {
        if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && ("SAME" === n.padInfo.type || "VALID" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);
        if (o().getBool("WEBGL_CONV_IM2COL") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);
        var r = new Qa(n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.conv2dDerInput = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
          var e = t.filterHeight,
            n = t.filterWidth,
            r = t.strideHeight,
            a = t.strideWidth,
            i = "channelsLast" === t.dataFormat,
            o = e - 1 - t.padInfo.top,
            s = n - 1 - t.padInfo.left,
            u = i ? 1 : 2,
            l = i ? 2 : 3,
            c = i ? 3 : 1;
          this.userCode = "\n      const ivec2 pads = ivec2(" + o + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + c + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u + "], coords[" + l + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n\n              if (" + i + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.conv2dDerFilter = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
          var e = t.strideHeight,
            n = t.strideWidth,
            r = t.padInfo.top,
            a = t.padInfo.left,
            i = "channelsLast" === t.dataFormat;
          this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + a + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              if (" + i + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.fusedDepthwiseConv2D = function (t) {
        var e, n = t.input,
          r = t.filter,
          a = t.convInfo,
          i = t.bias,
          s = t.activation,
          u = t.preluActivationWeights,
          l = o().getBool("WEBGL_PACK_DEPTHWISECONV") && a.strideWidth <= 2 && a.outChannels / a.inChannels == 1,
          c = s ? ao(s, l) : null,
          p = [n, r],
          h = null != i,
          f = null != u;
        return h && p.push(i), f && p.push(u), l ? (e = new ei(a, h, c, f), this.compileAndRun(e, p)) : (e = new ti(a, h, c, f), this.compileAndRun(e, p))
      }, e.prototype.depthwiseConv2D = function (t, e, n) {
        var r;
        return o().getBool("WEBGL_PACK_DEPTHWISECONV") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new ei(n), this.compileAndRun(r, [t, e])) : (r = new ti(n), this.compileAndRun(r, [t, e]))
      }, e.prototype.depthwiseConv2DDerInput = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
          var e = t.filterHeight,
            n = t.filterWidth,
            r = t.strideHeight,
            a = t.strideWidth,
            i = e - 1 - t.padInfo.top,
            o = n - 1 - t.padInfo.left,
            s = t.outChannels / t.inChannels;
          this.userCode = "\n      const ivec2 pads = ivec2(" + i + ", " + o + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s + "; dm++) {\n              int d2 = d1 * " + s + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
          var e = t.strideHeight,
            n = t.strideWidth,
            r = t.padInfo.top,
            a = t.padInfo.left,
            i = t.outChannels / t.inChannels;
          this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + i + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n            int xR = wR + yR * " + e + " - " + r + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n              int xC = wC + yC * " + n + " - " + a + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.conv3d = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["x", "W"], this.outputShape = t.outShape;
          var e = t.padInfo.front,
            n = t.padInfo.top,
            r = t.padInfo.left,
            a = t.strideDepth,
            i = t.strideHeight,
            o = t.strideWidth,
            s = t.dilationDepth,
            u = t.dilationHeight,
            l = t.dilationWidth,
            c = t.filterDepth,
            p = t.filterHeight,
            h = t.filterWidth,
            f = 4 * Math.floor(t.inChannels / 4),
            d = t.inChannels % 4;
          this.userCode = "\n      const ivec3 strides = ivec3(" + a + ", " + i + ", " + o + ");\n      const ivec3 pads = ivec3(" + e + ", " + n + ", " + r + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + c + "; wF++) {\n          int xF = xFCorner + wF * " + s + ";\n\n          if (xF < 0 || xF >= " + t.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + p + "; wR++) {\n            int xR = xRCorner + wR * " + u + ";\n\n            if (xR < 0 || xR >= " + t.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + h + "; wC++) {\n              int xC = xCCorner + wC * " + l + ";\n\n              if (xC < 0 || xC >= " + t.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + f + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === d) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + f + ") *\n                  getW(wF, wR, wC, " + f + ", d2);\n              } else if (" + (2 === d) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + f + "),\n                  getX(batch, xF, xR, xC, " + f + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + f + ", d2),\n                  getW(wF, wR, wC, " + f + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === d) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + f + "),\n                  getX(batch, xF, xR, xC, " + f + " + 1),\n                  getX(batch, xF, xR, xC, " + f + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + f + ", d2),\n                  getW(wF, wR, wC, " + f + " + 1, d2),\n                  getW(wF, wR, wC, " + f + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.conv3dDerInput = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
          var e = t.filterDepth,
            n = t.filterHeight,
            r = t.filterWidth,
            a = t.strideDepth,
            i = t.strideHeight,
            o = t.strideWidth,
            s = e - 1 - t.padInfo.front,
            u = n - 1 - t.padInfo.top,
            l = r - 1 - t.padInfo.left;
          this.userCode = "\n      const ivec3 pads = ivec3(" + s + ", " + u + ", " + l + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + a + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + i + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.conv3dDerFilter = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
          var e = t.strideDepth,
            n = t.strideHeight,
            r = t.strideWidth,
            a = t.padInfo.front,
            i = t.padInfo.top,
            o = t.padInfo.left;
          this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t.outDepth + "; yF++) {\n            int xF = wF + yF * " + e + " - " + a + ";\n\n            if (xF < 0 || xF >= " + t.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t.outHeight + "; yR++) {\n              int xR = wR + yR * " + n + " - " + i + ";\n\n              if (xR < 0 || xR >= " + t.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t.outWidth + "; yC++) {\n                int xC = wC + yC * " + r + " - " + o + ";\n\n                if (xC < 0 || xC >= " + t.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t, e])
      }, e.prototype.maxPool = function (t, e) {
        var n = new Ai(e, "max", !1);
        return this.compileAndRun(n, [t])
      }, e.prototype.avgPool = function (t, e) {
        var n = new Ai(e, "avg", !1);
        return this.compileAndRun(n, [t], "float32")
      }, e.prototype.maxPoolBackprop = function (t, e, n, r) {
        var a = new Ai(r, "max", !0),
          i = this.compileAndRun(a, [e]),
          o = new function (t) {
            this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
            var e = t.strideHeight,
              n = t.strideWidth,
              r = t.dilationHeight,
              a = t.effectiveFilterHeight,
              i = t.effectiveFilterWidth,
              o = a - 1 - t.padInfo.top,
              s = i - 1 - t.padInfo.left,
              u = a * i - 1;
            this.userCode = "\n      const ivec2 pads = ivec2(" + o + ", " + s + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + a + ";\n          wR += " + r + ") {\n          float dyR = float(dyRCorner + wR) / " + e + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + i + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + i + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
          }(r),
          s = this.compileAndRun(o, [t, i], e.dtype);
        return i.dispose(), s
      }, e.prototype.avgPoolBackprop = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["dy"], this.outputShape = t.inShape;
          var e = t.filterHeight,
            n = t.filterWidth,
            r = t.strideHeight,
            a = t.strideWidth,
            i = t.dilationHeight,
            o = t.dilationWidth,
            s = t.effectiveFilterHeight,
            u = t.effectiveFilterWidth,
            l = s - 1 - t.padInfo.top,
            c = u - 1 - t.padInfo.left,
            p = 1 / (e * n);
          this.userCode = "\n      const ivec2 pads = ivec2(" + l + ", " + c + ");\n      const float avgMultiplier = float(" + p + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s + ";\n            wR += " + i + ") {\n          float dyR = float(dyRCorner + wR) / " + r + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u + ";\n            wC+= " + o + ") {\n            float dyC = float(dyCCorner + wC) / " + a + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t], e.dtype)
      }, e.prototype.cast = function (t, e) {
        return oa(t, e, this)
      }, e.prototype.unstack = function (t, e) {
        for (var n = t.shape[e], r = new Array(t.rank - 1), a = 0, i = 0; i < t.rank; i++) i !== e && (r[a++] = t.shape[i]);
        var o = new Array(t.rank).fill(0),
          s = t.shape.slice();
        s[e] = 1;
        var u = new Array(n);
        for (i = 0; i < u.length; i++) o[e] = i, u[i] = this.slice(t, o, s).reshape(r);
        return u
      }, e.prototype.avgPool3d = function (t, e) {
        var n = new Ri(e, "avg", !1);
        return this.compileAndRun(n, [t], "float32")
      }, e.prototype.avgPool3dBackprop = function (t, e, n) {
        var r = new function (t) {
          this.variableNames = ["dy"], this.outputShape = t.inShape;
          var e = t.filterDepth,
            n = t.filterHeight,
            r = t.filterWidth,
            a = t.strideDepth,
            i = t.strideHeight,
            o = t.strideWidth,
            s = t.dilationDepth,
            u = t.dilationHeight,
            l = t.dilationWidth,
            c = t.effectiveFilterDepth,
            p = t.effectiveFilterHeight,
            h = t.effectiveFilterWidth,
            f = c - 1 - t.padInfo.front,
            d = p - 1 - t.padInfo.top,
            m = h - 1 - t.padInfo.left,
            g = 1 / (e * n * r);
          this.userCode = "\n      const ivec3 pads = ivec3(" + f + ", " + d + ", " + m + ");\n      const float avgMultiplier = float(" + g + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + c + ";\n            wD += " + s + ") {\n          float dyD = float(dyDCorner + wD) / " + a + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + p + ";\n              wR += " + u + ") {\n            float dyR = float(dyRCorner + wR) / " + i + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + h + ";\n                wC += " + l + ") {\n              float dyC = float(dyCCorner + wC) / " + o + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
        }(n);
        return this.compileAndRun(r, [t], e.dtype)
      }, e.prototype.maxPool3d = function (t, e) {
        var n = new Ri(e, "max", !1);
        return this.compileAndRun(n, [t], "float32")
      }, e.prototype.maxPool3dBackprop = function (t, e, n, r) {
        var a = new Ri(r, "max", !0),
          i = this.compileAndRun(a, [e]),
          o = new function (t) {
            this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
            var e = t.strideDepth,
              n = t.strideHeight,
              r = t.strideWidth,
              a = t.dilationDepth,
              i = t.dilationHeight,
              o = t.dilationWidth,
              s = t.effectiveFilterDepth,
              u = t.effectiveFilterHeight,
              l = t.effectiveFilterWidth,
              c = s - 1 - t.padInfo.front,
              p = u - 1 - t.padInfo.top,
              h = l - 1 - t.padInfo.left,
              f = s * u * l - 1;
            this.userCode = "\n      const ivec3 pads = ivec3(" + c + ", " + p + ", " + h + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s + ";\n           wD += " + a + ") {\n          float dyD = float(dyDCorner + wD) / " + e + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u + ";\n              wR += " + i + ") {\n            float dyR = float(dyRCorner + wR) / " + n + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + l + ";\n                wC += " + o + ") {\n              float dyC = float(dyCCorner + wC) / " + r + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + f + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u + " * " + l + " +\n                  wR * " + l + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "
          }(r),
          s = this.compileAndRun(o, [t, i], e.dtype);
        return i.dispose(), s
      }, e.prototype.reshape = function (t, e) {
        var n = this.texData.get(t.dataId);
        if (n.isPacked && !Ie(t.shape, e) && (null === n.texture || !Ie(n.shape, e))) {
          var r = this.packedReshape(t, e);
          return Dt.makeTensorFromDataId(r.dataId, r.shape, r.dtype)
        }
        return sa(t, e)
      }, e.prototype.resizeBilinear = function (t, e, n, r) {
        var a = o().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new function (t, e, n, r) {
          this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
          var a = t[0],
            i = t[1],
            o = t[2],
            s = t[3];
          this.outputShape = [a, e, n, s];
          var u = [r && e > 1 ? i - 1 : i, r && n > 1 ? o - 1 : o],
            l = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
          this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + u[0] / l[0] + ",\n          " + u[1] / l[1] + ",\n          " + u[1] / l[1] + ");\n      const vec3 inputShapeRC = vec3(" + i + ".0, " + o + ".0,\n                                     " + o + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (s - 1) + ";\n        bool hasNextRow = coords.z < " + (n - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "
        }(t.shape, e, n, r) : new function (t, e, n, r) {
          this.variableNames = ["A"], this.outputShape = [];
          var a = t[0],
            i = t[1],
            o = t[2],
            s = t[3];
          this.outputShape = [a, e, n, s];
          var u = [r && e > 1 ? i - 1 : i, r && n > 1 ? o - 1 : o],
            l = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];
          this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / l[0] + ",\n          " + u[1] / l[1] + ");\n      const vec2 inputShapeRC = vec2(" + i + ".0, " + o + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "
        }(t.shape, e, n, r);
        return this.compileAndRun(a, [t], "float32")
      }, e.prototype.resizeBilinearBackprop = function (t, e, n) {
        var r = new function (t, e, n) {
          this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
          var r = e.shape,
            a = r[1],
            i = r[2],
            o = t.shape,
            s = o[1],
            u = o[2],
            l = [n && s > 1 ? a - 1 : a, n && u > 1 ? i - 1 : i],
            c = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
            p = l[0] / c[0],
            h = l[1] / c[1],
            f = 1 / p,
            d = 1 / h,
            m = 2 * Math.ceil(f) + 2,
            g = 2 * Math.ceil(d) + 2;
          this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + p + ");\n        const float widthScale = float(" + h + ");\n\n        const float invHeightScale = float(" + f + ");\n        const float invWidthScale = float(" + d + ");\n\n        const int winHeight = int(" + m + ");\n        const int winWidth = int(" + g + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (a - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (i - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
        }(t, e, n);
        return this.compileAndRun(r, [t])
      }, e.prototype.resizeNearestNeighbor = function (t, e, n, r) {
        var a = new function (t, e, n, r) {
          this.variableNames = ["A"], this.outputShape = [];
          var a = t[0],
            i = t[1],
            o = t[2],
            s = t[3];
          this.outputShape = [a, e, n, s];
          var u = [r && e > 1 ? i - 1 : i, r && n > 1 ? o - 1 : o],
            l = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],
            c = r ? "0.5" : "0.0";
          this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u[0] / l[0] + ",\n          " + u[1] / l[1] + ");\n      const vec2 inputShapeRC = vec2(" + i + ".0, " + o + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + c + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "
        }(t.shape, e, n, r);
        return this.compileAndRun(a, [t])
      }, e.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
        var r = new function (t, e, n) {
          this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e.shape;
          var r = e.shape,
            a = r[1],
            i = r[2],
            o = t.shape,
            s = o[1],
            u = o[2],
            l = [n && s > 1 ? a - 1 : a, n && u > 1 ? i - 1 : i],
            c = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],
            p = l[0] / c[0],
            h = l[1] / c[1],
            f = 1 / p,
            d = 1 / h,
            m = 2 * Math.ceil(f) + 2,
            g = 2 * Math.ceil(d) + 2;
          this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + p + ");\n        const float widthScale = float(" + h + ");\n\n        const float invHeightScale = float(" + f + ");\n        const float invWidthScale = float(" + d + ");\n\n        const int winHeight = int(" + m + ");\n        const int winWidth = int(" + g + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + l[0] + ") *\n                (float(dyR) / float(" + c[0] + "));\n\n            float sourceFracCol =\n                float(" + l[1] + ") *\n                  (float(dyC) / float(" + c[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + a + ") - 1),\n                " + n + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + i + ") - 1),\n                " + n + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "
        }(t, e, n);
        return this.compileAndRun(r, [t])
      }, e.prototype.multinomial = function (t, e, n, r) {
        var a = e ? t : Wr(t),
          i = a.shape[0],
          o = a.shape[1],
          s = new Ei(i, o, n),
          u = s.getCustomSetupFunc(r);
        return this.compileAndRun(s, [a], "int32", u)
      }, e.prototype.oneHot = function (t, e, n, r) {
        var a = new function (t, e, n, r) {
          this.variableNames = ["indices"], this.outputShape = [t, e], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r + "), float(" + n + "),\n                      float(index == coords.y)));\n      }\n    "
        }(t.size, e, n, r);
        return this.compileAndRun(a, [t])
      }, e.prototype.diag = function (t) {
        var e = new function (t) {
          this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "
        }(t.size);
        return this.compileAndRun(e, [t])
      }, e.prototype.nonMaxSuppression = function (t, e, n, r, a) {
        return Ge("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), ga(t.dataSync(), e.dataSync(), n, r, a)
      }, e.prototype.cropAndResize = function (t, e, n, r, a, i) {
        var o = new function (t, e, n, r, a) {
          this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
          var i = t[0],
            o = t[1],
            s = t[2],
            u = t[3],
            l = e[0],
            c = n[0],
            p = n[1];
          this.outputShape = [l, c, p, u];
          var h = "bilinear" === r ? 1 : 0,
            f = [o - 1 + ".0", s - 1 + ".0"],
            d = f[0],
            m = f[1],
            g = c > 1 ? ["" + (o - 1) / (c - 1), "(y2-y1) * height_ratio", "y1*" + d + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + d],
            v = g[0],
            y = g[1],
            b = g[2],
            x = p > 1 ? ["" + (s - 1) / (p - 1), "(x2-x1) * width_ratio", "x1*" + m + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + m],
            w = x[0],
            C = x[1],
            N = x[2];
          this.userCode = "\n      const float height_ratio = float(" + v + ");\n      const float width_ratio = float(" + w + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + i + ") {\n          return;\n        }\n\n        float height_scale = " + y + ";\n        float width_scale = " + C + ";\n\n        float in_y = " + b + ";\n        if( in_y < 0.0 || in_y > " + d + " ) {\n          setOutput(float(" + a + "));\n          return;\n        }\n        float in_x = " + N + ";\n        if( in_x < 0.0 || in_x > " + m + " ) {\n          setOutput(float(" + a + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + h + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "
        }(t.shape, e.shape, r, a, i);
        return this.compileAndRun(o, [t, e, n], "float32")
      }, e.prototype.depthToSpace = function (t, e, n) {
        b(e > 1, function () {
          return "blockSize should be > 1 for depthToSpace, but was: " + e
        });
        var r = t.shape[0],
          a = "NHWC" === n ? t.shape[1] : t.shape[2],
          i = "NHWC" === n ? t.shape[2] : t.shape[3],
          o = "NHWC" === n ? t.shape[3] : t.shape[1],
          s = a * e,
          u = i * e,
          l = o / (e * e),
          c = new ri("NHWC" === n ? [r, s, u, l] : [r, l, s, u], e, n);
        return this.compileAndRun(c, [t])
      }, e.prototype.split = function (t, e, n) {
        return Ca(t, e, n)
      }, e.prototype.scatterND = function (t, e, n) {
        var r = Ar(0, t, n),
          a = r.sliceRank,
          i = r.numUpdates,
          o = r.sliceSize,
          s = r.strides,
          u = r.outputSize,
          l = [u / o, o],
          c = t.reshape([i, a]),
          p = e.reshape([i, o]);
        if (0 === u) return sa(cn([]), n);
        var h = hn(0),
          f = new Ti(i, a, c.rank, p.rank, s, l);
        return this.compileAndRun(f, [p, c, h]).reshape(n)
      }, e.prototype.sparseToDense = function (t, e, n, r) {
        var a = Ar(0, t, n),
          i = a.sliceRank,
          o = a.numUpdates,
          s = a.strides,
          u = a.outputSize,
          l = new Ti(o, i, t.rank, e.rank, s, [u, 1], !1);
        return this.compileAndRun(l, [e, t, r]).reshape(n)
      }, e.prototype.fft = function (t) {
        return this.fftImpl(t, !1)
      }, e.prototype.ifft = function (t) {
        return this.fftImpl(t, !0)
      }, e.prototype.fftImpl = function (t, e) {
        var n = this.texData.get(t.dataId),
          r = new ai("return real * expR - imag * expI;", t.shape, e),
          a = new ai("return real * expI + imag * expR;", t.shape, e),
          i = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)],
          o = this.compileAndRun(r, i),
          s = this.compileAndRun(a, i),
          u = this.complex(o, s).as2D(t.shape[0], t.shape[1]);
        return o.dispose(), s.dispose(), u
      }, e.prototype.gatherND = function (t, e) {
        var n = e.shape,
          r = n[n.length - 1],
          a = kr(t, e),
          i = a[0],
          o = a[1],
          s = a[2],
          u = a[3],
          l = e.reshape([o, r]),
          c = t.reshape([t.size / s, s]),
          p = new function (t, e, n) {
            this.sliceDim = t, this.strides = e, this.variableNames = ["x", "indices"], this.outputShape = n;
            var r = Pa(e.length),
              a = Pa(n.length),
              i = this.sliceDim > 1 ? "strides[j]" : "strides";
            this.userCode = "\n        " + r + " strides = " + r + "(" + this.strides + ");\n         void main() {\n          " + a + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + i + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "
          }(r, u, [o, s]);
        return this.compileAndRun(p, [c, l]).reshape(i)
      }, e.prototype.fill = function (t, e, n) {
        if ("string" === (n = n || G(e))) {
          var r = F(n, N(t));
          return r.fill(e), Dt.makeTensor(r, t, n, this)
        }
        var a = new ii(t, e),
          i = a.getCustomSetupFunc(e);
        return this.compileAndRun(a, [], n, i)
      }, e.prototype.onesLike = function (t) {
        if ("string" === t.dtype) throw new Error("onesLike is not supported under string dtype");
        return this.fill(t.shape, 1, t.dtype)
      }, e.prototype.zerosLike = function (t) {
        return this.fill(t.shape, "string" === t.dtype ? "" : 0, t.dtype)
      }, e.prototype.linspace = function (t, e, n) {
        return ua(t, e, n)
      }, e.prototype.makeTensorInfo = function (t, e) {
        var n = this.write(null, t, e);
        return this.texData.get(n).usage = null, {
          dataId: n,
          shape: t,
          dtype: e
        }
      }, e.prototype.makeOutput = function (t, e) {
        var n = this.makeTensorInfo(t, e).dataId;
        return Dt.makeTensorFromDataId(n, t, e, this)
      }, e.prototype.unpackTensor = function (t) {
        var e = new function (t) {
          this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;
          var e = t.length,
            n = Ea("rc", e),
            r = Pa(e),
            a = function (t, e) {
              if (1 === t) return "rc";
              for (var n = "", r = 0; r < t; r++) n += e[r], r < t - 1 && (n += ",");
              return n
            }(e, n),
            i = n.slice(-2),
            o = e <= 1 ? "rc" : "vec2(" + i.join(",") + ")";
          this.userCode = "\n      void main() {\n        " + r + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + a + ");\n\n        setOutput(getChannel(packedInput, " + o + "));\n      }\n    "
        }(t.shape);
        return this.runWebGLProgram(e, [t], t.dtype)
      }, e.prototype.packTensor = function (t) {
        var e = new function (t) {
          this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;
          var e = t.length;
          if (0 === e) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
          else {
            var n = Ea("rc", e),
              r = Pa(e),
              a = function (t, e, n) {
                if (1 === t) return "rc > " + e[0];
                for (var r = "", a = t - 2; a < t; a++) r += n[a] + " >= " + e[a], a < t - 1 && (r += "||");
                return r
              }(e, t, n),
              i = function (t, e, n, r) {
                if (1 === t) return "";
                var a = r.slice(-2);
                return "\n    int r = " + a[0] + ";\n    int c = " + a[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e + ";\n    bool rEdge = rp1 >= " + n + ";\n  "
              }(e, t[t.length - 1], t[t.length - 2], n),
              o = function (t, e) {
                var n = t.length,
                  r = function (t, e) {
                    for (var n = [], r = 0; r <= 1; r++)
                      for (var a = 0; a <= 1; a++) {
                        for (var i = (0 === r ? "r" : "rp1") + ", " + (0 === a ? "c" : "cp1"), o = 2; o < t; o++) i = e[e.length - 1 - o] + "," + i;
                        n.push(i)
                      }
                    return n
                  }(n, e);
                return 1 === n ? "getA(rc),\n            rc + 1 >= " + t[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r[0] + "),\n          cEdge ? 0. : getA(" + r[1] + "),\n          rEdge ? 0. : getA(" + r[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r[3] + ")"
              }(t, n);
            this.userCode = "\n        void main() {\n          " + r + " rc = getOutputCoords();\n\n          if(" + a + ") {\n            setOutput(vec4(0));\n          } else {\n            " + i + "\n\n            setOutput(vec4(" + o + "));\n          }\n        }\n      "
          }
        }(t.shape);
        return this.runWebGLProgram(e, [t], t.dtype, null, !0)
      }, e.prototype.packedReshape = function (t, e) {
        var n = [we(t.shape)].concat(Ce(t.shape)),
          r = {
            dtype: t.dtype,
            shape: n,
            dataId: t.dataId
          },
          a = new function (t, e) {
            this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;
            for (var n = "", r = 0; r < 4; r++) {
              var a = "thisRC = rc;";
              r % 2 == 1 && (a += "thisRC.z += 1;"), r > 1 && (a += "thisRC.y += 1;"), n += "\n        " + a + "\n        " + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r > 0 ? "}" : "") + "\n      "
            }
            this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + Ra(["r", "c", "d"], e) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + Ta(t) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t[1] + ";\n        int cols = " + t[2] + ";\n\n        " + n + "\n\n        setOutput(result);\n      }\n    "
          }([we(e)].concat(Ce(e)), n),
          i = this.runWebGLProgram(a, [r], t.dtype, null, !0);
        return {
          dataId: i.dataId,
          shape: e,
          dtype: i.dtype
        }
      }, e.prototype.decode = function (t) {
        var e, n = this.texData.get(t),
          r = n.isPacked,
          a = n.shape,
          i = n.dtype,
          o = Ne(a);
        return e = r ? new function (t) {
          this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Ft.DENSE;
          var e = Ut(t),
            n = Aa();
          this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + Ra(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n.output + " = result;\n      }\n    "
        }(o) : new function (t) {
          this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Ft.DENSE;
          var e = Ut(t),
            n = Aa();
          this.outputShape = t, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + Ra(["r", "c", "d"], t) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e[0] + ", " + e[1] + "));\n        int index = 4 * (resTexRC.x * " + e[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n.output + " = result;\n      }\n    "
        }(o), {
          dtype: i,
          shape: a,
          dataId: this.runWebGLProgram(e, [{
            shape: o,
            dtype: i,
            dataId: t
          }], i, null, !0).dataId
        }
      }, e.prototype.runWebGLProgram = function (t, e, n, r, a) {
        var i = this;
        void 0 === a && (a = !1);
        var s = this.makeTensorInfo(t.outputShape, n),
          u = this.texData.get(s.dataId);
        if (t.packedOutput && (u.isPacked = !0), t.outPackingScheme === Ft.DENSE) {
          var l = Ut(t.outputShape);
          u.texShape = l.map(function (t) {
            return 2 * t
          })
        }
        if (null != t.outTexUsage && (u.usage = t.outTexUsage), 0 === N(s.shape)) return u.values = _(s.dtype, 0), s;
        var c = [],
          p = e.map(function (e) {
            if ("complex64" === e.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
            var n = i.texData.get(e.dataId);
            if (null == n.texture) {
              if (!t.packedInputs && N(e.shape) <= o().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
                shape: e.shape,
                texData: null,
                isUniform: !0,
                uniformValues: n.values
              };
              t.packedInputs && (n.isPacked = !0, n.shape = e.shape)
            } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? i.unpackTensor(e) : i.packTensor(e), c.push(e), n = i.texData.get(e.dataId);
            else if (n.isPacked && !Ie(n.shape, e.shape)) {
              var r = e,
                a = e.shape;
              e.shape = n.shape, e = i.packedReshape(e, a), c.push(e), n = i.texData.get(e.dataId), r.shape = a
            }
            return i.uploadToGPU(e.dataId), {
              shape: e.shape,
              texData: n,
              isUniform: !1
            }
          });
        this.uploadToGPU(s.dataId);
        var h, f = {
            shape: s.shape,
            texData: u,
            isUniform: !1
          },
          d = function (t, e, n) {
            var r = "";
            p.concat(n).forEach(function (t) {
              var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0,
                n = t.isUniform ? "uniform" : t.texData.texShape;
              r += t.shape + "_" + n + "_" + e
            });
            var a = t.userCode;
            return t.constructor.name + "_" + r + "_" + a
          }(t, 0, f),
          m = this.getAndSaveBinary(d, function () {
            return function (t, e, n, r) {
              var a = e.userCode,
                i = n.map(function (t, n) {
                  var r = {
                    logicalShape: t.shape,
                    texShape: t.isUniform ? null : t.texData.texShape,
                    isUniform: t.isUniform,
                    isPacked: !t.isUniform && t.texData.isPacked,
                    flatOffset: null
                  };
                  return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {
                    name: e.variableNames[n],
                    shapeInfo: r
                  }
                }),
                s = i.map(function (t) {
                  return t.shapeInfo
                }),
                u = {
                  logicalShape: r.shape,
                  texShape: r.texData.texShape,
                  isUniform: !1,
                  isPacked: r.texData.isPacked,
                  flatOffset: null
                },
                l = Oa(i, u, a, e.packedInputs),
                c = t.createProgram(l),
                p = null,
                h = t.getUniformLocation(c, "NAN", !1);
              1 === o().getNumber("WEBGL_VERSION") && (p = t.getUniformLocation(c, "INFINITY", !1));
              for (var f = {}, d = 0; d < e.variableNames.length; d++) {
                var m = e.variableNames[d];
                f[m] = t.getUniformLocation(c, m, !1), f["offset" + m] = t.getUniformLocation(c, "offset" + m, !1)
              }
              return {
                program: e,
                source: l,
                webGLProgram: c,
                uniformLocations: f,
                inShapeInfos: s,
                outShapeInfo: u,
                infLoc: p,
                nanLoc: h
              }
            }(i.gpgpu, t, p, f)
          }),
          g = null != this.activeTimers;
        if (g && (h = this.startTimer()), function (t, e, n, r, a) {
            ki(e.inShapeInfos, n), ki([e.outShapeInfo], [r]);
            var i = r.texData.texture,
              s = r.texData.texShape;
            r.texData.isPacked ? t.setOutputPackedMatrixTexture(i, s[0], s[1]) : t.setOutputMatrixTexture(i, s[0], s[1]), t.setProgram(e.webGLProgram), 1 === o().getNumber("WEBGL_VERSION") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach(function (n, r) {
              var a = e.program.variableNames[r],
                i = e.uniformLocations[a],
                o = e.uniformLocations["offset" + a];
              if (null != i)
                if (n.isUniform)
                  if (N(n.shape) < 2) t.gl.uniform1f(i, n.uniformValues[0]);
                  else {
                    var s = n.uniformValues;
                    s instanceof Float32Array || (s = new Float32Array(s)), t.gl.uniform1fv(i, s)
                  }
              else null != n.texData.slice && null != o && t.gl.uniform1i(o, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, i, r)
            }), null != a && a(t, e.webGLProgram), t.executeProgram()
          }(this.gpgpu, m, p, f, r), c.forEach(function (t) {
            return i.disposeData(t.dataId)
          }), g && (h = this.endTimer(h), this.activeTimers.push({
            name: t.constructor.name,
            query: this.getQueryTime(h)
          })), !o().getBool("WEBGL_LAZILY_UNPACK") && u.isPacked && !1 === a) {
          var v = this.unpackTensor(s);
          return this.disposeData(s.dataId), v
        }
        return s
      }, e.prototype.compileAndRun = function (t, e, n, r, a) {
        void 0 === a && (a = !1), n = n || e[0].dtype;
        var i = this.runWebGLProgram(t, e, n, r, a);
        return Dt.makeTensorFromDataId(i.dataId, i.shape, i.dtype)
      }, e.prototype.getAndSaveBinary = function (t, e) {
        return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t]
      }, e.prototype.getTextureManager = function () {
        return this.textureManager
      }, e.prototype.dispose = function () {
        var t = this;
        this.disposed || (o().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach(function (e) {
          t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram), delete t.binaryCache[e]
        }), this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0)
      }, e.prototype.floatPrecision = function () {
        var t = this;
        return null == this.floatPrecisionValue && (this.floatPrecisionValue = We(function () {
          if (!o().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
            var e = o().getBool("DEBUG");
            o().set("DEBUG", !1);
            var n = t.abs(hn(1e-8)).dataSync()[0];
            if (o().set("DEBUG", e), n > 0) return 32
          }
          return 16
        })), this.floatPrecisionValue
      }, e.prototype.epsilon = function () {
        return 32 === this.floatPrecision() ? 1e-7 : 1e-4
      }, e.prototype.uploadToGPU = function (t) {
        var e, n = this.texData.get(t),
          r = n.shape,
          a = n.dtype,
          i = n.values,
          o = n.texture,
          s = n.usage,
          u = n.isPacked;
        if (null == o) {
          var l, c = null != this.activeTimers;
          c && (l = Z());
          var p = n.texShape;
          if (null == p && (p = Se(r, u), n.texShape = p), null != i) {
            var h = Ne(r),
              f = void 0,
              d = p[1],
              m = p[0],
              g = i instanceof Uint8Array;
            u ? (d = (e = jt(p[0], p[1]))[0], f = new function (t, e, n) {
              void 0 === n && (n = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
              var r = Aa(),
                a = e[0],
                i = e[1];
              this.outputShape = t;
              var o = "",
                s = "result";
              n && (s = "floor(result * 255. + 0.5)");
              for (var u = 0; u <= 1; u++)
                for (var l = 0; l <= 1; l++) {
                  var c = 2 * u + l;
                  o += "\n          localCoords = coords;\n          if(localCoords[2] + " + l + " < " + t[2] + ") {\n            localCoords[2] += " + l + ";\n            if(localCoords[1] + " + u + " < " + t[1] + ") {\n              localCoords[1] += " + u + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + i + ";\n              c = imod(flatIndex, " + i + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n              values = " + r.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + c + "] = values[0];\n              } else if(offset == 1) {\n                result[" + c + "] = values[1];\n              } else if(offset == 2) {\n                result[" + c + "] = values[2];\n              } else {\n                result[" + c + "] = values[3];\n              }\n            }\n          }\n        "
                }
              this.userCode = "\n      " + Ta(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + o + "\n\n        " + r.output + " = " + s + ";\n      }\n    "
            }(h, [m = e[1], d], g)) : f = new function (t, e, n) {
              void 0 === n && (n = !1), this.variableNames = ["A"];
              var r = Aa(),
                a = e[0],
                i = e[1];
              this.outputShape = t;
              var o = "result";
              n && (o = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + Ta(t) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + i + ";\n        int c = imod(flatIndex, " + i + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + i + ".0, " + a + ".0);\n        vec4 values = " + r.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r.output + " = vec4(" + o + ", 0., 0., 0.);\n      }\n    "
            }(h, [m, d], g);
            var v = this.makeTensorInfo([m, d], a);
            this.texData.get(v.dataId).usage = g ? Mt.PIXELS : Mt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId), d, m, i);
            var y = this.runWebGLProgram(f, [v], a, null, !0),
              b = this.texData.get(y.dataId);
            n.texture = b.texture, n.texShape = b.texShape, n.isPacked = b.isPacked, n.usage = b.usage, this.disposeData(v.dataId), this.texData.delete(y.dataId), n.values = null, c && (this.uploadWaitMs += Z() - l)
          } else {
            var x = this.acquireTexture(p, s, a, u);
            n.texture = x
          }
        }
      }, e.prototype.convertAndCacheOnCPU = function (t, e) {
        var n = this.texData.get(t),
          r = n.dtype;
        return this.releaseGPUData(t), null != e && (n.values = function (t, e) {
          if ("float32" === e || "complex64" === e) return t;
          if ("int32" === e || "bool" === e) {
            for (var n = "int32" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r) n[r] = Math.round(t[r]);
            return n
          }
          throw new Error("Unknown dtype " + e)
        }(e, r)), n.values
      }, e.prototype.acquireTexture = function (t, e, n, r) {
        if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
          var a = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
          this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + a + " MB, most likely due to a memory leak")
        }
        return this.textureManager.acquireTexture(t, e, r)
      }, e.prototype.computeBytes = function (t, e) {
        return t[0] * t[1] * P(e)
      }, e
    }(jr);
  Ot() && Dt.registerBackend("webgl", function () {
    return new oo
  }, 2), f({
    kernelName: "Square",
    gradFunc: function (t, e) {
      var n = e[0];
      return {
        x: function () {
          return t.mul(n.toFloat().mul(2))
        }
      }
    }
  });
  var so = on({
      square_: function (t) {
        var e = Ke(t, "x", "square"),
          n = [e];
        return Dt.runKernelFunc(function (t, n) {
          return n([e]), t.square(e)
        }, {
          x: e
        }, null, "Square", {}, n, [])
      }
    }),
    uo = on({
      abs_: function (t) {
        var e = Ke(t, "x", "abs");
        return "complex64" === e.dtype ? Dt.runKernelFunc(function (t) {
          return t.complexAbs(e)
        }, {
          $x: e
        }) : Dt.runKernelFunc(function (t, n) {
          var r = t.abs(e);
          return n([e]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return t.mul(n.toFloat().step(-1))
            }
          }
        }, "Abs")
      }
    }),
    lo = on({
      acos_: function (t) {
        var e = Ke(t, "x", "acos");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.acos(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.divStrict(hn(1).sub(n.toFloat().square()).sqrt()).neg()
            }
          }
        })
      }
    }),
    co = on({
      acosh_: function (t) {
        var e = Ke(t, "x", "acosh");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.acosh(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.divStrict(n.toFloat().square().sub(1).sqrt())
            }
          }
        })
      }
    }),
    po = on({
      asin_: function (t) {
        var e = Ke(t, "x", "asin");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.asin(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.divStrict(hn(1).sub(n.toFloat().square()).sqrt())
            }
          }
        })
      }
    }),
    ho = on({
      asinh_: function (t) {
        var e = Ke(t, "x", "asinh");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.asinh(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.divStrict(hn(1).add(n.toFloat().square()).sqrt())
            }
          }
        })
      }
    }),
    fo = on({
      atan_: function (t) {
        var e = Ke(t, "x", "atan");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.atan(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.div(n.toFloat().square().add(1))
            }
          }
        })
      }
    }),
    mo = on({
      atanh_: function (t) {
        var e = Ke(t, "x", "atanh");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.atanh(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.div(hn(1).sub(n.toFloat().square()))
            }
          }
        })
      }
    }),
    go = on({
      ceil_: function (t) {
        var e = Ke(t, "x", "ceil");
        return Dt.runKernelFunc(function (t) {
          return t.ceil(e)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    vo = on({
      clipByValue_: function (t, e, n) {
        var r = Ke(t, "x", "clipByValue");
        b(e <= n, function () {
          return "Error in clip: min (" + e + ") must be less than or equal to max (" + n + ")."
        });
        var a = [r],
          i = {
            min: e,
            max: n
          };
        return Dt.runKernelFunc(function (t, a) {
          var i = t.clip(r, e, n);
          return a([r]), i
        }, {
          x: r
        }, function (t, r) {
          var a = r[0];
          return {
            x: function () {
              return t.where(a.greaterEqual(e).logicalAnd(a.lessEqual(n)), In(t))
            }
          }
        }, "ClipByValue", i, a)
      }
    }),
    yo = on({
      cos_: function (t) {
        var e = Ke(t, "x", "cos"),
          n = [e];
        return Dt.runKernelFunc(function (t, n) {
          var r = t.cos(e);
          return n([e]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return n.toFloat().sin().neg().mul(t)
            }
          }
        }, "Cos", {}, n)
      }
    }),
    bo = on({
      cosh_: function (t) {
        var e = Ke(t, "x", "cosh");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.cosh(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return n.toFloat().sinh().mulStrict(t)
            }
          }
        })
      }
    }),
    xo = on({
      erf_: function (t) {
        var e = Ke(t, "x", "erf");
        return b("int32" === e.dtype || "float32" === e.dtype, function () {
          return "Input dtype must be `int32` or `float32`."
        }), "int32" === e.dtype && (e = e.toFloat()), Dt.runKernelFunc(function (t, n) {
          var r = t.erf(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)))
            }
          }
        })
      }
    }),
    wo = on({
      exp_: function (t) {
        var e = Ke(t, "x", "exp");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.exp(e);
          return n([r]), r
        }, {
          x: e
        }, function (t, e) {
          return {
            x: function () {
              return t.mulStrict(e[0])
            }
          }
        }, "Exp", {}, [], [!0])
      }
    }),
    Co = on({
      expm1_: function (t) {
        var e = Ke(t, "x", "expm1");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.expm1(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.mul(n.exp())
            }
          }
        })
      }
    }),
    No = on({
      floor_: function (t) {
        var e = Ke(t, "x", "floor");
        return Dt.runKernelFunc(function (t) {
          return t.floor(e)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    So = on({
      log_: function (t) {
        var e = Ke(t, "x", "log"),
          n = [e];
        return Dt.runKernelFunc(function (t, n) {
          var r = t.log(e);
          return n([e]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return t.div(n.toFloat())
            }
          }
        }, "Log", {}, n)
      }
    }),
    ko = on({
      log1p_: function (t) {
        var e = Ke(t, "x", "log1p");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.log1p(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.div(n.add(1))
            }
          }
        })
      }
    }),
    Io = on({
      logSigmoid_: function (t) {
        var e = Ke(t, "x", "logSigmoid");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.softplus(e.neg()).neg();
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.mul(n.neg().sigmoid())
            }
          }
        })
      }
    }),
    Eo = on({
      neg_: function (t) {
        var e = Ke(t, "x", "neg");
        return Dt.runKernelFunc(function (t) {
          return t.neg(e)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return t.neg()
            }
          }
        })
      }
    }),
    Ao = on({
      reciprocal_: function (t) {
        var e = Ke(t, "x", "reciprocal");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.reciprocal(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.div(n.square().neg())
            }
          }
        })
      }
    }),
    Ro = on({
      round_: function (t) {
        var e = Ke(t, "x", "round");
        return Dt.runKernelFunc(function (t) {
          return t.round(e)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    To = on({
      rsqrt_: function (t) {
        var e = Ke(t, "x", "rsqrt"),
          n = [e];
        return Dt.runKernelFunc(function (t, n) {
          var r = t.rsqrt(e);
          return n([e]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return t.div(n.pow(1.5).mul(2)).neg()
            }
          }
        }, "Rsqrt", {}, n)
      }
    }),
    Do = on({
      sigmoid_: function (t) {
        var e = Ke(t, "x", "sigmoid");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.sigmoid(e);
          return n([r]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return t.mul(n.mul(hn(1).sub(n)))
            }
          }
        }, "Sigmoid")
      }
    }),
    Oo = on({
      sign_: function (t) {
        var e = Ke(t, "x", "sign");
        return Dt.runKernelFunc(function (t) {
          return t.sign(e)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    _o = on({
      isNaN_: function (t) {
        var e = Ke(t, "x", "isNaN");
        return Dt.runKernelFunc(function (t) {
          return t.isNaN(e)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    Fo = on({
      isInf_: function (t) {
        var e = Ke(t, "x", "isInf");
        return Dt.runKernelFunc(function (t) {
          return t.isInf(e)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    Mo = on({
      isFinite_: function (t) {
        var e = Ke(t, "x", "isFinite");
        return Dt.runKernelFunc(function (t) {
          return t.isFinite(e)
        }, {
          $x: e
        }, function (t) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    zo = on({
      sin_: function (t) {
        var e = Ke(t, "x", "sin"),
          n = [e];
        return Dt.runKernelFunc(function (t, n) {
          var r = t.sin(e);
          return n([e]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return n.toFloat().cos().mul(t)
            }
          }
        }, "Sin", {}, n)
      }
    }),
    Lo = on({
      sinh_: function (t) {
        var e = Ke(t, "x", "sinh");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.sinh(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return n.toFloat().cosh().mulStrict(t)
            }
          }
        })
      }
    }),
    Bo = on({
      softplus_: function (t) {
        var e = Ke(t, "x", "softplus");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.softplus(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.mul(n.sigmoid())
            }
          }
        })
      }
    }),
    Po = on({
      sqrt_: function (t) {
        var e = Ke(t, "x", "sqrt");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.sqrt(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.div(n.toFloat().sqrt().mul(2))
            }
          }
        })
      }
    }),
    Wo = on({
      step_: function (t, e) {
        void 0 === e && (e = 0);
        var n = Ke(t, "x", "step");
        return Dt.runKernelFunc(function (t) {
          return t.step(n, e)
        }, {
          $x: n
        }, function (t) {
          return {
            $x: function () {
              return In(t)
            }
          }
        })
      }
    }),
    Vo = on({
      tan_: function (t) {
        var e = Ke(t, "x", "tan");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.tan(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return t.div(n.cos().square())
            }
          }
        })
      }
    }),
    Uo = on({
      tanh_: function (t) {
        var e = Ke(t, "x", "tanh");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.tanh(e);
          return n([r]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return hn(1).sub(n.square()).mulStrict(t)
            }
          }
        }, "Tanh", {}, null, [!0])
      }
    });

  function jo(t, e, n, r, a, i) {
    var o, s, u = Ke(t, "x", "batchNorm"),
      l = Ke(e, "mean", "batchNorm"),
      c = Ke(n, "variance", "batchNorm");
    return null != a && (o = Ke(a, "scale", "batchNorm")), null != r && (s = Ke(r, "offset", "batchNorm")), b(2 === u.rank, function () {
      return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + "."
    }), b(2 === l.rank || 1 === l.rank, function () {
      return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + l.rank + "."
    }), b(2 === c.rank || 1 === c.rank, function () {
      return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + c.rank + "."
    }), null != o && b(2 === o.rank || 1 === o.rank, function () {
      return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + o.rank + "."
    }), null != s && b(2 === s.rank || 1 === s.rank, function () {
      return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + "."
    }), Ho(u, l, c, s, o, i)
  }

  function Go(t, e, n, r, a, i) {
    var o, s, u = Ke(t, "x", "batchNorm"),
      l = Ke(e, "mean", "batchNorm"),
      c = Ke(n, "variance", "batchNorm");
    return null != a && (o = Ke(a, "scale", "batchNorm")), null != r && (s = Ke(r, "offset", "batchNorm")), b(3 === u.rank, function () {
      return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + "."
    }), b(3 === l.rank || 1 === l.rank, function () {
      return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + l.rank + "."
    }), b(3 === c.rank || 1 === c.rank, function () {
      return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + c.rank + "."
    }), null != o && b(3 === o.rank || 1 === o.rank, function () {
      return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + o.rank + "."
    }), null != s && b(3 === s.rank || 1 === s.rank, function () {
      return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + "."
    }), Ho(u, l, c, s, o, i)
  }

  function qo(t, e, n, r, a, i) {
    var o, s, u = Ke(t, "x", "batchNorm"),
      l = Ke(e, "mean", "batchNorm"),
      c = Ke(n, "variance", "batchNorm");
    return null != a && (o = Ke(a, "scale", "batchNorm")), null != r && (s = Ke(r, "offset", "batchNorm")), b(4 === u.rank, function () {
      return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + "."
    }), b(4 === l.rank || 1 === l.rank, function () {
      return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + l.rank + "."
    }), b(4 === c.rank || 1 === c.rank, function () {
      return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + c.rank + "."
    }), null != o && b(4 === o.rank || 1 === o.rank, function () {
      return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + o.rank + "."
    }), null != s && b(4 === s.rank || 1 === s.rank, function () {
      return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + "."
    }), Ho(u, l, c, s, o, i)
  }

  function Ho(t, e, n, r, a, i) {
    null == i && (i = .001);
    var o, s, u, l = Ke(t, "x", "batchNorm"),
      c = Ke(e, "mean", "batchNorm"),
      p = Ke(n, "variance", "batchNorm");
    null != a && (o = Ke(a, "scale", "batchNorm")), null != r && (s = Ke(r, "offset", "batchNorm")), b(c.rank === p.rank, function () {
      return "Batch normalization gradient requires mean and variance to have equal ranks."
    }), b(null == s || c.rank === s.rank, function () {
      return "Batch normalization gradient requires mean and offset to have equal ranks."
    }), b(null == o || c.rank === o.rank, function () {
      return "Batch normalization gradient requires mean and scale to have equal ranks."
    }), u = 0 === l.rank || 1 === l.rank ? l.as4D(1, 1, 1, l.size) : 2 === l.rank ? l.as4D(1, 1, l.shape[0], l.shape[1]) : 3 === l.rank ? l.as4D(1, l.shape[0], l.shape[1], l.shape[2]) : l;
    var h = [l, c, p, o];
    return Dt.runKernelFunc(function (t, e) {
      var n = t.batchNormalization(u, Ko(c), Ko(p), i, Ko(o), Ko(s));
      return e([l, c, p, o]), n
    }, {
      x: l,
      mean: c,
      variance: p,
      scale: o,
      offset: s
    }, function (t, e) {
      var n = e,
        r = n[0],
        a = n[1],
        o = n[2],
        s = n[3],
        l = null == s ? hn(1) : s,
        c = Hr(a.shape, u.shape),
        p = [];
      if (1 === a.rank) {
        for (var h = 0; h < u.shape.length - 1; ++h) p.push(u.shape[h]);
        p.push(1)
      }
      var f = r.sub(a),
        d = t.mul(l),
        m = To(o.add(hn(i))),
        g = m.mul(m).mul(m).mul(hn(-.5));
      return {
        x: function () {
          return 1 === a.rank ? t.mul(gr(m.as4D(1, 1, 1, a.shape[0]), p)).mul(l).reshape(r.shape) : t.mul(m).mul(l).reshape(r.shape)
        },
        mean: function () {
          var t = m.mul(hn(-1)).mul(d);
          return 1 === a.rank && (t = t.sum(c)), t.reshape(a.shape)
        },
        variance: function () {
          var t = g.mul(f).mul(d);
          return 1 === a.rank && (t = t.sum(c)), t.reshape(a.shape)
        },
        scale: function () {
          var e = f.mul(m),
            n = t.mul(e);
          return 1 === a.rank && (n = n.sum(c)), n.reshape(a.shape)
        },
        offset: function () {
          var e = t;
          return 1 === a.rank && (e = e.sum(c)), e.reshape(a.shape)
        }
      }
    }, "BatchNormalization", {
      varianceEpsilon: i
    }, h).reshape(l.shape)
  }

  function Ko(t) {
    return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t
  }

  function Xo() {
    Be("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")
  }
  var $o = on({
      batchNormalization2d_: function (t, e, n, r, a, i) {
        return void 0 === r && (r = .001), Xo(), jo(t, e, n, i, a, r)
      }
    }),
    Yo = on({
      batchNormalization3d_: function (t, e, n, r, a, i) {
        return void 0 === r && (r = .001), Xo(), Go(t, e, n, i, a, r)
      }
    }),
    Jo = on({
      batchNormalization4d_: function (t, e, n, r, a, i) {
        return void 0 === r && (r = .001), Xo(), qo(t, e, n, i, a, r)
      }
    }),
    Zo = on({
      batchNormalization_: function (t, e, n, r, a, i) {
        return void 0 === r && (r = .001), Xo(), Ho(t, e, n, i, a, r)
      }
    }),
    Qo = on({
      batchNorm_: Ho
    }),
    ts = on({
      batchNorm2d_: jo
    }),
    es = on({
      batchNorm3d_: Go
    }),
    ns = on({
      batchNorm4d_: qo
    }),
    rs = on({
      logicalAnd_: function (t, e) {
        var n = Ke(t, "a", "logicalAnd", "bool"),
          r = Ke(e, "b", "logicalAnd", "bool");
        return Kr(n.shape, r.shape), Dt.runKernelFunc(function (t) {
          return t.logicalAnd(n, r)
        }, {
          a: n,
          b: r
        }, null, "LogicalAnd")
      }
    }),
    as = on({
      logicalNot_: function (t) {
        var e = Ke(t, "x", "logicalNot", "bool");
        return Dt.runKernelFunc(function (t) {
          return t.logicalNot(e)
        }, {
          $x: e
        })
      }
    }),
    is = on({
      logicalOr_: function (t, e) {
        var n = Ke(t, "a", "logicalOr", "bool"),
          r = Ke(e, "b", "logicalOr", "bool");
        return Kr(n.shape, r.shape), Dt.runKernelFunc(function (t) {
          return t.logicalOr(n, r)
        }, {
          $a: n,
          $b: r
        })
      }
    }),
    os = on({
      logicalXor_: function (t, e) {
        var n = Ke(t, "a", "logicalXor", "bool"),
          r = Ke(e, "b", "logicalXor", "bool");
        return Kr(n.shape, r.shape), is(t, e).logicalAnd(rs(t, e).logicalNot())
      }
    }),
    ss = on({
      where_: function (t, e, n) {
        var r = Ke(e, "a", "where"),
          a = Ke(n, "b", "where"),
          i = Ke(t, "condition", "where", "bool");
        return x(r.shape, a.shape, "Error in where: "), 1 === i.rank ? b(i.shape[0] === r.shape[0], function () {
          return "The first dimension of `a` must match the size of `condition`."
        }) : x(i.shape, a.shape, "Error in where: "), Dt.runKernelFunc(function (t, e) {
          var n = t.select(i, r, a);
          return e([i]), n
        }, {
          $condition: i,
          $a: r,
          $b: a
        }, function (t, e) {
          var n = e[0];
          return {
            $condition: function () {
              return In(n).toFloat()
            },
            $a: function () {
              return t.mul(n.cast(t.dtype))
            },
            $b: function () {
              return t.mul(n.logicalNot().cast(t.dtype))
            }
          }
        })
      }
    }),
    us = function (t) {
      return r(this, void 0, void 0, function () {
        var e, n, r;
        return a(this, function (a) {
          switch (a.label) {
            case 0:
              return [4, (e = Ke(t, "condition", "whereAsync", "bool")).data()];
            case 1:
              return n = a.sent(), r = ka(e.shape, n), t !== e && e.dispose(), [2, r]
          }
        })
      })
    },
    ls = on({
      add_: function (t, e) {
        var n, r = Ke(t, "a", "add"),
          a = Ke(e, "b", "add");
        n = St(r, a), r = n[0], a = n[1];
        var i = Kr(r.shape, a.shape);
        return Dt.runKernelFunc(function (t) {
          return t.add(r, a)
        }, {
          a: r,
          b: a
        }, function (t) {
          return {
            a: function () {
              var e = t,
                n = Hr(r.shape, i);
              return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape)
            },
            b: function () {
              var e = t,
                n = Hr(a.shape, i);
              return n.length > 0 && (e = e.sum(n)), e.reshape(a.shape)
            }
          }
        }, "Add")
      }
    }),
    cs = on({
      addN_: function (t) {
        b(Array.isArray(t), function () {
          return "The argument passed to tf.addN() must be a list of tensors"
        }), b(t.length >= 1, function () {
          return "Must pass at least one tensor to tf.addN(), but got " + t.length
        });
        var e = t.map(function (t, e) {
            return Ke(t, "tensors" + e, "addN")
          }),
          n = e[0];
        e.forEach(function (t) {
          if (t.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype")
        }), e.forEach(function (t) {
          if (!S(t.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape")
        });
        var r = e;
        return Dt.runKernelFunc(function (t) {
          return t.addN(e)
        }, r, function (t) {
          var n = {};
          return e.forEach(function (e, r) {
            n[r] = function () {
              return t.clone()
            }
          }), n
        }, "AddN")
      }
    }),
    ps = on({
      addStrict_: function (t, e) {
        var n = Ke(t, "a", "addStrict"),
          r = Ke(e, "b", "addStrict");
        return x(n.shape, r.shape, "Error in addStrict: "), n.add(r)
      }
    }),
    hs = on({
      atan2_: function (t, e) {
        var n, r = Ke(t, "a", "atan2"),
          a = Ke(e, "b", "atan2");
        n = St(r, a), r = n[0], a = n[1];
        var i = Kr(r.shape, a.shape);
        return Dt.runKernelFunc(function (t, e) {
          var n = t.atan2(r, a);
          return e([r, a]), n
        }, {
          $a: r,
          $b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1];
          return {
            $a: function () {
              var e = ls(n.square(), r.square()),
                a = t.mul(r.div(e)),
                o = Hr(n.shape, i);
              return o.length > 0 && (a = a.sum(o)), a.reshape(n.shape)
            },
            $b: function () {
              var e = ls(n.square(), r.square()),
                a = Eo(t.mul(n.div(e))),
                o = Hr(r.shape, i);
              return o.length > 0 && (a = a.sum(o)), a.reshape(r.shape)
            }
          }
        })
      }
    }),
    fs = on({
      div_: function (t, e) {
        var n, r = Ke(t, "a", "div"),
          a = Ke(e, "b", "div");
        if (n = St(r, a), r = n[0], a = n[1], "int32" === r.dtype && "int32" === a.dtype) return gs(r, a);
        var i = Kr(r.shape, a.shape);
        return Dt.runKernelFunc(function (t, e) {
          var n = t.realDivide(r, a);
          return e([r, a]), n
        }, {
          a: r,
          b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1];
          return {
            a: function () {
              var e = t.div(r.toFloat()),
                a = Hr(n.shape, i);
              return a.length > 0 ? e.sum(a).reshape(n.shape) : e
            },
            b: function () {
              var e = t.mul(n.toFloat()),
                a = Hr(r.shape, i);
              a.length > 0 && (e = e.sum(a).reshape(r.shape));
              var o = r.square();
              return e.div(o.toFloat()).neg()
            }
          }
        }, "Div")
      }
    }),
    ds = on({
      divNoNan_: function (t, e) {
        var n, r = Ke(t, "a", "div"),
          a = Ke(e, "b", "div");
        r = (n = St(r, a))[0], a = n[1];
        var i = fs(r, a),
          o = In(i),
          s = a.equal(o);
        return ss(s, o, i)
      }
    }),
    ms = on({
      divStrict_: function (t, e) {
        var n = Ke(t, "a", "div"),
          r = Ke(e, "b", "div");
        return x(n.shape, r.shape, "Error in divideStrict: "), n.div(r)
      }
    }),
    gs = on({
      floorDiv_: function (t, e) {
        var n, r = Ke(t, "a", "floorDiv"),
          a = Ke(e, "b", "floorDiv");
        n = St(r, a), r = n[0], a = n[1];
        var i = Kr(r.shape, a.shape);
        return Dt.runKernelFunc(function (t, e) {
          var n = t.floorDiv(r, a);
          return e([r, a]), n
        }, {
          a: r,
          b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1];
          return {
            a: function () {
              var e = t.div(r.toFloat()),
                a = Hr(n.shape, i);
              return a.length > 0 ? e.sum(a).reshape(n.shape) : e
            },
            b: function () {
              var e = t.mul(n.toFloat()),
                a = Hr(r.shape, i);
              a.length > 0 && (e = e.sum(a).reshape(r.shape));
              var o = r.square();
              return e.div(o.toFloat()).neg()
            }
          }
        }, "FloorDiv")
      }
    }),
    vs = on({
      maximum_: function (t, e) {
        var n, r = Ke(t, "a", "maximum"),
          a = Ke(e, "b", "maximum");
        return n = St(r, a), r = n[0], a = n[1], "bool" === r.dtype && (r = r.toInt(), a = a.toInt()), Kr(r.shape, a.shape), Dt.runKernelFunc(function (t, e) {
          var n = t.maximum(r, a);
          return e([r, a]), n
        }, {
          a: r,
          b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1];
          return {
            a: function () {
              return t.mul(n.greaterEqual(r).toFloat())
            },
            b: function () {
              return t.mul(n.less(r).toFloat())
            }
          }
        }, "Maximum")
      }
    }),
    ys = on({
      maximumStrict_: function (t, e) {
        var n = Ke(t, "a", "maximumStrict"),
          r = Ke(e, "b", "maximumStrict");
        return x(n.shape, r.shape, "Error in maximumStrict: "), n.maximum(r)
      }
    }),
    bs = on({
      minimum_: function (t, e) {
        var n, r = Ke(t, "a", "minimum"),
          a = Ke(e, "b", "minimum");
        return n = St(r, a), r = n[0], a = n[1], "bool" === r.dtype && (r = r.toInt(), a = a.toInt()), Kr(r.shape, a.shape), Dt.runKernelFunc(function (t, e) {
          var n = t.minimum(r, a);
          return e([r, a]), n
        }, {
          a: r,
          b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1];
          return {
            a: function () {
              return t.mul(n.lessEqual(r).toFloat())
            },
            b: function () {
              return t.mul(n.greater(r).toFloat())
            }
          }
        }, "Minimum")
      }
    }),
    xs = on({
      minimumStrict_: function (t, e) {
        var n = Ke(t, "a", "minimumStrict"),
          r = Ke(e, "b", "minimumStrict");
        return x(n.shape, r.shape, "Error in minimumStrict: "), n.minimum(r)
      }
    }),
    ws = on({
      mod_: function (t, e) {
        var n, r = Ke(t, "a", "mod"),
          a = Ke(e, "b", "mod");
        n = St(r, a), r = n[0], a = n[1];
        var i = Kr(r.shape, a.shape);
        return Dt.runKernelFunc(function (t, e) {
          var n = t.mod(r, a);
          return e([r, a]), n
        }, {
          $a: r,
          $b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1];
          return {
            $a: function () {
              var e = Hr(n.shape, i);
              return e.length > 0 ? t.sum(e).reshape(n.shape) : t
            },
            $b: function () {
              var e = t.mul(n.div(r).floor().neg()),
                a = Hr(r.shape, i);
              return a.length > 0 ? e.sum(a).reshape(r.shape) : e
            }
          }
        })
      }
    }),
    Cs = on({
      modStrict_: function (t, e) {
        var n = Ke(t, "a", "modStrict"),
          r = Ke(e, "b", "modStrict");
        return x(n.shape, r.shape, "Error in modStrict: "), n.mod(r)
      }
    }),
    Ns = on({
      mul_: function (t, e) {
        var n, r = Ke(t, "a", "mul"),
          a = Ke(e, "b", "mul");
        n = St(r, a), r = n[0], a = n[1];
        var i = Kr(r.shape, a.shape);
        return Dt.runKernelFunc(function (t, e) {
          var n = t.multiply(r, a);
          return e([r, a]), n
        }, {
          a: r,
          b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1];
          return {
            a: function () {
              var e = t.mul(r.toFloat()),
                a = Hr(n.shape, i);
              return a.length > 0 ? e.sum(a).reshape(n.shape) : e
            },
            b: function () {
              var e = t.mul(n.toFloat()),
                a = Hr(r.shape, i);
              return a.length > 0 ? e.sum(a).reshape(r.shape) : e
            }
          }
        }, "Mul")
      }
    }),
    Ss = on({
      mulStrict_: function (t, e) {
        var n = Ke(t, "a", "mul"),
          r = Ke(e, "b", "mul");
        return x(n.shape, r.shape, "Error in multiplyStrict: "), n.mul(r)
      }
    }),
    ks = on({
      pow_: function (t, e) {
        var n = Ke(t, "base", "pow"),
          r = Ke(e, "exp", "pow"),
          a = Kr(n.shape, r.shape);
        return t = n.cast(Ct(n.dtype, r.dtype)), e = r.cast(Ct(n.dtype, r.dtype)), Dt.runKernelFunc(function (t, e) {
          var a = t.pow(n, r);
          return e([n, r, a]), a
        }, {
          $base: n,
          $exp: r
        }, function (t, e) {
          var n = e[0],
            r = e[1],
            i = e[2];
          return {
            $base: function () {
              var e = r.toFloat(),
                i = t.mul(e.mul(n.pow(e.sub(hn(1))))),
                o = Hr(n.shape, a);
              return o.length > 0 && (i = i.sum(o)), i.reshape(n.shape)
            },
            $exp: function () {
              var e = n.greater(0),
                o = n.log().where(e, In(n)),
                s = t.mul(i.mul(o)),
                u = Hr(r.shape, a);
              return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape)
            }
          }
        })
      }
    }),
    Is = on({
      powStrict_: function (t, e) {
        return x(t.shape, e.shape, "Error in powStrict: "), t.pow(e)
      }
    }),
    Es = on({
      squaredDifference_: function (t, e) {
        var n, r = Ke(t, "a", "squaredDifference"),
          a = Ke(e, "b", "squaredDifference");
        return n = St(r, a), r = n[0], a = n[1], Kr(r.shape, a.shape), Dt.runKernelFunc(function (t, e) {
          var n = t.squaredDifference(r, a);
          return e([r, a]), n
        }, {
          $a: r,
          $b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1],
            a = hn(2);
          return {
            $a: function () {
              return t.mul(n.sub(r).mul(a))
            },
            $b: function () {
              return t.mul(r.sub(n).mul(a))
            }
          }
        })
      }
    }),
    As = on({
      squaredDifferenceStrict_: function (t, e) {
        var n = Ke(t, "a", "squaredDifferenceStrict"),
          r = Ke(e, "b", "squaredDifferenceStrict");
        return x(n.shape, r.shape, "Error in squaredDifferenceStrict: "), n.squaredDifference(r)
      }
    }),
    Rs = on({
      sub_: function (t, e) {
        var n, r = Ke(t, "a", "sub"),
          a = Ke(e, "b", "sub");
        n = St(r, a), r = n[0], a = n[1];
        var i = Kr(r.shape, a.shape);
        return Dt.runKernelFunc(function (t) {
          return t.subtract(r, a)
        }, {
          a: r,
          b: a
        }, function (t) {
          return {
            a: function () {
              var e = t,
                n = Hr(r.shape, i);
              return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape)
            },
            b: function () {
              var e = t,
                n = Hr(a.shape, i);
              return n.length > 0 && (e = e.sum(n)), e.neg().reshape(a.shape)
            }
          }
        }, "Sub")
      }
    }),
    Ts = on({
      subStrict_: function (t, e) {
        var n = Ke(t, "a", "subStrict"),
          r = Ke(e, "b", "subStrict");
        return x(n.shape, r.shape, "Error in subStrict: "), n.sub(r)
      }
    }),
    Ds = on({
      equal_: function (t, e) {
        var n, r = Ke(t, "a", "equal"),
          a = Ke(e, "b", "equal");
        return n = St(r, a), r = n[0], a = n[1], Kr(r.shape, a.shape), Dt.runKernelFunc(function (t) {
          return t.equal(r, a)
        }, {
          $a: r,
          $b: a
        })
      }
    }),
    Os = on({
      equalStrict_: function (t, e) {
        var n = Ke(t, "a", "equalStrict"),
          r = Ke(e, "b", "equalStrict");
        return x(n.shape, r.shape, "Error in equalStrict: "), n.equal(r)
      }
    }),
    _s = on({
      greater_: function (t, e) {
        var n, r = Ke(t, "a", "greater"),
          a = Ke(e, "b", "greater");
        return n = St(r, a), r = n[0], a = n[1], Kr(r.shape, a.shape), Dt.runKernelFunc(function (t) {
          return t.greater(r, a)
        }, {
          a: r,
          b: a
        }, null, "Greater")
      }
    }),
    Fs = on({
      greaterEqual_: function (t, e) {
        var n, r = Ke(t, "a", "greaterEqual"),
          a = Ke(e, "b", "greaterEqual");
        return n = St(r, a), r = n[0], a = n[1], Kr(r.shape, a.shape), Dt.runKernelFunc(function (t, e) {
          var n = t.greaterEqual(r, a);
          return e([r, a]), n
        }, {
          a: r,
          b: a
        }, function (t, e) {
          var n = e[0],
            r = e[1];
          return {
            a: function () {
              return In(n)
            },
            b: function () {
              return In(r)
            }
          }
        }, "GreaterEqual")
      }
    }),
    Ms = on({
      greaterEqualStrict_: function (t, e) {
        var n = Ke(t, "a", "greaterEqualStrict"),
          r = Ke(e, "b", "greaterEqualStrict");
        return x(n.shape, r.shape, "Error in greaterEqualStrict: "), n.greaterEqual(r)
      }
    }),
    zs = on({
      greaterStrict_: function (t, e) {
        var n = Ke(t, "a", "greaterStrict"),
          r = Ke(e, "b", "greaterStrict");
        return x(n.shape, r.shape, "Error in greaterStrict: "), n.greater(r)
      }
    }),
    Ls = on({
      less_: function (t, e) {
        var n, r = Ke(t, "a", "less"),
          a = Ke(e, "b", "less");
        return n = St(r, a), r = n[0], a = n[1], Kr(r.shape, a.shape), Dt.runKernelFunc(function (t) {
          return t.less(r, a)
        }, {
          a: r,
          b: a
        }, null, "Less")
      }
    }),
    Bs = on({
      lessEqual_: function (t, e) {
        var n, r = Ke(t, "a", "lessEqual"),
          a = Ke(e, "b", "lessEqual");
        return n = St(r, a), r = n[0], a = n[1], Kr(r.shape, a.shape), Dt.runKernelFunc(function (t, e) {
          var n = t.lessEqual(r, a);
          return e([r, a]), n
        }, {
          a: r,
          b: a
        }, null, "LessEqual")
      }
    }),
    Ps = on({
      lessEqualStrict_: function (t, e) {
        var n = Ke(t, "a", "lessEqualStrict"),
          r = Ke(e, "b", "lessEqualStrict");
        return x(n.shape, r.shape, "Error in lessEqualStrict: "), n.lessEqual(r)
      }
    }),
    Ws = on({
      lessStrict_: function (t, e) {
        var n = Ke(t, "a", "lessStrict"),
          r = Ke(e, "b", "lessStrict");
        return x(n.shape, r.shape, "Error in lessStrict: "), n.less(r)
      }
    }),
    Vs = on({
      notEqual_: function (t, e) {
        var n, r = Ke(t, "a", "notEqual"),
          a = Ke(e, "b", "notEqual");
        return n = St(r, a), r = n[0], a = n[1], Kr(r.shape, a.shape), Dt.runKernelFunc(function (t) {
          return t.notEqual(r, a)
        }, {
          $a: r,
          $b: a
        })
      }
    }),
    Us = on({
      notEqualStrict_: function (t, e) {
        var n = Ke(t, "a", "notEqualStrict"),
          r = Ke(e, "b", "notEqualStrict");
        return x(n.shape, r.shape, "Error in notEqualStrict: "), n.notEqual(r)
      }
    });

  function js(t, e) {
    for (var n = [], r = t; r < e; ++r) n.push(r);
    return n
  }

  function Gs(t) {
    for (var e = [], n = 0; n < t.length; ++n)
      for (var r = 0; r < t[n].length; ++r) e.push(t[n][r]);
    return e
  }
  var qs = on({
      gather_: function (t, e, n) {
        void 0 === n && (n = 0);
        var r = Ke(t, "x", "gather"),
          a = Ke(e, "indices", "gather", "int32");
        n = D(n, r.shape)[0];
        var i = function (t, e, n) {
          for (var r = t.shape[n], a = [], i = 1, o = 1, s = 0; s < n; s++) a.push(t.shape[s]), i *= t.shape[s];
          for (s = 0; s < e.rank; s++) a.push(e.shape[s]);
          for (s = n + 1; s < t.rank; s++) a.push(t.shape[s]), o *= t.shape[s];
          return {
            batchSize: i,
            sliceSize: o,
            dimSize: r,
            outputShape: a
          }
        }(r, a, n);
        return Dt.runKernelFunc(function (t, e) {
          var i = t.gather(r, a.flatten(), n);
          return e([a]), i
        }, {
          $x: r
        }, function (t, e) {
          var a = e[0];
          return {
            $x: function () {
              var e = r.shape,
                i = a.size,
                o = e.slice(0, n),
                s = o.length,
                u = e.slice(n, e.length).slice(1),
                l = u.length,
                c = js(0, s),
                p = js(s + 1, s + 1 + l),
                h = Gs([o, [i], u]),
                f = t.reshape(h),
                d = a.reshape([i]),
                m = Gs([
                  [s], c, p
                ]),
                g = f.transpose(m),
                v = Hs(g, d, r.shape[n]),
                y = en(m);
              return v.transpose(y)
            }
          }
        }).reshape(i.outputShape)
      }
    }),
    Hs = on({
      unsortedSegmentSum_: function (t, e, n) {
        var r = Ke(t, "x", "unsortedSegmentSum"),
          a = Ke(e, "segmentIds", "unsortedSegmentSum", "int32");
        return b(k(n), function () {
          return "numSegments must be of dtype int"
        }), Dt.runKernelFunc(function (t, e) {
          var i = t.unsortedSegmentSum(r, a, n);
          return e([a]), i
        }, {
          $x: r
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return function (t, e) {
                for (var n = vs(e, In(e)), r = qs(t, n), a = Fs(e, hn(0, "int32")), i = r.rank - a.rank, o = 0; o < i; ++o) a = Qn(a, o + 1);
                a = rs(a, xn(r.shape, "bool"));
                var s = In(r);
                return ss(a, r, s)
              }(t, n)
            }
          }
        })
      }
    }),
    Ks = function (t, e, n) {
      return r(this, void 0, void 0, function () {
        var r, i, o, s, u, l, c, p, h, f, d, m, g;
        return a(this, function (a) {
          switch (a.label) {
            case 0:
              for (r = Ke(t, "tensor", "boolMask"), i = Ke(e, "mask", "boolMask", "bool"), o = null == n ? 0 : n, s = i.rank, u = r.shape, b(s > 0, function () {
                  return "mask cannot be scalar"
                }), x(u.slice(o, o + s), i.shape, "mask's shape must match the first K dimensions of tensor's shape,"), l = 1, c = o; c < o + s; c++) l *= u[c];
              return p = u.slice(0, o).concat([l], u.slice(o + s)), h = r.reshape(p), f = i.reshape([-1]), [4, us(f)];
            case 1:
              return d = a.sent(), m = d.squeeze([1]), g = qs(h, m, o), t !== r && r.dispose(), e !== i && i.dispose(), m.dispose(), h.dispose(), f.dispose(), d.dispose(), [2, g]
          }
        })
      })
    };

  function Xs(t, e, n, r, a, i, o) {
    void 0 === i && (i = "NHWC"), b(t.length === e.rank, function () {
      return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match"
    });
    var s = t,
      u = e,
      l = !1;
    3 === e.rank && (l = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [1, t[0], t[1], t[2]]), b(4 === s.length, function () {
      return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + "."
    }), b(4 === u.rank, function () {
      return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank
    }), b(4 === n.rank, function () {
      return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n.rank
    });
    var c = "NHWC" === i ? s[3] : s[1],
      p = "NHWC" === i ? u.shape[3] : u.shape[1];
    b(c === n.shape[2], function () {
      return "Error in conv2dDerInput: depth of input (" + c + ") must match input depth for filter " + n.shape[2] + "."
    }), b(p === n.shape[3], function () {
      return "Error in conv2dDerInput: depth of output (" + p + ") must match output depth for filter " + n.shape[3] + "."
    }), null != o && b(k(a), function () {
      return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + a + "."
    });
    var h = ia(i),
      f = Yr(s, n.shape, r, 1, a, o, !1, h),
      d = Dt.runKernelFunc(function (t, e) {
        var r = t.conv2dDerInput(u, n, f);
        return e([n, u]), r
      }, {
        dy4D: u,
        filter: n
      }, function (t, e) {
        var n = e[0],
          s = e[1];
        return {
          dy4D: function () {
            return Zs(t, n, r, a, i, 1, o)
          },
          filter: function () {
            return tu(t, s, n.shape, r, a, i, o)
          }
        }
      });
    return l ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d
  }

  function $s(t) {
    var e = function (t) {
        return "number" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t
      }(t),
      n = e[0],
      r = e[1],
      a = e[2];
    return 1 === n && 1 === r && 1 === a
  }

  function Ys(t, e, n, r, a) {
    b(t.length === e.rank, function () {
      return "Length of inShape (" + t.length + ") and rank of dy (" + e.rank + ") must match"
    });
    var i = t,
      o = e,
      s = !1;
    4 === e.rank && (s = !0, o = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), i = [1, t[0], t[1], t[2], t[3]]);
    var u = i[4],
      l = o.shape[4];
    b(5 === i.length, function () {
      return "Error in conv3dDerInput: inShape must be length 5, but got length " + i.length + "."
    }), b(5 === o.rank, function () {
      return "Error in conv3dDerInput: dy must be rank 5, but got rank " + o.rank
    }), b(5 === n.rank, function () {
      return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n.rank
    }), b(u === n.shape[3], function () {
      return "Error in conv3dDerInput: depth of input (" + u + ") must match input depth for filter " + n.shape[3] + "."
    }), b(l === n.shape[4], function () {
      return "Error in conv3dDerInput: depth of output (" + l + ") must match output depth for filter " + n.shape[4] + "."
    });
    var c = Jr(i, n.shape, r, 1, a),
      p = Dt.runKernelFunc(function (t) {
        return t.conv3dDerInput(o, n, c)
      }, {
        dy5D: o
      });
    return s ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4]) : p
  }
  var Js = on({
      conv1d_: function (t, e, n, r, a, i, o) {
        void 0 === a && (a = "NWC"), void 0 === i && (i = 1);
        var s = Ke(t, "x", "conv1d"),
          u = Ke(e, "filter", "conv1d"),
          l = s,
          c = !1;
        2 === s.rank && (c = !0, l = s.as3D(1, s.shape[0], s.shape[1])), b(3 === l.rank, function () {
          return "Error in conv1d: input must be rank 3, but got rank " + l.rank + "."
        }), b(3 === u.rank, function () {
          return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + "."
        }), null != o && b(k(r), function () {
          return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + "."
        }), b(l.shape[2] === u.shape[1], function () {
          return "Error in conv1d: depth of input (" + l.shape[2] + ") must match input depth for filter " + u.shape[1] + "."
        }), b(aa(n, i), function () {
          return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n + " and dilation '" + i + "'"
        }), b("NWC" === a, function () {
          return "Error in conv1d: got dataFormat of " + a + " but only NWC is currently supported."
        });
        var p = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),
          h = l.as4D(l.shape[0], 1, l.shape[1], l.shape[2]),
          f = Zs(h, p, [1, n], r, "NHWC", [1, i], o);
        return c ? f.as2D(f.shape[2], f.shape[3]) : f.as3D(f.shape[0], f.shape[2], f.shape[3])
      }
    }),
    Zs = on({
      conv2d_: function (t, e, n, r, a, i, o) {
        void 0 === a && (a = "NHWC"), void 0 === i && (i = [1, 1]);
        var s = Ke(t, "x", "conv2d"),
          u = Ke(e, "filter", "conv2d"),
          l = s,
          c = !1;
        3 === s.rank && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), b(4 === l.rank, function () {
          return "Error in conv2d: input must be rank 4, but got rank " + l.rank + "."
        }), b(4 === u.rank, function () {
          return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + "."
        }), null != o && b(k(r), function () {
          return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + "."
        });
        var p = "NHWC" === a ? l.shape[3] : l.shape[1];
        b(p === u.shape[2], function () {
          return "Error in conv2d: depth of input (" + p + ") must match input depth for filter " + u.shape[2] + "."
        }), b(aa(n, i), function () {
          return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'"
        });
        var h = ia(a),
          f = Yr(l.shape, u.shape, n, i, r, o, !1, h),
          d = [u, l],
          m = Dt.runKernelFunc(function (t, e) {
            var n = t.conv2d(l, u, f);
            return e([u, l]), n
          }, {
            x: l,
            filter: u
          }, function (t, e) {
            var o = e,
              s = o[0],
              u = o[1];
            return b(ra(i), function () {
              return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + i + "'"
            }), {
              x: function () {
                return eu(u.shape, t, s, n, r, a)
              },
              filter: function () {
                return tu(u, t, s.shape, n, r, a)
              }
            }
          }, "Conv2D", f, d);
        return c ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m
      }
    }),
    Qs = on({
      conv3d_: function (t, e, n, r, a, i) {
        void 0 === a && (a = "NDHWC"), void 0 === i && (i = [1, 1, 1]);
        var o = Ke(t, "x", "conv3d"),
          s = Ke(e, "filter", "conv3d"),
          u = o,
          l = !1;
        4 === o.rank && (l = !0, u = o.as5D(1, o.shape[0], o.shape[1], o.shape[2], o.shape[3])), b(5 === u.rank, function () {
          return "Error in conv3d: input must be rank 5, but got rank " + u.rank + "."
        }), b(5 === s.rank, function () {
          return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + "."
        }), b(u.shape[4] === s.shape[3], function () {
          return "Error in conv3d: depth of input (" + u.shape[4] + ") must match input depth for filter " + s.shape[3] + "."
        }), b(function (t, e) {
          return $s(n) || $s(e)
        }(0, i), function () {
          return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'"
        }), b("NDHWC" === a, function () {
          return "Error in conv3d: got dataFormat of " + a + " but only NDHWC is currently supported."
        });
        var c = Jr(u.shape, s.shape, n, i, r),
          p = Dt.runKernelFunc(function (t, e) {
            var n = t.conv3d(u, s, c);
            return e([u, s]), n
          }, {
            x: u,
            $filter: s
          }, function (t, e) {
            b($s(i), function () {
              return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + i + "'"
            });
            var a = e[0],
              o = e[1];
            return {
              x: function () {
                return Ys(a.shape, t, o, n, r)
              },
              $filter: function () {
                return function (t, e, n, r, a) {
                  var i = t;
                  4 === t.rank && (i = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));
                  var o = e;
                  4 === o.rank && (o = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3])), b(5 === i.rank, function () {
                    return "Error in conv3dDerFilter: input must be rank 5, but got shape " + i.shape + "."
                  }), b(5 === o.rank, function () {
                    return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + o.shape + "."
                  }), b(5 === n.length, function () {
                    return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n + "."
                  }), b(i.shape[4] === n[3], function () {
                    return "Error in conv3dDerFilter: depth of input " + i.shape[4] + ") must match input depth in filter (" + n[3] + "."
                  }), b(o.shape[4] === n[4], function () {
                    return "Error in conv3dDerFilter: depth of dy (" + o.shape[4] + ") must match output depth for filter (" + n[4] + ")."
                  });
                  var s = Jr(i.shape, n, r, 1, a);
                  return Dt.runKernelFunc(function (t) {
                    return t.conv3dDerFilter(i, o, s)
                  }, {
                    x5D: i,
                    dy5D: o
                  })
                }(a, t, o.shape, n, r)
              }
            }
          });
        return l ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4]) : p
      }
    }),
    tu = on({
      conv2dDerFilter_: function (t, e, n, r, a, i, o) {
        void 0 === i && (i = "NHWC");
        var s = t;
        3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
        var u = e;
        3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), b(4 === s.rank, function () {
          return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + "."
        }), b(4 === u.rank, function () {
          return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + "."
        }), b(4 === n.length, function () {
          return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n + "."
        });
        var l = "NHWC" === i ? s.shape[3] : s.shape[1],
          c = "NHWC" === i ? u.shape[3] : u.shape[1];
        b(l === n[2], function () {
          return "Error in conv2dDerFilter: depth of input " + l + ") must match input depth in filter (" + n[2] + "."
        }), b(c === n[3], function () {
          return "Error in conv2dDerFilter: depth of dy (" + c + ") must match output depth for filter (" + n[3] + ")."
        }), null != o && b(k(a), function () {
          return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + a + "."
        });
        var p = ia(i),
          h = Yr(s.shape, n, r, 1, a, o, !1, p);
        return Dt.runKernelFunc(function (t) {
          return t.conv2dDerFilter(s, u, h)
        }, {
          x4D: s,
          dy4D: u
        })
      }
    }),
    eu = on({
      conv2dDerInput_: Xs
    }),
    nu = on({
      depthwiseConv2d_: function (t, e, n, r, a, i, o) {
        void 0 === a && (a = "NHWC"), void 0 === i && (i = [1, 1]);
        var s = Ke(t, "x", "depthwiseConv2d"),
          u = Ke(e, "filter", "depthwiseConv2d"),
          l = s,
          c = !1;
        3 === s.rank && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), b(4 === l.rank, function () {
          return "Error in depthwiseConv2d: input must be rank 4, but got rank " + l.rank + "."
        }), b(4 === u.rank, function () {
          return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + "."
        }), b(l.shape[3] === u.shape[2], function () {
          return "Error in depthwiseConv2d: number of input channels (" + l.shape[3] + ") must match the inChannels dimension in filter " + u.shape[2] + "."
        }), null == i && (i = [1, 1]), b(aa(n, i), function () {
          return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + i + "'"
        }), null != o && b(k(r), function () {
          return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + r + "."
        });
        var p = Yr(l.shape, u.shape, n, i, r, o, !0),
          h = [l, u],
          f = Dt.runKernelFunc(function (t, e) {
            var n = t.depthwiseConv2D(l, u, p);
            return e([l, u]), n
          }, {
            x: l,
            filter: u
          }, function (t, e) {
            b(ra(i), function () {
              return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + i + "'"
            });
            var n = e[0],
              r = e[1];
            return {
              x: function () {
                return ru(n.shape, t, r, p)
              },
              filter: function () {
                return au(n, t, r.shape, p)
              }
            }
          }, "DepthwiseConv2dNative", p, h);
        return c ? f.as3D(f.shape[1], f.shape[2], f.shape[3]) : f
      }
    }),
    ru = on({
      depthwiseConv2dDerInput_: function (t, e, n, r) {
        var a = e,
          i = !1;
        3 === e.rank && (i = !0, a = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
        var o = Dt.runKernelFunc(function (t) {
          return t.depthwiseConv2DDerInput(a, n, r)
        }, {
          dy4D: a
        });
        return i ? o.as3D(o.shape[1], o.shape[2], o.shape[3]) : o
      }
    }),
    au = on({
      depthwiseConv2dDerFilter_: function (t, e, n, r) {
        var a = t;
        3 === t.rank && (a = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));
        var i = e;
        return 3 === i.rank && (i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Dt.runKernelFunc(function (t) {
          return t.depthwiseConv2DDerFilter(a, i, r)
        }, {
          x4D: a,
          dy4D: i
        })
      }
    }),
    iu = on({
      separableConv2d_: function (t, e, n, r, a, i, o) {
        void 0 === i && (i = [1, 1]), void 0 === o && (o = "NHWC");
        var s = Ke(t, "x", "separableConv2d"),
          u = Ke(e, "depthwiseFilter", "separableConv2d"),
          l = Ke(n, "pointwiseFilter", "separableConv2d"),
          c = s,
          p = !1;
        if (3 === s.rank && (p = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), "NCHW" === o) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
        b(4 === c.rank, function () {
          return "Error in separableConv2d: input must be rank 4, but got rank " + c.rank + "."
        }), b(4 === u.rank, function () {
          return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + "."
        }), b(4 === l.rank, function () {
          return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + "."
        }), b(1 === l.shape[0], function () {
          return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + l.shape[0] + "."
        }), b(1 === l.shape[1], function () {
          return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + l.shape[1] + "."
        });
        var h = u.shape[2],
          f = u.shape[3];
        b(l.shape[2] === h * f, function () {
          return "Error in separableConv2d: the third dimension of pointwise filter must be " + h * f + ", but got " + l.shape[2] + "."
        });
        var d = nu(c, u, r, a, o, i),
          m = Zs(d, l, 1, "valid", o);
        return p ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m
      }
    }),
    ou = on({
      conv2dTranspose_: function (t, e, n, r, a, i) {
        return Xs(n, Ke(t, "x", "conv2dTranspose"), Ke(e, "filter", "conv2dTranspose"), r, a, "NHWC", i)
      }
    }),
    su = on({
      conv3dTranspose_: function (t, e, n, r, a) {
        return Ys(n, Ke(t, "x", "conv3dTranspose"), Ke(e, "filter", "conv3dTranspose"), r, a)
      }
    }),
    uu = on({
      matMul_: function (t, e, n, r) {
        var a;
        void 0 === n && (n = !1), void 0 === r && (r = !1);
        var i = Ke(t, "a", "matMul"),
          o = Ke(e, "b", "matMul");
        a = St(i, o), i = a[0], o = a[1];
        var s = n ? i.shape[i.rank - 2] : i.shape[i.rank - 1],
          u = r ? o.shape[o.rank - 1] : o.shape[o.rank - 2],
          l = n ? i.shape[i.rank - 1] : i.shape[i.rank - 2],
          c = r ? o.shape[o.rank - 2] : o.shape[o.rank - 1],
          p = i.shape.slice(0, -2),
          h = o.shape.slice(0, -2),
          f = N(p),
          d = N(h);
        b(i.rank >= 2 && o.rank >= 2 && i.rank === o.rank, function () {
          return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + i.rank + " and " + o.rank + "."
        }), b(S(p, h), function () {
          return "Error in matMul: outer dimensions (" + p + ") and (" + h + ") of Tensors with shapes " + i.shape + " and " + o.shape + " must match."
        }), b(s === u, function () {
          return "Error in matMul: inner shapes (" + s + ") and (" + u + ") of Tensors with shapes " + i.shape + " and " + o.shape + " and transposeA=" + n + " and transposeB=" + r + " must match."
        });
        var m = i.shape.slice(0, -2).concat([l, c]),
          g = n ? i.as3D(f, s, l) : i.as3D(f, l, s),
          v = r ? o.as3D(d, c, u) : o.as3D(d, u, c),
          y = {
            transposeA: n,
            transposeB: r
          };
        return Dt.runKernelFunc(function (t, e) {
          var a = t.batchMatMul(g, v, n, r);
          return e([g, v]), a
        }, {
          a: g,
          b: v
        }, function (t, e) {
          var a = e,
            i = a[0],
            o = a[1];
          return n || r ? !n && r ? {
            a: function () {
              return t.matMul(o, !1, !1)
            },
            b: function () {
              return t.matMul(i, !0, !1)
            }
          } : n && !r ? {
            a: function () {
              return o.matMul(t, !1, !0)
            },
            b: function () {
              return i.matMul(t, !1, !1)
            }
          } : {
            a: function () {
              return o.matMul(t, !0, !0)
            },
            b: function () {
              return t.matMul(i, !0, !0)
            }
          } : {
            a: function () {
              return t.matMul(o, !1, !0)
            },
            b: function () {
              return i.matMul(t, !0, !1)
            }
          }
        }, "BatchMatMul", y).reshape(m)
      }
    }),
    lu = on({
      dot_: function (t, e) {
        var n = Ke(t, "t1", "dot"),
          r = Ke(e, "t2", "dot");
        b(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), function () {
          return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n.rank + " and " + r.rank + "."
        });
        var a = 1 === n.rank ? n.size : n.shape[1],
          i = 1 === r.rank ? r.size : r.shape[0];
        return b(a === i, function () {
          return "Error in dot: inner dimensions of inputs must match, but got " + a + " and " + i + "."
        }), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]))
      }
    }),
    cu = on({
      outerProduct_: function (t, e) {
        var n = Ke(t, "v1", "outerProduct"),
          r = Ke(e, "v2", "outerProduct");
        return b(1 === n.rank && 1 === r.rank, function () {
          return "Error in outerProduct: inputs must be rank 1, but got ranks " + n.rank + " and " + r.rank + "."
        }), n.as2D(-1, 1).matMul(r.as2D(1, -1))
      }
    }),
    pu = on({
      reverse_: function (t, e) {
        var n = Ke(t, "x", "reverse");
        if (0 === n.rank) return n.clone();
        var r = D(e, n.shape);
        return Dt.runKernelFunc(function (t) {
          return t.reverse(n, r)
        }, {
          $x: n
        }, function (t) {
          return {
            $x: function () {
              return t.reverse(r)
            }
          }
        }).reshapeAs(n)
      }
    }),
    hu = on({
      reverse1d_: function (t) {
        var e = Ke(t, "x", "reverse");
        return b(1 === e.rank, function () {
          return "Error in reverse1D: x must be rank 1 but got rank " + e.rank + "."
        }), pu(e, 0)
      }
    }),
    fu = on({
      reverse2d_: function (t, e) {
        var n = Ke(t, "x", "reverse");
        return b(2 === n.rank, function () {
          return "Error in reverse2D: x must be rank 2 but got rank " + n.rank + "."
        }), pu(n, e)
      }
    }),
    du = on({
      reverse3d_: function (t, e) {
        var n = Ke(t, "x", "reverse");
        return b(3 === n.rank, function () {
          return "Error in reverse3D: x must be rank 3 but got rank " + n.rank + "."
        }), pu(n, e)
      }
    }),
    mu = on({
      reverse4d_: function (t, e) {
        var n = Ke(t, "x", "reverse");
        return b(4 === n.rank, function () {
          return "Error in reverse4D: x must be rank 4 but got rank " + n.rank + "."
        }), pu(n, e)
      }
    });

  function gu(t, e, n, r, a, i) {
    var o = Ke(t, "x", "maxPool"),
      s = o,
      u = !1;
    3 === o.rank && (u = !0, s = o.as4D(1, o.shape[0], o.shape[1], o.shape[2])), null == r && (r = [1, 1]), b(4 === s.rank, function () {
      return "Error in maxPool: input must be rank 4 but got rank " + s.rank + "."
    }), b(aa(n, r), function () {
      return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'"
    }), null != i && b(k(a), function () {
      return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + a + "."
    });
    var l = Xr(s.shape, e, n, r, a, i);
    if (1 === l.filterWidth && 1 === l.filterHeight && S(l.inShape, l.outShape)) return o.clone();
    var c = [s],
      p = Dt.runKernelFunc(function (t, e) {
        var n = t.maxPool(s, l);
        return e([s, n]), n
      }, {
        x: s
      }, function (t, i) {
        var o = i[0],
          s = i[1];
        return {
          x: function () {
            return function (t, e, n, r, a, i, o, s) {
              var u = Ke(t, "dy", "maxPoolBackprop"),
                l = Ke(e, "input", "maxPoolBackprop"),
                c = Ke(n, "output", "maxPoolBackprop");
              b(l.rank === u.rank, function () {
                return "Rank of input (" + l.rank + ") does not match rank of dy (" + u.rank + ")"
              }), null == i && (i = [1, 1]), b(aa(a, i), function () {
                return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + a + " and dilations '" + i + "'"
              }), b(4 === u.rank, function () {
                return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + u.rank + "."
              }), b(4 === l.rank, function () {
                return "Error in maxPoolBackprop: input must be rank 4 but got rank " + l.rank + "."
              });
              var p = Xr(l.shape, r, a, i, o, s);
              return Dt.runKernelFunc(function (t) {
                return t.maxPoolBackprop(u, l, c, p)
              }, {
                $dy: u,
                $input: l
              })
            }(t, o, s, e, n, r, a)
          }
        }
      }, "MaxPool", l, c);
    return u ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p
  }

  function vu(t, e, n, r, a, i) {
    var o = Ke(t, "x", "avgPool", "float32");
    null == r && (r = [1, 1]), b(aa(n, r), function () {
      return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + r + "'"
    });
    var s = o,
      u = !1;
    3 === o.rank && (u = !0, s = o.as4D(1, o.shape[0], o.shape[1], o.shape[2])), b(4 === s.rank, function () {
      return "Error in avgPool: x must be rank 4 but got rank " + s.rank + "."
    }), null != i && b(k(a), function () {
      return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + a + "."
    });
    var l = Xr(s.shape, e, n, r, a, i);
    if (1 === l.filterWidth && 1 === l.filterHeight && S(l.inShape, l.outShape)) return o.clone();
    var c = Dt.runKernelFunc(function (t) {
      return t.avgPool(s, l)
    }, {
      x: s
    }, function (t) {
      return {
        x: function () {
          return function (t, e, n, r, a, i) {
            var o = Ke(t, "dy", "avgPoolBackprop"),
              s = Ke(e, "input", "avgPoolBackprop");
            b(s.rank === o.rank, function () {
              return "Rank of input (" + s.rank + ") does not match rank of dy (" + o.rank + ")"
            }), null == a && (a = [1, 1]), b(aa(r, a), function () {
              return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + a + "'"
            });
            var u = s,
              l = o,
              c = !1;
            3 === s.rank && (c = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), l = o.as4D(1, o.shape[0], o.shape[1], o.shape[2])), b(4 === l.rank, function () {
              return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + l.rank + "."
            }), b(4 === u.rank, function () {
              return "Error in avgPoolBackprop: input must be rank 4 but got rank " + u.rank + "."
            });
            var p = Xr(u.shape, n, r, a, i),
              h = Dt.runKernelFunc(function (t) {
                return t.avgPoolBackprop(l, u, p)
              }, {
                dy4D: l,
                input4D: u
              });
            return c ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h
          }(t, s, e, n, r, a)
        }
      }
    }, "AvgPool", l);
    return c = c.cast(o.dtype), u ? c.as3D(c.shape[1], c.shape[2], c.shape[3]) : c
  }
  var yu = on({
      maxPool_: function (t, e, n, r, a) {
        return gu(t, e, n, 1, r, a)
      }
    }),
    bu = on({
      avgPool_: function (t, e, n, r, a) {
        return vu(t, e, n, 1, r, a)
      }
    }),
    xu = on({
      pool_: function (t, e, n, r, a, i) {
        null == a && (a = [1, 1]), null == i && (i = 1), 0 === r && (r = "valid");
        var o = Ke(t, "x", "maxPool"),
          s = o,
          u = !1;
        3 === o.rank && (u = !0, s = o.as4D(1, o.shape[0], o.shape[1], o.shape[2])), b(aa(i, a), function () {
          return "Error in pool: Either strides or dilations must be 1. Got strides " + i + " and dilations '" + a + "'"
        });
        var l, c = Xr(s.shape, e, i, a, r),
          p = [c.dilationHeight, c.dilationWidth];
        l = "same" === r ? function (t, e) {
          var n = t.map(function (t, n) {
              return t + (t - 1) * (e[n] - 1)
            }).map(function (t) {
              return t - 1
            }),
            r = n.map(function (t) {
              return Math.floor(t / 2)
            }),
            a = n.map(function (t, e) {
              return t - r[e]
            });
          return n.map(function (t, e) {
            return [r[e], a[e]]
          })
        }([c.filterHeight, c.filterWidth], p) : [
          [0, 0],
          [0, 0]
        ];
        var h = 1 === p[0] && 1 === p[1],
          f = function (t, e, n) {
            var r = n.map(function (t) {
                return t[0]
              }),
              a = n.map(function (t) {
                return t[1]
              }),
              i = t.concat(r, a),
              o = e.map(function (t, e) {
                return (t - i[e] % t) % t
              }),
              s = a.map(function (t, e) {
                return t + o[e]
              });
            return [e.map(function (t, e) {
              return [r[e], s[e]]
            }), e.map(function (t, e) {
              return [0, o[e]]
            })]
          }([c.inHeight, c.inWidth], p, l),
          d = f[0],
          m = f[1],
          g = h ? r : "valid",
          v = h ? s : fr(s, p, d),
          y = ("avg" === n ? function () {
            return vu(v, e, i, 1, g)
          } : function () {
            return gu(v, e, i, 1, g)
          })(),
          x = h ? y : Kn(y, p, m);
        return u ? x.as3D(x.shape[1], x.shape[2], x.shape[3]) : x
      }
    }),
    wu = on({
      maxPool3d_: function (t, e, n, r, a, i, o) {
        void 0 === i && (i = "NDHWC");
        var s = Ke(t, "x", "maxPool3d"),
          u = s,
          l = !1;
        4 === s.rank && (l = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == o && (o = [1, 1, 1]), b(5 === u.rank, function () {
          return "Error in maxPool3d: x must be rank 5 but got rank " + u.rank + "."
        }), b("NDHWC" === i, function () {
          return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + i
        }), b(aa(n, o), function () {
          return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + o + "'"
        }), null != a && b(k(r), function () {
          return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
        });
        var c = $r(u.shape, e, n, o, r, a, i),
          p = Dt.runKernelFunc(function (t, e) {
            var n = t.maxPool3d(u, c);
            return e([u, n]), n
          }, {
            x: u
          }, function (t, i) {
            var s = i[0],
              u = i[1];
            return {
              x: function () {
                return function (t, e, n, r, a, i, o, s) {
                  var u = Ke(t, "dy", "maxPool3dBackprop"),
                    l = Ke(e, "input", "maxPool3dBackprop"),
                    c = Ke(n, "output", "maxPool3dBackprop"),
                    p = u,
                    h = l,
                    f = c,
                    d = !1;
                  4 === l.rank && (d = !0, p = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), h = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]), f = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3])), b(5 === p.rank, function () {
                    return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + p.rank + "."
                  }), b(5 === h.rank, function () {
                    return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + h.rank + "."
                  }), b(5 === f.rank, function () {
                    return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + f.rank + "."
                  }), null == i && (i = [1, 1, 1]), b(aa(a, i), function () {
                    return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + a + " and dilations '" + i + "'"
                  }), null != s && b(k(o), function () {
                    return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + s + " but got pad " + o + "."
                  });
                  var m = $r(h.shape, r, a, i, o, s),
                    g = Dt.runKernelFunc(function (t) {
                      return t.maxPool3dBackprop(p, h, f, m)
                    }, {
                      dy5D: p,
                      input5D: h
                    });
                  return d ? g.as4D(g.shape[1], g.shape[2], g.shape[3], g.shape[4]) : g
                }(t, s, u, e, n, o, r, a)
              }
            }
          });
        return l ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4]) : p
      }
    }),
    Cu = on({
      avgPool3d_: function (t, e, n, r, a, i, o) {
        void 0 === i && (i = "NDHWC");
        var s = Ke(t, "x", "avgPool3d", "float32"),
          u = s,
          l = !1;
        4 === s.rank && (l = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == o && (o = [1, 1, 1]), b(5 === u.rank, function () {
          return "Error in avgPool3d: x must be rank 5 but got rank " + u.rank + "."
        }), b("NDHWC" === i, function () {
          return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + i
        }), b(aa(n, o), function () {
          return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n + " and dilations '" + o + "'"
        }), null != a && b(k(r), function () {
          return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + "."
        });
        var c = $r(u.shape, e, n, o, r, a, i),
          p = Dt.runKernelFunc(function (t) {
            return t.avgPool3d(u, c)
          }, {
            x: u
          }, function (t) {
            return {
              x: function () {
                return function (t, e, n, r, a, i, o) {
                  var s = Ke(t, "dy", "avgPool3dBackprop"),
                    u = Ke(e, "input", "avgPool3dBackprop"),
                    l = s,
                    c = u,
                    p = !1;
                  4 === u.rank && (p = !0, l = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), c = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3])), b(5 === l.rank, function () {
                    return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + l.rank + "."
                  }), b(5 === c.rank, function () {
                    return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + c.rank + "."
                  }), null == a && (a = [1, 1, 1]), b(aa(r, a), function () {
                    return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + a + "'"
                  }), null != o && b(k(i), function () {
                    return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + i + "."
                  });
                  var h = $r(c.shape, n, r, a, i, o),
                    f = Dt.runKernelFunc(function (t) {
                      return t.avgPool3dBackprop(l, c, h)
                    }, {
                      dy5D: l,
                      input5D: c
                    });
                  return p ? f.as4D(f.shape[1], f.shape[2], f.shape[3], f.shape[4]) : f
                }(t, u, e, n, o, r, a)
              }
            }
          });
        return p = p.cast(u.dtype), l ? p.as4D(p.shape[1], p.shape[2], p.shape[3], p.shape[4]) : p
      }
    }),
    Nu = on({
      slice_: function (t, e, n) {
        var r, a, i = Ke(t, "x", "slice");
        if (0 === i.rank) throw new Error("Slicing scalar is not possible");
        (r = "number" == typeof e ? [e].concat(new Array(i.rank - 1).fill(0)) : e.length < i.rank ? e.concat(new Array(i.rank - e.length).fill(0)) : e.slice()).forEach(function (t) {
          b(-1 !== t, function () {
            return "slice() does not support negative begin indexing."
          })
        }), a = (a = null == n ? new Array(i.rank).fill(-1) : "number" == typeof n ? [n].concat(new Array(i.rank - 1).fill(-1)) : n.length < i.rank ? n.concat(new Array(i.rank - n.length).fill(-1)) : n).map(function (t, e) {
          return t >= 0 ? t : (b(-1 === t, function () {
            return "Negative size values should be exactly -1 but got " + t + " for the slice() size at index " + e + "."
          }), i.shape[e] - r[e])
        }), Rr(i, r, a);
        var o = i.shape,
          s = {
            begin: r,
            size: a
          };
        return Dt.runKernelFunc(function (t) {
          return t.slice(i, r, a)
        }, {
          x: i
        }, function (t) {
          for (var e = [], n = 0; n < t.rank; n++) e.push([r[n], o[n] - r[n] - a[n]]);
          return {
            x: function () {
              return t.pad(e)
            }
          }
        }, "Slice", s)
      }
    }),
    Su = on({
      slice1d_: function (t, e, n) {
        var r = Ke(t, "x", "slice1d");
        return b(1 === r.rank, function () {
          return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor"
        }), Nu(r, [e], [n])
      }
    }),
    ku = on({
      slice2d_: function (t, e, n) {
        var r = Ke(t, "x", "slice2d");
        return b(2 === r.rank, function () {
          return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor"
        }), Nu(r, e, n)
      }
    }),
    Iu = on({
      slice3d_: function (t, e, n) {
        var r = Ke(t, "x", "slice3d");
        return b(3 === r.rank, function () {
          return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor"
        }), Nu(r, e, n)
      }
    }),
    Eu = on({
      slice4d_: function (t, e, n) {
        var r = Ke(t, "x", "slice4d");
        return b(4 === r.rank, function () {
          return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor"
        }), Nu(r, e, n)
      }
    });

  function Au(t, e, n, r, a) {
    return e.rank < n.rank && (e = e.reshape(Ze(e.shape, r))), t.rank < n.rank && (t = t.reshape(Ze(t.shape, r))), {
      x: function () {
        var r = t.mul(n.equal(e).cast(t.dtype));
        return null == a ? r : r.transpose(a)
      }
    }
  }
  var Ru = on({
      all_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ke(t, "x", "all", "bool"),
          a = D(e, r.shape),
          i = a,
          o = tn(i, r.rank);
        null != o && (r = r.transpose(o), i = nn(i.length, r.rank));
        var s = Dt.runKernelFunc(function (t) {
          return t.all(r, i)
        }, {
          $x: r
        });
        if (n) {
          var u = Ze(s.shape, a);
          return s.reshape(u)
        }
        return s
      }
    }),
    Tu = on({
      any_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ke(t, "x", "any", "bool"),
          a = D(e, r.shape),
          i = a,
          o = tn(i, r.rank);
        null != o && (r = r.transpose(o), i = nn(i.length, r.rank));
        var s = Dt.runKernelFunc(function (t) {
          return t.any(r, i)
        }, {
          $x: r
        });
        if (n) {
          var u = Ze(s.shape, a);
          return s.reshape(u)
        }
        return s
      }
    }),
    Du = on({
      argMax_: function (t, e) {
        void 0 === e && (e = 0);
        var n = Ke(t, "x", "argMax");
        null == e && (e = 0);
        var r = D(e, n.shape),
          a = tn(r, n.rank);
        null != a && (n = n.transpose(a), r = nn(r.length, n.rank));
        var i = {
            axis: r[0]
          },
          o = [n];
        return Dt.runKernelFunc(function (t, e) {
          var a = t.argMax(n, r[0]);
          return e([n]), a
        }, {
          x: n
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return In(n)
            }
          }
        }, "ArgMax", i, o)
      }
    }),
    Ou = on({
      argMin_: function (t, e) {
        void 0 === e && (e = 0);
        var n = Ke(t, "x", "argMin");
        null == e && (e = 0);
        var r = D(e, n.shape),
          a = tn(r, n.rank);
        return null != a && (n = n.transpose(a), r = nn(r.length, n.rank)), Dt.runKernelFunc(function (t, e) {
          var a = t.argMin(n, r[0]);
          return e([n]), a
        }, {
          $x: n
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return In(n)
            }
          }
        })
      }
    }),
    _u = on({
      logSumExp_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ke(t, "x", "logSumExp"),
          a = D(e, r.shape),
          i = r.max(a, !0),
          o = r.sub(i).exp().sum(a).log(),
          s = i.reshape(o.shape).add(o);
        if (n) {
          var u = Ze(s.shape, a);
          return s.reshape(u)
        }
        return s
      }
    }),
    Fu = on({
      max_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ke(t, "x", "max"),
          a = r,
          i = D(e, r.shape),
          o = i,
          s = tn(o, r.rank);
        null != s && (r = r.transpose(s), o = nn(o.length, r.rank));
        var u = [r],
          l = Dt.runKernelFunc(function (t, e) {
            var n = t.max(r, o);
            return e([a, n]), n
          }, {
            x: r
          }, function (t, e) {
            return Au(t, e[1], e[0], i, s)
          }, "Max", {
            axes: o
          }, u, [!0]);
        if (n) {
          var c = Ze(l.shape, i);
          l = l.reshape(c)
        }
        return l
      }
    }),
    Mu = on({
      mean_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ke(t, "x", "mean"),
          a = D(e, r.shape),
          i = N(Je(r.shape, a)[1]);
        return Br(function (t) {
          var r = hn(i);
          return {
            value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),
            gradFunc: function (e) {
              var n = t.shape.slice();
              return a.forEach(function (t) {
                n[t] = 1
              }), e.reshape(n).mul(xn(t.shape, "float32")).div(i)
            }
          }
        })(r)
      }
    }),
    zu = on({
      min_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ke(t, "x", "min"),
          a = r,
          i = D(e, r.shape),
          o = i,
          s = tn(o, r.rank);
        null != s && (r = r.transpose(s), o = nn(o.length, r.rank));
        var u = [r],
          l = Dt.runKernelFunc(function (t, e) {
            var n = t.min(r, o);
            return e([a, n]), n
          }, {
            x: r
          }, function (t, e) {
            return Au(t, e[1], e[0], i, s)
          }, "Min", {
            axes: o
          }, u, [!0]);
        if (n) {
          var c = Ze(l.shape, i);
          l = l.reshape(c)
        }
        return l
      }
    }),
    Lu = on({
      moments_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = D(e, (t = Ke(t, "x", "moments")).shape),
          a = t.mean(r, n),
          i = a.shape;
        return n || (i = Ze(a.shape, r)), {
          mean: a,
          variance: t.toFloat().sub(a.reshape(i)).square().mean(r, n)
        }
      }
    }),
    Bu = on({
      sum_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ke(t, "x", "sum");
        "bool" === r.dtype && (r = r.toInt());
        var a = D(e, r.shape);
        return Br(function (t) {
          var e = tn(a, t.rank),
            r = a,
            i = t;
          null != e && (i = t.transpose(e), r = nn(r.length, t.rank));
          var o = function (e) {
              var n = t.shape.slice();
              return a.forEach(function (t) {
                n[t] = 1
              }), e.reshape(n).mul(xn(t.shape, "float32"))
            },
            s = {
              axes: r
            },
            u = Dt.runKernelFunc(function (t) {
              return t.sum(i, r)
            }, {
              x: i
            }, function (t) {
              return {
                x: function () {
                  return o(t)
                }
              }
            }, "Sum", s);
          if (n) {
            var l = Ze(u.shape, a);
            u = u.reshape(l)
          }
          return {
            value: u,
            gradFunc: o
          }
        })(r)
      }
    }),
    Pu = on({
      prod_: function (t, e, n) {
        void 0 === e && (e = null), void 0 === n && (n = !1);
        var r = Ke(t, "x", "prod");
        "bool" === r.dtype && (r = r.toInt());
        var a = D(e, r.shape),
          i = tn(a, r.rank),
          o = a,
          s = r;
        null != i && (s = r.transpose(i), o = nn(o.length, r.rank));
        var u = Dt.runKernelFunc(function (t) {
          return t.prod(s, o)
        }, {
          permutedX: s
        });
        if (n) {
          var l = Ze(u.shape, a);
          u = u.reshape(l)
        }
        return u
      }
    }),
    Wu = on({
      elu_: function (t) {
        var e = Ke(t, "x", "elu");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.elu(e);
          return n([r]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              return Dt.runKernelFunc(function (e) {
                return e.eluDer(t, n)
              }, {
                dy: t,
                y: n
              })
            }
          }
        })
      }
    }),
    Vu = on({
      leakyRelu_: function (t, e) {
        void 0 === e && (e = .2);
        var n = Ke(t, "x", "leakyRelu");
        return vs(hn(e).mul(n), n)
      }
    }),
    Uu = on({
      prelu_: function (t, e) {
        var n = Ke(t, "x", "prelu"),
          r = Ke(e, "alpha", "prelu");
        return Dt.runKernelFunc(function (t, e) {
          var a = t.prelu(n, r);
          return e([n, r]), a
        }, {
          x: n,
          alpha: r
        }, function (t, e) {
          var n = e[0],
            r = e[1],
            a = n.greater(0);
          return {
            x: function () {
              return ss(a, t, t.mul(r))
            },
            alpha: function () {
              var e = ss(a, In(t), t.mul(n)),
                i = Hr(r.shape, t.shape);
              return i.length > 0 && (e = e.sum(i)), e.reshape(r.shape)
            }
          }
        }, "Prelu")
      }
    }),
    ju = on({
      relu_: function (t) {
        var e = Ke(t, "x", "relu");
        return "bool" === e.dtype ? e.toInt() : Dt.runKernelFunc(function (t, n) {
          var r = t.relu(e);
          return n([e]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0];
          return {
            x: function () {
              return t.mulStrict(n.step().toFloat())
            }
          }
        }, "Relu")
      }
    }),
    Gu = on({
      relu6_: function (t) {
        var e = Ke(t, "x", "relu6");
        return "bool" === e.dtype ? e.toInt() : Dt.runKernelFunc(function (t, n) {
          var r = t.relu6(e);
          return n([e]), r
        }, {
          x: e
        }, function (t, e) {
          var n = e[0],
            r = n.lessEqual(6).mul(n.step());
          return {
            x: function () {
              return t.mulStrict(r.toFloat())
            }
          }
        }, "Relu6")
      }
    }),
    qu = on({
      selu_: function (t) {
        var e = Ke(t, "x", "selu");
        return Dt.runKernelFunc(function (t, n) {
          var r = t.selu(e);
          return n([e]), r
        }, {
          $x: e
        }, function (t, e) {
          var n = e[0];
          return {
            $x: function () {
              var e = n.greater(hn(0)),
                r = hn(Li),
                a = hn(Bi),
                i = t.mul(a),
                o = t.mul(r).mul(n.toFloat().exp());
              return ss(e, i, o)
            }
          }
        })
      }
    }),
    Hu = on({
      transpose_: function (t, e) {
        var n = Ke(t, "x", "transpose");
        if (null == e && (e = n.shape.map(function (t, e) {
            return e
          }).reverse()), b(n.rank === e.length, function () {
            return "Error in transpose: rank of input " + n.rank + " must match length of perm " + e + "."
          }), e.forEach(function (t) {
            b(t >= 0 && t < n.rank, function () {
              return "All entries in 'perm' must be between 0 and " + (n.rank - 1) + " but got " + e
            })
          }), n.rank <= 1) return n.clone();
        var r = {
          perm: e
        };
        return Dt.runKernelFunc(function (t) {
          return t.transpose(n, e)
        }, {
          x: n
        }, function (t) {
          var n = en(e);
          return {
            x: function () {
              return t.transpose(n)
            }
          }
        }, "Transpose", r)
      }
    }),
    Ku = on({
      localResponseNormalization_: function (t, e, n, r, a) {
        void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === a && (a = .5);
        var i = Ke(t, "x", "localResponseNormalization");
        b(4 === i.rank || 3 === i.rank, function () {
          return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + i.rank + "."
        }), b(k(e), function () {
          return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e + "."
        });
        var o = i,
          s = !1;
        3 === i.rank && (s = !0, o = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]));
        var u = Dt.runKernelFunc(function (t, i) {
          var s = t.localResponseNormalization4D(o, e, n, r, a);
          return i([o, s]), s
        }, {
          x4D: o
        }, function (t, i) {
          var o = i[0],
            s = i[1];
          return {
            x4D: function () {
              return Dt.runKernelFunc(function (i) {
                return i.LRNGrad(t, o, s, e, n, r, a)
              }, {})
            }
          }
        });
        return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
      }
    }),
    Xu = on({
      norm_: function (t, e, n, r) {
        void 0 === e && (e = "euclidean"), void 0 === n && (n = null), void 0 === r && (r = !1);
        var a = function t(e, n, r) {
            if (void 0 === r && (r = null), 0 === e.rank) return e.abs();
            if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r);
            if (1 === e.rank || "number" == typeof r || Array.isArray(r) && 1 === r.length) {
              if (1 === n) return e.abs().sum(r);
              if (n === 1 / 0) return e.abs().max(r);
              if (n === -1 / 0) return e.abs().min(r);
              if ("euclidean" === n || 2 === n) return e.abs().pow(hn(2, "int32")).sum(r).sqrt();
              throw new Error("Error in norm: invalid ord value: " + n)
            }
            if (Array.isArray(r) && 2 === r.length) {
              if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);
              if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);
              if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);
              if ("fro" === n || "euclidean" === n) return e.square().sum(r).sqrt();
              throw new Error("Error in norm: invalid ord value: " + n)
            }
            throw new Error("Error in norm: invalid axis: " + r)
          }(t = Ke(t, "x", "norm"), e, n),
          i = a.shape;
        if (r) {
          var o = D(n, t.shape);
          i = Ze(a.shape, o)
        }
        return a.reshape(i)
      }
    }),
    $u = on({
      basicLSTMCell_: function (t, e, n, r, a, i) {
        var o = Ke(t, "forgetBias", "basicLSTMCell"),
          s = Ke(e, "lstmKernel", "basicLSTMCell"),
          u = Ke(n, "lstmBias", "basicLSTMCell"),
          l = Ke(r, "data", "basicLSTMCell"),
          c = Ke(a, "c", "basicLSTMCell"),
          p = Ke(i, "h", "basicLSTMCell"),
          h = l.concat(p, 1).matMul(s).add(u),
          f = h.shape[0],
          d = h.shape[1] / 4,
          m = [f, d],
          g = h.slice([0, 0], m),
          v = h.slice([0, d], m),
          y = h.slice([0, 2 * d], m),
          b = h.slice([0, 3 * d], m),
          x = g.sigmoid().mulStrict(v.tanh()).addStrict(c.mulStrict(o.add(y).sigmoid()));
        return [x, x.tanh().mulStrict(b.sigmoid())]
      }
    }),
    Yu = on({
      multiRNNCell_: function (t, e, n, r) {
        for (var a = Ke(e, "data", "multiRNNCell"), i = Xe(n, "c", "multiRNNCell"), o = Xe(r, "h", "multiRNNCell"), s = a, u = [], l = 0; l < t.length; l++) {
          var c = t[l](s, i[l], o[l]);
          u.push(c[0]), u.push(c[1]), s = c[1]
        }
        var p = [],
          h = [];
        for (l = 0; l < u.length; l += 2) p.push(u[l]), h.push(u[l + 1]);
        return [p, h]
      }
    }),
    Ju = on({
      movingAverage_: function (t, e, n, r, a) {
        void 0 === a && (a = !0);
        var i = Ke(t, "v", "movingAverage"),
          o = Ke(e, "x", "movingAverage"),
          s = Ke(n, "decay", "movingAverage");
        kt(i, o), b(S(i.shape, o.shape), function () {
          return "Shape mismatch in v and x"
        });
        var u = hn(1),
          l = u.sub(s),
          c = o.sub(i).mul(l);
        if (a) {
          b(null != r, function () {
            return "When using zeroDebias: true, step is required."
          });
          var p = Ke(r, "step", "movingAverage");
          c = c.div(u.sub(ks(s, p)))
        }
        return i.add(c)
      }
    }),
    Zu = on({
      stridedSlice_: function (t, e, n, r, a, i, o, s, u) {
        if (void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), null == r && (r = new Array(e.length)), 0 !== o) throw new Error("ellipsis mask is not yet supported");
        var l = Ke(t, "x", "stridedSlice"),
          c = Tr(s),
          p = l.shape.slice();
        c.forEach(function (t) {
          e[t] = 0, n[t] = 1, p.splice(t, 0, 1)
        }), l = l.reshape(p);
        for (var h = 0; h < l.rank; h++) e[h] = Or(a, e, r, l.shape, h), n[h] = _r(i, n, r, l.shape, h), r[h] = r[h] || 1;
        var f = Tr(u);
        f.forEach(function (t) {
          n[t] = e[t] + 1, r[t] = 1
        });
        var d = Dr(e, n, r),
          m = d.filter(function (t, e) {
            return -1 === f.indexOf(e)
          });
        return r.every(function (t) {
          return 1 === t
        }) ? Nu(l, e, d).reshape(m) : Dt.runKernelFunc(function (t) {
          return t.stridedSlice(l, e, n, r)
        }, {
          $x: l
        }).reshape(m)
      }
    }),
    Qu = on({
      topk_: function (t, e, n) {
        void 0 === e && (e = 1), void 0 === n && (n = !0);
        var r = Ke(t, "x", "topk");
        if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
        var a = r.shape[r.shape.length - 1];
        if (e > a) throw new Error("'k' passed to topk() must be <= the last dimension (" + a + ") but got " + e);
        var i = Dt.runKernelFunc(function (t) {
          return t.topk(r, e, n)
        }, {
          $x: r
        });
        return {
          values: i[0],
          indices: i[1]
        }
      }
    }),
    tl = on({
      scatterND_: function (t, e, n) {
        var r = Ke(t, "indices", "scatterND", "int32"),
          a = Ke(e, "updates", "scatterND");
        return function (t, e, n) {
          if (e.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e.rank + ".");
          if (t.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t.rank + ".");
          if ("int32" !== e.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e.dtype);
          if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n);
          if (0 === n.length) {
            if (0 === e.size) throw new Error("Indices specified for empty output. indices shape: " + e.shape);
            if (0 === t.size) throw new Error("Updates specified for empty output. updates shape: " + t.shape)
          }! function (t, e, n) {
            var r = e.rank > 1 ? e.shape[e.rank - 1] : 1,
              a = e.rank > 1 ? e.rank - 1 : 1,
              i = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n.shape + ", indices.shape: " + e.shape + ", shape: " + t + ", sliceDim: " + r + ", and batchDim: " + a + ".";
            if (n.rank < a) throw new Error(i + " update.rank < " + a + ". ");
            if (t.length < r + (n.rank - a)) throw new Error(i + " Output shape length < " + (r + (n.rank - a)));
            if (n.rank !== a + t.length - r) throw new Error(i + " update.rank != " + (a + t.length - r));
            for (var o = 0; o < a; ++o)
              if (n.shape[o] !== e.shape[o]) throw new Error(i + " updates.shape[" + o + "] (" + n.shape[o] + ") != indices.shape[" + o + "] (" + e.shape[o] + ").");
            for (o = 0; o < n.rank - a; ++o)
              if (n.shape[o + a] !== t[o + r]) throw new Error(i + " updates.shape[" + (o + a) + "] (" + n.shape[o + a] + ") != shape[" + (o + a) + "] (" + t[o + a] + ")")
          }(n, e, t)
        }(a, r, n), Dt.runKernelFunc(function (t) {
          return t.scatterND(r, a, n)
        }, {
          $indices: r,
          $updates: a
        })
      }
    }),
    el = on({
      fft_: function (t) {
        b("complex64" === t.dtype, function () {
          return "The dtype for tf.spectral.fft() must be complex64 but got " + t.dtype + "."
        });
        var e = t.shape[t.shape.length - 1],
          n = t.size / e,
          r = t.as2D(n, e);
        return Dt.runKernelFunc(function (t) {
          return t.fft(r)
        }, {
          input: t
        }).reshape(t.shape)
      }
    }),
    nl = on({
      ifft_: function (t) {
        b("complex64" === t.dtype, function () {
          return "The dtype for tf.spectral.ifft() must be complex64 but got " + t.dtype + "."
        });
        var e = t.shape[t.shape.length - 1],
          n = t.size / e,
          r = t.as2D(n, e);
        return Dt.runKernelFunc(function (t) {
          return t.ifft(r)
        }, {
          input: t
        }).reshape(t.shape)
      }
    }),
    rl = on({
      rfft_: function (t, e) {
        b("float32" === t.dtype, function () {
          return "The dtype for rfft() must be real value but got " + t.dtype
        });
        var n, r = t.shape[t.shape.length - 1],
          a = t.size / r;
        if (null != e && e < r) {
          var i = t.shape.map(function (t) {
              return 0
            }),
            o = t.shape.map(function (t) {
              return t
            });
          o[t.shape.length - 1] = e, n = t.slice(i, o), r = e
        } else if (null != e && e > r) {
          var s = t.shape.map(function (t) {
            return t
          });
          s[t.shape.length - 1] = e - r, n = t.concat(wn(s), t.shape.length - 1), r = e
        } else n = t;
        var u = n.zerosLike(),
          l = sn(n, u).as2D(a, r),
          c = el(l),
          p = Math.floor(r / 2) + 1,
          h = un(c),
          f = ln(c),
          d = h.split([p, r - p], h.shape.length - 1),
          m = f.split([p, r - p], f.shape.length - 1),
          g = n.shape.slice();
        return g[n.shape.length - 1] = p, sn(d[0], m[0]).reshape(g)
      }
    }),
    al = on({
      irfft_: function (t) {
        var e = t.shape[t.shape.length - 1],
          n = t.size / e;
        if (e <= 2) {
          var r = t.as2D(n, e),
            a = nl(r);
          return un(a)
        }
        var i = [n, 2 * (e - 1)],
          o = un(t).as2D(n, e),
          s = ln(t).as2D(n, e),
          u = o.slice([0, 1], [n, e - 2]).reverse(1),
          l = s.slice([0, 1], [n, e - 2]).reverse(1).mul(hn(-1)),
          c = o.concat(u, 1),
          p = s.concat(l, 1);
        return r = sn(c, p).as2D(i[0], i[1]), a = nl(r), un(a)
      }
    }),
    il = Object.freeze({
      fft: el,
      ifft: nl,
      rfft: rl,
      irfft: al
    }),
    ol = on({
      sparseToDense_: function (t, e, n, r) {
        void 0 === r && (r = 0);
        var a = Ke(t, "sparseIndices", "sparseToDense", "int32"),
          i = Ke(e, "sparseValues", "sparseToDense"),
          o = Ke(r, "defaultValue", "sparseToDense", i.dtype);
        return function (t, e, n, r) {
          if ("int32" !== t.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t.dtype + ".");
          if (t.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t.shape + ".");
          var a = t.rank > 0 ? t.shape[0] : 1,
            i = t.rank > 1 ? t.shape[1] : 1;
          if (n.length !== i) throw new Error("outputShape has incorrect number of elements:, " + n.length + ", should be: " + i + ".");
          var o = e.size;
          if (0 !== e.rank && (1 !== e.rank || o !== a)) throw new Error("sparseValues has incorrect shape " + e.shape + ", should be [] or [" + a + "]");
          if (e.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype")
        }(a, i, n, o), Dt.runKernelFunc(function (t) {
          return t.sparseToDense(a, i, n, o)
        }, {
          $sparseIndices: a,
          $sparseValues: i,
          $defaultValue: o
        })
      }
    }),
    sl = on({
      gatherND_: function (t, e) {
        var n = Ke(e, "indices", "gatherND", "int32"),
          r = Ke(t, "x", "gatherND");
        return Dt.runKernelFunc(function (t) {
          return t.gatherND(r, n)
        }, {
          $x: r,
          $indices: n
        })
      }
    }),
    ul = on({
      diag_: function (t) {
        var e = Ke(t, "x", "diag").flatten(),
          n = t.shape.concat(t.shape);
        return Dt.runKernelFunc(function (t) {
          return t.diag(e)
        }, {
          $x: e
        }).reshape(n)
      }
    }),
    ll = on({
      dropout_: function (t, e, n, r) {
        var a = Ke(t, "x", "dropout");
        if (b("float32" === a.dtype, function () {
            return "x has to be a floating point tensor since it's going to be scaled, but got a " + a.dtype + " tensor instead."
          }), b(e >= 0 && e < 1, function () {
            return "rate must be a float in the range [0, 1), but got " + e + "."
          }), 0 === e) return t instanceof mt ? a.clone() : a;
        var i = function (t, e) {
            if (null == e) return t.shape.slice();
            if (S(t.shape, e)) return e;
            if (t.shape.length === e.length) {
              for (var n = [], r = 0; r < t.shape.length; r++) null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);
              return n
            }
            return e
          }(a, n),
          o = 1 - e,
          s = pr(i, 0, 1, "float32", r).add(o).floor().div(o);
        return a.mul(s)
      }
    });

  function cl(t, e, n) {
    for (var r = 1 - t % 2, a = new Float32Array(t), i = 0; i < t; ++i) {
      var o = 2 * Math.PI * i / (t + r - 1);
      a[i] = e - n * Math.cos(o)
    }
    return fn(a, "float32")
  }
  var pl = on({
      hannWindow_: function (t) {
        return cl(t, .5, .5)
      }
    }),
    hl = on({
      hammingWindow_: function (t) {
        return cl(t, .54, .46)
      }
    }),
    fl = on({
      frame_: function (t, e, n, r, a) {
        void 0 === r && (r = !1), void 0 === a && (a = 0);
        for (var i = 0, o = []; i + e <= t.size;) o.push(Nu(t, i, e)), i += n;
        if (r)
          for (; i < t.size;) {
            var s = i + e - t.size,
              u = En([Nu(t, i, e - s), Cn([s], a)]);
            o.push(u), i += n
          }
        return 0 === o.length ? dn([], [0, e]) : En(o).as2D(o.length, e)
      }
    }),
    dl = on({
      stft_: function (t, e, n, r, a) {
        var i;
        void 0 === a && (a = pl), null == r && (i = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(i) / Math.log(2)))));
        for (var o = fl(t, e, n), s = Ns(o, a(e)), u = [], l = 0; l < o.shape[0]; l++) u.push(rl(s.slice([l, 0], [1, e]), r));
        return En(u)
      }
    }),
    ml = Object.freeze({
      hannWindow: pl,
      hammingWindow: hl,
      frame: fl,
      stft: dl
    }),
    gl = function (t, e, n) {
      return void 0 === n && (n = 1), r(this, void 0, void 0, function () {
        var r, i, o, s, u, l, c, p, h, f, d, m, g, v;
        return a(this, function (a) {
          switch (a.label) {
            case 0:
              return r = Ke(t, "predictions", "inTopK"), i = Ke(e, "targets", "inTopK"), b(r.rank > 1, function () {
                return "inTopK() expects the predictions to be of rank 2 or higher, but got " + r.rank
              }), b(r.rank - 1 === i.rank, function () {
                return "predictions rank should be 1 larger than targets rank, but got predictions rank " + r.rank + " and targets rank " + i.rank
              }), x(r.shape.slice(0, r.shape.length - 1), i.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), o = r.shape[r.shape.length - 1], b(n > 0 && n <= o, function () {
                return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + o + "), but got " + n
              }), [4, r.data()];
            case 1:
              return s = a.sent(), [4, i.data()];
            case 2:
              for (u = a.sent(), l = [s.length / o, o], p = l[1], h = _("bool", c = l[0]), f = 0; f < c; f++) {
                for (d = f * p, m = s.subarray(d, d + p), g = [], v = 0; v < m.length; v++) g.push({
                  value: m[v],
                  index: v
                });
                for (g.sort(function (t, e) {
                    return e.value - t.value
                  }), h[f] = 0, v = 0; v < n; v++)
                  if (g[v].index === u[f]) {
                    h[f] = 1;
                    break
                  }
              }
              return t !== r && r.dispose(), e !== i && i.dispose(), [2, cn(h, i.shape, "bool")]
          }
        })
      })
    };
  ! function (t) {
    t[t.NONE = 0] = "NONE", t[t.MEAN = 1] = "MEAN", t[t.SUM = 2] = "SUM", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS"
  }(t.Reduction || (t.Reduction = {}));
  var vl = on({
      absoluteDifference_: function (e, n, r, a) {
        void 0 === a && (a = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var i = Ke(e, "labels", "absoluteDifference"),
          o = Ke(n, "predictions", "absoluteDifference"),
          s = null;
        null != r && (s = Ke(r, "weights", "absoluteDifference")), x(i.shape, o.shape, "Error in absoluteDifference: ");
        var u = i.sub(o).abs();
        return yl(u, s, a)
      }
    }),
    yl = on({
      computeWeightedLoss_: function (e, n, r) {
        void 0 === r && (r = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var a = Ke(e, "losses", "computeWeightedLoss"),
          i = null;
        null != n && (i = Ke(n, "weights", "computeWeightedLoss"));
        var o = null == i ? a : a.mul(i);
        if (r === t.Reduction.NONE) return o;
        if (r === t.Reduction.SUM) return o.sum();
        if (r === t.Reduction.MEAN) {
          if (null == i) return o.mean();
          var s = a.size / i.size,
            u = o.sum().div(i.sum());
          return s > 1 ? u.div(hn(s)) : u
        }
        if (r === t.Reduction.SUM_BY_NONZERO_WEIGHTS) {
          if (null == i) return o.sum().div(hn(a.size));
          var l = i.mul(xn(a.shape)).notEqual(hn(0)).sum().toFloat();
          return o.sum().div(l)
        }
        throw Error("Unknown reduction: " + r)
      }
    }),
    bl = on({
      cosineDistance_: function (e, n, r, a, i) {
        void 0 === i && (i = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var o = Ke(e, "labels", "cosineDistance"),
          s = Ke(n, "predictions", "cosineDistance"),
          u = null;
        null != a && (u = Ke(a, "weights", "cosineDistance")), x(o.shape, s.shape, "Error in cosineDistance: ");
        var l = hn(1).sub(o.mul(s).sum(r, !0));
        return yl(l, u, i)
      }
    }),
    xl = on({
      hingeLoss_: function (e, n, r, a) {
        void 0 === a && (a = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var i = Ke(e, "labels", "hingeLoss"),
          o = Ke(n, "predictions", "hingeLoss"),
          s = null;
        null != r && (s = Ke(r, "weights", "hingeLoss")), x(i.shape, o.shape, "Error in hingeLoss: ");
        var u = hn(1);
        i = hn(2).mul(i).sub(u);
        var l = u.sub(i.mul(o)).relu();
        return yl(l, s, a)
      }
    }),
    wl = on({
      huberLoss_: function (e, n, r, a, i) {
        void 0 === a && (a = 1), void 0 === i && (i = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var o = Ke(e, "labels", "huberLoss"),
          s = Ke(n, "predictions", "huberLoss"),
          u = null;
        null != r && (u = Ke(r, "weights", "huberLoss")), x(o.shape, s.shape, "Error in huberLoss: ");
        var l = hn(a),
          c = s.sub(o).abs(),
          p = bs(c, l),
          h = c.sub(p),
          f = hn(.5).mul(p.square()).add(l.mul(h));
        return yl(f, u, i)
      }
    }),
    Cl = on({
      logLoss_: function (e, n, r, a, i) {
        void 0 === a && (a = 1e-7), void 0 === i && (i = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var o = Ke(e, "labels", "logLoss"),
          s = Ke(n, "predictions", "logLoss"),
          u = null;
        null != r && (u = Ke(r, "weights", "logLoss")), x(o.shape, s.shape, "Error in logLoss: ");
        var l = hn(1),
          c = hn(a),
          p = o.mul(s.add(c).log()).neg().sub(l.sub(o).mul(l.sub(s).add(c).log()));
        return yl(p, u, i)
      }
    }),
    Nl = on({
      meanSquaredError_: function (e, n, r, a) {
        void 0 === a && (a = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var i = Ke(e, "labels", "meanSquaredError"),
          o = Ke(n, "predictions", "meanSquaredError"),
          s = null;
        null != r && (s = Ke(r, "weights", "meanSquaredError")), x(i.shape, o.shape, "Error in meanSquaredError: ");
        var u = i.squaredDifference(o);
        return yl(u, s, a)
      }
    }),
    Sl = on({
      sigmoidCrossEntropy_: function (e, n, r, a, i) {
        void 0 === a && (a = 0), void 0 === i && (i = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var o = Ke(e, "multiClassLabels", "sigmoidCrossEntropy"),
          s = Ke(n, "logits", "sigmoidCrossEntropy"),
          u = null;
        if (null != r && (u = Ke(r, "weights", "sigmoidCrossEntropy")), x(o.shape, s.shape, "Error in sigmoidCrossEntropy: "), a > 0) {
          var l = hn(a),
            c = hn(1),
            p = hn(.5);
          o = o.mul(c.sub(l)).add(p.mul(l))
        }
        var h = function (t, e) {
          var n = Ke(t, "labels", "sigmoidCrossEntropyWithLogits"),
            r = Ke(e, "logits", "sigmoidCrossEntropyWithLogits");
          x(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
          var a = r.relu(),
            i = r.mul(n),
            o = r.abs().neg().exp().log1p();
          return a.sub(i).add(o)
        }(o, s);
        return yl(h, u, i)
      }
    }),
    kl = on({
      softmaxCrossEntropy_: function (e, n, r, a, i) {
        void 0 === a && (a = 0), void 0 === i && (i = t.Reduction.SUM_BY_NONZERO_WEIGHTS);
        var o = Ke(e, "onehotLabels", "softmaxCrossEntropy"),
          s = Ke(n, "logits", "softmaxCrossEntropy"),
          u = null;
        if (null != r && (u = Ke(r, "weights", "softmaxCrossEntropy")), x(o.shape, s.shape, "Error in softmaxCrossEntropy: "), a > 0) {
          var l = hn(a),
            c = hn(1),
            p = hn(o.shape[1]);
          o = o.mul(c.sub(l)).add(l.div(p))
        }
        var h = function (t, e, n) {
          if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e.rank + " and dim was " + n);
          return Br(function (t, e, r) {
            var a = e.logSumExp([n], !0),
              i = e.toFloat().sub(a);
            return r([t, i]), {
              value: i.mul(t).neg().sum([n]),
              gradFunc: function (t, e) {
                var r = e[0],
                  a = e[1],
                  i = Ze(t.shape, [n]);
                return [t.reshape(i).mul(r.toFloat().sub(a.exp())), t.reshape(i).mul(a.exp().sub(r.toFloat()))]
              }
            }
          })(t, e)
        }(o, s);
        return yl(h, u, i)
      }
    }),
    Il = Object.freeze({
      get Reduction() {
        return t.Reduction
      },
      absoluteDifference: vl,
      computeWeightedLoss: yl,
      cosineDistance: bl,
      hingeLoss: xl,
      huberLoss: wl,
      logLoss: Cl,
      meanSquaredError: Nl,
      sigmoidCrossEntropy: Sl,
      softmaxCrossEntropy: kl
    });

  function El(t, e) {
    return void 0 === e && (e = !1), Dt.tidy(function () {
      if (2 !== t.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t.shape.length + "D Tensor.");
      for (var n = t.shape[0], r = t.shape[1], a = tr(n), i = t.clone(), o = dn([
          [1]
        ], [1, 1]), s = o.clone(), u = n >= r ? r : n, l = function (t) {
          var e, u = i,
            l = s,
            c = a;
          e = Dt.tidy(function () {
            var e = i.slice([t, t], [n - t, 1]),
              u = e.norm(),
              l = i.slice([t, t], [1, 1]),
              c = dn([
                [-1]
              ]).where(l.greater(0), dn([
                [1]
              ])),
              p = l.sub(c.mul(u)),
              h = e.div(p);
            s = 1 === h.shape[0] ? o.clone() : o.concat(h.slice([1, 0], [h.shape[0] - 1, h.shape[1]]), 0);
            var f = c.matMul(p).div(u).neg(),
              d = i.slice([t, 0], [n - t, r]),
              m = f.mul(s);
            if (0 === t) i = d.sub(m.matMul(s.transpose().matMul(d)));
            else {
              var g = d.sub(m.matMul(s.transpose().matMul(d)));
              i = i.slice([0, 0], [t, r]).concat(g, 0)
            }
            var v = a.slice([0, t], [n, a.shape[1] - t]);
            if (0 === t) a = v.sub(v.matMul(s).matMul(m.transpose()));
            else {
              var y = v.sub(v.matMul(s).matMul(m.transpose()));
              a = a.slice([0, 0], [n, t]).concat(y, 1)
            }
            return [s, i, a]
          }), s = e[0], i = e[1], a = e[2], Ve([u, l, c])
        }, c = 0; c < u; ++c) l(c);
      return !e && n > r && (a = a.slice([0, 0], [n, r]), i = i.slice([0, 0], [r, r])), [a, i]
    })
  }
  var Al = on({
      bandPart_: function (t, e, n) {
        if (e % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e + ".");
        if (n % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + n + ".");
        var r = Ke(t, "a", "bandPart");
        if (r.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r.rank + ".");
        var a = r.shape,
          i = r.shape.slice(-2),
          o = i[0],
          s = i[1];
        if (!(e <= o)) throw new Error("bandPart(): numLower (" + e + ") must not be greater than the number of rows (" + o + ").");
        if (!(n <= s)) throw new Error("bandPart(): numUpper (" + n + ") must not be greater than the number of columns (" + s + ").");
        e < 0 && (e = o), n < 0 && (n = s);
        var u = Sn(0, o, 1, "int32").reshape([-1, 1]),
          l = Sn(0, s, 1, "int32"),
          c = Rs(u, l),
          p = rs(c.lessEqual(hn(+e, "int32")), c.greaterEqual(hn(-n, "int32"))),
          h = wn([o, s], r.dtype);
        return mr(yr(r.reshape([-1, o, s])).map(function (t) {
          return ss(p, t, h)
        })).reshape(a)
      }
    }),
    Rl = on({
      gramSchmidt_: function (t) {
        var e;
        if (Array.isArray(t)) {
          e = !1, b(null != t && t.length > 0, function () {
            return "Gram-Schmidt process: input must not be null, undefined, or empty"
          });
          for (var n = t[0].shape[0], r = function (e) {
              b(t[e].shape[0] === n, function () {
                return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t[e].shape[0] + " vs. " + n + ")"
              })
            }, a = 1; a < t.length; ++a) r(a)
        } else e = !0, t = On(t, t.shape[0], 0).map(function (t) {
          return dr(t, [0])
        });
        b(t.length <= t[0].shape[0], function () {
          return "Gram-Schmidt: Number of vectors (" + t.length + ") exceeds number of dimensions (" + t[0].shape[0] + ")."
        });
        var i = [],
          o = t,
          s = function (t) {
            i.push(Dt.tidy(function () {
              var e = o[t];
              if (t > 0)
                for (var n = 0; n < t; ++n) {
                  var r = Bu(i[n].mulStrict(e)).mul(i[n]);
                  e = e.sub(r)
                }
              return e.div(Xu(e, "euclidean"))
            }))
          };
        for (a = 0; a < t.length; ++a) s(a);
        return e ? mr(i, 0) : i
      }
    }),
    Tl = on({
      qr_: function (t, e) {
        if (void 0 === e && (e = !1), t.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t.rank);
        if (2 === t.rank) return El(t, e);
        var n = t.shape.slice(0, t.shape.length - 2).reduce(function (t, e) {
            return t * e
          }),
          r = [],
          a = [];
        return yr(t.reshape([n, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0).forEach(function (t) {
          var n = El(t, e),
            i = n[0],
            o = n[1];
          r.push(i), a.push(o)
        }), [mr(r, 0).reshape(t.shape), mr(a, 0).reshape(t.shape)]
      }
    }),
    Dl = Object.freeze({
      bandPart: Al,
      gramSchmidt: Rl,
      qr: Tl
    });

  function Ol(t, e, n, r, a, i) {
    null == r && (r = .5), null == a && (a = Number.NEGATIVE_INFINITY), null == i && (i = 0);
    var o = t.shape[0];
    return n = Math.min(n, o), b(0 <= r && r <= 1, function () {
      return "iouThreshold must be in [0, 1], but was '" + r + "'"
    }), b(2 === t.rank, function () {
      return "boxes must be a 2D tensor, but was of rank '" + t.rank + "'"
    }), b(4 === t.shape[1], function () {
      return "boxes must have 4 columns, but 2nd dimension was " + t.shape[1]
    }), b(1 === e.rank, function () {
      return "scores must be a 1D tensor"
    }), b(e.shape[0] === o, function () {
      return "scores has incompatible shape with boxes. Expected " + o + ", but was " + e.shape[0]
    }), b(0 <= i && i <= 1, function () {
      return "softNmsSigma must be in [0, 1], but was '" + i + "'"
    }), {
      maxOutputSize: n,
      iouThreshold: r,
      scoreThreshold: a,
      softNmsSigma: i
    }
  }
  var _l = on({
      resizeBilinear_: function (t, e, n) {
        void 0 === n && (n = !1);
        var r = Ke(t, "images", "resizeBilinear");
        b(3 === r.rank || 4 === r.rank, function () {
          return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r.rank + "."
        }), b(2 === e.length, function () {
          return "Error in resizeBilinear: new shape must 2D, but got shape " + e + "."
        });
        var a = r,
          i = !1;
        3 === r.rank && (i = !0, a = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
        var o = e[0],
          s = e[1],
          u = Dt.runKernelFunc(function (t, e) {
            return e([a]), t.resizeBilinear(a, o, s, n)
          }, {
            x: a
          }, function (t, e) {
            return {
              x: function () {
                return Dt.runKernelFunc(function (r) {
                  return r.resizeBilinearBackprop(t, e[0], n)
                }, {})
              }
            }
          }, "ResizeBilinear", {
            alignCorners: n,
            newHeight: o,
            newWidth: s
          });
        return i ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
      }
    }),
    Fl = on({
      resizeNearestNeighbor_: function (t, e, n) {
        void 0 === n && (n = !1);
        var r = Ke(t, "images", "resizeNearestNeighbor");
        b(3 === r.rank || 4 === r.rank, function () {
          return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r.rank + "."
        }), b(2 === e.length, function () {
          return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e + "."
        }), b("float32" === r.dtype || "int32" === r.dtype, function () {
          return "`images` must have `int32` or `float32` as dtype"
        });
        var a = r,
          i = !1;
        3 === r.rank && (i = !0, a = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
        var o = e[0],
          s = e[1],
          u = Dt.runKernelFunc(function (t, e) {
            return e([a]), t.resizeNearestNeighbor(a, o, s, n)
          }, {
            batchImages: a
          }, function (t, e) {
            return {
              batchImages: function () {
                return Dt.runKernelFunc(function (r) {
                  return r.resizeNearestNeighborBackprop(t, e[0], n)
                }, {})
              }
            }
          });
        return i ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u
      }
    }),
    Ml = on({
      nonMaxSuppression_: function (t, e, n, r, a) {
        void 0 === r && (r = .5), void 0 === a && (a = Number.NEGATIVE_INFINITY);
        var i = Ke(t, "boxes", "nonMaxSuppression"),
          o = Ke(e, "scores", "nonMaxSuppression"),
          s = Ol(i, o, n, r, a);
        n = s.maxOutputSize, r = s.iouThreshold, a = s.scoreThreshold;
        var u = {
          maxOutputSize: n,
          iouThreshold: r,
          scoreThreshold: a
        };
        return Dt.runKernelFunc(function (t) {
          return t.nonMaxSuppression(i, o, n, r, a)
        }, {
          boxes: i,
          scores: o
        }, null, "NonMaxSuppressionV3", u)
      }
    }),
    zl = on({
      nonMaxSuppressionWithScore_: function (t, e, n, r, a, i) {
        void 0 === r && (r = .5), void 0 === a && (a = Number.NEGATIVE_INFINITY), void 0 === i && (i = 0);
        var o = Ke(t, "boxes", "nonMaxSuppression"),
          s = Ke(e, "scores", "nonMaxSuppression"),
          u = Ol(o, s, n, r, a, i),
          l = {
            maxOutputSize: n = u.maxOutputSize,
            iouThreshold: r = u.iouThreshold,
            scoreThreshold: a = u.scoreThreshold,
            softNmsSigma: i = u.softNmsSigma
          },
          c = Dt.runKernel("NonMaxSuppressionV5", {
            boxes: o,
            scores: s
          }, l);
        return {
          selectedIndices: c[0],
          selectedScores: c[1]
        }
      }
    }),
    Ll = on({
      cropAndResize_: function (t, e, n, r, a, i) {
        var o = Ke(t, "image", "cropAndResize"),
          s = Ke(e, "boxes", "cropAndResize", "float32"),
          u = Ke(n, "boxInd", "cropAndResize", "int32");
        a = a || "bilinear", i = i || 0;
        var l = s.shape[0];
        return b(4 === o.rank, function () {
          return "Error in cropAndResize: image must be rank 4,but got rank " + o.rank + "."
        }), b(2 === s.rank && 4 === s.shape[1], function () {
          return "Error in cropAndResize: boxes must be have size [" + l + ",4] but had shape " + s.shape + "."
        }), b(1 === u.rank && u.shape[0] === l, function () {
          return "Error in cropAndResize: boxInd must be have size [" + l + "] but had shape " + s.shape + "."
        }), b(2 === r.length, function () {
          return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + "."
        }), b(r[0] >= 1 && r[1] >= 1, function () {
          return "cropSize must be atleast [1,1], but was " + r
        }), b("bilinear" === a || "nearest" === a, function () {
          return "method must be bilinear or nearest, but was " + a
        }), Dt.runKernelFunc(function (t, e) {
          return t.cropAndResize(o, s, u, r, a, i)
        }, {
          images: o,
          boxes: s,
          boxInd: u
        }, null, "CropAndResize", {
          method: a,
          extrapolationValue: i,
          cropSize: r
        })
      }
    }),
    Bl = Object.freeze({
      resizeBilinear: _l,
      resizeNearestNeighbor: Fl,
      nonMaxSuppression: Ml,
      nonMaxSuppressionAsync: function (t, e, n, i, o) {
        return void 0 === i && (i = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), r(this, void 0, void 0, function () {
          var r, s, u, l, c, p, h;
          return a(this, function (a) {
            switch (a.label) {
              case 0:
                return r = Ke(t, "boxes", "nonMaxSuppressionAsync"), s = Ke(e, "scores", "nonMaxSuppressionAsync"), u = Ol(r, s, n, i, o), n = u.maxOutputSize, i = u.iouThreshold, o = u.scoreThreshold, [4, Promise.all([r.data(), s.data()])];
              case 1:
                return l = a.sent(), c = l[0], p = l[1], h = ga(c, p, n, i, o), r !== t && r.dispose(), s !== e && s.dispose(), [2, h]
            }
          })
        })
      },
      nonMaxSuppressionWithScore: zl,
      nonMaxSuppressionWithScoreAsync: function (t, e, n, i, o, s) {
        return void 0 === i && (i = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), void 0 === s && (s = 0), r(this, void 0, void 0, function () {
          var r, u, l, c, p, h, f;
          return a(this, function (a) {
            switch (a.label) {
              case 0:
                return r = Ke(t, "boxes", "nonMaxSuppressionAsync"), u = Ke(e, "scores", "nonMaxSuppressionAsync"), l = Ol(r, u, n, i, o, s), n = l.maxOutputSize, i = l.iouThreshold, o = l.scoreThreshold, s = l.softNmsSigma, [4, Promise.all([r.data(), u.data()])];
              case 1:
                return c = a.sent(), p = c[0], h = c[1], f = va(p, h, n, i, o, s), r !== t && r.dispose(), u !== e && u.dispose(), [2, f]
            }
          })
        })
      },
      cropAndResize: Ll
    }),
    Pl = function (t, e) {
      return !(t > 0) || "linear" === e
    },
    Wl = function (t, e, n) {
      if (null == n || "linear" === n) return t;
      if ("relu" === n) return t.mul(e.step());
      throw new Error("Gradient for activation " + n + " has not been implemented yet.")
    },
    Vl = function (t, e) {
      var n = e,
        r = Hr(t.shape, e.shape);
      return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape)
    },
    Ul = function (t, e, n) {
      if ("linear" === e) return t;
      if ("relu" === e) return ju(t);
      if ("elu" === e) return Wu(t);
      if ("relu6" === e) return Gu(t);
      if ("prelu" === e) return Uu(t, n);
      throw new Error("Unknown fused activation " + e + ".")
    },
    jl = on({
      fusedMatMul_: function (t) {
        var e, n = t.a,
          r = t.b,
          a = t.transposeA,
          i = void 0 !== a && a,
          o = t.transposeB,
          s = void 0 !== o && o,
          u = t.bias,
          l = t.activation,
          c = void 0 === l ? "linear" : l,
          p = t.preluActivationWeights;
        if (!1 === Pl(Dt.state.gradientDepth, c)) {
          var h = uu(n, r, i, s);
          return null != u && (h = ls(h, u)), Ul(h, c, p)
        }
        var f = Ke(n, "a", "fused matMul"),
          d = Ke(r, "b", "fused matMul");
        e = St(f, d), f = e[0], d = e[1];
        var m = i ? f.shape[f.rank - 2] : f.shape[f.rank - 1],
          g = s ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
          v = i ? f.shape[f.rank - 1] : f.shape[f.rank - 2],
          y = s ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
          x = f.shape.slice(0, -2),
          w = d.shape.slice(0, -2),
          C = N(x),
          k = N(w);
        b(f.rank >= 2 && d.rank >= 2 && f.rank === d.rank, function () {
          return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + f.rank + " and " + d.rank + "."
        }), b(S(x, w), function () {
          return "Error in fused matMul: outer dimensions (" + x + ") and (" + w + ") of Tensors with shapes " + f.shape + " and " + d.shape + " must match."
        }), b(m === g, function () {
          return "Error in fused matMul: inner shapes (" + m + ") and (" + g + ") of Tensors with shapes " + f.shape + " and " + d.shape + " and transposeA=" + i + " and transposeB=" + s + " must match."
        });
        var I, E, A = f.shape.slice(0, -2).concat([v, y]),
          R = i ? f.as3D(C, m, v) : f.as3D(C, v, m),
          T = s ? d.as3D(k, y, g) : d.as3D(k, g, y);
        null != u && Kr(A, (I = St(I = Ke(u, "bias", "fused matMul"), f)[0]).shape), null != p && (E = Ke(p, "prelu weights", "fused matMul"));
        var D = {
          $a: R,
          $b: T
        };
        return null != u && (D.$bias = I), null != p && (D.$preluActivationWeights = E), Dt.runKernelFunc(function (t, e) {
          var n = t.fusedBatchMatMul({
            a: R,
            b: T,
            transposeA: i,
            transposeB: s,
            bias: I,
            activation: c,
            preluActivationWeights: E
          });
          return e([R, T, n]), n
        }, D, function (t, e) {
          var n = e[0],
            r = e[1],
            a = e[2],
            o = Wl(t, a, c),
            l = {};
          return null != u && (l = {
            $bias: function () {
              return Vl(I, o)
            }
          }), i || s ? !i && s ? Object.assign({
            $a: function () {
              return o.matMul(r, !1, !1)
            },
            $b: function () {
              return o.matMul(n, !0, !1)
            }
          }, l) : i && !s ? Object.assign({
            $a: function () {
              return r.matMul(o, !1, !0)
            },
            $b: function () {
              return n.matMul(o, !1, !1)
            }
          }, l) : Object.assign({
            $a: function () {
              return r.matMul(o, !0, !0)
            },
            $b: function () {
              return o.matMul(n, !0, !0)
            }
          }, l) : Object.assign({
            $a: function () {
              return o.matMul(r, !1, !0)
            },
            $b: function () {
              return n.matMul(o, !0, !1)
            }
          }, l)
        }).reshape(A)
      }
    }),
    Gl = on({
      fusedConv2d_: function (t) {
        var e = t.x,
          n = t.filter,
          r = t.strides,
          a = t.pad,
          i = t.dataFormat,
          o = void 0 === i ? "NHWC" : i,
          s = t.dilations,
          u = void 0 === s ? [1, 1] : s,
          l = t.dimRoundingMode,
          c = t.bias,
          p = t.activation,
          h = void 0 === p ? "linear" : p,
          f = t.preluActivationWeights;
        if (h = h || "linear", !1 === Pl(Dt.state.gradientDepth, h)) {
          var d = Zs(e, n, r, a, o, u, l);
          return null != c && (d = ls(d, c)), Ul(d, h, f)
        }
        var m = Ke(e, "x", "conv2d"),
          g = Ke(n, "filter", "conv2d"),
          v = m,
          y = !1;
        3 === m.rank && (y = !0, v = m.as4D(1, m.shape[0], m.shape[1], m.shape[2])), b(4 === v.rank, function () {
          return "Error in fused conv2d: input must be rank 4, but got rank " + v.rank + "."
        }), b(4 === g.rank, function () {
          return "Error in fused conv2d: filter must be rank 4, but got rank " + g.rank + "."
        }), null != l && b(k(a), function () {
          return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + l + " but got pad " + a + "."
        }), b(v.shape[3] === g.shape[2], function () {
          return "Error in conv2d: depth of input (" + v.shape[3] + ") must match input depth for filter " + g.shape[2] + "."
        }), b(aa(r, u), function () {
          return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'"
        }), b("NHWC" === o, function () {
          return "Error in conv2d: got dataFormat of " + o + " but only NHWC is currently supported."
        });
        var x, w, C = Yr(v.shape, g.shape, r, u, a, l);
        null != c && (x = St(x = Ke(c, "bias", "fused conv2d"), m)[0], Kr(C.outShape, x.shape)), null != f && (w = Ke(f, "prelu weights", "fused conv2d"));
        var N = {
          x: v,
          filter: g
        };
        null != c && (N.bias = x), null != f && (N.preluActivationWeights = w);
        var S = [g, v],
          I = Dt.runKernelFunc(function (t, e) {
            var n = t.fusedConv2d({
              input: v,
              filter: g,
              convInfo: C,
              bias: x,
              activation: h,
              preluActivationWeights: w
            });
            return e([g, v, n]), n
          }, N, function (t, e) {
            var n = e,
              i = n[0],
              o = n[1],
              s = n[2],
              l = Wl(t, s, h);
            b(ra(u), function () {
              return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u + "'"
            });
            var p = {};
            return null != c && (p = {
              bias: function () {
                return Vl(x, l)
              }
            }), Object.assign({
              x: function () {
                return eu(o.shape, l, i, r, a)
              },
              filter: function () {
                return tu(o, l, i.shape, r, a)
              }
            }, p)
          }, "FusedConv2D", {
            convInfo: C,
            activation: h
          }, S, [!0]);
        return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I
      }
    }),
    ql = on({
      fusedDepthwiseConv2d_: function (t) {
        var e = t.x,
          n = t.filter,
          r = t.strides,
          a = t.pad,
          i = t.dataFormat,
          o = void 0 === i ? "NHWC" : i,
          s = t.dilations,
          u = void 0 === s ? [1, 1] : s,
          l = t.dimRoundingMode,
          c = t.bias,
          p = t.activation,
          h = void 0 === p ? "linear" : p,
          f = t.preluActivationWeights;
        if (!1 === Pl(Dt.state.gradientDepth, h)) {
          var d = nu(e, n, r, a, o, u, l);
          return null != c && (d = ls(d, c)), Ul(d, h, f)
        }
        var m = Ke(e, "x", "depthwiseConv2d"),
          g = Ke(n, "filter", "depthwiseConv2d"),
          v = m,
          y = !1;
        3 === m.rank && (y = !0, v = m.as4D(1, m.shape[0], m.shape[1], m.shape[2])), b(4 === v.rank, function () {
          return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + v.rank + "."
        }), b(4 === g.rank, function () {
          return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + g.rank + "."
        }), b(v.shape[3] === g.shape[2], function () {
          return "Error in fused depthwiseConv2d: number of input channels (" + v.shape[3] + ") must match the inChannels dimension in filter " + g.shape[2] + "."
        }), null == u && (u = [1, 1]), b(aa(r, u), function () {
          return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'"
        }), null != l && b(k(a), function () {
          return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + l + " but got pad " + a + "."
        });
        var x, w, C = Yr(v.shape, g.shape, r, u, a, l, !0);
        null != c && (x = St(x = Ke(c, "bias", "fused conv2d"), m)[0], Kr(C.outShape, x.shape)), null != f && (w = Ke(f, "prelu weights", "fused depthwiseConv2d"));
        var N = {
          x: v,
          filter: g
        };
        null != c && (N.bias = x), null != f && (N.preluActivationWeights = w);
        var S = [g, v],
          I = Dt.runKernelFunc(function (t, e) {
            var n = t.fusedDepthwiseConv2D({
              input: v,
              filter: g,
              convInfo: C,
              bias: x,
              activation: h,
              preluActivationWeights: w
            });
            return e([g, v, n]), n
          }, N, function (t, e) {
            b(ra(u), function () {
              return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u + "'"
            });
            var n = e[0],
              r = e[1],
              a = e[2],
              i = Wl(t, a, h),
              o = {};
            return null != c && (o = {
              bias: function () {
                return Vl(x, i)
              }
            }), Object.assign({
              x: function () {
                return ru(r.shape, i, n, C)
              },
              filter: function () {
                return au(r, i, n.shape, C)
              }
            }, o)
          }, "FusedDepthwiseConv2D", {
            convInfo: C,
            activation: h
          }, S, [!0]);
        return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I
      }
    }),
    Hl = Object.freeze({
      matMul: jl,
      conv2d: Gl,
      depthwiseConv2d: ql
    }),
    Kl = Object.freeze({
      image: Bl,
      linalg: Dl,
      losses: Il,
      spectral: il,
      fused: Hl,
      signal: ml,
      square: so,
      conv1d: Js,
      conv2d: Zs,
      conv3d: Qs,
      depthwiseConv2d: nu,
      separableConv2d: iu,
      conv2dTranspose: ou,
      conv3dTranspose: su,
      op: on,
      batchNormalization2d: $o,
      batchNormalization3d: Yo,
      batchNormalization4d: Jo,
      batchNormalization: Zo,
      batchNorm: Qo,
      batchNorm2d: ts,
      batchNorm3d: es,
      batchNorm4d: ns,
      booleanMaskAsync: Ks,
      complex: sn,
      real: un,
      imag: ln,
      concat: En,
      concat1d: An,
      concat2d: Rn,
      concat3d: Tn,
      concat4d: Dn,
      split: On,
      matMul: uu,
      dot: lu,
      outerProduct: cu,
      reverse: pu,
      reverse1d: hu,
      reverse2d: fu,
      reverse3d: du,
      reverse4d: mu,
      maxPool: yu,
      avgPool: bu,
      pool: xu,
      maxPool3d: wu,
      avgPool3d: Cu,
      slice: Nu,
      slice1d: Su,
      slice2d: ku,
      slice3d: Iu,
      slice4d: Eu,
      abs: uo,
      acos: lo,
      acosh: co,
      asin: po,
      asinh: ho,
      atan: fo,
      atanh: mo,
      ceil: go,
      clipByValue: vo,
      cos: yo,
      cosh: bo,
      erf: xo,
      exp: wo,
      expm1: Co,
      floor: No,
      log: So,
      log1p: ko,
      logSigmoid: Io,
      neg: Eo,
      reciprocal: Ao,
      round: Ro,
      rsqrt: To,
      sigmoid: Do,
      sign: Oo,
      isNaN: _o,
      isInf: Fo,
      isFinite: Mo,
      sin: zo,
      sinh: Lo,
      softplus: Bo,
      sqrt: Po,
      step: Wo,
      tan: Vo,
      tanh: Uo,
      all: Ru,
      any: Tu,
      argMax: Du,
      argMin: Ou,
      logSumExp: _u,
      max: Fu,
      mean: Mu,
      min: zu,
      moments: Lu,
      sum: Bu,
      prod: Pu,
      equal: Ds,
      equalStrict: Os,
      greater: _s,
      greaterEqual: Fs,
      greaterEqualStrict: Ms,
      greaterStrict: zs,
      less: Ls,
      lessEqual: Bs,
      lessEqualStrict: Ps,
      lessStrict: Ws,
      notEqual: Vs,
      notEqualStrict: Us,
      add: ls,
      addN: cs,
      addStrict: ps,
      atan2: hs,
      div: fs,
      divNoNan: ds,
      divStrict: ms,
      floorDiv: gs,
      maximum: vs,
      maximumStrict: ys,
      minimum: bs,
      minimumStrict: xs,
      mod: ws,
      modStrict: Cs,
      mul: Ns,
      mulStrict: Ss,
      pow: ks,
      powStrict: Is,
      squaredDifference: Es,
      squaredDifferenceStrict: As,
      sub: Rs,
      subStrict: Ts,
      elu: Wu,
      leakyRelu: Vu,
      prelu: Uu,
      relu: ju,
      relu6: Gu,
      selu: qu,
      logicalAnd: rs,
      logicalNot: as,
      logicalOr: is,
      logicalXor: os,
      where: ss,
      whereAsync: us,
      buffer: qn,
      print: Hn,
      batchToSpaceND: Kn,
      broadcastTo: Xn,
      cast: $n,
      clone: Yn,
      cumsum: Jn,
      depthToSpace: Zn,
      expandDims: Qn,
      eye: tr,
      multinomial: er,
      oneHot: nr,
      pad: rr,
      pad1d: ar,
      pad2d: ir,
      pad3d: or,
      pad4d: sr,
      rand: ur,
      randomNormal: lr,
      randomGamma: cr,
      randomUniform: pr,
      reshape: hr,
      spaceToBatchND: fr,
      squeeze: dr,
      stack: mr,
      tile: gr,
      truncatedNormal: vr,
      unstack: yr,
      setdiff1dAsync: br,
      fill: Cn,
      linspace: Nn,
      ones: xn,
      range: Sn,
      scalar: hn,
      tensor: cn,
      tensor1d: fn,
      tensor2d: dn,
      tensor3d: mn,
      tensor4d: gn,
      tensor5d: vn,
      tensor6d: yn,
      variable: bn,
      zeros: wn,
      onesLike: kn,
      zerosLike: In,
      transpose: Hu,
      softmax: Wr,
      logSoftmax: Vr,
      localResponseNormalization: Ku,
      norm: Xu,
      gather: qs,
      unsortedSegmentSum: Hs,
      basicLSTMCell: $u,
      multiRNNCell: Yu,
      movingAverage: Ju,
      stridedSlice: Zu,
      topk: Qu,
      scatterND: tl,
      fft: el,
      ifft: nl,
      rfft: rl,
      irfft: al,
      sparseToDense: ol,
      gatherND: sl,
      diag: ul,
      dropout: ll,
      hannWindow: pl,
      hammingWindow: hl,
      frame: fl,
      stft: dl,
      inTopKAsync: gl
    });

  function Xl(t, e) {
    Array.isArray(t) || (t = [t]), t.forEach(function (t) {
      null != t && b("complex64" !== t.dtype, function () {
        return e + " does not support complex64 tensors."
      })
    })
  }

  function $l(t, e, n, r) {
    if ("linear" === n) return t.linear(e);
    if ("relu" === n) return t.relu(e);
    if ("elu" === n) return t.elu(e);
    if ("relu6" === n) return t.relu6(e);
    if ("prelu" === n) return t.prelu(e, r);
    throw new Error("Activation " + n + " has not been implemented for the CPU backend.")
  }
  var Yl = function (t) {
    function e() {
      var e = t.call(this) || this;
      return e.blockSize = 48, e.firstUse = !0, e.data = new Ur(e, Dt), e
    }
    return n(e, t), e.prototype.write = function (t, e, n) {
      this.firstUse && (this.firstUse = !1, o().get("IS_NODE") && Ge("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
      var r = {};
      return this.data.set(r, {
        values: t,
        dtype: n
      }), r
    }, e.prototype.move = function (t, e, n, r) {
      this.data.set(t, {
        values: e,
        dtype: r
      })
    }, e.prototype.numDataIds = function () {
      return this.data.numDataIds()
    }, e.prototype.read = function (t) {
      return r(this, void 0, void 0, function () {
        return a(this, function (e) {
          return [2, this.readSync(t)]
        })
      })
    }, e.prototype.readSync = function (t) {
      var e = this.data.get(t),
        n = e.dtype,
        r = e.complexTensors;
      return "complex64" === n ? ca(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values
    }, e.prototype.bufferSync = function (t) {
      var e = this.readSync(t.dataId),
        n = e;
      if ("string" === t.dtype) try {
        n = e.map(function (t) {
          return et(t)
        })
      } catch (t) {
        throw new Error("Failed to decode encoded string bytes into utf-8")
      }
      return qn(t.shape, t.dtype, n)
    }, e.prototype.makeOutput = function (t, e, n) {
      var r = this.write(t, e, n);
      return Dt.makeTensorFromDataId(r, e, n, this)
    }, e.prototype.disposeData = function (t) {
      if (this.data.has(t)) {
        var e = this.data.get(t).complexTensors;
        null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t)
      }
    }, e.prototype.time = function (t) {
      return r(this, void 0, void 0, function () {
        var e;
        return a(this, function (n) {
          return e = Z(), t(), [2, {
            kernelMs: Z() - e
          }]
        })
      })
    }, e.prototype.memory = function () {
      return {
        unreliable: !0,
        reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
      }
    }, e.prototype.complex = function (t, e) {
      var n = this.makeOutput(null, t.shape, "complex64");
      return this.data.get(n.dataId).complexTensors = {
        real: Dt.keep(t.clone()),
        imag: Dt.keep(e.clone())
      }, n
    }, e.prototype.real = function (t) {
      return this.data.get(t.dataId).complexTensors.real.clone()
    }, e.prototype.imag = function (t) {
      return this.data.get(t.dataId).complexTensors.imag.clone()
    }, e.prototype.slice = function (t, e, n) {
      if (Xl(t, "slice"), Fr(t.shape, e, n)) {
        var r = Mr(e, t.strides),
          a = N(n);
        return cn(this.readSync(t.dataId).subarray(r, r + a), n, t.dtype)
      }
      for (var i = qn(n, t.dtype), o = this.bufferSync(t), s = 0; s < i.size; ++s) {
        var u = i.indexToLoc(s).map(function (t, n) {
          return t + e[n]
        });
        i.values[s] = o.get.apply(o, u)
      }
      return i.toTensor()
    }, e.prototype.stridedSlice = function (t, e, n, r) {
      Xl(t, "stridedSlice");
      var a = Dr(e, n, r);
      if (a.some(function (t) {
          return 0 === t
        })) return cn([], a);
      for (var i = qn(a, t.dtype), o = this.bufferSync(t), s = 0; s < i.size; s++) {
        for (var u = i.indexToLoc(s), l = new Array(u.length), c = 0; c < l.length; c++) l[c] = u[c] * r[c] + e[c];
        i.set.apply(i, [o.get.apply(o, l)].concat(u))
      }
      return i.toTensor()
    }, e.prototype.diag = function (t) {
      for (var e = this.readSync(t.dataId), n = qn([t.size, t.size], t.dtype), r = n.values, a = 0; a < e.length; a++) r[a * t.size + a] = e[a];
      return n.toTensor()
    }, e.prototype.unstack = function (t, e) {
      for (var n = t.shape[e], r = new Array(t.rank - 1), a = 0, i = 0; i < t.rank; i++) i !== e && (r[a++] = t.shape[i]);
      var o = new Array(t.rank).fill(0),
        s = t.shape.slice();
      s[e] = 1;
      var u = new Array(n);
      for (i = 0; i < u.length; i++) o[e] = i, u[i] = this.slice(t, o, s).reshape(r);
      return u
    }, e.prototype.reverse = function (t, e) {
      Xl(t, "reverse");
      for (var n = qn(t.shape, t.dtype), r = this.bufferSync(t), a = function (a) {
          var i = n.indexToLoc(a),
            o = i.slice();
          e.forEach(function (e) {
            return o[e] = t.shape[e] - 1 - o[e]
          }), n.set.apply(n, [r.get.apply(r, o)].concat(i))
        }, i = 0; i < n.size; i++) a(i);
      return n.toTensor()
    }, e.prototype.concat = function (t, e) {
      var n = this;
      if ("complex64" === t[0].dtype) {
        var r = t.map(function (t) {
            return un(t)
          }),
          a = t.map(function (t) {
            return ln(t)
          });
        return sn(this.concat(r, e), this.concat(a, e))
      }
      var i = t.map(function (t) {
          var n = N(t.shape.slice(e));
          return t.as2D(-1, n)
        }),
        o = an(i.map(function (t) {
          return t.shape
        }), 1),
        s = qn(o, t[0].dtype).values;
      if (1 === i[0].shape[0]) {
        var u = 0;
        i.forEach(function (t) {
          s.set(n.readSync(t.dataId), u), u += t.size
        })
      } else {
        var l = 0;
        i.forEach(function (t) {
          for (var e = n.readSync(t.dataId), r = 0, a = 0; a < t.shape[0]; ++a)
            for (var i = a * o[1] + l, u = 0; u < t.shape[1]; ++u) s[i + u] = e[r++];
          l += t.shape[1]
        })
      }
      var c = an(t.map(function (t) {
        return t.shape
      }), e);
      return cn(s, c, t[0].dtype)
    }, e.prototype.neg = function (t) {
      return Xl(t, "neg"), this.multiply(hn(-1), t)
    }, e.prototype.add = function (t, e) {
      return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
        return {
          real: t + n,
          imag: e + r
        }
      }) : this.broadcastedBinaryOp(t, e, Ct(t.dtype, e.dtype), function (t, e) {
        return t + e
      })
    }, e.prototype.addN = function (t) {
      var e = this;
      Xl(t, "addN");
      for (var n = t.map(function (t) {
          return e.readSync(t.dataId)
        }), r = qn(t[0].shape, t[0].dtype), a = r.values, i = 0; i < t.length; i++)
        for (var o = n[i], s = 0; s < a.length; s++) a[s] += o[s];
      return r.toTensor()
    }, e.prototype.subtract = function (t, e) {
      return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
        return {
          real: t - n,
          imag: e - r
        }
      }) : this.broadcastedBinaryOp(t, e, Ct(t.dtype, e.dtype), function (t, e) {
        return t - e
      })
    }, e.prototype.pow = function (t, e) {
      return Xl([t, e], "pow"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
        return Math.pow(t, e)
      })
    }, e.prototype.batchMatMul = function (t, e, n, r) {
      Xl([t, e], "matMul");
      for (var a = n ? t.shape[1] : t.shape[2], i = n ? t.shape[2] : t.shape[1], o = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = this.readSync(t.dataId), l = this.readSync(e.dataId), c = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], p = c[0], h = c[1], f = c[2], d = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]], m = d[0], g = d[1], v = d[2], y = i * o, b = qn([s, i, o], t.dtype), x = b.values, w = this.blockSize, C = 0; C < s; C++)
        for (var N = 0; N < i; N += w)
          for (var S = 0; S < o; S += w)
            for (var k = 0; k < a; k += w)
              for (var I = Math.min(N + w, i), E = Math.min(S + w, o), A = Math.min(k + w, a), R = N; R < I; R++)
                for (var T = S; T < E; T++) {
                  for (var D = 0, O = k; O < A; O++) D += u[C * p + R * h + O * f] * l[O * m + T * g + C * v];
                  x[C * y + (R * o + T)] += D
                }
      return b.toTensor()
    }, e.prototype.fusedBatchMatMul = function (t) {
      var e = t.a,
        n = t.b,
        r = t.transposeA,
        a = t.transposeB,
        i = t.bias,
        o = t.activation,
        s = t.preluActivationWeights,
        u = this.batchMatMul(e, n, r, a);
      return i && (u = this.add(u, i)), o && (u = $l(this, u, o, s)), u
    }, e.prototype.multiply = function (t, e) {
      return "complex64" === t.dtype || "complex64" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast("complex64"), e.cast("complex64"), function (t, e, n, r) {
        return {
          real: t * n - e * r,
          imag: t * r + e * n
        }
      }) : this.broadcastedBinaryOp(t, e, Ct(t.dtype, e.dtype), function (t, e) {
        return t * e
      })
    }, e.prototype.realDivide = function (t, e) {
      return Xl([t, e], "realDivide"), this.broadcastedBinaryOp(t, e, "float32", function (t, e) {
        return t / e
      })
    }, e.prototype.floorDiv = function (t, e) {
      return Xl([t, e], "floorDiv"), this.broadcastedBinaryOp(t, e, "int32", function (t, e) {
        return Math.floor(t / e)
      })
    }, e.prototype.sum = function (t, e) {
      Xl(t, "sum"), Qe("sum", e, t.rank);
      for (var n = Je(t.shape, e), r = n[0], a = n[1], i = wn(r, Ct(t.dtype, "int32")), o = N(a), s = this.readSync(i.dataId), u = this.readSync(t.dataId), l = 0; l < s.length; ++l) {
        for (var c = l * o, p = 0, h = 0; h < o; ++h) p += u[c + h];
        s[l] = p
      }
      return i
    }, e.prototype.prod = function (t, e) {
      Xl(t, "sum");
      for (var n = Je(t.shape, e), r = n[0], a = n[1], i = wn(r, Ct(t.dtype, "int32")), o = N(a), s = this.readSync(i.dataId), u = this.readSync(t.dataId), l = 0; l < s.length; ++l) {
        for (var c = l * o, p = 1, h = 0; h < o; ++h) p *= u[c + h];
        s[l] = p
      }
      return i
    }, e.prototype.unsortedSegmentSum = function (t, e, n) {
      Xl(t, "unsortedSegmentSum");
      for (var r = [], a = t.rank - e.rank, i = 0; i < a; ++i) e = e.expandDims(i + 1);
      for (i = 0; i < n; ++i) {
        var o = hn(i, "int32"),
          s = Ds(o, e).asType("float32").mul(t).sum(0);
        r.push(s)
      }
      return mr(r)
    }, e.prototype.argMin = function (t, e) {
      Xl(t, "argMin");
      var n = [e];
      Qe("argMin", n, t.rank);
      for (var r = Je(t.shape, n), a = r[0], i = r[1], o = wn(a, "int32"), s = N(i), u = this.readSync(o.dataId), l = this.readSync(t.dataId), c = 0; c < u.length; ++c) {
        for (var p = c * s, h = l[p], f = 0, d = 0; d < s; ++d) {
          var m = l[p + d];
          m < h && (h = m, f = d)
        }
        u[c] = f
      }
      return o
    }, e.prototype.argMax = function (t, e) {
      Xl(t, "argMax");
      var n = [e];
      Qe("argMax", n, t.rank);
      for (var r = Je(t.shape, n), a = r[0], i = r[1], o = wn(a, "int32"), s = N(i), u = this.readSync(o.dataId), l = this.readSync(t.dataId), c = 0; c < u.length; ++c) {
        for (var p = c * s, h = l[p], f = 0, d = 0; d < s; ++d) {
          var m = l[p + d];
          m > h && (h = m, f = d)
        }
        u[c] = f
      }
      return o
    }, e.prototype.cumsum = function (t, e, n, r) {
      if (Xl(t, "cumsum"), e !== t.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + e);
      for (var a = Ct(t.dtype, "int32"), i = wn(t.shape, a), o = this.readSync(i.dataId), s = this.readSync(t.dataId), u = t.shape[t.rank - 1], l = r ? function (t, e) {
          return t + u - e - 1
        } : function (t, e) {
          return t + e
        }, c = 0; c < s.length; c += u)
        for (var p = 0; p < u; p++) {
          var h = l(c, p);
          if (0 === p) o[h] = n ? 0 : s[h];
          else {
            var f = l(c, p - 1);
            o[h] = n ? s[f] + o[f] : s[h] + o[f]
          }
        }
      return i
    }, e.prototype.equal = function (t, e) {
      return Xl([t, e], "equal"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
        return t === e ? 1 : 0
      })
    }, e.prototype.notEqual = function (t, e) {
      return Xl([t, e], "notEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
        return t !== e ? 1 : 0
      })
    }, e.prototype.less = function (t, e) {
      return Xl([t, e], "less"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
        return t < e ? 1 : 0
      })
    }, e.prototype.lessEqual = function (t, e) {
      return Xl([t, e], "lessEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
        return t <= e ? 1 : 0
      })
    }, e.prototype.greater = function (t, e) {
      return Xl([t, e], "greater"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
        return t > e ? 1 : 0
      })
    }, e.prototype.greaterEqual = function (t, e) {
      return Xl([t, e], "greaterEqual"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
        return t >= e ? 1 : 0
      })
    }, e.prototype.logicalNot = function (t) {
      Xl(t, "logicalNot");
      for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r] ? 0 : 1;
      return this.makeOutput(n, t.shape, "bool")
    }, e.prototype.logicalAnd = function (t, e) {
      return Xl([t, e], "logicalAnd"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
        return t && e
      })
    }, e.prototype.logicalOr = function (t, e) {
      return Xl([t, e], "logicalOr"), this.broadcastedBinaryOp(t, e, "bool", function (t, e) {
        return t || e
      })
    }, e.prototype.select = function (t, e, n) {
      Xl([t, e, n], "select");
      for (var r = this.readSync(t.dataId), a = this.readSync(e.dataId), i = this.readSync(n.dataId), o = wn(e.shape, Ct(e.dtype, n.dtype)), s = this.readSync(o.dataId), u = 0, l = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : N(e.shape.slice(1)), c = 0; c < r.length; c++)
        for (var p = 0; p < l; p++) 1 === r[c] ? s[u++] = a[c] : s[u++] = i[c];
      return o
    }, e.prototype.where = function (t) {
      Xl([t], "where");
      var e = this.readSync(t.dataId);
      return ka(t.shape, e)
    }, e.prototype.topk = function (t, e, n) {
      return Xl(t, "topk"), Sa(this.readSync(t.dataId), t.shape, t.dtype, e)
    }, e.prototype.min = function (t, e) {
      Xl(t, "min"), Qe("min", e, t.rank);
      for (var n = Je(t.shape, e), r = n[0], a = n[1], i = wn(r, t.dtype), o = N(a), s = this.readSync(i.dataId), u = this.readSync(t.dataId), l = 0; l < s.length; ++l) {
        for (var c = l * o, p = u[c], h = 0; h < o; ++h) {
          var f = u[c + h];
          f < p && (p = f)
        }
        s[l] = p
      }
      return i
    }, e.prototype.minimum = function (t, e) {
      return Xl([t, e], "minimum"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
        return Math.min(t, e)
      })
    }, e.prototype.mod = function (t, e) {
      return Xl([t, e], "mod"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
        var n = t % e;
        return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e
      })
    }, e.prototype.max = function (t, e) {
      Xl(t, "max"), Qe("max", e, t.rank);
      for (var n = Je(t.shape, e), r = n[0], a = n[1], i = wn(r, t.dtype), o = N(a), s = this.readSync(i.dataId), u = this.readSync(t.dataId), l = 0; l < s.length; ++l) {
        for (var c = l * o, p = u[c], h = 0; h < o; ++h) {
          var f = u[c + h];
          f > p && (p = f)
        }
        s[l] = p
      }
      return i
    }, e.prototype.maximum = function (t, e) {
      return Xl([t, e], "maximum"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
        return Math.max(t, e)
      })
    }, e.prototype.all = function (t, e) {
      Xl(t, "all"), Qe("all", e, t.rank);
      for (var n = Je(t.shape, e), r = n[0], a = n[1], i = wn(r, t.dtype), o = N(a), s = this.readSync(i.dataId), u = this.readSync(t.dataId), l = 0; l < s.length; ++l) {
        for (var c = l * o, p = u[c], h = 0; h < o; ++h) {
          var f = u[c + h];
          p = p && f
        }
        s[l] = p
      }
      return i
    }, e.prototype.any = function (t, e) {
      Xl(t, "any"), Qe("any", e, t.rank);
      for (var n = Je(t.shape, e), r = n[0], a = n[1], i = wn(r, t.dtype), o = N(a), s = this.readSync(i.dataId), u = this.readSync(t.dataId), l = 0; l < s.length; ++l) {
        for (var c = l * o, p = u[c], h = 0; h < o; ++h) {
          var f = u[c + h];
          p = p || f
        }
        s[l] = p
      }
      return i
    }, e.prototype.squaredDifference = function (t, e) {
      return Xl([t, e], "squaredDifference"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
        var n = t - e;
        return n * n
      })
    }, e.prototype.ceil = function (t) {
      Xl(t, "ceil");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.ceil(e[r]);
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.floor = function (t) {
      Xl(t, "floor");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.floor(e[r]);
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.sign = function (t) {
      Xl(t, "x");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.isNaN = function (t) {
      Xl(t, "x");
      for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isNaN(e[r]) && (n[r] = 1);
      return this.makeOutput(n, t.shape, "bool")
    }, e.prototype.isInf = function (t) {
      Xl(t, "x");
      for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Math.abs(e[r]) === 1 / 0 && (n[r] = 1);
      return this.makeOutput(n, t.shape, "bool")
    }, e.prototype.isFinite = function (t) {
      Xl(t, "x");
      for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isFinite(e[r]) && (n[r] = 1);
      return this.makeOutput(n, t.shape, "bool")
    }, e.prototype.round = function (t) {
      Xl(t, "round");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var a = Math.floor(e[r]);
        e[r] - a < .5 ? n[r] = Math.floor(e[r]) : e[r] - a > .5 ? n[r] = Math.ceil(e[r]) : n[r] = a % 2 == 0 ? a : a + 1
      }
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.exp = function (t) {
      Xl(t, "exp");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.exp(e[r]);
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.expm1 = function (t) {
      Xl(t, "expm1");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.expm1(e[r]);
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.log = function (t) {
      Xl(t, "log");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var a = e[r];
        n[r] = Math.log(a)
      }
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.log1p = function (t) {
      Xl(t, "log1p");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var a = e[r];
        n[r] = Math.log1p(a)
      }
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.sqrt = function (t) {
      Xl(t, "sqrt");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var a = e[r];
        n[r] = Math.sqrt(a)
      }
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.rsqrt = function (t) {
      Xl(t, "rsqrt");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {
        var a = e[r];
        n[r] = 1 / Math.sqrt(a)
      }
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.reciprocal = function (t) {
      Xl(t, "reciprocal");
      for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = 1 / e[r];
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.linear = function (t) {
      return t
    }, e.prototype.relu = function (t) {
      Xl(t, "relu");
      for (var e = wn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), a = 0; a < r.length; ++a) n[a] = Math.max(0, r[a]);
      return e
    }, e.prototype.relu6 = function (t) {
      Xl(t, "relu");
      for (var e = wn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), a = 0; a < r.length; ++a) n[a] = Math.min(Math.max(0, r[a]), 6);
      return e
    }, e.prototype.prelu = function (t, e) {
      return Xl([t, e], "prelu"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
        return t < 0 ? e * t : t
      })
    }, e.prototype.elu = function (t) {
      Xl(t, "elu");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
        var a = n[r];
        e[r] = a >= 0 ? a : Math.exp(a) - 1
      }
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.eluDer = function (t, e) {
      Xl([t, e], "eluDer");
      for (var n = new Float32Array(e.size), r = this.readSync(e.dataId), a = this.readSync(t.dataId), i = 0; i < r.length; ++i) {
        var o = r[i];
        n[i] = o >= 1 ? a[i] : a[i] * (o + 1)
      }
      return this.makeOutput(n, e.shape, "float32")
    }, e.prototype.selu = function (t) {
      Xl(t, "selu");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
        var a = n[r];
        e[r] = a >= 0 ? 1.0507009873554805 * a : 1.7580993408473768 * (Math.exp(a) - 1)
      }
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.clip = function (t, e, n) {
      Xl(t, "clip");
      for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), i = 0; i < a.length; ++i) {
        var o = a[i];
        r[i] = o > n ? n : o < e ? e : o
      }
      return this.makeOutput(r, t.shape, "float32")
    }, e.prototype.abs = function (t) {
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.abs(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.complexAbs = function (t) {
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r) {
        var a = n[2 * r],
          i = n[2 * r + 1];
        e[r] = Math.hypot(a, i)
      }
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.int = function (t) {
      Xl(t, "int");
      for (var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = n[r];
      return this.makeOutput(e, t.shape, "int32")
    }, e.prototype.sigmoid = function (t) {
      Xl(t, "sigmoid");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = 1 / (1 + Math.exp(-n[r]));
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.softplus = function (t) {
      Xl(t, "softplus");
      for (var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), a = 0; a < r.length; ++a) {
        var i, o = r[a] > -e,
          s = r[a] < e,
          u = Math.exp(r[a]);
        i = s ? u : o ? r[a] : Math.log(1 + u), n[a] = i
      }
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.sin = function (t) {
      Xl(t, "sin");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sin(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.cos = function (t) {
      Xl(t, "cos");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cos(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.tan = function (t) {
      Xl(t, "tan");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.tan(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.asin = function (t) {
      Xl(t, "asin");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asin(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.acos = function (t) {
      Xl(t, "acos");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acos(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.atan = function (t) {
      Xl(t, "atan");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atan(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.atan2 = function (t, e) {
      return Xl([t, e], "atan2"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {
        return Math.atan2(t, e)
      })
    }, e.prototype.sinh = function (t) {
      Xl(t, "sinh");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sinh(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.cosh = function (t) {
      Xl(t, "cosh");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cosh(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.tanh = function (t) {
      Xl(t, "tanh");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = I(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.asinh = function (t) {
      Xl(t, "asinh");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asinh(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.acosh = function (t) {
      Xl(t, "acosh");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acosh(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.atanh = function (t) {
      Xl(t, "atanh");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atanh(n[r]);
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.erf = function (t) {
      Xl(t, "erf");
      for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {
        var a = Math.sign(n[r]),
          i = Math.abs(n[r]),
          o = 1 / (1 + .3275911 * i);
        e[r] = a * (1 - ((((1.061405429 * o - 1.453152027) * o + 1.421413741) * o - .284496736) * o + .254829592) * o * Math.exp(-i * i))
      }
      return this.makeOutput(e, t.shape, "float32")
    }, e.prototype.step = function (t, e) {
      void 0 === e && (e = 0), Xl(t, "step");
      for (var n = new Float32Array(t.size), r = this.readSync(t.dataId), a = 0; a < r.length; ++a) {
        var i = r[a];
        isNaN(i) ? n[a] = NaN : n[a] = i > 0 ? 1 : e
      }
      return this.makeOutput(n, t.shape, "float32")
    }, e.prototype.fusedConv2d = function (t) {
      var e = t.input,
        n = t.filter,
        r = t.convInfo,
        a = t.bias,
        i = t.activation,
        o = t.preluActivationWeights,
        s = this.conv2d(e, n, r);
      return a && (s = this.add(s, a)), i && (s = $l(this, s, i, o)), s
    }, e.prototype.conv2d = function (t, e, n) {
      Xl([t, e], "conv2d");
      for (var r = n.filterHeight, a = n.filterWidth, i = n.dilationHeight, o = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, l = "channelsLast" === n.dataFormat, c = qn(n.outShape, t.dtype), p = t.strides[0], h = l ? t.strides[1] : t.strides[2], f = l ? t.strides[2] : 1, d = l ? 1 : t.strides[1], m = c.strides[0], g = l ? c.strides[1] : c.strides[2], v = l ? c.strides[2] : 1, y = l ? 1 : c.strides[1], b = this.readSync(t.dataId), x = this.readSync(e.dataId), w = c.values, C = 0; C < n.batchSize; ++C)
        for (var N = C * p, S = C * m, k = 0; k < n.outHeight; ++k)
          for (var I = S + k * g, E = k * n.strideHeight - u, A = 0; A < r; A++) {
            var R = E + A * i;
            if (!(R < 0 || R >= n.inHeight))
              for (var T = A * e.strides[0], D = N + R * h, O = 0; O < n.outWidth; ++O)
                for (var _ = I + O * v, F = O * n.strideWidth - s, M = 0; M < a; M++) {
                  var z = F + M * o;
                  if (!(z < 0 || z >= n.inWidth))
                    for (var L = D + z * f, B = T + M * e.strides[1], P = 0; P < n.inChannels; ++P) {
                      for (var W = b[L + P * d], V = 0; V < n.outChannels; ++V) w[_ + V * y] += W * x[B + V];
                      B += n.outChannels
                    }
                }
          }
      return c.toTensor()
    }, e.prototype.conv3d = function (t, e, n) {
      for (var r = n.filterDepth, a = n.filterHeight, i = n.filterWidth, o = n.dilationDepth, s = n.dilationHeight, u = n.dilationWidth, l = n.padInfo.front, c = n.padInfo.left, p = n.padInfo.top, h = qn(n.outShape, t.dtype), f = this.readSync(t.dataId), d = this.readSync(e.dataId), m = h.values, g = 0; g < n.batchSize; ++g)
        for (var v = g * t.strides[0], y = g * h.strides[0], b = 0; b < n.outDepth; ++b)
          for (var x = y + b * h.strides[1], w = b * n.strideDepth - l, C = 0; C < r; C++) {
            var N = w + C * o;
            if (!(N < 0 || N >= n.inDepth))
              for (var S = C * e.strides[0], k = v + N * t.strides[1], I = 0; I < n.outHeight; ++I)
                for (var E = x + I * h.strides[2], A = I * n.strideHeight - p, R = 0; R < a; R++) {
                  var T = A + R * s;
                  if (!(T < 0 || T >= n.inHeight))
                    for (var D = S + R * e.strides[1], O = k + T * t.strides[2], _ = 0; _ < n.outWidth; ++_)
                      for (var F = E + _ * n.outChannels, M = _ * n.strideWidth - c, z = 0; z < i; z++) {
                        var L = M + z * u;
                        if (!(L < 0 || L >= n.inWidth))
                          for (var B = D + z * e.strides[2], P = O + L * n.inChannels, W = B, V = 0; V < n.inChannels; ++V) {
                            for (var U = f[P + V], j = 0; j < n.outChannels; ++j) m[F + j] += U * d[W + j];
                            W += n.outChannels
                          }
                      }
                }
          }
      return h.toTensor()
    }, e.prototype.conv2dDerInput = function (t, e, n) {
      Xl([t, e], "conv2dDerInput");
      for (var r = qn(n.inShape, "float32"), a = r.values, i = this.readSync(t.dataId), o = this.readSync(e.dataId), s = e.strides, u = s[0], l = s[1], c = s[2], p = n.batchSize, h = n.filterHeight, f = n.filterWidth, d = n.inChannels, m = n.inHeight, g = n.inWidth, v = n.outChannels, y = n.outHeight, b = n.outWidth, x = n.strideHeight, w = n.strideWidth, C = n.dataFormat, N = h - 1 - n.padInfo.top, S = f - 1 - n.padInfo.left, k = "channelsLast" === C, I = r.strides[0], E = k ? r.strides[1] : r.strides[2], A = k ? r.strides[2] : 1, R = k ? 1 : r.strides[1], T = t.strides[0], D = k ? t.strides[1] : t.strides[2], O = k ? t.strides[2] : 1, _ = k ? 1 : t.strides[1], F = 0; F < p; ++F)
        for (var M = 0; M < d; ++M)
          for (var z = 0; z < m; ++z)
            for (var L = z - N, B = Math.max(0, Math.ceil(L / x)), P = Math.min(y, (h + L) / x), W = 0; W < g; ++W) {
              for (var V = W - S, U = Math.max(0, Math.ceil(V / w)), j = Math.min(b, (f + V) / w), G = 0, q = B; q < P; ++q)
                for (var H = q * x - L, K = U; K < j; ++K)
                  for (var X = T * F + D * q + O * K, $ = u * (h - 1 - H) + l * (f - 1 - (K * w - V)) + c * M, Y = 0; Y < v; ++Y) G += i[X + _ * Y] * o[$ + Y];
              a[I * F + E * z + A * W + R * M] = G
            }
      return r.toTensor()
    }, e.prototype.conv3dDerInput = function (t, e, n) {
      for (var r = qn(n.inShape, "float32"), a = r.values, i = r.strides, o = i[0], s = i[1], u = i[2], l = i[3], c = this.readSync(t.dataId), p = t.strides, h = p[0], f = p[1], d = p[2], m = p[3], g = this.readSync(e.dataId), v = e.strides, y = v[0], b = v[1], x = v[2], w = v[3], C = n.batchSize, N = n.filterDepth, S = n.filterHeight, k = n.filterWidth, I = n.inChannels, E = n.inDepth, A = n.inHeight, R = n.inWidth, T = n.outChannels, D = n.outDepth, O = n.outHeight, _ = n.outWidth, F = n.strideDepth, M = n.strideHeight, z = n.strideWidth, L = N - 1 - n.padInfo.front, B = S - 1 - n.padInfo.top, P = k - 1 - n.padInfo.left, W = 0; W < C; ++W)
        for (var V = 0; V < I; ++V)
          for (var U = 0; U < E; ++U)
            for (var j = U - L, G = Math.max(0, Math.ceil(j / F)), q = Math.min(D, (N + j) / F), H = 0; H < A; ++H)
              for (var K = H - B, X = Math.max(0, Math.ceil(K / M)), $ = Math.min(O, (S + K) / M), Y = 0; Y < R; ++Y) {
                for (var J = Y - P, Z = Math.max(0, Math.ceil(J / z)), Q = Math.min(_, (k + J) / z), tt = 0, et = G; et < q; ++et)
                  for (var nt = et * F - j, rt = X; rt < $; ++rt)
                    for (var at = rt * M - K, it = Z; it < Q; ++it)
                      for (var ot = h * W + f * et + d * rt + m * it, st = y * (N - 1 - nt) + b * (S - 1 - at) + x * (k - 1 - (it * z - J)) + w * V, ut = 0; ut < T; ++ut) tt += c[ot + ut] * g[st + ut];
                a[o * W + s * U + u * H + l * Y + V] = tt
              }
      return r.toTensor()
    }, e.prototype.conv2dDerFilter = function (t, e, n) {
      Xl([t, e], "conv2dDerFilter");
      for (var r = n.strideHeight, a = n.strideWidth, i = n.filterHeight, o = n.filterWidth, s = "channelsLast" === n.dataFormat, u = qn(n.filterShape, "float32"), l = n.padInfo.left, c = n.padInfo.top, p = this.bufferSync(t), h = this.bufferSync(e), f = 0; f < i; ++f)
        for (var d = Math.max(0, Math.ceil((c - f) / r)), m = Math.min(n.outHeight, (n.inHeight + c - f) / r), g = 0; g < o; ++g)
          for (var v = Math.max(0, Math.ceil((l - g) / a)), y = Math.min(n.outWidth, (n.inWidth + l - g) / a), b = 0; b < n.inChannels; ++b)
            for (var x = 0; x < n.outChannels; ++x) {
              for (var w = 0, C = 0; C < n.batchSize; ++C)
                for (var N = d; N < m; ++N)
                  for (var S = f + N * r - c, k = v; k < y; ++k) {
                    var I = g + k * a - l;
                    w += s ? p.get(C, S, I, b) * h.get(C, N, k, x) : p.get(C, b, S, I) * h.get(C, x, N, k)
                  }
              u.set(w, f, g, b, x)
            }
      return u.toTensor()
    }, e.prototype.conv3dDerFilter = function (t, e, n) {
      for (var r = n.strideDepth, a = n.strideHeight, i = n.strideWidth, o = n.filterDepth, s = n.filterHeight, u = n.filterWidth, l = qn(n.filterShape, "float32"), c = l.values, p = l.strides, h = p[0], f = p[1], d = p[2], m = p[3], g = this.readSync(e.dataId), v = e.strides, y = v[0], b = v[1], x = v[2], w = v[3], C = this.readSync(t.dataId), N = t.strides, S = N[0], k = N[1], I = N[2], E = N[3], A = n.padInfo.front, R = n.padInfo.left, T = n.padInfo.top, D = 0; D < o; ++D)
        for (var O = Math.max(0, Math.ceil((A - D) / r)), _ = Math.min(n.outDepth, (n.inDepth + A - D) / r), F = D * h, M = 0; M < s; ++M)
          for (var z = Math.max(0, Math.ceil((T - M) / a)), L = Math.min(n.outHeight, (n.inHeight + T - M) / a), B = M * f + F, P = 0; P < u; ++P)
            for (var W = Math.max(0, Math.ceil((R - P) / i)), V = Math.min(n.outWidth, (n.inWidth + R - P) / i), U = P * d + B, j = 0; j < n.inChannels; ++j)
              for (var G = j * m + U, q = 0; q < n.outChannels; ++q) {
                for (var H = 0, K = 0; K < n.batchSize; ++K)
                  for (var X = K * S, $ = K * y, Y = O; Y < _; ++Y)
                    for (var J = (D + Y * r - A) * k + X, Z = Y * b + $, Q = z; Q < L; ++Q)
                      for (var tt = (M + Q * a - T) * I + J, et = Q * x + Z, nt = W; nt < V; ++nt) {
                        var rt = nt * w + et;
                        H += C[(P + nt * i - R) * E + tt + j] * g[rt + q]
                      }
                c[G + q] = H
              }
      return l.toTensor()
    }, e.prototype.fusedDepthwiseConv2D = function (t) {
      var e = t.input,
        n = t.filter,
        r = t.convInfo,
        a = t.bias,
        i = t.activation,
        o = t.preluActivationWeights,
        s = this.depthwiseConv2D(e, n, r);
      return a && (s = this.add(s, a)), i && (s = $l(this, s, i, o)), s
    }, e.prototype.depthwiseConv2D = function (t, e, n) {
      Xl([t, e], "depthwiseConv2D");
      for (var r = n.filterHeight, a = n.filterWidth, i = n.dilationHeight, o = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, l = n.outChannels / n.inChannels, c = qn(n.outShape, t.dtype), p = this.readSync(t.dataId), h = this.readSync(e.dataId), f = c.values, d = 0; d < n.batchSize; ++d)
        for (var m = d * t.strides[0], g = d * c.strides[0], v = 0; v < n.outHeight; ++v)
          for (var y = g + v * c.strides[1], b = v * n.strideHeight - s, x = 0; x < r; ++x) {
            var w = b + x * i;
            if (!(w < 0 || w >= n.inHeight))
              for (var C = x * e.strides[0], N = m + w * t.strides[1], S = 0; S < n.outWidth; ++S)
                for (var k = y + S * c.strides[2], I = S * n.strideWidth - u, E = 0; E < a; ++E) {
                  var A = I + E * o;
                  if (!(A < 0 || A >= n.inWidth))
                    for (var R = C + E * e.strides[1], T = N + A * n.inChannels, D = k, O = R, _ = 0; _ < n.inChannels; ++_) {
                      for (var F = p[T + _], M = 0; M < l; ++M) f[D + M] += F * h[O + M];
                      D += l, O += l
                    }
                }
          }
      return c.toTensor()
    }, e.prototype.depthwiseConv2DDerInput = function (t, e, n) {
      Xl([t, e], "depthwiseConv2DDerInput");
      for (var r = qn(n.inShape, "float32"), a = r.values, i = r.strides, o = i[0], s = i[1], u = i[2], l = this.readSync(t.dataId), c = t.strides, p = c[0], h = c[1], f = c[2], d = this.readSync(e.dataId), m = e.strides, g = m[0], v = m[1], y = m[2], b = n.batchSize, x = n.filterHeight, w = n.filterWidth, C = n.inChannels, N = n.inHeight, S = n.inWidth, k = n.outChannels, I = n.outHeight, E = n.outWidth, A = n.strideHeight, R = n.strideWidth, T = x - 1 - n.padInfo.top, D = w - 1 - n.padInfo.left, O = k / C, _ = 0; _ < b; ++_)
        for (var F = 0; F < C; ++F)
          for (var M = 0; M < N; ++M)
            for (var z = M - T, L = Math.max(0, Math.ceil(z / A)), B = Math.min(I, (x + z) / A), P = 0; P < S; ++P) {
              for (var W = P - D, V = Math.max(0, Math.ceil(W / R)), U = Math.min(E, (w + W) / R), j = 0, G = L; G < B; ++G)
                for (var q = G * A - z, H = V; H < U; ++H)
                  for (var K = p * _ + h * G + f * H, X = g * (x - 1 - q) + v * (w - 1 - (H * R - W)) + y * F, $ = 0; $ < O; ++$) j += l[K + (F * O + $)] * d[X + $];
              a[o * _ + s * M + u * P + F] = j
            }
      return r.toTensor()
    }, e.prototype.depthwiseConv2DDerFilter = function (t, e, n) {
      Xl([t, e], "depthwiseConv2DDerFilter");
      for (var r = n.strideHeight, a = n.strideWidth, i = n.filterHeight, o = n.filterWidth, s = qn(n.filterShape, "float32"), u = n.padInfo.left, l = n.padInfo.top, c = n.outChannels / n.inChannels, p = this.bufferSync(t), h = this.bufferSync(e), f = 0; f < i; ++f)
        for (var d = Math.max(0, Math.ceil((l - f) / r)), m = Math.min(n.outHeight, (n.inHeight + l - f) / r), g = 0; g < o; ++g)
          for (var v = Math.max(0, Math.ceil((u - g) / a)), y = Math.min(n.outWidth, (n.inWidth + u - g) / a), b = 0; b < n.outChannels; ++b) {
            for (var x = Math.trunc(b / c), w = b % c, C = 0, N = 0; N < n.batchSize; ++N)
              for (var S = d; S < m; ++S)
                for (var k = f + S * r - l, I = v; I < y; ++I) {
                  var E = g + I * a - u;
                  C += p.get(N, k, E, x) * h.get(N, S, I, b)
                }
            s.set(C, f, g, x, w)
          }
      return s.toTensor()
    }, e.prototype.tile = function (t, e) {
      return Xl(t, "tile"), Na(this.bufferSync(t), e)
    }, e.prototype.pad = function (t, e, n) {
      Xl(t, "pad");
      var r = e.map(function (e, n) {
          return e[0] + t.shape[n] + e[1]
        }),
        a = e.map(function (t) {
          return t[0]
        }),
        i = this.bufferSync(t),
        o = qn(r, t.dtype);
      0 !== n && o.values.fill(n);
      for (var s = 0; s < t.size; s++) {
        var u = i.indexToLoc(s),
          l = u.map(function (t, e) {
            return t + a[e]
          });
        o.set.apply(o, [i.get.apply(i, u)].concat(l))
      }
      return o.toTensor()
    }, e.prototype.transpose = function (t, e) {
      Xl(t, "transpose");
      for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[e[r]];
      var a = this.readSync(t.dataId),
        i = qn(n, t.dtype),
        o = this.bufferSync(t);
      for (r = 0; r < t.size; ++r) {
        for (var s = o.indexToLoc(r), u = new Array(s.length), l = 0; l < u.length; l++) u[l] = s[e[l]];
        var c = i.locToIndex(u);
        i.values[c] = a[r]
      }
      return i.toTensor()
    }, e.prototype.gather = function (t, e, n) {
      Xl([t, e], "gather");
      var r = t.shape.slice(),
        a = this.readSync(e.dataId);
      r[n] = a.length;
      for (var i = qn(r, t.dtype), o = this.bufferSync(t), s = 0; s < i.size; ++s) {
        var u = i.indexToLoc(s),
          l = u.slice();
        l[n] = a[u[n]];
        var c = o.locToIndex(l);
        i.values[s] = o.values[c]
      }
      return i.toTensor()
    }, e.prototype.batchToSpaceND = function (t, e, n) {
      Xl([t], "batchToSpaceND");
      var r = e.reduce(function (t, e) {
          return t * e
        }),
        a = xr(t.shape, e, r),
        i = wr(a.length, e.length),
        o = Cr(t.shape, e, r),
        s = Nr(n, e.length),
        u = Sr(o, n, e.length);
      return t.reshape(a).transpose(i).reshape(o).slice(s, u)
    }, e.prototype.spaceToBatchND = function (t, e, n) {
      Xl([t], "spaceToBatchND");
      var r = e.reduce(function (t, e) {
          return t * e
        }),
        a = [
          [0, 0]
        ];
      a.push.apply(a, n);
      for (var i = 1 + e.length; i < t.shape.length; ++i) a.push([0, 0]);
      var o = t.pad(a),
        s = xr(o.shape, e, r, !1),
        u = wr(s.length, e.length, !1),
        l = Cr(o.shape, e, r, !1);
      return o.reshape(s).transpose(u).reshape(l)
    }, e.prototype.pool = function (t, e, n) {
      Xl(t, "pool");
      for (var r = e.strideHeight, a = e.strideWidth, i = e.dilationHeight, o = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, l = e.padInfo.top, c = e.padInfo.left, p = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, h = this.readSync(t.dataId), f = qn(e.outShape, t.dtype), d = f.values, m = e.outShape[1] * e.outShape[2] * e.outShape[3], g = e.outShape[2] * e.outShape[3], v = e.outShape[3], y = 0; y < e.batchSize; ++y)
        for (var b = y * m, x = y * t.strides[0], w = 0; w < e.inChannels; ++w)
          for (var C = 0; C < e.outHeight; ++C)
            for (var N = C * r - l, S = Math.max(0, N), k = Math.min(e.inHeight, s + N), I = b + C * g, E = 0; E < e.outWidth; ++E) {
              for (var A = E * a - c, R = Math.max(0, A), T = Math.min(e.inWidth, u + A), D = p, O = 0, _ = 0, F = S; F < k; F += i) {
                for (var M = x + F * t.strides[1], z = R; z < T; z += o) {
                  var L = h[M + z * t.strides[2] + w];
                  "max" === n && L > D ? D = L : "avg" === n && (O += L, _++)
                }
                if (isNaN(D)) break
              }
              d[I + E * v + w] = "avg" === n ? O / _ : D
            }
      return f.toTensor()
    }, e.prototype.maxPool = function (t, e) {
      return this.pool(t, e, "max")
    }, e.prototype.maxPoolPositions = function (t, e) {
      for (var n = qn(e.outShape, "int32"), r = e.strideHeight, a = e.strideWidth, i = e.dilationHeight, o = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, l = e.padInfo.top, c = e.padInfo.left, p = this.bufferSync(t), h = 0; h < e.batchSize; ++h)
        for (var f = 0; f < e.inChannels; ++f)
          for (var d = 0; d < e.outHeight; ++d) {
            for (var m = d * r - l, g = m; g < 0;) g += i;
            for (var v = Math.min(e.inHeight, s + m), y = 0; y < e.outWidth; ++y) {
              for (var b = y * a - c, x = b; x < 0;) x += o;
              for (var w = Math.min(e.inWidth, u + b), C = Number.NEGATIVE_INFINITY, N = -1, S = g; S < v; S += i)
                for (var k = S - m, I = x; I < w; I += o) {
                  var E = I - b,
                    A = p.get(h, S, I, f);
                  A > C && (C = A, N = k * u + E)
                }
              n.set(N, h, d, y, f)
            }
          }
      return n.toTensor()
    }, e.prototype.maxPoolBackprop = function (t, e, n, r) {
      Xl([e, n], "maxPoolBackprop");
      for (var a = this.maxPoolPositions(e, r), i = r.strideHeight, o = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, l = r.effectiveFilterHeight, c = r.effectiveFilterWidth, p = c - 1 - r.padInfo.left, h = l - 1 - r.padInfo.top, f = qn(e.shape, "float32"), d = this.bufferSync(a), m = this.bufferSync(t), g = 0; g < r.batchSize; ++g)
        for (var v = 0; v < r.inChannels; ++v)
          for (var y = 0; y < r.inHeight; ++y)
            for (var b = 0; b < r.inWidth; ++b) {
              for (var x = y - h, w = b - p, C = 0, N = 0; N < l; N += s) {
                var S = (x + N) / i;
                if (!(S < 0 || S >= r.outHeight || Math.floor(S) !== S))
                  for (var k = 0; k < c; k += u) {
                    var I = (w + k) / o;
                    if (!(I < 0 || I >= r.outWidth || Math.floor(I) !== I)) {
                      var E = l * c - 1 - d.get(g, S, I, v) === N * c + k ? 1 : 0;
                      0 !== E && (C += m.get(g, S, I, v) * E)
                    }
                  }
              }
              f.set(C, g, y, b, v)
            }
      return f.toTensor()
    }, e.prototype.avgPoolBackprop = function (t, e, n) {
      Xl([t, e], "avgPoolBackprop");
      for (var r = n.strideHeight, a = n.strideWidth, i = n.filterHeight, o = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, l = n.effectiveFilterHeight, c = n.effectiveFilterWidth, p = c - 1 - n.padInfo.left, h = l - 1 - n.padInfo.top, f = qn(e.shape, "float32"), d = 1 / (i * o), m = this.bufferSync(t), g = 0; g < n.batchSize; ++g)
        for (var v = 0; v < n.inChannels; ++v)
          for (var y = 0; y < n.inHeight; ++y)
            for (var b = 0; b < n.inWidth; ++b) {
              for (var x = y - h, w = b - p, C = 0, N = 0; N < l; N += s) {
                var S = (x + N) / r;
                if (!(S < 0 || S >= n.outHeight || Math.floor(S) !== S))
                  for (var k = 0; k < c; k += u) {
                    var I = (w + k) / a;
                    I < 0 || I >= n.outWidth || Math.floor(I) !== I || (C += m.get(g, S, I, v))
                  }
              }
              f.set(C * d, g, y, b, v)
            }
      return f.toTensor()
    }, e.prototype.pool3d = function (t, e, n) {
      Xl(t, "pool3d");
      for (var r = e.strideDepth, a = e.strideHeight, i = e.strideWidth, o = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, l = e.effectiveFilterDepth, c = e.effectiveFilterHeight, p = e.effectiveFilterWidth, h = e.padInfo.front, f = e.padInfo.top, d = e.padInfo.left, m = "max" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, g = this.readSync(t.dataId), v = qn(e.outShape, t.dtype), y = v.values, b = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], x = e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[3] * e.outShape[4], C = e.outShape[4], N = 0; N < e.batchSize; ++N)
        for (var S = N * b, k = N * t.strides[0], I = 0; I < e.inChannels; ++I)
          for (var E = 0; E < e.outDepth; ++E) {
            for (var A = E * r - h, R = A; R < 0;) R += o;
            for (var T = Math.min(e.inDepth, l + A), D = S + E * x, O = 0; O < e.outHeight; ++O) {
              for (var _ = O * a - f, F = _; F < 0;) F += s;
              for (var M = Math.min(e.inHeight, c + _), z = D + O * w, L = 0; L < e.outWidth; ++L) {
                for (var B = L * i - d, P = B; P < 0;) P += u;
                for (var W = Math.min(e.inWidth, p + B), V = z + L * C, U = m, j = 0, G = 0, q = R; q < T; q += o) {
                  for (var H = k + q * t.strides[1], K = F; K < M; K += s) {
                    for (var X = H + K * t.strides[2], $ = P; $ < W; $ += u) {
                      var Y = g[X + $ * t.strides[3] + I];
                      if ("max" === n && Y > U ? U = Y : "avg" === n && (j += Y, G++), isNaN(U)) break
                    }
                    if (isNaN(U)) break
                  }
                  if (isNaN(U)) break
                }
                y[V + I] = "avg" === n ? j / G : U
              }
            }
          }
      return v.toTensor()
    }, e.prototype.avgPool3d = function (t, e) {
      return Xl(t, "avgPool3d"), this.pool3d(t, e, "avg").toFloat()
    }, e.prototype.avgPool3dBackprop = function (t, e, n) {
      Xl([t, e], "avgPool3dBackprop");
      for (var r = n.strideDepth, a = n.strideHeight, i = n.strideWidth, o = n.filterDepth, s = n.filterHeight, u = n.filterWidth, l = n.dilationDepth, c = n.dilationHeight, p = n.dilationWidth, h = n.effectiveFilterDepth, f = n.effectiveFilterHeight, d = n.effectiveFilterWidth, m = h - 1 - n.padInfo.front, g = d - 1 - n.padInfo.left, v = f - 1 - n.padInfo.top, y = qn(e.shape, "float32"), b = 1 / (o * s * u), x = this.bufferSync(t), w = 0; w < n.batchSize; ++w)
        for (var C = 0; C < n.inChannels; ++C)
          for (var N = 0; N < n.inDepth; ++N)
            for (var S = 0; S < n.inHeight; ++S)
              for (var k = 0; k < n.inWidth; ++k) {
                for (var I = N - m, E = S - v, A = k - g, R = 0, T = 0; T < h; T += l) {
                  var D = (I + T) / r;
                  if (!(D < 0 || D >= n.outDepth || Math.floor(D) !== D))
                    for (var O = 0; O < f; O += c) {
                      var _ = (E + O) / a;
                      if (!(_ < 0 || _ >= n.outHeight || Math.floor(_) !== _))
                        for (var F = 0; F < d; F += p) {
                          var M = (A + F) / i;
                          M < 0 || M >= n.outWidth || Math.floor(M) !== M || (R += x.get(w, D, _, M, C))
                        }
                    }
                }
                y.set(R * b, w, N, S, k, C)
              }
      return y.toTensor()
    }, e.prototype.maxPool3d = function (t, e) {
      return Xl(t, "maxPool3d"), this.pool3d(t, e, "max").toFloat()
    }, e.prototype.maxPool3dPositions = function (t, e) {
      for (var n = qn(e.outShape, "int32"), r = e.strideDepth, a = e.strideHeight, i = e.strideWidth, o = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, l = e.effectiveFilterDepth, c = e.effectiveFilterHeight, p = e.effectiveFilterWidth, h = e.padInfo.front, f = e.padInfo.top, d = e.padInfo.left, m = this.bufferSync(t), g = 0; g < e.batchSize; ++g)
        for (var v = 0; v < e.inChannels; ++v)
          for (var y = 0; y < e.outDepth; ++y) {
            for (var b = y * r - h, x = b; x < 0;) x += o;
            for (var w = Math.min(e.inDepth, l + b), C = 0; C < e.outHeight; ++C) {
              for (var N = C * a - f, S = N; S < 0;) S += s;
              for (var k = Math.min(e.inHeight, c + N), I = 0; I < e.outWidth; ++I) {
                for (var E = I * i - d, A = E; A < 0;) A += u;
                for (var R = Math.min(e.inWidth, p + E), T = Number.NEGATIVE_INFINITY, D = -1, O = x; O < w; O += o)
                  for (var _ = O - b, F = S; F < k; F += s)
                    for (var M = F - N, z = A; z < R; z += u) {
                      var L = z - E,
                        B = m.get(g, O, F, z, v);
                      B >= T && (T = B, D = _ * c * p + M * c + L)
                    }
                n.set(D, g, y, C, I, v)
              }
            }
          }
      return n.toTensor()
    }, e.prototype.maxPool3dBackprop = function (t, e, n, r) {
      Xl([e, n], "maxPool3dBackprop");
      for (var a = this.maxPool3dPositions(e, r), i = r.strideDepth, o = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, l = r.dilationHeight, c = r.dilationWidth, p = r.effectiveFilterDepth, h = r.effectiveFilterHeight, f = r.effectiveFilterWidth, d = p - 1 - r.padInfo.front, m = f - 1 - r.padInfo.left, g = h - 1 - r.padInfo.top, v = qn(e.shape, "float32"), y = this.bufferSync(a), b = this.bufferSync(t), x = 0; x < r.batchSize; ++x)
        for (var w = 0; w < r.inChannels; ++w)
          for (var C = 0; C < r.inDepth; ++C)
            for (var N = 0; N < r.inHeight; ++N)
              for (var S = 0; S < r.inWidth; ++S) {
                for (var k = C - d, I = N - g, E = S - m, A = 0, R = 0; R < p; R += u) {
                  var T = (k + R) / i;
                  if (!(T < 0 || T >= r.outDepth || Math.floor(T) !== T))
                    for (var D = 0; D < h; D += l) {
                      var O = (I + D) / o;
                      if (!(O < 0 || O >= r.outHeight || Math.floor(O) !== O))
                        for (var _ = 0; _ < f; _ += c) {
                          var F = (E + _) / s;
                          if (!(F < 0 || F >= r.outWidth || Math.floor(F) !== F)) {
                            var M = p * h * f - 1 - y.get(x, T, O, F, w) === R * h * f + D * f + _ ? 1 : 0;
                            0 !== M && (A += b.get(x, T, O, F, w) * M)
                          }
                        }
                    }
                }
                v.set(A, x, C, N, S, w)
              }
      return v.toTensor()
    }, e.prototype.cast = function (t, e) {
      return oa(t, e, this)
    }, e.prototype.reshape = function (t, e) {
      return sa(t, e)
    }, e.prototype.avgPool = function (t, e) {
      return Xl(t, "avgPool"), this.pool(t, e, "avg").toFloat()
    }, e.prototype.resizeBilinear = function (t, e, n, r) {
      Xl(t, "resizeBilinear");
      for (var a = t.shape, i = a[0], o = a[1], s = a[2], u = a[3], l = this.readSync(t.dataId), c = new Float32Array(N([i, e, n, u])), p = [r && e > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s], h = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = 0, d = p[0] / h[0], m = p[1] / h[1], g = 0; g < i; g++)
        for (var v = 0; v < e; v++)
          for (var y = d * v, b = Math.floor(y), x = y - b, w = Math.min(o - 1, Math.ceil(y)), C = g * t.strides[0] + b * t.strides[1], S = g * t.strides[0] + w * t.strides[1], k = 0; k < n; k++)
            for (var I = m * k, E = Math.floor(I), A = I - E, R = Math.min(s - 1, Math.ceil(I)), T = C + E * t.strides[2], D = S + E * t.strides[2], O = C + R * t.strides[2], _ = S + R * t.strides[2], F = 0; F < u; F++) {
              var M = l[T + F],
                z = l[D + F],
                L = M + (l[O + F] - M) * A,
                B = L + (z + (l[_ + F] - z) * A - L) * x;
              c[f++] = B
            }
      return cn(c, [i, e, n, u])
    }, e.prototype.resizeBilinearBackprop = function (t, e, n) {
      Xl([t, e], "resizeBilinearBackprop");
      for (var r = e.shape, a = r[0], i = r[1], o = r[2], s = r[3], u = t.shape, l = u[1], c = u[2], p = new Float32Array(a * i * o * s), h = [n && l > 1 ? i - 1 : i, n && c > 1 ? o - 1 : o], f = [n && l > 1 ? l - 1 : l, n && c > 1 ? c - 1 : c], d = h[0] / f[0], m = h[1] / f[1], g = this.readSync(t.dataId), v = 0, y = 0; y < a; y++)
        for (var b = y * e.strides[0], x = 0; x < l; x++)
          for (var w = x * d, C = Math.floor(w), N = Math.min(Math.ceil(w), i - 1), S = b + C * e.strides[1], k = b + N * e.strides[1], I = w - C, E = 1 - I, A = 0; A < c; A++)
            for (var R = A * m, T = Math.floor(R), D = Math.min(Math.ceil(R), o - 1), O = R - T, _ = 1 - O, F = S + T * e.strides[2], M = S + D * e.strides[2], z = k + T * e.strides[2], L = k + D * e.strides[2], B = E * _, P = E * O, W = I * _, V = I * O, U = 0; U < s; U++) {
              var j = g[v++];
              p[F + U] += j * B, p[M + U] += j * P, p[z + U] += j * W, p[L + U] += j * V
            }
      return gn(p, [a, o, i, s], e.dtype)
    }, e.prototype.resizeNearestNeighbor = function (t, e, n, r) {
      Xl(t, "resizeNearestNeighbor");
      for (var a = t.shape, i = a[0], o = a[1], s = a[2], u = a[3], l = this.readSync(t.dataId), c = new Float32Array(i * e * n * u), p = [r && e > 1 ? o - 1 : o, r && n > 1 ? s - 1 : s], h = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = p[0] / h[0], d = p[1] / h[1], m = 0, g = 0; g < i; g++)
        for (var v = g * t.strides[0], y = 0; y < e; y++)
          for (var b = f * y, x = v + Math.min(o - 1, r ? Math.round(b) : Math.floor(b)) * t.strides[1], w = 0; w < n; w++)
            for (var C = d * w, N = x + Math.min(s - 1, r ? Math.round(C) : Math.floor(C)) * t.strides[2], S = 0; S < u; S++) {
              var k = l[N + S];
              c[m++] = k
            }
      return cn(c, [i, e, n, u], t.dtype)
    }, e.prototype.resizeNearestNeighborBackprop = function (t, e, n) {
      Xl([t, e], "resizeNearestNeighborBackprop");
      for (var r = e.shape, a = r[0], i = r[1], o = r[2], s = r[3], u = t.shape, l = u[1], c = u[2], p = new Float32Array(a * i * o * s), h = this.readSync(t.dataId), f = [n && l > 1 ? i - 1 : i, n && c > 1 ? o - 1 : o], d = [n && l > 1 ? l - 1 : l, n && c > 1 ? c - 1 : c], m = f[0] / d[0], g = f[1] / d[1], v = 1 / m, y = 1 / g, b = 2 * Math.ceil(v) + 2, x = 2 * Math.ceil(y) + 2, w = 0; w < a; w++)
        for (var C = w * e.strides[0], N = 0; N < i; N++)
          for (var S = C + N * e.strides[1], k = Math.floor(N * v), I = Math.floor(k - b / 2), E = 0; E < o; E++)
            for (var A = S + E * e.strides[2], R = Math.floor(E * y), T = Math.floor(R - x / 2), D = 0; D < s; D++) {
              for (var O = 0, _ = 0; _ < b; _++) {
                var F = _ + I;
                if (!(F < 0 || F >= l)) {
                  var M = C + F * t.strides[1],
                    z = F * m;
                  if (N === Math.min(i - 1, n ? Math.round(z) : Math.floor(z)))
                    for (var L = 0; L < x; L++) {
                      var B = L + T;
                      if (!(B < 0 || B >= c)) {
                        var P = M + B * t.strides[2],
                          W = B * g;
                        E === Math.min(o - 1, n ? Math.round(W) : Math.floor(W)) && (O += h[P + D])
                      }
                    }
                }
              }
              p[A + D] = O
            }
      return gn(p, e.shape, e.dtype)
    }, e.prototype.batchNormalization = function (t, e, n, r, a, i) {
      Xl([t, e, n, a, i], "batchNorm");
      for (var o = this.readSync(t.dataId), s = this.readSync(e.dataId), u = this.readSync(n.dataId), l = a ? this.readSync(a.dataId) : new Float32Array([1]), c = i ? this.readSync(i.dataId) : new Float32Array([0]), p = new Float32Array(o.length), h = c.length, f = l.length, d = u.length, m = s.length, g = 0, v = 0, y = 0, b = 0, x = 0; x < o.length; ++x) p[x] = c[g++] + (o[x] - s[v++]) * l[y++] / Math.sqrt(u[b++] + r), g >= h && (g = 0), v >= m && (v = 0), y >= f && (y = 0), b >= d && (b = 0);
      return gn(p, t.shape)
    }, e.prototype.localResponseNormalization4D = function (t, e, n, r, a) {
      Xl(t, "localResponseNormalization4D");
      var i = t.shape[3],
        o = i - 1,
        s = this.readSync(t.dataId),
        u = t.size,
        l = new Float32Array(u);

      function c(t) {
        for (var n = t % i, r = t - n + Math.max(0, n - e), a = t - n + Math.min(n + e, o), u = 0; r <= a; r++) {
          var l = s[r];
          u += l * l
        }
        return u
      }
      for (var p = 0; p < u; p++) {
        var h = c(p),
          f = s[p] * Math.pow(n + r * h, -a);
        l[p] = f
      }
      return gn(l, t.shape)
    }, e.prototype.LRNGrad = function (t, e, n, r, a, i, o) {
      Xl(t, "LRNGrad");
      for (var s = t.shape[3], u = this.readSync(t.dataId), l = this.readSync(e.dataId), c = this.readSync(n.dataId), p = new Float32Array(t.size), h = t.size, f = 0; f < h; f++) {
        for (var d = f % s, m = f - d + Math.max(0, d - r), g = f - d + Math.min(s, d + r + 1), v = 0, y = m; y < g; y++) v += Math.pow(l[y], 2);
        for (v = i * v + a, y = m; y < g; y++) {
          var b = -2 * i * o * l[y] * c[f] / v;
          f === y && (b += Math.pow(v, -o)), b *= u[f], p[y] += b
        }
      }
      return gn(p, t.shape)
    }, e.prototype.multinomial = function (t, e, n, r) {
      Xl(t, "multinomial");
      for (var a = e ? t : Wr(t), i = a.shape[0], o = a.shape[1], s = wn([i, n], "int32"), u = this.readSync(s.dataId), l = this.readSync(a.dataId), c = 0; c < i; ++c) {
        var p = c * o,
          h = new Float32Array(o - 1);
        h[0] = l[p];
        for (var f = 1; f < h.length; ++f) h[f] = h[f - 1] + l[p + f];
        for (var d = Vn(r.toString()), m = c * n, g = 0; g < n; ++g) {
          var v = d();
          u[m + g] = h.length;
          for (var y = 0; y < h.length; y++)
            if (v < h[y]) {
              u[m + g] = y;
              break
            }
        }
      }
      return s
    }, e.prototype.oneHot = function (t, e, n, r) {
      Xl(t, "oneHot");
      var a = new Float32Array(t.size * e);
      a.fill(r);
      for (var i = this.readSync(t.dataId), o = 0; o < t.size; ++o) i[o] >= 0 && i[o] < e && (a[o * e + i[o]] = n);
      return dn(a, [t.size, e], "int32")
    }, e.prototype.nonMaxSuppression = function (t, e, n, r, a) {
      return Xl(t, "nonMaxSuppression"), ga(this.readSync(t.dataId), this.readSync(e.dataId), n, r, a)
    }, e.prototype.fft = function (t) {
      return this.fftBatch(t, !1)
    }, e.prototype.ifft = function (t) {
      return this.fftBatch(t, !0)
    }, e.prototype.fftBatch = function (t, e) {
      for (var n = t.shape[0], r = t.shape[1], a = qn(t.shape, "float32"), i = qn(t.shape, "float32"), o = un(t).as2D(n, r), s = ln(t).as2D(n, r), u = 0; u < n; u++)
        for (var l = o.slice([u, 0], [1, r]), c = s.slice([u, 0], [1, r]), p = sn(l, c), h = this.readSync(this.fftImpl(p, e).dataId), f = 0; f < r; f++) {
          var d = pa(h, f);
          a.values[u * r + f] = d.real, i.values[u * r + f] = d.imag
        }
      return sn(a.toTensor(), i.toTensor()).as2D(n, r)
    }, e.prototype.fftImpl = function (t, e) {
      var n = t.as1D(),
        r = n.size;
      if (this.isExponentOf2(r)) {
        var a = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);
        return e && (a = sn(un(a).div(hn(r)), ln(a).div(hn(r)))), a
      }
      var i = this.readSync(t.dataId),
        o = function (t) {
          for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2) e[r / 2] = t[r], n[r / 2] = t[r + 1];
          return {
            real: e,
            imag: n
          }
        }(this.fourierTransformByMatmul(i, r, e));
      return sn(o.real, o.imag).as2D(t.shape[0], t.shape[1])
    }, e.prototype.isExponentOf2 = function (t) {
      return 0 == (t & t - 1)
    }, e.prototype.fftRadix2 = function (t, e, n) {
      if (1 === e) return t;
      var r = this.readSync(t.dataId),
        a = e / 2,
        i = function (t) {
          for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), a = 0; a < t.length; a += 4) n[Math.floor(a / 4)] = t[a], r[Math.floor(a / 4)] = t[a + 1];
          return {
            real: n,
            imag: r
          }
        }(r),
        o = sn(i.real, i.imag).as1D(),
        s = function (t) {
          for (var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), a = 2; a < t.length; a += 4) n[Math.floor(a / 4)] = t[a], r[Math.floor(a / 4)] = t[a + 1];
          return {
            real: n,
            imag: r
          }
        }(r),
        u = sn(s.real, s.imag).as1D();
      o = this.fftRadix2(o, a, n), u = this.fftRadix2(u, a, n);
      var l = function (t, e) {
          for (var n = new Float32Array(t / 2), r = new Float32Array(t / 2), a = 0; a < Math.ceil(t / 2); a++) {
            var i = (e ? 2 : -2) * Math.PI * (a / t);
            n[a] = Math.cos(i), r[a] = Math.sin(i)
          }
          return {
            real: n,
            imag: r
          }
        }(e, n),
        c = sn(l.real, l.imag).mul(u),
        p = o.add(c),
        h = o.sub(c),
        f = un(p).concat(un(h)),
        d = ln(p).concat(ln(h));
      return sn(f, d).as1D()
    }, e.prototype.fourierTransformByMatmul = function (t, e, n) {
      for (var r = new Float32Array(2 * e), a = 0; a < e; a++) {
        for (var i = 0, o = 0, s = 0; s < e; s++) {
          var u = fa(a * s, e, n),
            l = pa(t, s);
          i += l.real * u.real - l.imag * u.imag, o += l.real * u.imag + l.imag * u.real
        }
        n && (i /= e, o /= e), ha(r, i, o, a)
      }
      return r
    }, e.prototype.depthToSpace = function (t, e, n) {
      b("NHWC" === n, function () {
        return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n
      }), b(e > 1, function () {
        return "blockSize should be > 1 for depthToSpace, but was: " + e
      });
      for (var r = t.shape[0], a = t.shape[1], i = t.shape[2], o = t.shape[3], s = a * e, u = i * e, l = o / (e * e), c = this.readSync(t.dataId), p = new Float32Array(r * s * u * l), h = 0, f = 0; f < r; ++f)
        for (var d = 0; d < s; ++d)
          for (var m = Math.floor(d / e), g = d % e, v = 0; v < u; ++v)
            for (var y = Math.floor(v / e), x = (g * e + v % e) * l, w = 0; w < l; ++w) {
              var C = w + x + o * (y + i * (m + a * f));
              p[h++] = c[C]
            }
      return gn(p, [r, s, u, l])
    }, e.prototype.broadcastedBinaryOp = function (t, e, n, r) {
      var a = Kr(t.shape, e.shape),
        i = qn(a, n),
        o = this.readSync(t.dataId),
        s = this.readSync(e.dataId),
        u = qr(t.shape, a),
        l = qr(e.shape, a),
        c = i.values;
      if (u.length + l.length === 0)
        for (var p = 0; p < c.length; ++p) c[p] = r(o[p % o.length], s[p % s.length]);
      else {
        var h = this.bufferSync(t),
          f = this.bufferSync(e),
          d = function (n) {
            var a = i.indexToLoc(n),
              p = a.slice(-t.rank);
            u.forEach(function (t) {
              return p[t] = 0
            });
            var d = h.locToIndex(p),
              m = a.slice(-e.rank);
            l.forEach(function (t) {
              return m[t] = 0
            });
            var g = f.locToIndex(m);
            c[n] = r(o[d], s[g])
          };
        for (p = 0; p < c.length; ++p) d(p)
      }
      return i.toTensor()
    }, e.prototype.broadcastedBinaryComplexOp = function (t, e, n) {
      var r = Kr(t.shape, e.shape),
        a = qn(r, "float32"),
        i = qn(r, "float32"),
        o = this.readSync(t.dataId),
        s = this.readSync(e.dataId),
        u = qr(t.shape, r),
        l = qr(e.shape, r),
        c = a.values,
        p = i.values;
      if (u.length + l.length === 0)
        for (var h = 0; h < c.length; h++) {
          var f = h % o.length,
            d = h % s.length,
            m = n(o[2 * f], o[2 * f + 1], s[2 * d], s[2 * d + 1]);
          c[h] = m.real, p[h] = m.imag
        } else {
          var g = this.bufferSync(this.data.get(t.dataId).complexTensors.real),
            v = this.bufferSync(this.data.get(e.dataId).complexTensors.real),
            y = function (r) {
              var i = a.indexToLoc(r),
                h = i.slice(-t.rank);
              u.forEach(function (t) {
                return h[t] = 0
              });
              var f = g.locToIndex(h),
                d = i.slice(-e.rank);
              l.forEach(function (t) {
                return d[t] = 0
              });
              var m = v.locToIndex(d),
                y = n(o[2 * f], o[2 * f + 1], s[2 * m], s[2 * m + 1]);
              c[r] = y.real, p[r] = y.imag
            };
          for (h = 0; h < c.length; h++) y(h)
        }
      return this.complex(a.toTensor(), i.toTensor())
    }, e.prototype.split = function (t, e, n) {
      return Ca(t, e, n)
    }, e.prototype.dispose = function () {}, e.prototype.floatPrecision = function () {
      return 32
    }, e.prototype.epsilon = function () {
      return 1e-7
    }, e.prototype.cropAndResize = function (t, e, n, r, a, i) {
      for (var o = t.shape, s = o[0], u = o[1], l = o[2], c = o[3], p = e.shape[0], h = r[0], f = r[1], d = qn([p, h, f, c], "float32"), m = this.readSync(e.dataId), g = this.readSync(n.dataId), v = this.readSync(t.dataId), y = t.strides, b = d.strides, x = 0; x < p; x++) {
        var w = 4 * x,
          C = m[w],
          N = m[w + 1],
          S = m[w + 2],
          k = m[w + 3],
          I = g[x];
        if (!(I >= s))
          for (var E = h > 1 ? (S - C) * (u - 1) / (h - 1) : 0, A = f > 1 ? (k - N) * (l - 1) / (f - 1) : 0, R = 0; R < h; R++) {
            var T = h > 1 ? C * (u - 1) + R * E : .5 * (C + S) * (u - 1);
            if (T < 0 || T > u - 1)
              for (var D = 0; D < f; D++)
                for (var O = 0; O < c; O++) {
                  var _ = O + D * b[2] + R * b[1] + x * b[0];
                  d.values[_] = i
                } else if ("bilinear" === a) {
                  var F = Math.floor(T),
                    M = Math.ceil(T),
                    z = T - F;
                  for (D = 0; D < f; D++)
                    if ((q = f > 1 ? N * (l - 1) + D * A : .5 * (N + k) * (l - 1)) < 0 || q > l - 1)
                      for (O = 0; O < c; O++) _ = O + D * b[2] + R * b[1] + x * b[0], d.values[_] = i;
                    else {
                      var L = Math.floor(q),
                        B = Math.ceil(q),
                        P = q - L;
                      for (O = 0; O < c; O++) {
                        var W = v[_ = O + L * y[2] + F * y[1] + I * y[0]],
                          V = v[_ = O + B * y[2] + F * y[1] + I * y[0]],
                          U = v[_ = O + L * y[2] + M * y[1] + I * y[0]],
                          j = W + (V - W) * P,
                          G = U + (v[_ = O + B * y[2] + M * y[1] + I * y[0]] - U) * P;
                        _ = O + D * b[2] + R * b[1] + x * b[0], d.values[_] = j + (G - j) * z
                      }
                    }
                } else
                  for (D = 0; D < f; ++D) {
                    var q;
                    if ((q = f > 1 ? N * (l - 1) + D * A : .5 * (N + k) * (l - 1)) < 0 || q > l - 1)
                      for (O = 0; O < c; O++) _ = O + D * b[2] + R * b[1] + x * b[0], d.values[_] = i;
                    else {
                      var H = Math.round(q),
                        K = Math.round(T);
                      for (O = 0; O < c; O++) {
                        var X = O + H * y[2] + K * y[1] + I * y[0],
                          $ = O + D * b[2] + R * b[1] + x * b[0];
                        d.values[$] = v[X]
                      }
                    }
                  }
          }
      }
      return d.toTensor()
    }, e.prototype.sparseToDense = function (t, e, n, r) {
      var a = Ar(0, t, n),
        i = a.sliceRank,
        o = a.numUpdates,
        s = a.sliceSize,
        u = a.strides,
        l = a.outputSize;
      return this.scatter(t, e, n, l, s, o, i, u, r, !1)
    }, e.prototype.gatherND = function (t, e) {
      var n = e.shape,
        r = n[n.length - 1],
        a = kr(t, e),
        i = a[0],
        o = a[1],
        s = a[2],
        u = a[3];
      if (0 === o) return cn([], i, t.dtype);
      for (var l = new pt([o, s], t.dtype), c = this.readSync(e.dataId), p = this.readSync(t.dataId), h = 0; h < o; h++) {
        for (var f = [], d = 0, m = 0; m < r; m++) {
          var g = c[h * r + m];
          d += g * u[m], f.push(g)
        }
        if (d < 0 || d >= t.size / s) throw new Error("Invalid indices: " + f + " does not index into " + t.shape);
        for (var v = 0; v < s; v++) l.values[h * s + v] = p[d * s + v]
      }
      return l.toTensor().reshape(i)
    }, e.prototype.scatterND = function (t, e, n) {
      var r = Ar(0, t, n),
        a = r.sliceRank,
        i = r.numUpdates,
        o = r.sliceSize,
        s = r.strides,
        u = r.outputSize,
        l = hn(0);
      return this.scatter(t, e, n, u, o, i, a, s, l, !0)
    }, e.prototype.fill = function (t, e, n) {
      var r = F(n = n || G(e), N(t));
      return r.fill(e), Dt.makeTensor(r, t, n, this)
    }, e.prototype.onesLike = function (t) {
      if ("string" === t.dtype) throw new Error("onesLike is not supported for string tensors");
      return this.fill(t.shape, 1, t.dtype)
    }, e.prototype.zerosLike = function (t) {
      var e = F(t.dtype, N(t.shape));
      return this.makeOutput(e, t.shape, t.dtype)
    }, e.prototype.linspace = function (t, e, n) {
      return ua(t, e, n)
    }, e.prototype.scatter = function (t, e, n, r, a, i, o, s, u, l) {
      var c = [r / a, a],
        p = this.readSync(t.dataId),
        h = this.readSync(e.dataId);
      if (0 === r) return cn([], n, e.dtype);
      var f = new pt(c, e.dtype);
      f.values.fill(this.readSync(u.dataId)[0]);
      for (var d = 0; d < i; d++) {
        for (var m = [], g = 0, v = 0; v < o; v++) {
          var y = p[d * o + v];
          m.push(y), g += y * s[v]
        }
        if (g < 0 || g >= r / a) throw new Error("Invalid indices: " + m + " does not index into " + n);
        for (var b = 0; b < a; b++) l ? f.values[g * a + b] += h[d * a + b] : f.values[g * a + b] = 0 === e.rank ? h[0] : h[d * a + b]
      }
      return f.toTensor().reshape(n)
    }, e
  }(jr);
  Dt.registerBackend("cpu", function () {
    return new Yl
  }, 1), h({
    kernelName: "Square",
    backendName: "cpu",
    kernelFunc: function (t) {
      var e = t.inputs,
        n = t.backend,
        r = e.x,
        a = n;
      Xl(r, "square");
      for (var i = a.data.get(r.dataId).values, o = new Float32Array(i.length), s = 0; s < i.length; ++s) {
        var u = i[s];
        o[s] = u * u
      }
      return {
        dataId: a.write(o, r.shape, r.dtype),
        shape: r.shape,
        dtype: r.dtype
      }
    }
  }), h({
    kernelName: "NonMaxSuppressionV5",
    backendName: "cpu",
    kernelFunc: function (t) {
      var e = t.inputs,
        n = t.backend,
        r = t.attrs,
        a = e,
        i = a.boxes,
        o = a.scores,
        s = r,
        u = s.maxOutputSize,
        l = s.iouThreshold,
        c = s.scoreThreshold,
        p = s.softNmsSigma,
        h = n;
      Xl(i, "NonMaxSuppressionWithScore");
      var f = va(h.data.get(i.dataId).values, h.data.get(o.dataId).values, u, l, c, p);
      return [f.selectedIndices, f.selectedScores]
    }
  }), h({
    kernelName: "Square",
    backendName: "webgl",
    kernelFunc: function (t) {
      var e = t.inputs,
        n = t.backend,
        r = e.x,
        a = n,
        i = new Pi(r.shape, "return x * x;");
      return a.runWebGLProgram(i, [r], r.dtype)
    }
  });
  var Jl;
  h({
    kernelName: "FromPixels",
    backendName: "webgl",
    kernelFunc: function (t) {
      var e = t.inputs,
        n = t.backend,
        r = t.attrs,
        a = e.pixels,
        i = r.numChannels,
        s = "undefined" != typeof HTMLVideoElement && a instanceof HTMLVideoElement,
        u = "undefined" != typeof HTMLImageElement && a instanceof HTMLImageElement,
        l = s ? [a.videoWidth, a.videoHeight] : [a.width, a.height],
        c = l[0],
        p = l[1],
        h = [p, c],
        f = [p, c, i];
      (u || s) && (null == Jl && (Jl = document.createElement("canvas").getContext("2d")), Jl.canvas.width = c, Jl.canvas.height = p, Jl.drawImage(a, 0, 0, c, p), a = Jl.canvas);
      var d = n.makeTensorInfo(h, "int32");
      n.texData.get(d.dataId).usage = Mt.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), a);
      var m = o().getBool("WEBGL_PACK") ? new function (t) {
          this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
          var e = Aa(),
            n = t[0],
            r = t[1];
          this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r + ".0, " + n + ".0);\n            vec4 values = " + e.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e.output + " = result;\n      }\n    "
        }(f) : new function (t) {
          this.variableNames = ["A"];
          var e = Aa(),
            n = t[0],
            r = t[1];
          this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r + ".0, " + n + ".0);\n\n        vec4 values = " + e.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "
        }(f),
        g = n.runWebGLProgram(m, [d], "int32");
      return n.disposeData(d.dataId), g
    }
  }), h({
    kernelName: "NonMaxSuppressionV5",
    backendName: "webgl",
    kernelFunc: function (t) {
      var e = t.inputs,
        n = t.backend,
        r = t.attrs;
      Ge("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
      var a = e,
        i = a.boxes,
        o = a.scores,
        s = r,
        u = s.maxOutputSize,
        l = s.iouThreshold,
        c = s.scoreThreshold,
        p = s.softNmsSigma,
        h = n,
        f = va(h.readSync(i.dataId), h.readSync(o.dataId), u, l, c, p);
      return [f.selectedIndices, f.selectedScores]
    }
  });
  var Zl = function () {
    function t() {}
    return t.prototype.fetch = function (t, e) {
      return fetch(t, e)
    }, t.prototype.now = function () {
      return performance.now()
    }, t.prototype.encode = function (t, e) {
      if ("utf-8" !== e && "utf8" !== e) throw new Error("Browser's encoder only supports utf-8, but got " + e);
      return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(t)
    }, t.prototype.decode = function (t, e) {
      return new TextDecoder(e).decode(t)
    }, t
  }();
  o().get("IS_BROWSER") && o().setPlatform("browser", new Zl);
  var Ql, tc = function () {
    function t() {
      this.util = require("util"), this.textEncoder = new this.util.TextEncoder
    }
    return t.prototype.fetch = function (t, e) {
      return null != o().global.fetch ? o().global.fetch(t, e) : (null == Ql && (Ql = require("node-fetch")), Ql(t, e))
    }, t.prototype.now = function () {
      var t = process.hrtime();
      return 1e3 * t[0] + t[1] / 1e6
    }, t.prototype.encode = function (t, e) {
      if ("utf-8" !== e && "utf8" !== e) throw new Error("Node built-in encoder only supports utf-8, but got " + e);
      return this.textEncoder.encode(t)
    }, t.prototype.decode = function (t, e) {
      return 0 === t.length ? "" : new this.util.TextDecoder(e).decode(t)
    }, t
  }();
  o().get("IS_NODE") && o().setPlatform("node", new tc);
  var ec = {
      float32: 4,
      int32: 4,
      uint16: 2,
      uint8: 1,
      bool: 1
    },
    nc = 4;

  function rc(t, e) {
    for (var n = {}, r = 0, a = function (e) {
        var a = e.name,
          i = e.dtype,
          o = e.shape,
          s = N(o),
          u = void 0;
        if ("quantization" in e) {
          var l = e.quantization;
          if ("uint8" !== l.dtype && "uint16" !== l.dtype) throw new Error("Weight " + e.name + " has unknown quantization dtype " + l.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
          var c = ec[l.dtype],
            p = t.slice(r, r + s * c),
            h = "uint8" === l.dtype ? new Uint8Array(p) : new Uint16Array(p);
          if ("float32" === i) u = Float32Array.from(h, function (t) {
            return t * l.scale + l.min
          });
          else {
            if ("int32" !== i) throw new Error("Unsupported dtype in weight '" + a + "': " + i);
            u = Int32Array.from(h, function (t) {
              return Math.round(t * l.scale + l.min)
            })
          }
          r += s * c
        } else if ("string" === i) {
          var f = N(e.shape);
          u = [];
          for (var d = 0; d < f; d++) {
            var m = new Uint32Array(t.slice(r, r + nc))[0];
            r += nc;
            var g = new Uint8Array(t.slice(r, r + m));
            u.push(g), r += m
          }
        } else {
          var v = ec[i];
          if (p = t.slice(r, r + s * v), "float32" === i) u = new Float32Array(p);
          else if ("int32" === i) u = new Int32Array(p);
          else {
            if ("bool" !== i) throw new Error("Unsupported dtype in weight '" + a + "': " + i);
            u = new Uint8Array(p)
          }
          r += s * v
        }
        n[a] = cn(u, o, i)
      }, i = 0, o = e; i < o.length; i++) a(o[i]);
    return n
  }
  var ac = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

  function ic(t) {
    return ac ? Buffer.byteLength(t) : new Blob([t]).size
  }

  function oc(t) {
    var e = 0;
    t.forEach(function (t) {
      e += t.byteLength
    });
    var n = new Uint8Array(e),
      r = 0;
    return t.forEach(function (t) {
      n.set(new Uint8Array(t), r), r += t.byteLength
    }), n.buffer
  }

  function sc(t) {
    for (t = t.trim(); t.endsWith("/");) t = t.slice(0, t.length - 1);
    var e = t.split("/");
    return e[e.length - 1]
  }

  function uc(t) {
    if (t.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return {
      dateSaved: new Date,
      modelTopologyType: "JSON",
      modelTopologyBytes: null == t.modelTopology ? 0 : ic(JSON.stringify(t.modelTopology)),
      weightSpecsBytes: null == t.weightSpecs ? 0 : ic(JSON.stringify(t.weightSpecs)),
      weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength
    }
  }
  var lc = function () {
      function t() {
        this.saveRouters = [], this.loadRouters = []
      }
      return t.getInstance = function () {
        return null == t.instance && (t.instance = new t), t.instance
      }, t.registerSaveRouter = function (e) {
        t.getInstance().saveRouters.push(e)
      }, t.registerLoadRouter = function (e) {
        t.getInstance().loadRouters.push(e)
      }, t.getSaveHandlers = function (e) {
        return t.getHandlers(e, "save")
      }, t.getLoadHandlers = function (e, n) {
        return t.getHandlers(e, "load", n)
      }, t.getHandlers = function (e, n, r) {
        var a = [];
        return ("load" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach(function (t) {
          var n = t(e, r);
          null !== n && a.push(n)
        }), a
      }, t
    }(),
    cc = "://",
    pc = function () {
      function t() {
        this.managers = {}
      }
      return t.getInstance = function () {
        return null == t.instance && (t.instance = new t), t.instance
      }, t.registerManager = function (e, n) {
        b(null != e, function () {
          return "scheme must not be undefined or null."
        }), e.endsWith(cc) && (e = e.slice(0, e.indexOf(cc))), b(e.length > 0, function () {
          return "scheme must not be an empty string."
        });
        var r = t.getInstance();
        b(null == r.managers[e], function () {
          return "A model store manager is already registered for scheme '" + e + "'."
        }), r.managers[e] = n
      }, t.getManager = function (t) {
        var e = this.getInstance().managers[t];
        if (null == e) throw new Error("Cannot find model manager for scheme '" + t + "'");
        return e
      }, t.getSchemes = function () {
        return Object.keys(this.getInstance().managers)
      }, t
    }();

  function hc(t) {
    if (-1 === t.indexOf(cc)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + pc.getSchemes().join(","));
    return {
      scheme: t.split(cc)[0],
      path: t.split(cc)[1]
    }
  }

  function fc(t, e, n) {
    return void 0 === n && (n = !1), r(this, void 0, void 0, function () {
      var r, i, o, s, u, l, c, p, h;
      return a(this, function (a) {
        switch (a.label) {
          case 0:
            return b(t !== e, function () {
              return "Old path and new path are the same: '" + t + "'"
            }), b((r = lc.getLoadHandlers(t)).length > 0, function () {
              return "Copying failed because no load handler is found for source URL " + t + "."
            }), b(r.length < 2, function () {
              return "Copying failed because more than one (" + r.length + ") load handlers for source URL " + t + "."
            }), i = r[0], b((o = lc.getSaveHandlers(e)).length > 0, function () {
              return "Copying failed because no save handler is found for destination URL " + e + "."
            }), b(o.length < 2, function () {
              return "Copying failed because more than one (" + r.length + ") save handlers for destination URL " + e + "."
            }), s = o[0], u = hc(t).scheme, l = hc(t).path, c = u === hc(t).scheme, [4, i.load()];
          case 1:
            return p = a.sent(), n && c ? [4, pc.getManager(u).removeModel(l)] : [3, 3];
          case 2:
            a.sent(), a.label = 3;
          case 3:
            return [4, s.save(p)];
          case 4:
            return h = a.sent(), !n || c ? [3, 6] : [4, pc.getManager(u).removeModel(l)];
          case 5:
            a.sent(), a.label = 6;
          case 6:
            return [2, h.modelArtifactsInfo]
        }
      })
    })
  }
  var dc = "models_store",
    mc = "model_info_store";

  function gc() {
    if (!o().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    var t = window,
      e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;
    if (null == e) throw new Error("The current browser does not appear to support IndexedDB.");
    return e
  }

  function vc(t) {
    var e = t.result;
    e.createObjectStore(dc, {
      keyPath: "modelPath"
    }), e.createObjectStore(mc, {
      keyPath: "modelPath"
    })
  }
  var yc = function () {
      function t(t) {
        if (this.indexedDB = gc(), null == t || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
        this.modelPath = t
      }
      return t.prototype.save = function (t) {
        return r(this, void 0, void 0, function () {
          return a(this, function (e) {
            if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
            return [2, this.databaseAction(this.modelPath, t)]
          })
        })
      }, t.prototype.load = function () {
        return r(this, void 0, void 0, function () {
          return a(this, function (t) {
            return [2, this.databaseAction(this.modelPath)]
          })
        })
      }, t.prototype.databaseAction = function (t, e) {
        var n = this;
        return new Promise(function (t, r) {
          var a = n.indexedDB.open("tensorflowjs", 1);
          a.onupgradeneeded = function () {
            return vc(a)
          }, a.onsuccess = function () {
            var i = a.result;
            if (null == e) {
              var o = i.transaction(dc, "readonly"),
                s = o.objectStore(dc).get(n.modelPath);
              s.onsuccess = function () {
                if (null == s.result) return i.close(), r(new Error("Cannot find model with path '" + n.modelPath + "' in IndexedDB."));
                t(s.result.modelArtifacts)
              }, s.onerror = function (t) {
                return i.close(), r(s.error)
              }, o.oncomplete = function () {
                return i.close()
              }
            } else {
              var u, l = uc(e),
                c = i.transaction(mc, "readwrite"),
                p = c.objectStore(mc),
                h = p.put({
                  modelPath: n.modelPath,
                  modelArtifactsInfo: l
                });
              h.onsuccess = function () {
                var a = (u = i.transaction(dc, "readwrite")).objectStore(dc).put({
                  modelPath: n.modelPath,
                  modelArtifacts: e,
                  modelArtifactsInfo: l
                });
                a.onsuccess = function () {
                  return t({
                    modelArtifactsInfo: l
                  })
                }, a.onerror = function (t) {
                  var e = (p = c.objectStore(mc)).delete(n.modelPath);
                  e.onsuccess = function () {
                    return i.close(), r(a.error)
                  }, e.onerror = function (t) {
                    return i.close(), r(a.error)
                  }
                }
              }, h.onerror = function (t) {
                return i.close(), r(h.error)
              }, c.oncomplete = function () {
                null == u ? i.close() : u.oncomplete = function () {
                  return i.close()
                }
              }
            }
          }, a.onerror = function (t) {
            return r(a.error)
          }
        })
      }, t.URL_SCHEME = "indexeddb://", t
    }(),
    bc = function (t) {
      return o().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(yc.URL_SCHEME) ? (e = t.slice(yc.URL_SCHEME.length), new yc(e)) : null;
      var e
    };
  lc.registerSaveRouter(bc), lc.registerLoadRouter(bc);
  var xc = function () {
    function t() {
      this.indexedDB = gc()
    }
    return t.prototype.listModels = function () {
      return r(this, void 0, void 0, function () {
        var t = this;
        return a(this, function (e) {
          return [2, new Promise(function (e, n) {
            var r = t.indexedDB.open("tensorflowjs", 1);
            r.onupgradeneeded = function () {
              return vc(r)
            }, r.onsuccess = function () {
              var t = r.result,
                a = t.transaction(mc, "readonly"),
                i = a.objectStore(mc).getAll();
              i.onsuccess = function () {
                for (var t = {}, n = 0, r = i.result; n < r.length; n++) {
                  var a = r[n];
                  t[a.modelPath] = a.modelArtifactsInfo
                }
                e(t)
              }, i.onerror = function (e) {
                return t.close(), n(i.error)
              }, a.oncomplete = function () {
                return t.close()
              }
            }, r.onerror = function (t) {
              return n(r.error)
            }
          })]
        })
      })
    }, t.prototype.removeModel = function (t) {
      return r(this, void 0, void 0, function () {
        var e = this;
        return a(this, function (n) {
          var r;
          return t = (r = t).startsWith(yc.URL_SCHEME) ? r.slice(yc.URL_SCHEME.length) : r, [2, new Promise(function (n, r) {
            var a = e.indexedDB.open("tensorflowjs", 1);
            a.onupgradeneeded = function () {
              return vc(a)
            }, a.onsuccess = function () {
              var e, i = a.result,
                o = i.transaction(mc, "readwrite"),
                s = o.objectStore(mc),
                u = s.get(t);
              u.onsuccess = function () {
                if (null == u.result) return i.close(), r(new Error("Cannot find model with path '" + t + "' in IndexedDB."));
                var a = s.delete(t),
                  o = function () {
                    var a = (e = i.transaction(dc, "readwrite")).objectStore(dc).delete(t);
                    a.onsuccess = function () {
                      return n(u.result.modelArtifactsInfo)
                    }, a.onerror = function (t) {
                      return r(u.error)
                    }
                  };
                a.onsuccess = o, a.onerror = function (t) {
                  return o(), i.close(), r(u.error)
                }
              }, u.onerror = function (t) {
                return i.close(), r(u.error)
              }, o.oncomplete = function () {
                null == e ? i.close() : e.oncomplete = function () {
                  return i.close()
                }
              }
            }, a.onerror = function (t) {
              return r(a.error)
            }
          })]
        })
      })
    }, t
  }();
  if (o().getBool("IS_BROWSER")) try {
    pc.registerManager(yc.URL_SCHEME, new xc)
  } catch (e) {}
  var wc = "/",
    Cc = "tensorflowjs_models",
    Nc = "info",
    Sc = "model_topology",
    kc = "weight_specs",
    Ic = "weight_data",
    Ec = "model_metadata";

  function Ac(t) {
    return {
      info: [Cc, t, Nc].join(wc),
      topology: [Cc, t, Sc].join(wc),
      weightSpecs: [Cc, t, kc].join(wc),
      weightData: [Cc, t, Ic].join(wc),
      modelMetadata: [Cc, t, Ec].join(wc)
    }
  }

  function Rc(t) {
    var e = t.split(wc);
    if (e.length < 3) throw new Error("Invalid key format: " + t);
    return e.slice(1, e.length - 1).join(wc)
  }
  var Tc = function () {
      function t(t) {
        if (!o().getBool("IS_BROWSER") || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
        if (this.LS = window.localStorage, null == t || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
        this.modelPath = t, this.keys = Ac(this.modelPath)
      }
      return t.prototype.save = function (t) {
        return r(this, void 0, void 0, function () {
          var e, n, r;
          return a(this, function (a) {
            if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
            e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), r = uc(t);
            try {
              return this.LS.setItem(this.keys.info, JSON.stringify(r)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function (t) {
                return ac ? Buffer.from(t).toString("base64") : btoa(String.fromCharCode.apply(null, new Uint8Array(t)))
              }(t.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
                format: t.format,
                generatedBy: t.generatedBy,
                convertedBy: t.convertedBy,
                userDefinedMetadata: t.userDefinedMetadata
              })), [2, {
                modelArtifactsInfo: r
              }]
            } catch (t) {
              throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + r.modelTopologyBytes + ", weightSpecsBytes=" + r.weightSpecsBytes + ", weightDataBytes=" + r.weightDataBytes + ".")
            }
            return [2]
          })
        })
      }, t.prototype.load = function () {
        return r(this, void 0, void 0, function () {
          var t, e, n, r, i, o, s;
          return a(this, function (a) {
            if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
            if ("JSON" !== t.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
            if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
            if (e.modelTopology = n, null == (r = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
            if (e.weightSpecs = r, null != (i = this.LS.getItem(this.keys.modelMetadata)) && (o = JSON.parse(i), e.format = o.format, e.generatedBy = o.generatedBy, e.convertedBy = o.convertedBy, e.userDefinedMetadata = o.userDefinedMetadata), null == (s = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
            return e.weightData = function (t) {
              if (ac) {
                var e = Buffer.from(t, "base64");
                return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength)
              }
              for (var n = atob(t), r = new Uint8Array(n.length), a = 0; a < n.length; ++a) r.set([n.charCodeAt(a)], a);
              return r.buffer
            }(s), [2, e]
          })
        })
      }, t.URL_SCHEME = "localstorage://", t
    }(),
    Dc = function (t) {
      return o().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Tc.URL_SCHEME) ? (e = t.slice(Tc.URL_SCHEME.length), new Tc(e)) : null;
      var e
    };
  lc.registerSaveRouter(Dc), lc.registerLoadRouter(Dc);
  var Oc = function () {
    function t() {
      b(o().getBool("IS_BROWSER"), function () {
        return "Current environment is not a web browser"
      }), b(void 0 !== window.localStorage, function () {
        return "Current browser does not appear to support localStorage"
      }), this.LS = window.localStorage
    }
    return t.prototype.listModels = function () {
      return r(this, void 0, void 0, function () {
        var t, e, n, r, i, o;
        return a(this, function (a) {
          for (t = {}, e = Cc + wc, n = wc + Nc, r = 0; r < this.LS.length; ++r)(i = this.LS.key(r)).startsWith(e) && i.endsWith(n) && (o = Rc(i), t[o] = JSON.parse(this.LS.getItem(i)));
          return [2, t]
        })
      })
    }, t.prototype.removeModel = function (t) {
      return r(this, void 0, void 0, function () {
        var e, n;
        return a(this, function (r) {
          var a;
          if (t = (a = t).startsWith(Tc.URL_SCHEME) ? a.slice(Tc.URL_SCHEME.length) : a, e = Ac(t), null == this.LS.getItem(e.info)) throw new Error("Cannot find model at path '" + t + "'");
          return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [2, n]
        })
      })
    }, t
  }();
  if (o().getBool("IS_BROWSER")) try {
    pc.registerManager(Tc.URL_SCHEME, new Oc)
  } catch (e) {}
  var _c = "model",
    Fc = ".json",
    Mc = ".weights.bin";

  function zc(t) {
    return new Promise(function (t) {
      return setTimeout(t)
    }).then(t)
  }
  var Lc = function () {
      function t(e) {
        if (!o().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = _c), this.modelTopologyFileName = e + Fc, this.weightDataFileName = e + Mc
      }
      return t.prototype.save = function (t) {
        return r(this, void 0, void 0, function () {
          var e, n, r, i, o, s;
          return a(this, function (a) {
            switch (a.label) {
              case 0:
                if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                if (e = window.URL.createObjectURL(new Blob([t.weightData], {
                    type: "application/octet-stream"
                  })), !(t.modelTopology instanceof ArrayBuffer)) return [3, 1];
                throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
              case 1:
                return n = [{
                  paths: ["./" + this.weightDataFileName],
                  weights: t.weightSpecs
                }], r = {
                  modelTopology: t.modelTopology,
                  format: t.format,
                  generatedBy: t.generatedBy,
                  convertedBy: t.convertedBy,
                  weightsManifest: n
                }, i = window.URL.createObjectURL(new Blob([JSON.stringify(r)], {
                  type: "application/json"
                })), (o = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, o.href = i, [4, zc(function () {
                  return o.dispatchEvent(new MouseEvent("click"))
                })];
              case 2:
                return a.sent(), null == t.weightData ? [3, 4] : ((s = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s.href = e, [4, zc(function () {
                  return s.dispatchEvent(new MouseEvent("click"))
                })]);
              case 3:
                a.sent(), a.label = 4;
              case 4:
                return [2, {
                  modelArtifactsInfo: uc(t)
                }]
            }
          })
        })
      }, t.URL_SCHEME = "downloads://", t
    }(),
    Bc = function () {
      function t(t) {
        if (null == t || t.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t);
        this.files = t
      }
      return t.prototype.load = function () {
        return r(this, void 0, void 0, function () {
          var t, e, n = this;
          return a(this, function (r) {
            return t = this.files[0], e = this.files.slice(1), [2, new Promise(function (r, a) {
              var i = new FileReader;
              i.onload = function (i) {
                var o = JSON.parse(i.target.result),
                  s = o.modelTopology;
                if (null != s) {
                  0 === e.length && r({
                    modelTopology: s
                  });
                  var u = o.weightsManifest;
                  if (null != u) {
                    var l;
                    try {
                      l = n.checkManifestAndWeightFiles(u, e)
                    } catch (t) {
                      return void a(t)
                    }
                    var c = [],
                      p = [],
                      h = [];
                    u.forEach(function (t) {
                      t.paths.forEach(function (t) {
                        p.push(t), h.push(null)
                      }), c.push.apply(c, t.weights)
                    }), u.forEach(function (t) {
                      t.paths.forEach(function (t) {
                        var e = new FileReader;
                        e.onload = function (e) {
                          var n = e.target.result,
                            a = p.indexOf(t);
                          h[a] = n, -1 === h.indexOf(null) && r({
                            modelTopology: s,
                            weightSpecs: c,
                            weightData: oc(h),
                            format: o.format,
                            generatedBy: o.generatedBy,
                            convertedBy: o.convertedBy,
                            userDefinedMetadata: o.userDefinedMetadata
                          })
                        }, e.onerror = function (e) {
                          return a("Failed to weights data from file of path '" + t + "'.")
                        }, e.readAsArrayBuffer(l[t])
                      })
                    })
                  } else a(new Error("weightManifest field is missing from file " + t.name))
                } else a(new Error("modelTopology field is missing from file " + t.name))
              }, i.onerror = function (e) {
                return a("Failed to read model topology and weights manifest JSON from file '" + t.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")
              }, i.readAsText(t)
            })]
          })
        })
      }, t.prototype.checkManifestAndWeightFiles = function (t, e) {
        for (var n = [], r = e.map(function (t) {
            return sc(t.name)
          }), a = {}, i = 0, o = t; i < o.length; i++) o[i].paths.forEach(function (t) {
          var i = sc(t);
          if (-1 !== n.indexOf(i)) throw new Error("Duplicate file basename found in weights manifest: '" + i + "'");
          if (n.push(i), -1 === r.indexOf(i)) throw new Error("Weight file with basename '" + i + "' is not provided.");
          a[t] = e[r.indexOf(i)]
        });
        if (n.length !== e.length) throw new Error("Mismatch in the number of files in weights manifest (" + n.length + ") and the number of weight files provided (" + e.length + ").");
        return a
      }, t
    }();

  function Pc(t, e, n, r) {
    ! function (t) {
      b(null != t && Array.isArray(t) && t.length > 0, function () {
        return "promises must be a none empty array"
      })
    }(t),
    function (t, e) {
      b(t >= 0 && t <= 1, function () {
        return "Progress fraction must be in range [0, 1], but got startFraction " + t
      }), b(e >= 0 && e <= 1, function () {
        return "Progress fraction must be in range [0, 1], but got endFraction " + e
      }), b(e >= t, function () {
        return "startFraction must be no more than endFraction, but got startFraction " + t + " and endFraction " + e
      })
    }(n = null == n ? 0 : n, r = null == r ? 1 : r);
    var a = 0;
    return Promise.all(t.map(function (i) {
      return i.then(function (i) {
        var o = n + ++a / t.length * (r - n);
        return e(o), i
      }), i
    }))
  }

  function Wc(t, e) {
    return r(this, void 0, void 0, function () {
      var n, r, i, s, u, l, c, p, h;
      return a(this, function (a) {
        switch (a.label) {
          case 0:
            return null == e && (e = {}), n = null == e.fetchFunc ? o().platform.fetch : e.fetchFunc, r = t.map(function (t) {
              return n(t, e.requestInit, {
                isBinary: !0
              })
            }), i = 0, s = .5, null != e.onProgress ? [3, 2] : [4, Promise.all(r)];
          case 1:
            return u = a.sent(), [3, 4];
          case 2:
            return [4, Pc(r, e.onProgress, i, s)];
          case 3:
            u = a.sent(), a.label = 4;
          case 4:
            return l = u.map(function (t) {
              return t.arrayBuffer()
            }), c = .5, p = 1, null != e.onProgress ? [3, 6] : [4, Promise.all(l)];
          case 5:
            return h = a.sent(), [3, 8];
          case 6:
            return [4, Pc(l, e.onProgress, c, p)];
          case 7:
            h = a.sent(), a.label = 8;
          case 8:
            return [2, h]
        }
      })
    })
  }

  function Vc(t) {
    var e = this;
    return function (n, i, o) {
      return void 0 === i && (i = ""), r(e, void 0, void 0, function () {
        var e, r, s, u, l, c, p, h, f, d;
        return a(this, function (a) {
          switch (a.label) {
            case 0:
              if (e = n.map(function () {
                  return !1
                }), r = {}, s = null != o ? o.map(function () {
                  return !1
                }) : [], u = [], n.forEach(function (t, n) {
                  var a = 0;
                  t.weights.forEach(function (t) {
                    var i = "quantization" in t ? t.quantization.dtype : t.dtype,
                      l = ec[i] * N(t.shape),
                      c = function () {
                        e[n] = !0, null == r[n] && (r[n] = []), r[n].push({
                          manifestEntry: t,
                          groupOffset: a,
                          sizeBytes: l
                        })
                      };
                    null != o ? o.forEach(function (e, n) {
                      e === t.name && (c(), s[n] = !0)
                    }) : c(), u.push(t.name), a += l
                  })
                }), !s.every(function (t) {
                  return t
                })) throw l = o.filter(function (t, e) {
                return !s[e]
              }), new Error("Could not find weights in manifest with names: " + l.join(", ") + ". \nManifest JSON has weights with names: " + u.join(", ") + ".");
              return c = e.reduce(function (t, e, n) {
                return e && t.push(n), t
              }, []), p = [], c.forEach(function (t) {
                n[t].paths.forEach(function (t) {
                  var e = i + (i.endsWith("/") ? "" : "/") + t;
                  p.push(e)
                })
              }), [4, t(p)];
            case 1:
              return h = a.sent(), f = {}, d = 0, c.forEach(function (t) {
                for (var e = n[t].paths.length, a = 0, i = 0; i < e; i++) a += h[d + i].byteLength;
                for (var o = new ArrayBuffer(a), s = new Uint8Array(o), u = 0, l = 0; l < e; l++) {
                  var c = new Uint8Array(h[d + l]);
                  s.set(c, u), u += c.byteLength
                }
                r[t].forEach(function (t) {
                  var e = rc(o.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry]);
                  for (var n in e) f[n] = e[n]
                }), d += e
              }), [2, f]
          }
        })
      })
    }
  }
  lc.registerSaveRouter(function (t) {
    return o().getBool("IS_BROWSER") && !Array.isArray(t) && t.startsWith(Lc.URL_SCHEME) ? function (t) {
      return void 0 === t && (t = "model"), new Lc(t)
    }(t.slice(Lc.URL_SCHEME.length)) : null
  });
  var Uc = function () {
    function t(t, e) {
      if (this.DEFAULT_METHOD = "POST", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (b("function" == typeof e.fetchFunc, function () {
          return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"
        }), this.fetch = e.fetchFunc) : this.fetch = o().platform.fetch, b(null != t && t.length > 0, function () {
          return "URL path for http must not be null, undefined or empty."
        }), Array.isArray(t) && b(2 === t.length, function () {
          return "URL paths for http must have a length of 2, (actual length is " + t.length + ")."
        }), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
      this.requestInit = e.requestInit || {}
    }
    return t.prototype.save = function (t) {
      return r(this, void 0, void 0, function () {
        var e, n, r, i;
        return a(this, function (a) {
          switch (a.label) {
            case 0:
              if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
              return (e = Object.assign({
                method: this.DEFAULT_METHOD
              }, this.requestInit)).body = new FormData, n = [{
                paths: ["./model.weights.bin"],
                weights: t.weightSpecs
              }], r = {
                modelTopology: t.modelTopology,
                format: t.format,
                generatedBy: t.generatedBy,
                convertedBy: t.convertedBy,
                userDefinedMetadata: t.userDefinedMetadata,
                weightsManifest: n
              }, e.body.append("model.json", new Blob([JSON.stringify(r)], {
                type: "application/json"
              }), "model.json"), null != t.weightData && e.body.append("model.weights.bin", new Blob([t.weightData], {
                type: "application/octet-stream"
              }), "model.weights.bin"), [4, this.fetch(this.path, e)];
            case 1:
              if ((i = a.sent()).ok) return [2, {
                modelArtifactsInfo: uc(t),
                responses: [i]
              }];
              throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + i.status + ".")
          }
        })
      })
    }, t.prototype.load = function () {
      return r(this, void 0, void 0, function () {
        var t, e, n, r, i, o, s, u, l, c, p, h;
        return a(this, function (a) {
          switch (a.label) {
            case 0:
              return [4, this.fetch(this.path, this.requestInit)];
            case 1:
              if (!(t = a.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t.status + ". Please verify this URL points to the model JSON of the model to load.");
              a.label = 2;
            case 2:
              return a.trys.push([2, 4, , 5]), [4, t.json()];
            case 3:
              return e = a.sent(), [3, 5];
            case 4:
              throw a.sent(), n = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n += " Please make sure the server is serving valid JSON for this request.", new Error(n);
            case 5:
              if (r = e.modelTopology, i = e.weightsManifest, o = e.generatedBy, s = e.convertedBy, u = e.format, l = e.userDefinedMetadata, null == r && null == i) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
              return null == i ? [3, 7] : [4, this.loadWeights(i)];
            case 6:
              h = a.sent(), c = h[0], p = h[1], a.label = 7;
            case 7:
              return [2, {
                modelTopology: r,
                weightSpecs: c,
                weightData: p,
                userDefinedMetadata: l,
                generatedBy: o,
                convertedBy: s,
                format: u
              }]
          }
        })
      })
    }, t.prototype.loadWeights = function (t) {
      return r(this, void 0, void 0, function () {
        var e, n, r, i, o, s, u, l, c, p, h;
        return a(this, function (a) {
          switch (a.label) {
            case 0:
              for (e = Array.isArray(this.path) ? this.path[1] : this.path, n = function (t) {
                  var e = t.lastIndexOf("/"),
                    n = t.lastIndexOf("?");
                  return [t.substring(0, e) + "/", n > e ? t.substring(n) : ""]
                }(e), r = n[0], i = n[1], o = this.weightPathPrefix || r, s = [], u = 0, l = t; u < l.length; u++) c = l[u], s.push.apply(s, c.weights);
              return p = [], t.forEach(function (t) {
                t.paths.forEach(function (t) {
                  p.push(o + t + i)
                })
              }), [4, Wc(p, {
                requestInit: this.requestInit,
                fetchFunc: this.fetch,
                onProgress: this.onProgress
              })];
            case 1:
              return h = a.sent(), [2, [s, oc(h)]]
          }
        })
      })
    }, t.URL_SCHEME_REGEX = /^https?:\/\//, t
  }();

  function jc(t) {
    return null != t.match(Uc.URL_SCHEME_REGEX)
  }
  var Gc = function (t, e) {
    return "undefined" == typeof fetch ? null : (Array.isArray(t) ? t.every(function (t) {
      return jc(t)
    }) : jc(t)) ? qc(t, {
      onProgress: e
    }) : null
  };

  function qc(t, e) {
    return new Uc(t, e)
  }
  lc.registerSaveRouter(Gc), lc.registerLoadRouter(Gc);
  var Hc, Kc = function () {
      function t(t) {
        this.modelArtifacts = t
      }
      return t.prototype.load = function () {
        return r(this, void 0, void 0, function () {
          return a(this, function (t) {
            return [2, this.modelArtifacts]
          })
        })
      }, t
    }(),
    Xc = function () {
      function t(t) {
        this.saveHandler = t
      }
      return t.prototype.save = function (t) {
        return r(this, void 0, void 0, function () {
          return a(this, function (e) {
            return [2, this.saveHandler(t)]
          })
        })
      }, t
    }(),
    $c = Object.freeze({
      browserFiles: function (t) {
        return new Bc(t)
      },
      browserHTTPRequest: function (t, e) {
        return qc(t, e)
      },
      concatenateArrayBuffers: oc,
      decodeWeights: rc,
      encodeWeights: function (t, e) {
        return r(this, void 0, void 0, function () {
          var n, i, o, s, u, l = this;
          return a(this, function (c) {
            switch (c.label) {
              case 0:
                for (n = [], i = [], o = Array.isArray(t) ? t.map(function (t) {
                    return t.name
                  }) : Object.keys(t), s = function (s) {
                    var u = o[s],
                      c = Array.isArray(t) ? t[s].tensor : t[u];
                    if ("float32" !== c.dtype && "int32" !== c.dtype && "bool" !== c.dtype && "string" !== c.dtype) throw new Error("Unsupported dtype in weight '" + u + "': " + c.dtype);
                    var p = {
                      name: u,
                      shape: c.shape,
                      dtype: c.dtype
                    };
                    if ("string" === c.dtype) {
                      var h = new Promise(function (t) {
                        return r(l, void 0, void 0, function () {
                          var e, n, r, i, o, s, u;
                          return a(this, function (a) {
                            switch (a.label) {
                              case 0:
                                return [4, c.bytes()];
                              case 1:
                                for (e = a.sent(), n = e.reduce(function (t, e) {
                                    return t + e.length
                                  }, 0) + nc * e.length, r = new Uint8Array(n), i = 0, o = 0; o < e.length; o++) s = e[o], u = new Uint8Array(new Uint32Array([s.length]).buffer), r.set(u, i), i += nc, r.set(s, i), i += s.length;
                                return t(r), [2]
                            }
                          })
                        })
                      });
                      i.push(h)
                    } else i.push(c.data());
                    null != e && (p.group = e), n.push(p)
                  }, u = 0; u < o.length; ++u) s(u);
                return [4, Promise.all(i)];
              case 1:
                return [2, {
                  data: function (t) {
                    if (null === t) throw new Error("Invalid input value: " + JSON.stringify(t));
                    var e = 0,
                      n = [];
                    t.forEach(function (t) {
                      if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t.constructor.name)
                    });
                    var r = new Uint8Array(e),
                      a = 0;
                    return n.forEach(function (t) {
                      r.set(new Uint8Array(t.buffer), a), a += t.byteLength
                    }), r.buffer
                  }(c.sent()),
                  specs: n
                }]
            }
          })
        })
      },
      fromMemory: function (t, e, n, r) {
        return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new Kc(t) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Kc({
          modelTopology: t
        })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Kc({
          modelTopology: t,
          weightSpecs: e,
          weightData: n,
          trainingConfig: r
        }))
      },
      getLoadHandlers: function (t, e) {
        return lc.getLoadHandlers(t, e)
      },
      getModelArtifactsInfoForJSON: uc,
      getSaveHandlers: function (t) {
        return lc.getSaveHandlers(t)
      },
      http: qc,
      isHTTPScheme: jc,
      loadWeights: function (t, e, n, i) {
        return void 0 === e && (e = ""), r(this, void 0, void 0, function () {
          return a(this, function (r) {
            return [2, Vc(function (t) {
              return Wc(t, {
                requestInit: i
              })
            })(t, e, n)]
          })
        })
      },
      registerLoadRouter: function (t) {
        return lc.registerLoadRouter(t)
      },
      registerSaveRouter: function (t) {
        return lc.registerSaveRouter(t)
      },
      weightsLoaderFactory: Vc,
      withSaveHandler: function (t) {
        return new Xc(t)
      },
      copyModel: function (t, e) {
        return r(this, void 0, void 0, function () {
          return a(this, function (n) {
            return [2, fc(t, e, !1)]
          })
        })
      },
      listModels: function () {
        return r(this, void 0, void 0, function () {
          var t, e, n, r, i, o, s;
          return a(this, function (a) {
            switch (a.label) {
              case 0:
                t = pc.getSchemes(), e = {}, n = 0, r = t, a.label = 1;
              case 1:
                return n < r.length ? (i = r[n], [4, pc.getManager(i).listModels()]) : [3, 4];
              case 2:
                for (s in o = a.sent()) e[i + cc + s] = o[s];
                a.label = 3;
              case 3:
                return n++, [3, 1];
              case 4:
                return [2, e]
            }
          })
        })
      },
      moveModel: function (t, e) {
        return r(this, void 0, void 0, function () {
          return a(this, function (n) {
            return [2, fc(t, e, !0)]
          })
        })
      },
      removeModel: function (t) {
        return r(this, void 0, void 0, function () {
          var e;
          return a(this, function (n) {
            return e = hc(t), [2, pc.getManager(e.scheme).removeModel(e.path)]
          })
        })
      }
    }),
    Yc = on({
      confusionMatrix_: function (t, e, n) {
        var r = Ke(t, "labels", "confusionMatrix"),
          a = Ke(e, "predictions", "confusionMatrix");
        b(null == n || n > 0 && Number.isInteger(n), function () {
          return "If provided, numClasses must be a positive integer, but got " + n
        }), b(1 === r.rank, function () {
          return "Expected the rank of labels to be 1, but got " + r.rank
        }), b(1 === a.rank, function () {
          return "Expected the rank of predictions to be 1, but got " + a.rank
        }), b(r.shape[0] === a.shape[0], function () {
          return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + a.shape[0] + ". Labels and predictions should have the same number of elements."
        }), b(n > 0 && Number.isInteger(n), function () {
          return "numClasses is required to be a positive integer, but got " + n
        });
        var i = nr(r.asType("int32"), n),
          o = nr(a.asType("int32"), n);
        return i.transpose().matMul(o).asType("int32")
      }
    }),
    Jc = Object.freeze({
      confusionMatrix: Yc
    }),
    Zc = on({
      fromPixels_: function (t, e) {
        if (void 0 === e && (e = 3), e > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
        if (null == t) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
        var n = !1,
          r = !1,
          a = !1,
          i = !1,
          o = !1;
        if (t.data instanceof Uint8Array) n = !0;
        else if ("undefined" != typeof ImageData && t instanceof ImageData) r = !0;
        else if ("undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement) a = !0;
        else if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) i = !0;
        else {
          if (null == t.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t.constructor.name);
          o = !0
        }
        if (a && a && t.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
        if (null != l("FromPixels", Dt.backendName)) return Dt.runKernel("FromPixels", {
          pixels: t
        }, {
          numChannels: e
        });
        var s, u, c = a ? [t.videoWidth, t.videoHeight] : [t.width, t.height],
          p = c[0],
          h = c[1];
        if (o ? s = t.getContext("2d").getImageData(0, 0, p, h).data : r || n ? s = t.data : (i || a) && (null == Hc && (Hc = document.createElement("canvas").getContext("2d")), Hc.canvas.width = p, Hc.canvas.height = h, Hc.drawImage(t, 0, 0, p, h), s = Hc.getImageData(0, 0, p, h).data), 4 === e) u = new Int32Array(s);
        else {
          var f = p * h;
          u = new Int32Array(f * e);
          for (var d = 0; d < f; d++)
            for (var m = 0; m < e; ++m) u[d * e + m] = s[4 * d + m]
        }
        return mn(u, [h, p, e], "int32")
      }
    }),
    Qc = Object.freeze({
      toPixels: function (t, e) {
        return r(this, void 0, void 0, function () {
          var n, r, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, C, N, S, k;
          return a(this, function (a) {
            switch (a.label) {
              case 0:
                if (n = Ke(t, "img", "toPixels"), t instanceof mt || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n.rank + ".");
                if (r = n.shape.slice(0, 2), i = r[0], o = r[1], (s = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === s) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + s);
                return [4, n.data()];
              case 1:
                return u = a.sent(), l = n.min(), c = n.max(), [4, Promise.all([l.data(), c.data()])];
              case 2:
                if (p = a.sent(), h = p[0], f = p[1], d = h[0], m = f[0], l.dispose(), c.dispose(), "float32" === n.dtype) {
                  if (d < 0 || m > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + d + " - " + m + "].")
                } else {
                  if ("int32" !== n.dtype) throw new Error("Unsupported type for toPixels: " + n.dtype + ". Please use float32 or int32 tensors.");
                  if (d < 0 || m > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + d + " - " + m + "].")
                }
                for (g = "float32" === n.dtype ? 255 : 1, v = new Uint8ClampedArray(o * i * 4), y = 0; y < i * o; ++y) b = void 0, x = void 0, w = void 0, C = void 0, 1 === s ? (b = u[y] * g, x = u[y] * g, w = u[y] * g, C = 255) : 3 === s ? (b = u[3 * y] * g, x = u[3 * y + 1] * g, w = u[3 * y + 2] * g, C = 255) : 4 === s && (b = u[4 * y] * g, x = u[4 * y + 1] * g, w = u[4 * y + 2] * g, C = u[4 * y + 3] * g), v[0 + (N = 4 * y)] = Math.round(b), v[N + 1] = Math.round(x), v[N + 2] = Math.round(w), v[N + 3] = Math.round(C);
                return null != e && (e.width = o, e.height = i, S = e.getContext("2d"), k = new ImageData(v, o, i), S.putImageData(k, 0, 0)), n !== t && n.dispose(), [2, v]
            }
          })
        })
      },
      fromPixels: Zc
    }),
    tp = function () {
      function t() {}
      return t.prototype.getClassName = function () {
        return this.constructor.className
      }, t.fromConfig = function (t, e) {
        return new t(e)
      }, t
    }(),
    ep = function () {
      function t() {
        this.classNameMap = {}
      }
      return t.getMap = function () {
        return null == t.instance && (t.instance = new t), t.instance
      }, t.register = function (e) {
        t.getMap().classNameMap[e.className] = [e, e.fromConfig]
      }, t
    }();

  function np(t) {
    b(null != t.className, function () {
      return "Class being registered does not have the static className property defined."
    }), b("string" == typeof t.className, function () {
      return "className is required to be a string, but got type " + typeof t.className
    }), b(t.className.length > 0, function () {
      return "Class being registered has an empty-string as its className, which is disallowed."
    }), ep.register(t)
  }
  var rp = Object.freeze({
      Serializable: tp,
      SerializationMap: ep,
      registerClass: np
    }),
    ap = .001,
    ip = .1;

  function op() {
    return 32 === Dt.backend.floatPrecision() ? ap : ip
  }

  function sp(t, e, n) {
    var r = !0;
    if ((B(t) || B(e)) && (r = !1), B(t) && B(e) && (r = !0), r) {
      var a = t.constructor.name,
        i = e.constructor.name;
      if (a !== i) throw new Error("Arrays are of different type. Actual: " + a + ". Expected: " + i)
    }
    if (Array.isArray(t) && Array.isArray(e)) {
      var o = qe(t),
        s = qe(e);
      if (!S(o, s)) throw new Error("Arrays have different shapes. Actual: [" + o + "]. Expected: [" + s + "]")
    }
    var u = B(t) ? t : C(t),
      l = B(e) ? e : C(e);
    if (u.length !== l.length) throw new Error("Arrays have different lengths actual: " + u.length + " vs expected: " + l.length + ".\nActual:   " + u + ".\nExpected: " + l + ".");
    for (var c = 0; c < l.length; ++c) {
      var p = u[c],
        h = l[c];
      if (!n(p, h)) throw new Error("Arrays differ: actual[" + c + "] = " + p + ", expected[" + c + "] = " + h + ".\nActual:   " + u + ".\nExpected: " + l + ".")
    }
  }

  function up(t, e, n) {
    return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n)
  }
  var lp = Object.freeze({
      TEST_EPSILON_FLOAT16: ip,
      expectArraysClose: function (t, e, n) {
        return null == n && (n = op()), sp(t, e, function (t, e) {
          return up(t, e, n)
        })
      },
      testEpsilon: op,
      expectPromiseToFail: function (t, e) {
        t().then(function () {
          return e.fail()
        }, function () {
          return e()
        })
      },
      expectArraysEqual: function (t, e) {
        var n = "string" == typeof e || "number" == typeof e || "boolean" == typeof e ? [e] : e;
        return V(t) || V(t[0]) || V(e) || V(e[0]) ? sp(t, n, function (t, e) {
          return t == e
        }) : sp(t, e, function (t, e) {
          return up(t, e, 0)
        })
      },
      expectNumbersClose: function (t, e, n) {
        if (null == n && (n = op()), !up(t, e, n)) throw new Error("Numbers differ: actual === " + t + ", expected === " + e)
      },
      expectValuesInRange: function (t, e, n) {
        for (var r = 0; r < t.length; r++)
          if (t[r] < e || t[r] > n) throw new Error("Value out of range:" + t[r] + " low: " + e + ", high: " + n)
      },
      expectArrayBuffersEqual: function (t, e) {
        expect(new Float32Array(t)).toEqual(new Float32Array(e))
      }
    }),
    cp = Object.freeze({
      gpgpu_util: Ni,
      webgl_util: ze,
      forceHalfFloat: function () {
        o().set("WEBGL_FORCE_F16_TEXTURES", !0)
      },
      MathBackendWebGL: oo,
      setWebGLContext: Pt,
      GPGPUContext: Si
    }),
    pp = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return n(e, t), e.prototype.minimize = function (t, e, n) {
        void 0 === e && (e = !1);
        var r = this.computeGradients(t, n),
          a = r.value,
          i = r.grads;
        if (null != n) {
          var o = n.map(function (t) {
            return {
              name: t.name,
              tensor: i[t.name]
            }
          });
          this.applyGradients(o)
        } else this.applyGradients(i);
        return Ve(i), e ? a : (a.dispose(), null)
      }, Object.defineProperty(e.prototype, "iterations", {
        get: function () {
          return null == this.iterations_ && (this.iterations_ = 0), this.iterations_
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.incrementIterations = function () {
        this.iterations_ = this.iterations + 1
      }, e.prototype.computeGradients = function (t, e) {
        return Lr(t, e)
      }, e.prototype.dispose = function () {
        null != this.iterations_ && Ve(this.iterations_)
      }, e.prototype.saveIterations = function () {
        return r(this, void 0, void 0, function () {
          return a(this, function (t) {
            return null == this.iterations_ && (this.iterations_ = 0), [2, {
              name: "iter",
              tensor: hn(this.iterations_, "int32")
            }]
          })
        })
      }, e.prototype.getWeights = function () {
        return r(this, void 0, void 0, function () {
          return a(this, function (t) {
            throw new Error("getWeights() is not implemented for this optimizer yet.")
          })
        })
      }, e.prototype.setWeights = function (t) {
        return r(this, void 0, void 0, function () {
          return a(this, function (t) {
            throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName())
          })
        })
      }, e.prototype.extractIterations = function (t) {
        return r(this, void 0, void 0, function () {
          var e;
          return a(this, function (n) {
            switch (n.label) {
              case 0:
                return e = this, [4, t[0].tensor.data()];
              case 1:
                return e.iterations_ = n.sent()[0], [2, t.slice(1)]
            }
          })
        })
      }, e
    }(tp);
  Object.defineProperty(pp, Symbol.hasInstance, {
    value: function (t) {
      return null != t.minimize && null != t.computeGradients && null != t.applyGradients
    }
  });
  var hp = function (t) {
    function e(e, n, r) {
      void 0 === r && (r = null);
      var a = t.call(this) || this;
      return a.learningRate = e, a.rho = n, a.epsilon = r, a.accumulatedGrads = [], a.accumulatedUpdates = [], null == r && (a.epsilon = Dt.backend.epsilon()), a
    }
    return n(e, t), e.prototype.applyGradients = function (t) {
      var e = this;
      (Array.isArray(t) ? t.map(function (t) {
        return t.name
      }) : Object.keys(t)).forEach(function (n, r) {
        var a = Dt.registeredVariables[n];
        null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
          originalName: n + "/accum_grad",
          variable: We(function () {
            return In(a).variable(!1)
          })
        }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {
          originalName: n + "/accum_var",
          variable: We(function () {
            return In(a).variable(!1)
          })
        });
        var i = Array.isArray(t) ? t[r].tensor : t[n];
        if (null != i) {
          var o = e.accumulatedGrads[r].variable,
            s = e.accumulatedUpdates[r].variable;
          We(function () {
            var t = o.mul(e.rho).add(i.square().mul(1 - e.rho)),
              n = s.add(e.epsilon).sqrt().div(o.add(e.epsilon).sqrt()).mul(i),
              r = s.mul(e.rho).add(n.square().mul(1 - e.rho));
            o.assign(t), s.assign(r);
            var u = n.mul(-e.learningRate).add(a);
            a.assign(u)
          })
        }
      }), this.incrementIterations()
    }, e.prototype.dispose = function () {
      null != this.accumulatedUpdates && (Ve(this.accumulatedGrads.map(function (t) {
        return t.variable
      })), Ve(this.accumulatedUpdates.map(function (t) {
        return t.variable
      })))
    }, e.prototype.getWeights = function () {
      return r(this, void 0, void 0, function () {
        var t;
        return a(this, function (e) {
          switch (e.label) {
            case 0:
              return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
            case 1:
              return [2, [e.sent()].concat(t.map(function (t) {
                return {
                  name: t.originalName,
                  tensor: t.variable
                }
              }))]
          }
        })
      })
    }, e.prototype.setWeights = function (t) {
      return r(this, void 0, void 0, function () {
        var e;
        return a(this, function (n) {
          switch (n.label) {
            case 0:
              return [4, this.extractIterations(t)];
            case 1:
              return t = n.sent(), e = t.length / 2, this.accumulatedGrads = t.slice(0, e).map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              }), this.accumulatedUpdates = t.slice(e, 2 * e).map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              }), [2]
          }
        })
      })
    }, e.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate,
        rho: this.rho,
        epsilon: this.epsilon
      }
    }, e.fromConfig = function (t, e) {
      return new t(e.learningRate, e.rho, e.epsilon)
    }, e.className = "Adadelta", e
  }(pp);
  np(hp);
  var fp = function (t) {
    function e(e, n) {
      void 0 === n && (n = .1);
      var r = t.call(this) || this;
      return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r
    }
    return n(e, t), e.prototype.applyGradients = function (t) {
      var e = this;
      (Array.isArray(t) ? t.map(function (t) {
        return t.name
      }) : Object.keys(t)).forEach(function (n, r) {
        var a = Dt.registeredVariables[n];
        null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {
          originalName: n + "/accumulator",
          variable: We(function () {
            return Cn(a.shape, e.initialAccumulatorValue).variable(!1)
          })
        });
        var i = Array.isArray(t) ? t[r].tensor : t[n];
        if (null != i) {
          var o = e.accumulatedGrads[r].variable;
          We(function () {
            var t = o.add(i.square());
            o.assign(t);
            var n = i.div(t.add(Dt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(a);
            a.assign(n)
          })
        }
      }), this.incrementIterations()
    }, e.prototype.dispose = function () {
      null != this.accumulatedGrads && Ve(this.accumulatedGrads.map(function (t) {
        return t.variable
      }))
    }, e.prototype.getWeights = function () {
      return r(this, void 0, void 0, function () {
        return a(this, function (t) {
          switch (t.label) {
            case 0:
              return [4, this.saveIterations()];
            case 1:
              return [2, [t.sent()].concat(this.accumulatedGrads.map(function (t) {
                return {
                  name: t.originalName,
                  tensor: t.variable
                }
              }))]
          }
        })
      })
    }, e.prototype.setWeights = function (t) {
      return r(this, void 0, void 0, function () {
        return a(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.extractIterations(t)];
            case 1:
              return t = e.sent(), this.accumulatedGrads = t.map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              }), [2]
          }
        })
      })
    }, e.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate,
        initialAccumulatorValue: this.initialAccumulatorValue
      }
    }, e.fromConfig = function (t, e) {
      return new t(e.learningRate, e.initialAccumulatorValue)
    }, e.className = "Adagrad", e
  }(pp);
  np(fp);
  var dp = function (t) {
    function e(e, n, r, a) {
      void 0 === a && (a = null);
      var i = t.call(this) || this;
      return i.learningRate = e, i.beta1 = n, i.beta2 = r, i.epsilon = a, i.accumulatedFirstMoment = [], i.accumulatedSecondMoment = [], We(function () {
        i.accBeta1 = hn(n).variable(), i.accBeta2 = hn(r).variable()
      }), null == a && (i.epsilon = Dt.backend.epsilon()), i
    }
    return n(e, t), e.prototype.applyGradients = function (t) {
      var e = this,
        n = Array.isArray(t) ? t.map(function (t) {
          return t.name
        }) : Object.keys(t);
      We(function () {
        var r = Rs(1, e.accBeta1),
          a = Rs(1, e.accBeta2);
        n.forEach(function (n, i) {
          var o = Dt.registeredVariables[n];
          null == e.accumulatedFirstMoment[i] && (e.accumulatedFirstMoment[i] = {
            originalName: n + "/m",
            variable: We(function () {
              return In(o).variable(!1)
            })
          }), null == e.accumulatedSecondMoment[i] && (e.accumulatedSecondMoment[i] = {
            originalName: n + "/v",
            variable: We(function () {
              return In(o).variable(!1)
            })
          });
          var s = Array.isArray(t) ? t[i].tensor : t[n];
          if (null != s) {
            var u = e.accumulatedFirstMoment[i].variable,
              l = e.accumulatedSecondMoment[i].variable,
              c = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
              p = l.mul(e.beta2).add(s.square().mul(1 - e.beta2)),
              h = c.div(r),
              f = p.div(a);
            u.assign(c), l.assign(p);
            var d = h.div(f.sqrt().add(e.epsilon)).mul(-e.learningRate).add(o);
            o.assign(d)
          }
        }), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2))
      }), this.incrementIterations()
    }, e.prototype.dispose = function () {
      this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Ve(this.accumulatedFirstMoment.map(function (t) {
        return t.variable
      })), null != this.accumulatedSecondMoment && Ve(this.accumulatedSecondMoment.map(function (t) {
        return t.variable
      }))
    }, e.prototype.getWeights = function () {
      return r(this, void 0, void 0, function () {
        var t;
        return a(this, function (e) {
          switch (e.label) {
            case 0:
              return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
            case 1:
              return [2, [e.sent()].concat(t.map(function (t) {
                return {
                  name: t.originalName,
                  tensor: t.variable
                }
              }))]
          }
        })
      })
    }, e.prototype.setWeights = function (t) {
      return r(this, void 0, void 0, function () {
        var e, n = this;
        return a(this, function (r) {
          switch (r.label) {
            case 0:
              return [4, this.extractIterations(t)];
            case 1:
              return t = r.sent(), We(function () {
                n.accBeta1.assign(ks(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(ks(n.beta2, n.iterations_ + 1))
              }), e = t.length / 2, this.accumulatedFirstMoment = t.slice(0, e).map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              }), this.accumulatedSecondMoment = t.slice(e, 2 * e).map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              }), [2]
          }
        })
      })
    }, e.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon
      }
    }, e.fromConfig = function (t, e) {
      return new t(e.learningRate, e.beta1, e.beta2, e.epsilon)
    }, e.className = "Adam", e
  }(pp);
  np(dp);
  var mp = function (t) {
    function e(e, n, r, a, i) {
      void 0 === a && (a = null), void 0 === i && (i = 0);
      var o = t.call(this) || this;
      return o.learningRate = e, o.beta1 = n, o.beta2 = r, o.epsilon = a, o.decay = i, o.accumulatedFirstMoment = [], o.accumulatedWeightedInfNorm = [], We(function () {
        o.iteration = hn(0).variable(), o.accBeta1 = hn(n).variable()
      }), null == a && (o.epsilon = Dt.backend.epsilon()), o
    }
    return n(e, t), e.prototype.applyGradients = function (t) {
      var e = this,
        n = Array.isArray(t) ? t.map(function (t) {
          return t.name
        }) : Object.keys(t);
      We(function () {
        var r = Rs(1, e.accBeta1),
          a = fs(-e.learningRate, e.iteration.mul(e.decay).add(1));
        n.forEach(function (n, i) {
          var o = Dt.registeredVariables[n];
          null == e.accumulatedFirstMoment[i] && (e.accumulatedFirstMoment[i] = {
            originalName: n + "/m",
            variable: In(o).variable(!1)
          }), null == e.accumulatedWeightedInfNorm[i] && (e.accumulatedWeightedInfNorm[i] = {
            originalName: n + "/v",
            variable: In(o).variable(!1)
          });
          var s = Array.isArray(t) ? t[i].tensor : t[n];
          if (null != s) {
            var u = e.accumulatedFirstMoment[i].variable,
              l = e.accumulatedWeightedInfNorm[i].variable,
              c = u.mul(e.beta1).add(s.mul(1 - e.beta1)),
              p = l.mul(e.beta2),
              h = s.abs(),
              f = p.maximum(h);
            u.assign(c), l.assign(f);
            var d = a.div(r).mul(c.div(f.add(e.epsilon))).add(o);
            o.assign(d)
          }
        }), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1))
      }), this.incrementIterations()
    }, e.prototype.dispose = function () {
      this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Ve(this.accumulatedFirstMoment.map(function (t) {
        return t.variable
      })), null != this.accumulatedWeightedInfNorm && Ve(this.accumulatedWeightedInfNorm.map(function (t) {
        return t.variable
      }))
    }, e.prototype.getWeights = function () {
      return r(this, void 0, void 0, function () {
        return a(this, function (t) {
          throw new Error("getWeights() is not implemented for Adamax yet.")
        })
      })
    }, e.prototype.setWeights = function (t) {
      return r(this, void 0, void 0, function () {
        return a(this, function (t) {
          throw new Error("setWeights() is not implemented for Adamax yet.")
        })
      })
    }, e.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon,
        decay: this.decay
      }
    }, e.fromConfig = function (t, e) {
      return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay)
    }, e.className = "Adamax", e
  }(pp);
  np(mp);
  var gp = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      return n.learningRate = e, n.setLearningRate(e), n
    }
    return n(e, t), e.prototype.applyGradients = function (t) {
      var e = this;
      (Array.isArray(t) ? t.map(function (t) {
        return t.name
      }) : Object.keys(t)).forEach(function (n, r) {
        var a = Array.isArray(t) ? t[r].tensor : t[n];
        if (null != a) {
          var i = Dt.registeredVariables[n];
          We(function () {
            var t = e.c.mul(a).add(i);
            i.assign(t)
          })
        }
      }), this.incrementIterations()
    }, e.prototype.setLearningRate = function (t) {
      this.learningRate = t, null != this.c && this.c.dispose(), this.c = Ue(hn(-t))
    }, e.prototype.dispose = function () {
      this.c.dispose()
    }, e.prototype.getWeights = function () {
      return r(this, void 0, void 0, function () {
        return a(this, function (t) {
          switch (t.label) {
            case 0:
              return [4, this.saveIterations()];
            case 1:
              return [2, [t.sent()]]
          }
        })
      })
    }, e.prototype.setWeights = function (t) {
      return r(this, void 0, void 0, function () {
        return a(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.extractIterations(t)];
            case 1:
              if (0 !== (t = e.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
              return [2]
          }
        })
      })
    }, e.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate
      }
    }, e.fromConfig = function (t, e) {
      return new t(e.learningRate)
    }, e.className = "SGD", e
  }(pp);
  np(gp);
  var vp = function (t) {
    function e(e, n, r) {
      void 0 === r && (r = !1);
      var a = t.call(this, e) || this;
      return a.learningRate = e, a.momentum = n, a.useNesterov = r, a.accumulations = [], a.m = hn(a.momentum), a
    }
    return n(e, t), e.prototype.applyGradients = function (t) {
      var e = this;
      (Array.isArray(t) ? t.map(function (t) {
        return t.name
      }) : Object.keys(t)).forEach(function (n, r) {
        var a = Dt.registeredVariables[n];
        null == e.accumulations[r] && (e.accumulations[r] = {
          originalName: n + "/momentum",
          variable: We(function () {
            return In(a).variable(!1)
          })
        });
        var i = e.accumulations[r].variable,
          o = Array.isArray(t) ? t[r].tensor : t[n];
        null != o && We(function () {
          var t, n = e.m.mul(i).add(o);
          t = e.useNesterov ? e.c.mul(o.add(n.mul(e.m))).add(a) : e.c.mul(n).add(a), i.assign(n), a.assign(t)
        })
      }), this.incrementIterations()
    }, e.prototype.dispose = function () {
      this.m.dispose(), null != this.accumulations && Ve(this.accumulations.map(function (t) {
        return t.variable
      }))
    }, e.prototype.setMomentum = function (t) {
      this.momentum = t
    }, e.prototype.getWeights = function () {
      return r(this, void 0, void 0, function () {
        return a(this, function (t) {
          switch (t.label) {
            case 0:
              return [4, this.saveIterations()];
            case 1:
              return [2, [t.sent()].concat(this.accumulations.map(function (t) {
                return {
                  name: t.originalName,
                  tensor: t.variable
                }
              }))]
          }
        })
      })
    }, e.prototype.setWeights = function (t) {
      return r(this, void 0, void 0, function () {
        return a(this, function (e) {
          switch (e.label) {
            case 0:
              return [4, this.extractIterations(t)];
            case 1:
              return t = e.sent(), this.accumulations = t.map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              }), [2]
          }
        })
      })
    }, e.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate,
        momentum: this.momentum,
        useNesterov: this.useNesterov
      }
    }, e.fromConfig = function (t, e) {
      return new t(e.learningRate, e.momentum, e.useNesterov)
    }, e.className = "Momentum", e
  }(gp);
  np(vp);
  var yp = function (t) {
    function e(e, n, r, a, i) {
      void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === a && (a = null), void 0 === i && (i = !1);
      var o = t.call(this) || this;
      return o.learningRate = e, o.decay = n, o.momentum = r, o.epsilon = a, o.accumulatedMeanSquares = [], o.accumulatedMoments = [], o.accumulatedMeanGrads = [], o.centered = i, null == a && (o.epsilon = Dt.backend.epsilon()), o
    }
    return n(e, t), e.prototype.applyGradients = function (t) {
      var e = this;
      (Array.isArray(t) ? t.map(function (t) {
        return t.name
      }) : Object.keys(t)).forEach(function (n, r) {
        var a = Dt.registeredVariables[n];
        null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {
          originalName: n + "/rms",
          variable: We(function () {
            return In(a).variable(!1)
          })
        }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {
          originalName: n + "/momentum",
          variable: We(function () {
            return In(a).variable(!1)
          })
        }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {
          originalName: n + "/mg",
          variable: We(function () {
            return In(a).variable(!1)
          })
        });
        var i = Array.isArray(t) ? t[r].tensor : t[n];
        if (null != i) {
          var o = e.accumulatedMeanSquares[r].variable,
            s = e.accumulatedMoments[r].variable;
          We(function () {
            var t = o.mul(e.decay).add(i.square().mul(1 - e.decay));
            if (e.centered) {
              var n = e.accumulatedMeanGrads[r].variable,
                u = n.mul(e.decay).add(i.mul(1 - e.decay)),
                l = s.mul(e.momentum).add(i.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));
              o.assign(t), n.assign(u), s.assign(l);
              var c = a.sub(l);
              a.assign(c)
            } else {
              var p = o.mul(e.decay).add(i.square().mul(1 - e.decay));
              l = s.mul(e.momentum).add(i.mul(e.learningRate).div(p.add(e.epsilon).sqrt())), o.assign(p), s.assign(l), c = a.sub(l), a.assign(c)
            }
          })
        }
      }), this.incrementIterations()
    }, e.prototype.dispose = function () {
      null != this.accumulatedMeanSquares && Ve(this.accumulatedMeanSquares.map(function (t) {
        return t.variable
      })), null != this.accumulatedMeanGrads && this.centered && Ve(this.accumulatedMeanGrads.map(function (t) {
        return t.variable
      })), null != this.accumulatedMoments && Ve(this.accumulatedMoments.map(function (t) {
        return t.variable
      }))
    }, e.prototype.getWeights = function () {
      return r(this, void 0, void 0, function () {
        var t;
        return a(this, function (e) {
          switch (e.label) {
            case 0:
              return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];
            case 1:
              return [2, [e.sent()].concat(t.map(function (t) {
                return {
                  name: t.originalName,
                  tensor: t.variable
                }
              }))]
          }
        })
      })
    }, e.prototype.setWeights = function (t) {
      return r(this, void 0, void 0, function () {
        var e;
        return a(this, function (n) {
          switch (n.label) {
            case 0:
              return [4, this.extractIterations(t)];
            case 1:
              return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, this.accumulatedMeanSquares = t.slice(0, e).map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              }), this.accumulatedMoments = t.slice(e, 2 * e).map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map(function (t) {
                return {
                  originalName: t.name,
                  variable: t.tensor.variable(!1)
                }
              })), [2]
          }
        })
      })
    }, e.prototype.getConfig = function () {
      return {
        learningRate: this.learningRate,
        decay: this.decay,
        momentum: this.momentum,
        epsilon: this.epsilon,
        centered: this.centered
      }
    }, e.fromConfig = function (t, e) {
      return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered)
    }, e.className = "RMSProp", e
  }(pp);
  np(yp);
  var bp = function () {
      function t() {}
      return t.sgd = function (t) {
        return new gp(t)
      }, t.momentum = function (t, e, n) {
        return void 0 === n && (n = !1), new vp(t, e, n)
      }, t.rmsprop = function (t, e, n, r, a) {
        return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === a && (a = !1), new yp(t, e, n, r, a)
      }, t.adam = function (t, e, n, r) {
        return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new dp(t, e, n, r)
      }, t.adadelta = function (t, e, n) {
        return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new hp(t, e, n)
      }, t.adamax = function (t, e, n, r, a) {
        return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === a && (a = 0), new mp(t, e, n, r, a)
      }, t.adagrad = function (t, e) {
        return void 0 === e && (e = .1), new fp(t, e)
      }, t
    }(),
    xp = {
      sgd: bp.sgd,
      momentum: bp.momentum,
      adadelta: bp.adadelta,
      adagrad: bp.adagrad,
      rmsprop: bp.rmsprop,
      adamax: bp.adamax,
      adam: bp.adam
    },
    wp = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function (t) {
      return t()
    };

  function Cp() {
    return new Promise(function (t) {
      return wp(function () {
        return t()
      })
    })
  }
  ft = Kl;
  var Np = function (t, e) {
    return (Np = Object.setPrototypeOf || {
        __proto__: []
      }
      instanceof Array && function (t, e) {
        t.__proto__ = e
      } || function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
      })(t, e)
  };

  function Sp(t, e) {
    function n() {
      this.constructor = t
    }
    Np(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
  }
  var kp, Ip = function () {
    return (Ip = Object.assign || function (t) {
      for (var e, n = 1, r = arguments.length; n < r; n++)
        for (var a in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a]);
      return t
    }).apply(this, arguments)
  };

  function Ep(t, e, n, r) {
    return new(n || (n = Promise))(function (a, i) {
      function o(t) {
        try {
          u(r.next(t))
        } catch (t) {
          i(t)
        }
      }

      function s(t) {
        try {
          u(r.throw(t))
        } catch (t) {
          i(t)
        }
      }

      function u(t) {
        t.done ? a(t.value) : new n(function (e) {
          e(t.value)
        }).then(o, s)
      }
      u((r = r.apply(t, e || [])).next())
    })
  }

  function Ap(t, e) {
    var n, r, a, i, o = {
      label: 0,
      sent: function () {
        if (1 & a[0]) throw a[1];
        return a[1]
      },
      trys: [],
      ops: []
    };
    return i = {
      next: s(0),
      throw: s(1),
      return: s(2)
    }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
      return this
    }), i;

    function s(i) {
      return function (s) {
        return function (i) {
          if (n) throw new TypeError("Generator is already executing.");
          for (; o;) try {
            if (n = 1, r && (a = 2 & i[0] ? r.return : i[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, i[1])).done) return a;
            switch (r = 0, a && (i = [2 & i[0], a.value]), i[0]) {
              case 0:
              case 1:
                a = i;
                break;
              case 4:
                return o.label++, {
                  value: i[1],
                  done: !1
                };
              case 5:
                o.label++, r = i[1], i = [0];
                continue;
              case 7:
                i = o.ops.pop(), o.trys.pop();
                continue;
              default:
                if (!(a = (a = o.trys).length > 0 && a[a.length - 1]) && (6 === i[0] || 2 === i[0])) {
                  o = 0;
                  continue
                }
                if (3 === i[0] && (!a || i[1] > a[0] && i[1] < a[3])) {
                  o.label = i[1];
                  break
                }
                if (6 === i[0] && o.label < a[1]) {
                  o.label = a[1], a = i;
                  break
                }
                if (a && o.label < a[2]) {
                  o.label = a[2], o.ops.push(i);
                  break
                }
                a[2] && o.ops.pop(), o.trys.pop();
                continue
            }
            i = e.call(t, o)
          } catch (t) {
            i = [6, t], r = 0
          } finally {
            n = a = 0
          }
          if (5 & i[0]) throw i[1];
          return {
            value: i[0] ? i[1] : void 0,
            done: !0
          }
        }([i, s])
      }
    }
  }

  function Rp() {
    return null == kp && (kp = je().epsilon()), kp
  }
  var Tp = function (t) {
      function e(n) {
        var r = t.call(this, n) || this;
        return Object.setPrototypeOf(r, e.prototype), r
      }
      return Sp(e, t), e
    }(Error),
    Dp = function (t) {
      function e(n) {
        var r = t.call(this, n) || this;
        return Object.setPrototypeOf(r, e.prototype), r
      }
      return Sp(e, t), e
    }(Error),
    Op = function (t) {
      function e(n) {
        var r = t.call(this, n) || this;
        return Object.setPrototypeOf(r, e.prototype), r
      }
      return Sp(e, t), e
    }(Error),
    _p = function (t) {
      function e(n) {
        var r = t.call(this, n) || this;
        return Object.setPrototypeOf(r, e.prototype), r
      }
      return Sp(e, t), e
    }(Error),
    Fp = function (t) {
      function e(n) {
        var r = t.call(this, n) || this;
        return Object.setPrototypeOf(r, e.prototype), r
      }
      return Sp(e, t), e
    }(Error);
  ! function (t) {
    function e(n) {
      var r = t.call(this, n) || this;
      return Object.setPrototypeOf(r, e.prototype), r
    }
    Sp(e, t)
  }(Error);

  function Mp(t, e) {
    if (Array.isArray(t)) {
      for (var n = [], r = 0; r < e; r++) n = n.concat(t);
      return n
    }
    return (n = new Array(e)).fill(t), n
  }

  function zp(t, e) {
    if (!t) throw new Fp(e)
  }

  function Lp(t, e) {
    for (var n = 0, r = 0, a = t; r < a.length; r++) a[r] === e && n++;
    return n
  }

  function Bp(t) {
    return 1 === t.length ? t[0] : t
  }

  function Pp(t) {
    return Array.isArray(t) ? t : [t]
  }

  function Wp(t) {
    var e = t.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    return "_" !== e[0] ? e : "private" + e
  }

  function Vp(t) {
    return t.length <= 1 ? t : -1 === t.indexOf("_") ? t : t.replace(/[_]+(\w|$)/g, function (t, e) {
      return e.toUpperCase()
    })
  }
  var Up = {};

  function jp(t) {
    if (null === t || void 0 === t) return null;
    var e = {};
    return e.className = t.getClassName(), e.config = t.getConfig(), e
  }

  function Gp(t, e, n, r, a) {
    var i, o, s;
    if (void 0 === e && (e = {}), void 0 === n && (n = {}), void 0 === r && (r = "object"), void 0 === a && (a = !1), "string" == typeof t) {
      var u = t,
        l = void 0;
      if (u in n) l = n[u];
      else if (u in Up) l = Up[u];
      else if (null == (l = e[u])) throw new Op("Unknown " + r + ": " + t + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
      return l
    }
    var c = t;
    if (null == c.className || null == c.config) throw new Op(r + ": Improper config format: " + JSON.stringify(c) + ".\n'className' and 'config' must set.");
    var p = c.className,
      h = void 0,
      f = void 0;
    if (p in n ? (h = (i = n[p])[0], f = i[1]) : p in Up ? (h = (o = Up.className)[0], f = o[1]) : p in e && (h = (s = e[p])[0], f = s[1]), null == h) throw new Op("Unknown " + r + ": " + p + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
    if (null != f) {
      for (var d = {}, m = 0, g = Object.keys(Up); m < g.length; m++) d[C = g[m]] = Up[C];
      for (var v = 0, y = Object.keys(n); v < y.length; v++) d[C = y[v]] = n[C];
      c.config.customObjects = d;
      for (var b = Ip({}, Up), x = 0, w = Object.keys(n); x < w.length; x++) {
        var C = w[x];
        Up[C] = n[C]
      }! function t(e) {
        if (null != e && "object" == typeof e)
          if (Array.isArray(e)) e.forEach(function (e) {
            return t(e)
          });
          else
            for (var n = 0, r = Object.keys(e); n < r.length; n++) {
              var a = r[n],
                i = e[a];
              null != i && "object" == typeof i && (Array.isArray(i) || "ndarray" !== i.type || "number" != typeof i.value ? t(i) : e[a] = i.value)
            }
      }(c.config);
      var N = f(h, c.config, n, a);
      return Up = Ip({}, b), N
    }
    b = Ip({}, Up);
    for (var S = 0, k = Object.keys(n); S < k.length; S++) C = k[S], Up[C] = n[C];
    return N = new h(c.config), Up = Ip({}, b), N
  }

  function qp(t, e) {
    return -1 * function (t, e) {
      return t < e ? -1 : t > e ? 1 : 0
    }(t, e)
  }

  function Hp(t) {
    if (null == t) return t;
    for (var e = [], n = 0, r = t; n < r.length; n++) {
      var a = r[n]; - 1 === e.indexOf(a) && e.push(a)
    }
    return e
  }

  function Kp(t) {
    if (null == t) throw new Op("Invalid value in obj: " + JSON.stringify(t));
    for (var e in t)
      if (t.hasOwnProperty(e)) return !1;
    return !0
  }

  function Xp(t, e, n) {
    if (null != n && t.indexOf(n) < 0) throw new Op(n + " is not a valid " + e + ".  Valid values are " + t + " or null/undefined.")
  }

  function $p(t, e, n, r) {
    return void 0 === n && (n = 0), void 0 === r && (r = 1 / 0), zp(n >= 0), zp(r >= n), Array.isArray(t) && t.length >= n && t.length <= r && t.every(function (t) {
      return typeof t === e
    })
  }

  function Yp(t, e) {
    Array.isArray(t) ? (nt.assert(t.length > 0, function () {
      return e + " is unexpectedly an empty array."
    }), t.forEach(function (t, n) {
      return Yp(t, "element " + (n + 1) + " of " + e)
    })) : nt.assert(Number.isInteger(t) && t > 0, function () {
      return "Expected " + e + " to be a positive integer, but got " + function t(e) {
        return null === e ? "null" : Array.isArray(e) ? "[" + e.map(function (e) {
          return t(e)
        }).join(",") + "]" : "string" == typeof e ? '"' + e + '"' : "" + e
      }(t) + "."
    })
  }

  function Jp(t) {
    return "relu" === t ? "relu" : "linear" === t ? "linear" : "elu" === t ? "elu" : null
  }

  function Zp(t, e) {
    return We(function () {
      return Po(Bu(Ss(t, t), e, !0))
    })
  }
  var Qp = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e.prototype.getConfig = function () {
        return {}
      }, e
    }(rp.Serializable),
    th = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return n.defaultMaxValue = 2, n.defaultAxis = 0, n.maxValue = null != e.maxValue ? e.maxValue : n.defaultMaxValue, n.axis = null != e.axis ? e.axis : n.defaultAxis, n
      }
      return Sp(e, t), e.prototype.apply = function (t) {
        var e = this;
        return We(function () {
          var n = Zp(t, e.axis),
            r = vo(n, 0, e.maxValue);
          return Ns(t, fs(r, ls(Rp(), n)))
        })
      }, e.prototype.getConfig = function () {
        return {
          maxValue: this.maxValue,
          axis: this.axis
        }
      }, e.className = "MaxNorm", e
    }(Qp);
  rp.registerClass(th);
  var eh = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      return n.defaultAxis = 0, n.axis = null != e.axis ? e.axis : n.defaultAxis, n
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      var e = this;
      return We(function () {
        return fs(t, ls(Rp(), Zp(t, e.axis)))
      })
    }, e.prototype.getConfig = function () {
      return {
        axis: this.axis
      }
    }, e.className = "UnitNorm", e
  }(Qp);
  rp.registerClass(eh);
  var nh = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return ju(t)
    }, e.className = "NonNeg", e
  }(Qp);
  rp.registerClass(nh);
  var rh = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      return n.defaultMinValue = 0, n.defaultMaxValue = 1, n.defaultRate = 1, n.defaultAxis = 0, n.minValue = null != e.minValue ? e.minValue : n.defaultMinValue, n.maxValue = null != e.maxValue ? e.maxValue : n.defaultMaxValue, n.rate = null != e.rate ? e.rate : n.defaultRate, n.axis = null != e.axis ? e.axis : n.defaultAxis, n
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      var e = this;
      return We(function () {
        var n = Zp(t, e.axis),
          r = ls(Ns(e.rate, vo(n, e.minValue, e.maxValue)), Ns(1 - e.rate, n));
        return Ns(t, fs(r, ls(Rp(), n)))
      })
    }, e.prototype.getConfig = function () {
      return {
        minValue: this.minValue,
        maxValue: this.maxValue,
        rate: this.rate,
        axis: this.axis
      }
    }, e.className = "MinMaxNorm", e
  }(Qp);
  rp.registerClass(rh);
  var ah = {
    maxNorm: "MaxNorm",
    minMaxNorm: "MinMaxNorm",
    nonNeg: "NonNeg",
    unitNorm: "UnitNorm"
  };

  function ih(t) {
    return jp(t)
  }

  function oh(t, e) {
    return void 0 === e && (e = {}), Gp(t, rp.SerializationMap.getMap().classNameMap, e, "constraint")
  }

  function sh(t) {
    return null == t ? null : "string" == typeof t ? oh({
      className: t in ah ? ah[t] : t,
      config: {}
    }) : t instanceof Qp ? t : oh(t)
  }
  var uh = Object.freeze({
      maxNorm: function (t) {
        return new th(t)
      },
      unitNorm: function (t) {
        return new eh(t)
      },
      nonNeg: function () {
        return new nh
      },
      minMaxNorm: function (t) {
        return new rh(t)
      }
    }),
    lh = ["channelsFirst", "channelsLast"],
    ch = ["valid", "same", "causal"],
    ph = ["max", "avg"],
    hh = ["sum", "mul", "concat", "ave"],
    fh = new Map;

  function dh(t) {
    Xp(lh, "DataFormat", t)
  }

  function mh(t) {
    Xp(ch, "PaddingMode", t)
  }

  function gh(t) {
    Xp(ph, "PoolMode", t)
  }
  var vh = [],
    yh = "/";

  function bh(t, e) {
    vh.push(t);
    try {
      var n = e();
      return vh.pop(), n
    } catch (t) {
      throw vh.pop(), t
    }
  }

  function xh(t) {
    if (!Nh(t)) throw new Error("Not a valid tensor name: '" + t + "'");
    return (0 === vh.length ? "" : vh.join(yh) + yh) + t
  }

  function wh(t) {
    if (!Nh(t)) throw new Error("Not a valid tensor name: '" + t + "'");
    fh.has(t) || fh.set(t, 0);
    var e = fh.get(t);
    if (fh.set(t, fh.get(t) + 1), e > 0) {
      var n = t + "_" + e;
      return fh.set(n, 1), n
    }
    return t
  }
  var Ch = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

  function Nh(t) {
    return !!t.match(Ch)
  }

  function Sh(t) {
    return t === parseInt(t.toString(), 10)
  }

  function kh(t, e, n) {
    null == e && (e = 0), null == n && (n = t.length);
    for (var r = 1, a = e; a < n; ++a) r *= t[a];
    return r
  }

  function Ih(t) {
    return fn(t = Array.isArray(t) ? new Float32Array(t) : t)
  }

  function Eh(t) {
    return zu(Ih(t)).dataSync()[0]
  }

  function Ah(t) {
    return Fu(Ih(t)).dataSync()[0]
  }

  function Rh(t, e) {
    if (e < t) throw new Op("end (" + e + ") < begin (" + t + ") is forbidden.");
    for (var n = [], r = t; r < e; ++r) n.push(r);
    return n
  }

  function Th(t, e) {
    return t.asType(e)
  }

  function Dh(t, e) {
    void 0 === e && (e = -1);
    var n = t.shape.slice();
    return e < 0 && (e = n.length + e + 1), n.splice(e, 0, 1), t.reshape(n)
  }

  function Oh(t, e, n) {
    return We(function () {
      switch (t.rank) {
        case 1:
          return Su(t, e, n);
        case 2:
          return ku(t, [e, 0], [n, t.shape[1]]);
        case 3:
          return Iu(t, [e, 0, 0], [n, t.shape[1], t.shape[2]]);
        case 4:
          return Eu(t, [e, 0, 0, 0], [n, t.shape[1], t.shape[2], t.shape[3]]);
        case 5:
          return Nu(t, [e, 0, 0, 0, 0], [n, t.shape[1], t.shape[2], t.shape[3], t.shape[4]]);
        case 6:
          return Nu(t, [e, 0, 0, 0, 0, 0], [n, t.shape[1], t.shape[2], t.shape[3], t.shape[4], t.shape[5]]);
        default:
          throw new Op("sliceAlongFirstAxis() received an unsupported tensor rank: " + t.rank)
      }
    })
  }

  function _h(t, e, n) {
    return We(function () {
      switch (t.rank) {
        case 1:
          return Su(t, e, n);
        case 2:
          return ku(t, [0, e], [t.shape[0], n]);
        case 3:
          return Iu(t, [0, 0, e], [t.shape[0], t.shape[1], n]);
        case 4:
          return Eu(t, [0, 0, 0, e], [t.shape[0], t.shape[1], t.shape[2], n]);
        default:
          throw new Op("sliceAlongLastAxis() received an unsupported tensor rank: " + t.rank)
      }
    })
  }

  function Fh(t, e, n, r) {
    return We(function () {
      switch (t.rank) {
        case 1:
          return Su(t, e, n);
        case 2:
          switch (r) {
            case 1:
              return Oh(t, e, n);
            case 2:
              return _h(t, e, n);
            default:
              throw new Op("The axis is not within the rank of the tensor " + r)
          }
          case 3:
            switch (r) {
              case 1:
                return Oh(t, e, n);
              case 2:
                return Iu(t, [0, e, 0], [t.shape[0], n, t.shape[2]]);
              case 3:
                return _h(t, e, n);
              default:
                throw new Op("The axis is not within the rank of the tensor " + r)
            }
            case 4:
              switch (r) {
                case 1:
                  return Oh(t, e, n);
                case 2:
                  return Eu(t, [0, e, 0, 0], [t.shape[0], n, t.shape[2], t.shape[3]]);
                case 3:
                  return Eu(t, [0, 0, e, 0], [t.shape[0], t.shape[1], n, t.shape[3]]);
                case 4:
                  return _h(t, e, n);
                default:
                  throw new Op("The axis is not within the rank of the tensor " + r)
              }
              default:
                throw new Op("sliceAlongLastAxis() received an unsupported tensor rank: " + t.rank)
      }
    })
  }

  function Mh(t, e) {
    var n;
    return void 0 === e && (e = -1), e < 0 && (e = 0 !== (n = t[0].rank) ? n : 0), e === t[0].rank && (e = -1), En(t, e)
  }

  function zh(t, e) {
    switch (t.rank) {
      case 1:
        return An([t, e]);
      case 2:
        return Rn([t, e], 0);
      case 3:
        return Tn([t, e], 0);
      case 4:
        return Dn([t, e], 0);
      default:
        throw new Op("concatAlongFirstAxis() received an unsupported tensor rank: " + t.rank)
    }
  }

  function Lh(t, e) {
    if (Array.isArray(e) || (e = [e]), t.rank !== e.length) throw new Op("The length of input n (" + e.length + ") does not match the number of dimensions in input x (" + t.rank + ")");
    return gr(t, e)
  }

  function Bh(t, e, n, r, a) {
    return void 0 === e && (e = 0), void 0 === n && (n = 1), lr(t, e, n, r, a)
  }

  function Ph(t, e, n, r) {
    if (t.rank < 2 || e.rank < 2) throw new _p("dot requires both inputs to be rank >= 2 but got x shape = " + t.shape + " and y shape = " + e.shape);
    if (e.rank >= 3 && t.shape.slice(-1)[0] !== (c = e.shape.slice(-2)[0])) throw new _p("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " + t.shape + " and  y shape = " + e.shape);
    if (2 === t.rank && 2 === e.rank) {
      var a = !1,
        i = !1;
      return Hl.matMul({
        a: t,
        b: e,
        transposeA: a,
        transposeB: i,
        bias: r ? Uh(t.rank, r, "channelsLast") : null,
        activation: n
      })
    }
    var o = t.shape.slice(),
      s = o.pop();
    t = t.reshape([-1, s]);
    var u = e.shape.slice(),
      l = u.pop(),
      c = u.pop(),
      p = u.concat([l]),
      h = Array.from({
        length: e.rank
      }, function (t, n) {
        return 0 === n ? e.rank - 2 : n <= e.rank - 2 ? n - 1 : n
      });
    e = e.transpose(h).reshape([c, -1]);
    var f = o.concat(p);
    return a = !1, i = !1, Hl.matMul({
      a: t,
      b: e,
      transposeA: a,
      transposeB: i,
      bias: r ? Uh(t.rank, r, "channelsLast") : null,
      activation: n
    }).reshape(f)
  }

  function Wh(t, e, n) {
    return We(function () {
      return e = Array.isArray(e) ? fn(e, "int32") : e.toInt(), qs(t, e, n)
    })
  }

  function Vh(t) {
    return Ss(t, t)
  }

  function Uh(t, e, n) {
    var r = e.shape;
    if (1 !== e.rank && e.rank !== t) throw new Op("Unexpected bias dimensions: " + e.rank + "; expected it to be 1 or " + t);
    if (5 === t) {
      if ("channelsFirst" === n) return 1 === r.length ? e.reshape([1, r[0], 1, 1, 1]) : e.reshape([1, r[3], r[0], r[1], r[2]]);
      if ("channelsLast" === n) return 1 === r.length ? e.reshape([1, 1, 1, 1, r[0]]) : e.reshape([1].concat(r))
    } else if (4 === t) {
      if ("channelsFirst" === n) return 1 === r.length ? e.reshape([1, r[0], 1, 1]) : e.reshape([1, r[2], r[0], r[1]]);
      if ("channelsLast" === n) return 1 === r.length ? e.reshape([1, 1, 1, r[0]]) : e.reshape([1].concat(r))
    } else if (3 === t) {
      if ("channelsFirst" === n) return 1 === r.length ? e.reshape([1, r[0], 1]) : e.reshape([1, r[1], r[0]]);
      if ("channelsLast" === n) return 1 === r.length ? e.reshape([1, 1, r[0]]) : e.reshape([1].concat(r))
    } else if (t < 3) return e;
    throw new Op("Unsupported input rank by biasAdd: " + e.rank)
  }

  function jh(t, e, n) {
    return We(function () {
      return null == n && (n = "channelsLast"), dh(n), t.add(Uh(t.rank, e, n))
    })
  }

  function Gh(t, e, n, r) {
    return We(function () {
      return ll(t, e, n, r)
    })
  }

  function qh(t, e, n) {
    return void 0 === n && (n = !1), n ? t() : e()
  }
  var Hh = ["fanIn", "fanOut", "fanAvg"],
    Kh = ["normal", "uniform", "truncatedNormal"];
  var Xh = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e.prototype.fromConfigUsesCustomObjects = function () {
        return !1
      }, e.prototype.getConfig = function () {
        return {}
      }, e
    }(rp.Serializable),
    $h = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e.prototype.apply = function (t, e) {
        return wn(t, e)
      }, e.className = "Zeros", e
    }(Xh);
  rp.registerClass($h);
  var Yh = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      return xn(t, e)
    }, e.className = "Ones", e
  }(Xh);
  rp.registerClass(Yh);
  var Jh = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      if ("object" != typeof e) throw new Op("Expected argument of type ConstantConfig but got " + e);
      if (void 0 === e.value) throw new Op("config must have value set but got " + e);
      return n.value = e.value, n
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      var n = this;
      return We(function () {
        return Ns(hn(n.value), xn(t, e))
      })
    }, e.prototype.getConfig = function () {
      return {
        value: this.value
      }
    }, e.className = "Constant", e
  }(Xh);
  rp.registerClass(Jh);
  var Zh = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      return n.DEFAULT_MINVAL = -.05, n.DEFAULT_MAXVAL = .05, n.minval = e.minval || n.DEFAULT_MINVAL, n.maxval = e.maxval || n.DEFAULT_MAXVAL, n.seed = e.seed, n
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      return pr(t, this.minval, this.maxval, e)
    }, e.prototype.getConfig = function () {
      return {
        minval: this.minval,
        maxval: this.maxval,
        seed: this.seed
      }
    }, e.className = "RandomUniform", e
  }(Xh);
  rp.registerClass(Zh);
  var Qh = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = e.mean || n.DEFAULT_MEAN, n.stddev = e.stddev || n.DEFAULT_STDDEV, n.seed = e.seed, n
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      if ("float32" !== (e = e || "float32") && "int32" !== e) throw new _p("randomNormal does not support dType " + e + ".");
      return Bh(t, this.mean, this.stddev, e, this.seed)
    }, e.prototype.getConfig = function () {
      return {
        mean: this.mean,
        stddev: this.stddev,
        seed: this.seed
      }
    }, e.className = "RandomNormal", e
  }(Xh);
  rp.registerClass(Qh);
  var tf = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = .05, n.mean = e.mean || n.DEFAULT_MEAN, n.stddev = e.stddev || n.DEFAULT_STDDEV, n.seed = e.seed, n
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      if ("float32" !== (e = e || "float32") && "int32" !== e) throw new _p("truncatedNormal does not support dType " + e + ".");
      return vr(t, this.mean, this.stddev, e, this.seed)
    }, e.prototype.getConfig = function () {
      return {
        mean: this.mean,
        stddev: this.stddev,
        seed: this.seed
      }
    }, e.className = "TruncatedNormal", e
  }(Xh);
  rp.registerClass(tf);
  var ef = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      return n.gain = null != e.gain ? e.gain : 1, n
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      var n = this;
      return We(function () {
        if (2 !== t.length || t[0] !== t[1]) throw new Op("Identity matrix initializer can only be used for 2D square matrices.");
        return Ns(n.gain, tr(t[0]))
      })
    }, e.prototype.getConfig = function () {
      return {
        gain: this.gain
      }
    }, e.className = "Identity", e
  }(Xh);
  rp.registerClass(ef);
  var nf = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      if (e.scale < 0) throw new Op("scale must be a positive float. Got: " + e.scale);
      return n.scale = null == e.scale ? 1 : e.scale, n.mode = null == e.mode ? "fanIn" : e.mode,
        function (t) {
          Xp(Hh, "FanMode", t)
        }(n.mode), n.distribution = null == e.distribution ? "normal" : e.distribution,
        function (t) {
          Xp(Kh, "Distribution", t)
        }(n.distribution), n.seed = e.seed, n
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      var n = function (t, e) {
          var n, r;
          if (void 0 === e && (e = "channelsLast"), dh(e), 2 === t.length) n = t[0], r = t[1];
          else if (-1 !== [3, 4, 5].indexOf(t.length))
            if ("channelsFirst" === e) {
              var a = kh(t, 2);
              n = t[1] * a, r = t[0] * a
            } else "channelsLast" === e && (a = kh(t, 0, t.length - 2), n = t[t.length - 2] * a, r = t[t.length - 1] * a);
          else {
            var i = kh(t);
            n = Math.sqrt(i), r = Math.sqrt(i)
          }
          return [n, r]
        }(t),
        r = n[0],
        a = n[1],
        i = this.scale;
      if ("fanIn" === this.mode ? i /= Math.max(1, r) : "fanOut" === this.mode ? i /= Math.max(1, a) : i /= Math.max(1, (r + a) / 2), "normal" === this.distribution) {
        var o = Math.sqrt(i);
        if ("float32" !== (e = e || "float32") && "int32" !== e) throw new _p(this.getClassName() + " does not support dType " + e + ".");
        return vr(t, 0, o, e, this.seed)
      }
      var s = Math.sqrt(3 * i);
      return pr(t, -s, s, e)
    }, e.prototype.getConfig = function () {
      return {
        scale: this.scale,
        mode: this.mode,
        distribution: this.distribution,
        seed: this.seed
      }
    }, e.className = "VarianceScaling", e
  }(Xh);
  rp.registerClass(nf);
  var rf = function (t) {
    function e(e) {
      return t.call(this, {
        scale: 1,
        mode: "fanAvg",
        distribution: "uniform",
        seed: null == e ? null : e.seed
      }) || this
    }
    return Sp(e, t), e.prototype.getClassName = function () {
      return nf.className
    }, e.className = "GlorotUniform", e
  }(nf);
  rp.registerClass(rf);
  var af = function (t) {
    function e(e) {
      return t.call(this, {
        scale: 1,
        mode: "fanAvg",
        distribution: "normal",
        seed: null == e ? null : e.seed
      }) || this
    }
    return Sp(e, t), e.prototype.getClassName = function () {
      return nf.className
    }, e.className = "GlorotNormal", e
  }(nf);
  rp.registerClass(af);
  var of = function (t) {
    function e(e) {
      return t.call(this, {
        scale: 2,
        mode: "fanIn",
        distribution: "normal",
        seed: null == e ? null : e.seed
      }) || this
    }
    return Sp(e, t), e.prototype.getClassName = function () {
      return nf.className
    }, e.className = "HeNormal", e
  }(nf);
  rp.registerClass( of );
  var sf = function (t) {
    function e(e) {
      return t.call(this, {
        scale: 2,
        mode: "fanIn",
        distribution: "uniform",
        seed: null == e ? null : e.seed
      }) || this
    }
    return Sp(e, t), e.prototype.getClassName = function () {
      return nf.className
    }, e.className = "HeUniform", e
  }(nf);
  rp.registerClass(sf);
  var uf = function (t) {
    function e(e) {
      return t.call(this, {
        scale: 1,
        mode: "fanIn",
        distribution: "normal",
        seed: null == e ? null : e.seed
      }) || this
    }
    return Sp(e, t), e.prototype.getClassName = function () {
      return nf.className
    }, e.className = "LeCunNormal", e
  }(nf);
  rp.registerClass(uf);
  var lf = function (t) {
    function e(e) {
      return t.call(this, {
        scale: 1,
        mode: "fanIn",
        distribution: "uniform",
        seed: null == e ? null : e.seed
      }) || this
    }
    return Sp(e, t), e.prototype.getClassName = function () {
      return nf.className
    }, e.className = "LeCunNormal", e
  }(nf);
  rp.registerClass(lf);
  var cf = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      if (n.DEFAULT_GAIN = 1, n.gain = null == e.gain ? n.DEFAULT_GAIN : e.gain, n.seed = e.seed, null != n.seed) throw new _p("Random seed is not implemented for Orthogonal Initializer yet.");
      return n
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      var n = this;
      return We(function () {
        if (2 !== t.length) throw new _p("The Orthogonal Initializer does not support non-2D shapes yet.");
        t[0] * t[1] > 2e3 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (" + t[0] * t[1] + ") elements: Slowness may result.");
        var e = Bh(t[0] > t[1] ? [t[1], t[0]] : t, 0, 1, "float32"),
          r = Dl.gramSchmidt(e);
        return t[0] > t[1] && (r = r.transpose()), Ns(n.gain, r)
      })
    }, e.prototype.getConfig = function () {
      return {
        gain: this.gain,
        seed: this.seed
      }
    }, e.className = "Orthogonal", e
  }(Xh);
  rp.registerClass(cf);
  var pf = {
    constant: "Constant",
    glorotNormal: "GlorotNormal",
    glorotUniform: "GlorotUniform",
    heNormal: "HeNormal",
    heUniform: "HeUniform",
    identity: "Identity",
    leCunNormal: "LeCunNormal",
    leCunUniform: "LeCunUniform",
    ones: "Ones",
    orthogonal: "Orthogonal",
    randomNormal: "RandomNormal",
    randomUniform: "RandomUniform",
    truncatedNormal: "TruncatedNormal",
    varianceScaling: "VarianceScaling",
    zeros: "Zeros"
  };

  function hf(t, e) {
    return void 0 === e && (e = {}), Gp(t, rp.SerializationMap.getMap().classNameMap, e, "initializer")
  }

  function ff(t) {
    return jp(t)
  }

  function df(t) {
    if ("string" == typeof t) {
      var e = t in pf ? pf[t] : t;
      if ("GlorotNormal" === e) return new af;
      if ("GlorotUniform" === e) return new rf;
      if ("HeNormal" === e) return new of ;
      if ("HeUniform" === e) return new sf;
      if ("LeCunNormal" === e) return new uf;
      if ("LeCunUniform" === e) return new lf;
      var n = {};
      return n.className = e, n.config = {}, hf(n)
    }
    return t instanceof Xh ? t : hf(t)
  }
  var mf = Object.freeze({
      zeros: function () {
        return new $h
      },
      ones: function () {
        return new Yh
      },
      constant: function (t) {
        return new Jh(t)
      },
      randomUniform: function (t) {
        return new Zh(t)
      },
      randomNormal: function (t) {
        return new Qh(t)
      },
      truncatedNormal: function (t) {
        return new tf(t)
      },
      identity: function (t) {
        return new ef(t)
      },
      varianceScaling: function (t) {
        return new nf(t)
      },
      glorotUniform: function (t) {
        return new rf(t)
      },
      glorotNormal: function (t) {
        return new af(t)
      },
      heNormal: function (t) {
        return new of (t)
      },
      heUniform: function (t) {
        return new sf(t)
      },
      leCunNormal: function (t) {
        return new uf(t)
      },
      leCunUniform: function (t) {
        return new lf(t)
      },
      orthogonal: function (t) {
        return new cf(t)
      }
    }),
    gf = 0;

  function vf() {
    return gf++
  }
  var yf = {};

  function bf(t) {
    return void 0 === t && (t = ""), t in yf || (yf[t] = 0), yf[t] += 1, t + yf[t].toString()
  }

  function xf(t) {
    return Array.isArray(t) && Array.isArray(t[0])
  }

  function wf(t) {
    return 0 === t.length ? [] : Array.isArray(t[0]) ? t : [t]
  }

  function Cf(t) {
    var e;
    if (Array.isArray(t)) {
      if (1 !== t.length) throw new Op("Expected Tensor length to be 1; got " + t.length);
      e = t[0]
    } else e = t;
    return e
  }

  function Nf(t) {
    if (Array.isArray(t) && Array.isArray(t[0])) {
      if (1 === t.length) return (t = t)[0];
      throw new Op("Expected exactly 1 Shape; got " + t.length)
    }
    return t
  }

  function Sf(t) {
    for (var e = 0, n = 0, r = t; n < r.length; n++) {
      var a = r[n];
      0 === a.shape.length ? e += 1 : e += a.shape.reduce(function (t, e) {
        return t * e
      })
    }
    return e
  }
  var kf = "Variable",
    If = function () {
      function t(t, e, n, r, a) {
        void 0 === e && (e = "float32"), void 0 === n && (n = kf), void 0 === r && (r = !0), void 0 === a && (a = null), this.dtype = null == e ? "float32" : e, this.shape = t.shape, this.id = vf(), n = null == n ? kf : n, this.originalName = xh(n), this.name = wh(this.originalName), this.trainable_ = r, this.constraint = a, this.val = bn(t, this.trainable_, this.name, this.dtype)
      }
      return t.prototype.read = function () {
        return this.assertNotDisposed(), this.val
      }, t.prototype.write = function (t) {
        return this.assertNotDisposed(),
          function (t, e) {
            if (t.shape.toString() !== e.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(t.shape) + " vs. " + JSON.stringify(e.shape))
          }(this.val, t), this.val.id !== t.id && (this.val.assign(t), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this
      }, t.prototype.dispose = function () {
        this.assertNotDisposed(), this.val.dispose()
      }, t.prototype.assertNotDisposed = function () {
        if (this.val.isDisposed) throw new Error("LayersVariable " + this.name + " is already disposed.")
      }, Object.defineProperty(t.prototype, "trainable", {
        get: function () {
          return this.trainable_
        },
        set: function (t) {
          this.trainable_ = t, this.val.trainable = t
        },
        enumerable: !0,
        configurable: !0
      }), t
    }();

  function Ef(t) {
    return t.map(function (t) {
      return t.read()
    })
  }

  function Af(t) {
    t.forEach(function (t) {
      t[0].write(t[1])
    })
  }
  var Rf = function (t) {
      this.dtype = t.dtype, this.shape = t.shape, null != t.shape ? this.ndim = t.shape.length : this.ndim = t.ndim, this.maxNDim = t.maxNDim, this.minNDim = t.minNDim, this.axes = t.axes || {}
    },
    Tf = function (t, e, n, r, a, i, o) {
      this.dtype = t, this.shape = e, this.sourceLayer = n, this.inputs = r, this.callArgs = a, this.outputTensorIndex = o, this.id = vf(), null != i && (this.originalName = xh(i), this.name = wh(this.originalName)), this.rank = e.length
    },
    Df = 0,
    Of = function () {
      function t(t, e) {
        this.callArgs = e, this.id = Df++, this.outboundLayer = t.outboundLayer, this.inboundLayers = t.inboundLayers, this.nodeIndices = t.nodeIndices, this.tensorIndices = t.tensorIndices, this.inputTensors = t.inputTensors, this.outputTensors = t.outputTensors, this.inputMasks = t.inputMasks, this.outputMasks = t.outputMasks, this.inputShapes = t.inputShapes, this.outputShapes = t.outputShapes;
        for (var n = 0, r = t.inboundLayers; n < r.length; n++) {
          var a = r[n];
          null != a && a.outboundNodes.push(this)
        }
        t.outboundLayer.inboundNodes.push(this)
      }
      return t.prototype.getConfig = function () {
        for (var t = [], e = 0, n = this.inboundLayers; e < n.length; e++) {
          var r = n[e];
          null != r ? t.push(r.name) : t.push(null)
        }
        return {
          outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
          inboundLayers: t,
          nodeIndices: this.nodeIndices,
          tensorIndices: this.tensorIndices
        }
      }, t
    }(),
    _f = 0,
    Ff = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        n._callHook = null, n._addedWeightNames = [], n._stateful = !1, n.id = _f++, n.activityRegularizer = null, n.inputSpec = null, n.supportsMasking = !1, n._trainableWeights = [], n._nonTrainableWeights = [], n._losses = [], n._updates = [], n._built = !1, n.inboundNodes = [], n.outboundNodes = [];
        var r = e.name;
        if (!r) {
          var a = n.getClassName();
          r = Wp(a) + "_" + bf(a)
        }
        if (n.name = r, n.trainable_ = null == e.trainable || e.trainable, null != e.inputShape || null != e.batchInputShape) {
          var i = void 0;
          if (null != e.batchInputShape) i = e.batchInputShape;
          else if (null != e.inputShape) {
            var o = null;
            null != e.batchSize && (o = e.batchSize), i = [o].concat(e.inputShape)
          }
          n.batchInputShape = i;
          var s = e.dtype;
          null == s && (s = e.inputDType), null == s && (s = "float32"), n.dtype = s
        }
        return null != e.weights ? n.initialWeights = e.weights : n.initialWeights = null, n._refCount = null, n.fastWeightInitDuringBuild = !1, n
      }
      return Sp(e, t), e.nodeKey = function (t, e) {
        return t.name + "_ib-" + e.toString()
      }, e.prototype.getNodeAtIndex = function (t, e) {
        if (0 === this.inboundNodes.length) throw new Dp("The layer has never been called and thus has no defined " + e + ".");
        if (this.inboundNodes.length <= t) throw new Op("Asked to get " + e + " at node " + t + ", but the layer has only " + this.inboundNodes.length + " inbound nodes.");
        return this.inboundNodes[t]
      }, e.prototype.getInputAt = function (t) {
        return Bp(this.getNodeAtIndex(t, "input").inputTensors)
      }, e.prototype.getOutputAt = function (t) {
        return Bp(this.getNodeAtIndex(t, "output").outputTensors)
      }, Object.defineProperty(e.prototype, "input", {
        get: function () {
          if (this.inboundNodes.length > 1) throw new Tp("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
          if (0 === this.inboundNodes.length) throw new Tp("Layer " + this.name + " is not connected, no input to return.");
          return Bp(this.getNodeAtIndex(0, "input").inputTensors)
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "output", {
        get: function () {
          if (0 === this.inboundNodes.length) throw new Tp("Layer " + this.name + " has no inbound nodes.");
          if (this.inboundNodes.length > 1) throw new Tp("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
          return Bp(this.getNodeAtIndex(0, "output").outputTensors)
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "losses", {
        get: function () {
          return this._losses
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.calculateLosses = function () {
        return this.losses.map(function (t) {
          return t()
        })
      }, Object.defineProperty(e.prototype, "updates", {
        get: function () {
          return this._updates
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "built", {
        get: function () {
          return this._built
        },
        set: function (t) {
          this._built = t
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "trainable", {
        get: function () {
          return this.trainable_
        },
        set: function (t) {
          this._trainableWeights.forEach(function (e) {
            return e.trainable = t
          }), this.trainable_ = t
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "trainableWeights", {
        get: function () {
          return this.trainable_ ? this._trainableWeights.filter(function (t) {
            return t.trainable
          }) : []
        },
        set: function (t) {
          this._trainableWeights = t
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
        get: function () {
          return this.trainable ? this._trainableWeights.filter(function (t) {
            return !t.trainable
          }).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights)
        },
        set: function (t) {
          this._nonTrainableWeights = t
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "weights", {
        get: function () {
          return this.trainableWeights.concat(this.nonTrainableWeights)
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "stateful", {
        get: function () {
          return this._stateful
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.resetStates = function () {
        if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")
      }, e.prototype.assertInputCompatibility = function (t) {
        if (t = Pp(t), null != this.inputSpec && 0 !== this.inputSpec.length) {
          var e = Pp(this.inputSpec);
          if (t.length !== e.length) throw new Op("Layer " + this.name + " expects " + e.length + " inputs, but it received " + t.length + " input tensors. Input received: " + t);
          for (var n = 0; n < t.length; n++) {
            var r = t[n],
              a = e[n];
            if (null != a) {
              var i = r.rank;
              if (null != a.ndim && i !== a.ndim) throw new Op("Input " + n + " is incompatible with layer " + this.name + ": expected ndim=" + a.ndim + ", found ndim=" + i);
              if (null != a.maxNDim && i > a.maxNDim) throw new Op("Input " + n + " is incompatible with layer " + this.name + ": expected max_ndim=" + a.maxNDim + ", found ndim=" + i);
              if (null != a.minNDim && i < a.minNDim) throw new Op("Input " + n + " is incompatible with layer " + this.name + ": expected min_ndim=" + a.minNDim + ", found ndim=" + i + ".");
              if (null != a.dtype && r.dtype !== a.dtype) throw new Op("Input " + n + " is incompatible with layer " + this.name + " : expected dtype=" + a.dtype + ", found dtype=" + r.dtype + ".");
              if (a.axes) {
                var o = r.shape;
                for (var s in a.axes) {
                  var u = Number(s),
                    l = a.axes[s],
                    c = u >= 0 ? o[u] : o[o.length + u];
                  if (null != l && -1 === [l, null].indexOf(c)) throw new Op("Input " + n + " is incompatible with layer " + this.name + ": expected axis " + u + " of input shape to have value " + l + " but got shape " + o + ".")
                }
              }
              if (null != a.shape)
                for (var p = 0; p < a.shape.length; ++p) {
                  var h = a.shape[p],
                    f = r.shape[p];
                  if (null != h && null != f && h !== f) throw new Op("Input " + n + " is incompatible with layer " + this.name + ": expected shape=" + a.shape + ", found shape=" + r.shape + ".")
                }
            }
          }
        }
      }, e.prototype.call = function (t, e) {
        return t
      }, e.prototype.invokeCallHook = function (t, e) {
        null != this._callHook && this._callHook(t, e)
      }, e.prototype.setCallHook = function (t) {
        this._callHook = t
      }, e.prototype.clearCallHook = function () {
        this._callHook = null
      }, e.prototype.apply = function (t, e) {
        var n = this;
        e = e || {}, this.assertNotDisposed();
        for (var r = Pp(t), a = !0, i = 0, o = r; i < o.length; i++)
          if (!(o[i] instanceof Tf)) {
            a = !1;
            break
          } for (var s = !0, u = 0, l = r; u < l.length; u++)
          if (l[u] instanceof Tf) {
            s = !1;
            break
          } if (a === s) throw new Op("Arguments to apply() must be all SymbolicTensors or all Tensors");
        return bh(this.name, function () {
          if (!n.built) {
            n.assertInputCompatibility(t);
            for (var a = [], i = 0, o = Pp(t); i < o.length; i++) {
              var u = o[i];
              a.push(u.shape)
            }
            n.build(Bp(a)), n.built = !0, n.initialWeights && n.setWeights(n.initialWeights), null === n._refCount && s && (n._refCount = 1)
          }
          if (n.assertInputCompatibility(t), s) {
            for (var l = [], c = 0, p = Pp(m = n.call(t, e)); c < p.length; c++) {
              var h = p[c]; - 1 !== r.indexOf(h) && (h = h.clone()), l.push(h)
            }
            if (m = Bp(l), null != n.activityRegularizer) throw new _p("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
            return m
          }
          var f = function (t) {
              for (var e = [], n = 0, r = t = Pp(t); n < r.length; n++) {
                var a = r[n];
                e.push(a.shape)
              }
              return Bp(e)
            }(t),
            d = n.computeOutputShape(f),
            m = void 0;
          if (n.warnOnIncompatibleInputShape(Array.isArray(t) ? f[0] : f), m = null != d && d.length > 0 && Array.isArray(d[0]) ? d.map(function (r, a) {
              return new Tf("float32", r, n, Pp(t), e, n.name, a)
            }) : new Tf("float32", d, n, Pp(t), e, n.name), n.addInboundNode(t, m, null, null, f, d, e), n._refCount++, null != n.activityRegularizer) throw new _p("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          return m
        })
      }, e.prototype.warnOnIncompatibleInputShape = function (t) {
        if (null != this.batchInputShape)
          if (t.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: " + JSON.stringify(t) + ") does not match that of the batchInputShape (" + JSON.stringify(this.batchInputShape) + ") of the layer " + this.name);
          else {
            var e = !1;
            this.batchInputShape.forEach(function (n, r) {
              null != n && null != t[r] && t[r] !== n && (e = !0)
            }), e && console.warn("The shape of the input tensor (" + JSON.stringify(t) + ") does not match the expectation of layer " + this.name + ": " + JSON.stringify(this.batchInputShape))
          }
      }, Object.defineProperty(e.prototype, "outputShape", {
        get: function () {
          if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new Tp("The layer " + this.name + " has never been called and thus has no defined output shape.");
          for (var t = [], e = 0, n = this.inboundNodes; e < n.length; e++) {
            var r = n[e],
              a = JSON.stringify(r.outputShapes); - 1 === t.indexOf(a) && t.push(a)
          }
          if (1 === t.length) {
            var i = this.inboundNodes[0].outputShapes;
            return Array.isArray(i) && Array.isArray(i[0]) && 1 === i.length ? i[0] : i
          }
          throw new Tp("The layer " + this.name + ' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.')
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.countParams = function () {
        if (!this.built) throw new Dp("You tried to call countParams() on " + this.name + ", but the layer is not built yet. Build it first by calling build(batchInputShape).");
        return Sf(this.weights)
      }, e.prototype.build = function (t) {
        this.built = !0
      }, e.prototype.getWeights = function (t) {
        return void 0 === t && (t = !1), Ef(t ? this.trainableWeights : this.weights)
      }, e.prototype.setWeights = function (t) {
        var e = this;
        We(function () {
          var n = e.weights;
          if (n.length !== t.length) throw new Op('You called setWeights(weights) on layer "' + e.name + '" with a weight list of length ' + t.length + ", but the layer was expecting " + n.length + " weights. Provided weights: " + t + "...");
          if (0 !== n.length) {
            for (var r = [], a = Ef(n), i = 0; i < a.length; ++i) {
              var o = a[i],
                s = n[i],
                u = t[i];
              if (!nt.arraysEqual(o.shape, u.shape)) throw new Op("Layer weight shape " + o.shape + " not compatible with provided weight shape " + u.shape);
              r.push([s, u])
            }
            Af(r)
          }
        })
      }, e.prototype.addWeight = function (t, e, n, r, a, i, o) {
        if (-1 !== this._addedWeightNames.indexOf(t)) throw new Op("Duplicate weight name " + t + " for layer " + this.name);
        this._addedWeightNames.push(t), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (r = df("zeros"));
        var s = r.apply(e, n),
          u = new If(s, n, t, i, o);
        return s.dispose(), null != a && this.addLoss(function () {
          return a.apply(u.read())
        }), null == i && (i = !0), i ? this._trainableWeights.push(u) : this._nonTrainableWeights.push(u), u
      }, e.prototype.setFastWeightInitDuringBuild = function (t) {
        this.fastWeightInitDuringBuild = t
      }, e.prototype.addLoss = function (t) {
        var e;
        null == t || Array.isArray(t) && 0 === t.length || (t = Pp(t), void 0 !== this._losses && null !== this._losses && (e = this.losses).push.apply(e, t))
      }, e.prototype.computeOutputShape = function (t) {
        return t
      }, e.prototype.computeMask = function (t, e) {
        var n = this;
        if (!this.supportsMasking) {
          if (null != e) {
            if (!Array.isArray(e)) throw new TypeError("Layer " + this.name + " does not support masking, but was passed an inputMask.");
            e.forEach(function (t) {
              if (null != t) throw new TypeError("Layer " + n.name + " does not support masking, but was passed an inputMask.")
            })
          }
          return null
        }
        return e
      }, e.prototype.addInboundNode = function (t, e, n, r, a, i, o) {
        void 0 === o && (o = null);
        var s = Pp(t);
        e = Pp(e), n = Pp(n), r = Pp(r), a = wf(a), i = wf(i);
        for (var u = [], l = [], c = [], p = 0, h = s; p < h.length; p++) {
          var f = h[p];
          u.push(f.sourceLayer), l.push(f.nodeIndex), c.push(f.tensorIndex)
        }
        new Of({
          outboundLayer: this,
          inboundLayers: u,
          nodeIndices: l,
          tensorIndices: c,
          inputTensors: s,
          outputTensors: e,
          inputMasks: n,
          outputMasks: r,
          inputShapes: a,
          outputShapes: i
        }, o);
        for (var d = 0; d < e.length; d++) e[d].sourceLayer = this, e[d].nodeIndex = this.inboundNodes.length - 1, e[d].tensorIndex = d
      }, e.prototype.getConfig = function () {
        var t = {
          name: this.name,
          trainable: this.trainable
        };
        return null != this.batchInputShape && (t.batchInputShape = this.batchInputShape), null != this.dtype && (t.dtype = this.dtype), t
      }, e.prototype.disposeWeights = function () {
        return this.weights.forEach(function (t) {
          return t.dispose()
        }), this.weights.length
      }, e.prototype.assertNotDisposed = function () {
        if (0 === this._refCount) throw new Error("Layer '" + this.name + "' is already disposed.")
      }, e.prototype.dispose = function () {
        if (!this.built) throw new Error("Cannot dispose Layer " + this.name + " because it has not been built yet.");
        if (null === this._refCount) throw new Error("Cannot dispose Layer " + this.name + " because it has not been used yet.");
        this.assertNotDisposed();
        var t = 0;
        return 0 == --this._refCount && (t = this.disposeWeights()), {
          refCountAfterDispose: this._refCount,
          numDisposedVariables: t
        }
      }, e
    }(rp.Serializable);
  var Mf, zf = function (t) {
    function e(e) {
      var n = t.call(this, {
        dtype: e.dtype,
        name: null != e.name ? e.name : bf("input").toString()
      }) || this;
      if (null == e.batchSize && (e.batchSize = null), null == e.sparse && (e.sparse = !1), n.trainable = !1, n.built = !0, n.sparse = e.sparse, null != e.inputShape && null != e.batchInputShape) throw new Op("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
      var r = e.batchInputShape;
      if (null == r) {
        if (null == e.inputShape) throw new Op("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
        r = [e.batchSize].concat(e.inputShape)
      } else if (null != e.batchSize) throw new Op("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
      var a = e.dtype || "float32";
      n.batchInputShape = r, n.dtype = a, n.inputSpec = [{
        shape: r
      }];
      var i = new Tf(n.dtype, n.batchInputShape, n, [], {}, n.name);
      return i.nodeIndex = 0, i.tensorIndex = 0, new Of({
        outboundLayer: n,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: [i],
        outputTensors: [i],
        inputMasks: [null],
        outputMasks: [null],
        inputShapes: [r],
        outputShapes: [r]
      }), n
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      throw new Op("Cannot pass any input to an InputLayer's apply() method. InputLayer name: " + this.name)
    }, e.prototype.dispose = function () {
      return {
        refCountAfterDispose: this._refCount,
        numDisposedVariables: 0
      }
    }, e.prototype.getConfig = function () {
      return {
        batchInputShape: this.batchInputShape,
        dtype: this.dtype,
        sparse: this.sparse,
        name: this.name
      }
    }, e.className = "InputLayer", e
  }(Ff);

  function Lf(t) {
    if (null == t.batchShape && null == t.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
    if (null != t.batchShape && null != t.shape) throw new Op("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
    var e = t.batchShape;
    null != t.shape && null == e && (e = [null].concat(t.shape));
    var n = t.dtype;
    return null == n && (n = "float32"), new zf({
      batchInputShape: e,
      name: t.name,
      dtype: n,
      sparse: t.sparse
    }).inboundNodes[0].outputTensors[0]
  }

  function Bf(t) {
    return Ep(this, void 0, void 0, function () {
      var e, n, r, a, i, o, s, u;
      return Ap(this, function (l) {
        switch (l.label) {
          case 0:
            if (null == t) return [2];
            for (a in e = [], n = [], r = [], t) "number" != typeof (i = t[a]) && (o = i, e.push(o.data()), n.push(a), r.push(o));
            return e.length > 0 ? [4, Promise.all(e)] : [3, 2];
          case 1:
            for (s = l.sent(), u = 0; u < s.length; ++u) t[n[u]] = s[u][0];
            Ve(r), l.label = 2;
          case 2:
            return [2]
        }
      })
    })
  }

  function Pf(t) {
    if (null != t)
      for (var e in t) {
        var n = t[e];
        "number" != typeof n && n.dispose()
      }
  }
  rp.registerClass(zf),
    function (t) {
      t[t.SILENT = 0] = "SILENT", t[t.VERBOSE = 1] = "VERBOSE"
    }(Mf || (Mf = {}));
  var Wf = 125,
    Vf = function () {
      function t() {
        this.validationData = null
      }
      return t.prototype.setParams = function (t) {
        this.params = t
      }, t.prototype.onEpochBegin = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (t) {
            return [2]
          })
        })
      }, t.prototype.onEpochEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (t) {
            return [2]
          })
        })
      }, t.prototype.onBatchBegin = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (t) {
            return [2]
          })
        })
      }, t.prototype.onBatchEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (t) {
            return [2]
          })
        })
      }, t.prototype.onTrainBegin = function (t) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (t) {
            return [2]
          })
        })
      }, t.prototype.onTrainEnd = function (t) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (t) {
            return [2]
          })
        })
      }, t.prototype.setModel = function (t) {}, t
    }(),
    Uf = function () {
      function t(t, e) {
        void 0 === e && (e = 10), null == t && (t = []), this.callbacks = t, this.queueLength = e
      }
      return t.prototype.append = function (t) {
        this.callbacks.push(t)
      }, t.prototype.setParams = function (t) {
        for (var e = 0, n = this.callbacks; e < n.length; e++) n[e].setParams(t)
      }, t.prototype.setModel = function (t) {
        for (var e = 0, n = this.callbacks; e < n.length; e++) n[e].setModel(t)
      }, t.prototype.onEpochBegin = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var n, r;
          return Ap(this, function (a) {
            switch (a.label) {
              case 0:
                null == e && (e = {}), n = 0, r = this.callbacks, a.label = 1;
              case 1:
                return n < r.length ? [4, r[n].onEpochBegin(t, e)] : [3, 4];
              case 2:
                a.sent(), a.label = 3;
              case 3:
                return n++, [3, 1];
              case 4:
                return [2]
            }
          })
        })
      }, t.prototype.onEpochEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var n, r;
          return Ap(this, function (a) {
            switch (a.label) {
              case 0:
                null == e && (e = {}), n = 0, r = this.callbacks, a.label = 1;
              case 1:
                return n < r.length ? [4, r[n].onEpochEnd(t, e)] : [3, 4];
              case 2:
                a.sent(), a.label = 3;
              case 3:
                return n++, [3, 1];
              case 4:
                return [2]
            }
          })
        })
      }, t.prototype.onBatchBegin = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var n, r;
          return Ap(this, function (a) {
            switch (a.label) {
              case 0:
                null == e && (e = {}), n = 0, r = this.callbacks, a.label = 1;
              case 1:
                return n < r.length ? [4, r[n].onBatchBegin(t, e)] : [3, 4];
              case 2:
                a.sent(), a.label = 3;
              case 3:
                return n++, [3, 1];
              case 4:
                return [2]
            }
          })
        })
      }, t.prototype.onBatchEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var n, r;
          return Ap(this, function (a) {
            switch (a.label) {
              case 0:
                null == e && (e = {}), n = 0, r = this.callbacks, a.label = 1;
              case 1:
                return n < r.length ? [4, r[n].onBatchEnd(t, e)] : [3, 4];
              case 2:
                a.sent(), a.label = 3;
              case 3:
                return n++, [3, 1];
              case 4:
                return [2]
            }
          })
        })
      }, t.prototype.onTrainBegin = function (t) {
        return Ep(this, void 0, void 0, function () {
          var e, n;
          return Ap(this, function (r) {
            switch (r.label) {
              case 0:
                null == t && (t = {}), e = 0, n = this.callbacks, r.label = 1;
              case 1:
                return e < n.length ? [4, n[e].onTrainBegin(t)] : [3, 4];
              case 2:
                r.sent(), r.label = 3;
              case 3:
                return e++, [3, 1];
              case 4:
                return [2]
            }
          })
        })
      }, t.prototype.onTrainEnd = function (t) {
        return Ep(this, void 0, void 0, function () {
          var e, n;
          return Ap(this, function (r) {
            switch (r.label) {
              case 0:
                null == t && (t = {}), e = 0, n = this.callbacks, r.label = 1;
              case 1:
                return e < n.length ? [4, n[e].onTrainEnd(t)] : [3, 4];
              case 2:
                r.sent(), r.label = 3;
              case 3:
                return e++, [3, 1];
              case 4:
                return [2]
            }
          })
        })
      }, t
    }(),
    jf = function (t) {
      function e() {
        return t.call(this) || this
      }
      return Sp(e, t), e.prototype.onEpochBegin = function (t) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (t) {
            return this.seen = 0, this.totals = {}, [2]
          })
        })
      }, e.prototype.onBatchEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var t, n, r, a, i = this;
          return Ap(this, function (o) {
            for (a in null == e && (e = {}), t = null == e.size ? 0 : e.size, this.seen += t, n = function (n) {
                var a = e[n];
                if ("number" == typeof a) r.totals.hasOwnProperty(n) || (r.totals[n] = 0), r.totals[n] = r.totals[n] + a * t;
                else {
                  var o = void 0;
                  n in r.totals ? o = r.totals[n] : r.totals[n] = 0;
                  var s = We(function () {
                    return ls(i.totals[n], Ns(a, t))
                  });
                  r.totals[n] = s, null != o && o.dispose()
                }
              }, r = this, e) n(a);
            return [2]
          })
        })
      }, e.prototype.onEpochEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var t, n, r, a, i, o = this;
          return Ap(this, function (s) {
            if (null != e)
              for (t = function (t) {
                  if (null == n.totals[t]) return "continue";
                  "number" == typeof n.totals[t] ? e[t] = n.totals[t] / n.seen : We(function () {
                    var n = Ns(fs(1, o.seen), o.totals[t]);
                    e[t] = n, o.totals[t].dispose(), Ue(e[t])
                  })
                }, n = this, r = 0, a = this.params.metrics; r < a.length; r++) i = a[r], t(i);
            return [2]
          })
        })
      }, e
    }(Vf),
    Gf = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e.prototype.onTrainBegin = function (t) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (t) {
            return this.epoch = [], this.history = {}, [2]
          })
        })
      }, e.prototype.onEpochEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var n;
          return Ap(this, function (r) {
            for (n in null == e && (e = {}), this.epoch.push(t), e) null == this.history[n] && (this.history[n] = []), this.history[n].push(e[n]);
            return [2]
          })
        })
      }, e.prototype.syncData = function () {
        return Ep(this, void 0, void 0, function () {
          var t, e, n, r, a, i, o, s, u;
          return Ap(this, function (l) {
            switch (l.label) {
              case 0:
                for (r in t = [], e = [], n = [], this.history)
                  for (a = this.history[r], i = 0; i < a.length; ++i) "number" != typeof a[i] && (o = a[i], t.push(o.data()), e.push(r), n.push(i));
                return [4, Promise.all(t)];
              case 1:
                for (s = l.sent(), u = 0; u < s.length; ++u) this.history[e[u]][n[u]].dispose(), this.history[e[u]][n[u]] = s[u][0];
                return [2]
            }
          })
        })
      }, e
    }(Vf),
    qf = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        if (r.currentEpoch = 0, r.yieldEvery = n || "auto", "auto" === r.yieldEvery && (r.yieldEvery = Wf), "never" === r.yieldEvery && null != e.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
        return nt.isNumber(r.yieldEvery) && (r.maybeWait = function (t, e) {
          var n, r = nt.now();
          return function () {
            for (var a = [], i = 0; i < arguments.length; i++) a[i] = arguments[i];
            var o = nt.now();
            return o - r < e ? n : (r = o, n = t.apply(void 0, a))
          }
        }(r.maybeWait.bind(r), r.yieldEvery)), r.trainBegin = e.onTrainBegin, r.trainEnd = e.onTrainEnd, r.epochBegin = e.onEpochBegin, r.epochEnd = e.onEpochEnd, r.batchBegin = e.onBatchBegin, r.batchEnd = e.onBatchEnd, r.yield = e.onYield, r
      }
      return Sp(e, t), e.prototype.maybeWait = function (t, e, n) {
        return Ep(this, void 0, void 0, function () {
          var r;
          return Ap(this, function (a) {
            switch (a.label) {
              case 0:
                return r = [], null == this.yield ? [3, 2] : [4, Bf(n)];
              case 1:
                a.sent(), r.push(this.yield(t, e, n)), a.label = 2;
              case 2:
                return r.push(Cp()), [4, Promise.all(r)];
              case 3:
                return a.sent(), [2]
            }
          })
        })
      }, e.prototype.onEpochBegin = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (n) {
            switch (n.label) {
              case 0:
                return this.currentEpoch = t, null == this.epochBegin ? [3, 3] : [4, Bf(e)];
              case 1:
                return n.sent(), [4, this.epochBegin(t, e)];
              case 2:
                n.sent(), n.label = 3;
              case 3:
                return [2]
            }
          })
        })
      }, e.prototype.onEpochEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var n;
          return Ap(this, function (r) {
            switch (r.label) {
              case 0:
                return n = [], null == this.epochEnd ? [3, 2] : [4, Bf(e)];
              case 1:
                r.sent(), n.push(this.epochEnd(t, e)), r.label = 2;
              case 2:
                return "epoch" === this.yieldEvery && n.push(Cp()), [4, Promise.all(n)];
              case 3:
                return r.sent(), [2]
            }
          })
        })
      }, e.prototype.onBatchBegin = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (n) {
            switch (n.label) {
              case 0:
                return null == this.batchBegin ? [3, 3] : [4, Bf(e)];
              case 1:
                return n.sent(), [4, this.batchBegin(t, e)];
              case 2:
                n.sent(), n.label = 3;
              case 3:
                return [2]
            }
          })
        })
      }, e.prototype.onBatchEnd = function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var n;
          return Ap(this, function (r) {
            switch (r.label) {
              case 0:
                return n = [], null == this.batchEnd ? [3, 2] : [4, Bf(e)];
              case 1:
                r.sent(), n.push(this.batchEnd(t, e)), r.label = 2;
              case 2:
                return "batch" === this.yieldEvery ? n.push(Cp()) : nt.isNumber(this.yieldEvery) && n.push(this.maybeWait(this.currentEpoch, t, e)), [4, Promise.all(n)];
              case 3:
                return r.sent(), [2]
            }
          })
        })
      }, e.prototype.onTrainBegin = function (t) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (e) {
            switch (e.label) {
              case 0:
                return null == this.trainBegin ? [3, 3] : [4, Bf(t)];
              case 1:
                return e.sent(), [4, this.trainBegin(t)];
              case 2:
                e.sent(), e.label = 3;
              case 3:
                return [2]
            }
          })
        })
      }, e.prototype.onTrainEnd = function (t) {
        return Ep(this, void 0, void 0, function () {
          return Ap(this, function (e) {
            switch (e.label) {
              case 0:
                return null == this.trainEnd ? [3, 3] : [4, Bf(t)];
              case 1:
                return e.sent(), [4, this.trainEnd(t)];
              case 2:
                e.sent(), e.label = 3;
              case 3:
                return [2]
            }
          })
        })
      }, e
    }(Vf);

  function Hf(t, e) {
    return null == t && (t = {}), t instanceof Vf ? [t] : Array.isArray(t) && t[0] instanceof Vf ? t : Pp(t).map(function (t) {
      return new qf(t, e)
    })
  }
  var Kf = function () {
    function t() {}
    return t.registerCallbackConstructor = function (e, n) {
      nt.assert(e >= 0 && Number.isInteger(e), function () {
        return "Verbosity level is expected to be an integer >= 0, but got " + e
      }), t.checkForDuplicate(n), null == t.constructors[e] && (t.constructors[e] = []), t.constructors[e].push(n)
    }, t.checkForDuplicate = function (e) {
      for (var n in t.constructors) t.constructors[+n].forEach(function (t) {
        if (t === e) throw new Op("Duplicate callback constructor.")
      })
    }, t.clear = function () {
      t.constructors = {}
    }, t.createCallbacks = function (e) {
      var n = [];
      for (var r in t.constructors) {
        var a = +r;
        e >= a && n.push.apply(n, t.constructors[a])
      }
      return n.map(function (t) {
        return new t
      })
    }, t.constructors = {}, t
  }();

  function Xf(t, e, n, r, a, i, o, s, u) {
    var l = new Gf,
      c = [new jf].concat(Kf.createCallbacks(e));
    null != t && c.push.apply(c, t), c.push(l);
    var p = new Uf(c);
    return p.setParams({
      epochs: n,
      initialEpoch: r,
      samples: a,
      steps: i,
      batchSize: o,
      verbose: e,
      doValidation: s,
      metrics: u
    }), {
      callbackList: p,
      history: l
    }
  }

  function $f(t, e, n) {
    return void 0 === e && (e = {}), void 0 === n && (n = !1), Gp(t, rp.SerializationMap.getMap().classNameMap, e, "layer", n)
  }

  function Yf(t, e) {
    return We(function () {
      "float32" !== t.dtype && (t = t.asType("float32"));
      var n = Bu(Vh(t), e, !0),
        r = Cn(n.shape, Rp()),
        a = Po(vs(n, r));
      return fs(t, a)
    })
  }

  function Jf(t, e) {
    return We(function () {
      return Mu(Vh(Rs(e, t)), -1)
    })
  }

  function Zf(t, e) {
    return We(function () {
      return Mu(uo(Rs(e, t)), -1)
    })
  }

  function Qf(t, e) {
    return We(function () {
      var n = Rs(t, e),
        r = vo(uo(t), Rp(), Number.MAX_VALUE),
        a = uo(fs(n, r));
      return Ns(100, Mu(a, -1))
    })
  }

  function td(t, e, n) {
    return void 0 === n && (n = !1), We(function () {
      if (n) e = Wr(e);
      else {
        var r = Bu(e, e.shape.length - 1, !0);
        e = fs(e, r)
      }
      return e = vo(e, Rp(), 1 - Rp()), Eo(Bu(Ns(t.toFloat(), So(e)), e.shape.length - 1))
    })
  }

  function ed(t, e) {
    return We(function () {
      var n = No(function (t) {
          var e = [kh(t.shape)];
          return t.reshape(e)
        }(t)).toInt(),
        r = (e = vo(e, Rp(), 1 - Rp())).shape;
      return td(nr(n, r[r.length - 1]).reshape(r), e, !1)
    })
  }

  function nd(t, e) {
    return We(function () {
      var n;
      return n = vo(e, Rp(), 1 - Rp()), n = So(fs(n, Rs(1, n))), Mu(function (t, e) {
        if (!nt.arraysEqual(t.shape, e.shape)) throw new Op("logits and labels must have the same shape, but got shapes " + JSON.stringify(t.shape) + " and " + JSON.stringify(e.shape));
        return We(function () {
          var n = e.relu(),
            r = e.abs().neg();
          return n.sub(e.mul(t)).add(r.exp().log1p())
        })
      }(t, n), -1)
    })
  }

  function rd(t, e) {
    return We(function () {
      var n = Yf(t, -1),
        r = Yf(e, -1),
        a = Ns(n, r);
      return Eo(Bu(a, -1))
    })
  }
  var ad = {
    meanSquaredError: Jf,
    meanAbsoluteError: Zf,
    meanAbsolutePercentageError: Qf,
    meanSquaredLogarithmicError: function (t, e) {
      return We(function () {
        var n = vo(e, Rp(), Number.MAX_VALUE),
          r = So(ls(1, n)),
          a = vo(t, Rp(), Number.MAX_VALUE),
          i = So(ls(1, a));
        return Mu(Vh(Rs(r, i)), -1)
      })
    },
    squaredHinge: function (t, e) {
      return We(function () {
        var n = vs(0, Rs(1, Ns(t, e)));
        return Mu(Vh(n), -1)
      })
    },
    hinge: function (t, e) {
      return We(function () {
        var n = vs(0, Rs(1, Ns(t, e)));
        return Mu(n, -1)
      })
    },
    categoricalHinge: function (t, e) {
      return We(function () {
        var n = Bu(Ns(t, e), -1),
          r = Fu(Ns(Rs(1, t), e), -1);
        return vs(0, ls(1, Rs(r, n)))
      })
    },
    logcosh: function (t, e) {
      return We(function () {
        var n = Math.log(2),
          r = Rs(e, t),
          a = Rs(ls(r, Bo(Ns(-2, r))), n);
        return Mu(a, -1)
      })
    },
    categoricalCrossentropy: td,
    sparseCategoricalCrossentropy: ed,
    binaryCrossentropy: nd,
    kullbackLeiblerDivergence: function (t, e) {
      return We(function () {
        var n = vo(t, Rp(), 1),
          r = vo(e, Rp(), 1);
        return Bu(Ns(t, So(fs(n, r))), -1)
      })
    },
    poisson: function (t, e) {
      return We(function () {
        var n = So(ls(Rp(), e));
        return Mu(Rs(e, Ns(t, n)), -1)
      })
    },
    cosineProximity: rd
  };

  function id(t) {
    if ("string" == typeof t) {
      if (t in ad) return ad[t];
      var e = "Unknown loss " + t;
      throw t.toLowerCase().includes("softmaxcrossentropy") && (e = "Unknown loss " + t + '. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new Op(e)
    }
    return t
  }

  function od(t, e) {
    return We(function () {
      var n = Ns(.5, kn(e)),
        r = Th(_s(e, n), t.dtype);
      return Mu(Ds(t, r), -1)
    })
  }

  function sd(t, e) {
    return We(function () {
      return Th(Ds(Du(t, -1), Du(e, -1)), "float32")
    })
  }

  function ud(t, e) {
    return We(function () {
      return rs(t.equal(1), e.equal(1)).sum().cast("float32")
    })
  }

  function ld(t, e) {
    return We(function () {
      var n = ud(t, e),
        r = function (t, e) {
          return We(function () {
            return rs(t.equal(0), e.equal(1)).sum().cast("float32")
          })
        }(t, e),
        a = n.add(r);
      return ss(_s(a, 0), n.div(a), 0).cast("float32")
    })
  }

  function cd(t, e) {
    return We(function () {
      var n = ud(t, e),
        r = function (t, e) {
          return We(function () {
            return rs(t.equal(1), e.equal(0)).sum().cast("float32")
          })
        }(t, e),
        a = n.add(r);
      return ss(_s(a, 0), n.div(a), 0).cast("float32")
    })
  }

  function pd(t, e) {
    return nd(t, e)
  }

  function hd(t, e) {
    return t.rank === e.rank && (t = t.squeeze([t.rank - 1])), (e = e.argMax(-1)).dtype !== t.dtype && (e = e.asType(t.dtype)), Ds(t, e).asType("float32")
  }
  var fd = td,
    dd = ed,
    md = {
      binaryAccuracy: od,
      categoricalAccuracy: sd,
      precision: ld,
      categoricalCrossentropy: fd,
      sparseCategoricalCrossentropy: dd,
      mse: Jf,
      MSE: Jf,
      mae: Zf,
      MAE: Zf,
      mape: Qf,
      MAPE: Qf,
      cosine: rd
    };

  function gd(t) {
    if (zp(null !== t, "Unknown LossOrMetricFn " + t), "string" == typeof t) return t;
    for (var e = void 0, n = 0, r = Object.keys(ad); n < r.length; n++) {
      var a = r[n];
      if (ad[a] === t) {
        e = a;
        break
      }
    }
    if (void 0 !== e) return e;
    for (var i = 0, o = Object.keys(md); i < o.length; i++)
      if (a = o[i], md[a] === t) {
        e = a;
        break
      } return void 0 !== e ? e : t.name
  }
  var vd = 1048576;

  function yd(t, e, n) {
    if (void 0 === n && (n = !1), null == t || "object" != typeof t || Object.getPrototypeOf(t) !== Object.prototype || ! function t(e) {
        if (null === e) return !0;
        if ("object" == typeof e) {
          if (Object.getPrototypeOf(e) === Object.prototype) {
            for (var n = 0, r = Object.keys(e); n < r.length; n++) {
              var a = r[n];
              if ("string" != typeof a) return !1;
              if (!t(e[a])) return !1
            }
            return !0
          }
          if (Array.isArray(e)) {
            for (var i = 0, o = e; i < o.length; i++)
              if (!t(o[i])) return !1;
            return !0
          }
          return !1
        }
        var s = typeof e;
        return "string" === s || "number" === s || "boolean" === s
      }(t)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
    if (n) {
      var r = JSON.stringify(t);
      r.length > vd && console.warn('User-defined metadata of model "' + e + '" is too large in size (length=' + r.length + " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= " + vd + ".")
    }
  }

  function bd(t, e, n, r) {
    void 0 === r && (r = console.log);
    var a, i = function (t) {
        var e = !0,
          n = [],
          r = [];
        for (var a in t.nodesByDepth) n.push(t.nodesByDepth[a]);
        for (var i = 0, o = n; i < o.length; i++) {
          var s = o[i];
          if (s.length > 1 || 1 === s.length && s[0].inboundLayers.length > 1) {
            e = !1;
            break
          }
          r.push.apply(r, s)
        }
        if (e)
          for (var u = 0, l = t.layers; u < l.length; u++) {
            for (var c = !1, p = 0, h = l[u].inboundNodes; p < h.length; p++) {
              var f = h[p];
              if (-1 !== r.indexOf(f)) {
                if (c) {
                  e = !1;
                  break
                }
                c = !0
              }
            }
            if (!e) break
          }
        return e
      }(t),
      o = ["Layer (type)", "Output shape", "Param #"];
    if (i ? (e = e || 65, n = n || [.45, .85, 1]) : (e = e || 98, n = n || [.33, .55, .67, 1]), n[n.length - 1] <= 1 && (n = n.map(function (t) {
        return Math.floor(e * t)
      })), !i)
      for (var s in o.push("Receives inputs"), a = [], t.nodesByDepth) a.push.apply(a, t.nodesByDepth[s]);
    r("_".repeat(e)), xd(o, n, r), r("=".repeat(e));
    for (var u = t.layers, l = 0; l < u.length; ++l) i ? wd(u[l], n, r) : Cd(u[l], n, a, r), r((l === u.length - 1 ? "=" : "_").repeat(e));
    t.checkTrainableWeightsConsistency();
    var c = function (t) {
        return null != t.collectedTrainableWeights ? Sf(t.collectedTrainableWeights) : Sf(t.trainableWeights)
      }(t),
      p = Sf(t.nonTrainableWeights);
    r("Total params: " + (c + p)), r("Trainable params: " + c), r("Non-trainable params: " + p), r("_".repeat(e))
  }

  function xd(t, e, n) {
    void 0 === n && (n = console.log);
    for (var r = "", a = 0; a < t.length; ++a) a > 0 && (r = r.slice(0, r.length - 1) + " "), r = (r += t[a]).slice(0, e[a]), r += " ".repeat(e[a] - r.length);
    n(r)
  }

  function wd(t, e, n) {
    var r;
    try {
      r = JSON.stringify(t.outputShape)
    } catch (t) {
      r = "multiple"
    }
    xd([t.name + " (" + t.getClassName() + ")", r, t.countParams().toString()], e, n)
  }

  function Cd(t, e, n, r) {
    var a;
    try {
      a = JSON.stringify(t.outputShape)
    } catch (t) {
      a = "multiple"
    }
    for (var i = [], o = 0, s = t.inboundNodes; o < s.length; o++) {
      var u = s[o];
      if (!(null != n && n.length > 0 && -1 === n.indexOf(u)))
        for (var l = 0; l < u.inboundLayers.length; ++l) {
          var c = u.inboundLayers[l].name,
            p = u.nodeIndices[l],
            h = u.tensorIndices[l];
          i.push(c + "[" + p + "][" + h + "]")
        }
    }
    var f = t.name,
      d = t.getClassName(),
      m = 0 === i.length ? "" : i[0];
    for (xd([f + " (" + d + ")", a, t.countParams().toString(), m], e, r), l = 1; l < i.length; ++l) xd(["", "", "", i[l]], e, r)
  }

  function Nd(t, e, n) {
    return ("inboundNodes" === t || "outputLayers" === t || "inputLayers" === t) && 0 === e && "string" == typeof n
  }

  function Sd(t, e) {
    if (null === t) return null;
    if ("string" == typeof t) return Vp(t);
    if ("number" == typeof t || "boolean" == typeof t) return t;
    if (t instanceof Array) {
      for (var n = [], r = t.length, a = 0; a < r; ++a) {
        var i = t[a];
        Nd(e, a, i) ? n.push(i) : n.push(Sd(i, e))
      }
      return n
    }
    for (var o = {}, s = 0, u = Object.keys(t); s < u.length; s++) {
      var l = u[s],
        c = t[l];
      if ("name" === l && "string" == typeof c) o[l] = c;
      else {
        var p = Vp(l);
        o[p] = Sd(c, p)
      }
    }
    return o
  }
  var kd = function () {
      function t(e) {
        if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof t)
          for (var n in e.id2Value) this.id2Value[n] = e.id2Value[n], n in e.id2Mask && (this.id2Mask[n] = e.id2Mask[n]);
        else {
          if (null == e) return;
          for (var r = 0, a = e; r < a.length; r++) {
            var i = a[r];
            this.add(i.key, i.value)
          }
        }
      }
      return t.prototype.add = function (t, e, n) {
        if (null != this.id2Value[t.id]) throw new Op("Duplicate key: name=" + t.name + ", id=" + t.id);
        return this.id2Value[t.id] = function (t, e) {
          if (null == t.dtype || t.dtype === e.dtype) return e;
          try {
            return $n(e, t.dtype)
          } catch (n) {
            throw new Op("The dtype of the feed (" + e.dtype + ") can not be cast to the dtype of the key '" + t.name + "' (" + t.dtype + ").")
          }
        }(t, e), this.name2Id[t.name] = t.id, null != n && (this.id2Mask[t.id] = n), this
      }, t.prototype.addFeed = function (t) {
        this.add(t.key, t.value)
      }, t.prototype.hasKey = function (t) {
        return null != this.id2Value[t.id]
      }, t.prototype.names = function () {
        return Object.keys(this.name2Id)
      }, t.prototype.getValue = function (t) {
        if (t instanceof Tf) {
          if (null == this.id2Value[t.id]) throw new Op("Nonexistent key: " + t.name);
          return this.id2Value[t.id]
        }
        var e = this.name2Id[t];
        if (null == e) throw new Op("Feed dict has no SymbolicTensor name: " + t);
        return this.id2Value[e]
      }, t.prototype.getMask = function (t) {
        if (t instanceof Tf) {
          if (null == this.id2Value[t.id]) throw new Op("Nonexistent key: " + t.name);
          return this.id2Mask[t.id]
        }
        var e = this.name2Id[t];
        if (null == e) throw new Op("Feed dict has no SymbolicTensor name: " + t);
        return this.id2Mask[e]
      }, t.prototype.disposeMasks = function () {
        null != this.id2Mask && Ve(this.id2Mask)
      }, t
    }(),
    Id = {},
    Ed = {};

  function Ad(t, e, n, r) {
    for (var a = null != n && n.training, i = Array.isArray(t), o = i ? t : [t], s = o.map(function (t) {
        return t.name
      }), u = [], l = e.names(), c = 0, p = s; c < p.length; c++) {
      var h = p[c]; - 1 !== l.indexOf(h) ? u.push(e.getValue(h)) : u.push(null)
    }
    null != r && (r.maxNumTensors = -1 / 0, r.minNumTensors = 1 / 0);
    var f, d, m = s.join(",") + "|" + e.names().join(",");
    if (null == Id[m]) {
      var g = function (t, e) {
        nt.assert(null != t && t.length > 0, function () {
          return "Expected at least one fetch, got none"
        });
        var n = [],
          r = {};
        if (1 === t.length) {
          var a = Rd(t[0], e);
          n = a.sorted, r = a.recipientMap
        } else
          for (var i = new Set, o = 0, s = t; o < s.length; o++) {
            for (var u = Rd(s[o], e), l = u.sorted, c = u.recipientMap, p = 0, h = l; p < h.length; p++) {
              var f = h[p];
              i.has(f.name) || (n.push(f), i.add(f.name))
            }
            var d = function (t) {
              null == r[t] && (r[t] = new Set), c[t].forEach(function (e) {
                return r[t].add(e)
              })
            };
            for (var m in c) d(m)
          }
        return {
          sorted: n,
          recipientCounts: function (t) {
            var e = {};
            for (var n in t) e[n] = t[n].size;
            return e
          }(r)
        }
      }(o, e);
      f = g.sorted, d = g.recipientCounts, Id[m] = f, Ed[m] = d
    }
    f = Id[m], d = {}, a || Object.assign(d, Ed[m]);
    for (var v = new kd(e), y = 0; y < f.length; ++y) {
      if (null != r) {
        var b = Pe().numTensors;
        b > r.maxNumTensors && (r.maxNumTensors = b), b < r.minNumTensors && (r.minNumTensors = b)
      }
      var x = f[y],
        w = x.sourceLayer;
      if (!(w instanceof zf)) {
        for (var C = [], N = [], S = [], k = !1, I = 0, E = x.inputs; I < E.length; I++) {
          var A = E[I],
            R = v.getValue(A),
            T = v.getMask(A);
          C.push(R), N.push(T), null != T && (k = !0), a || (d[A.name]--, 0 !== d[A.name] || e.hasKey(A) || -1 !== s.indexOf(A.name) || R.isDisposed || !0 === A.sourceLayer.stateful || S.push(R))
        }
        k && ((n = n || {}).mask = N[0]);
        var D = Pp(w.apply(C, n)),
          O = null;
        w.supportsMasking && (O = w.computeMask(C, N));
        for (var _ = Td(x), F = Array.isArray(_) ? _ : [_], M = 0; M < F.length; ++M) {
          v.hasKey(F[M]) || v.add(F[M], D[M], Array.isArray(O) ? O[0] : O);
          var z = s.indexOf(F[M].name); - 1 !== z && (u[z] = D[M])
        }
        a || Ve(S)
      }
    }
    return v.disposeMasks(), i ? u : u[0]
  }

  function Rd(t, e) {
    for (var n = new Set, r = [], a = {}, i = 0, o = e.names(); i < o.length; i++) {
      var s = o[i];
      n.add(s)
    }
    var u = [],
      l = [];
    for (u.push(t); u.length > 0;) {
      var c = u[u.length - 1];
      if (n.has(c.name)) u.pop();
      else {
        var p = l[l.length - 1] === u.length - 1;
        if (0 === c.inputs.length || p) u.pop(), r.push(c), n.add(c.name), p && l.pop();
        else {
          l.push(u.length - 1);
          for (var h = 0, f = c.inputs; h < f.length; h++) {
            var d = f[h];
            null == a[d.name] && (a[d.name] = new Set), a[d.name].add(c.name), n.has(d.name) || u.push(d)
          }
        }
      }
    }
    return {
      sorted: r,
      recipientMap: a
    }
  }

  function Td(t) {
    var e;
    if (1 === t.sourceLayer.inboundNodes.length) e = t.sourceLayer.output;
    else {
      for (var n = null, r = 0; r < t.sourceLayer.inboundNodes.length; ++r)
        for (var a = 0, i = t.sourceLayer.inboundNodes[r].outputTensors; a < i.length; a++)
          if (i[a].id === t.id) {
            n = r;
            break
          } e = t.sourceLayer.getOutputAt(n)
    }
    return e
  }

  function Dd(t, e) {
    return function (t, e, n) {
      var r = e.length;
      if (null == t || Array.isArray(t) && 0 === t.length) return e.map(function (t) {
        return null
      });
      if (1 === r) return Array.isArray(t) && 1 === t.length ? t : "object" == typeof t && e[0] in t ? [t[e[0]]] : [t];
      if (Array.isArray(t)) {
        if (t.length !== r) throw new Error("Provided " + n + " is an array of " + t.length + " element(s), but the model has " + r + " outputs. Make sure a set of weights is provided for each model output.");
        return t
      }
      if ("object" == typeof t && Object.keys(t).length > 0 && "object" == typeof t[Object.keys(t)[0]]) {
        var a = [];
        return e.forEach(function (e) {
          e in t ? a.push(t[e]) : a.push(null)
        }), a
      }
      throw new Error("The model has multiple (" + r + ") outputs, so " + n + " must be either an array with " + r + " elements or an object with " + e + " keys. Provided " + n + " not understood: " + JSON.stringify(t))
    }(t, e, "classWeight")
  }

  function Od(t, e, n, r) {
    return Ep(this, void 0, void 0, function () {
      var a, i, o, s, u;
      return Ap(this, function (l) {
        switch (l.label) {
          case 0:
            if (null != e || null != r) throw new Error("Support sampleWeight is not implemented yet");
            return null == n ? [3, 2] : (a = We(function () {
              if (1 === t.shape.length) return t.clone();
              if (2 === t.shape.length) {
                if (t.shape[1] > 1) return t.argMax(1);
                if (1 === t.shape[1]) return t.reshape([t.shape[0]]);
                throw new Error("Encountered unexpected last-dimension size (" + t.shape[1] + ") during handling of class weights. The size is expected to be >= 1.")
              }
              throw new Error("Unexpected rank of target (y) tensor (" + t.rank + ") during handling of class weights. The rank is expected to be 1 or 2.")
            }), s = (o = Array).from, [4, a.data()]);
          case 1:
            return i = s.apply(o, [l.sent()]), Ve(a), u = [], i.forEach(function (t) {
              if (null == n[t]) throw new Error("classWeight must contain all classes in the training data. The class " + t + " exists in the data but not in classWeight");
              u.push(n[t])
            }), [2, fn(u, "float32")];
          case 2:
            return [2, null]
        }
      })
    })
  }

  function _d(t, e) {
    return Ns(t, e)
  }
  var Fd = 32;

  function Md(t, e) {
    var n, r, a = e;
    n = a.xs, r = a.ys, nt.assert(null != n && null != r, function () {
      return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + e
    });
    var i = zd("input", t.inputNames, n),
      o = zd("output", t.outputNames, r),
      s = i[0].shape[0];
    nt.assert(i.length === t.inputs.length, function () {
      return "LayersModel has " + t.inputs.length + " inputs, but the dataset provides " + i.length + " inputs.  (Expected input keys: " + JSON.stringify(t.inputNames) + ")"
    }), nt.assert(o.length === t.outputs.length, function () {
      return "LayersModel has " + t.outputs.length + " outputs, but the dataset provides " + o.length + " outputs.  (Expected output keys: " + JSON.stringify(t.outputNames) + ")"
    });
    for (var u = function (e) {
        nt.assert(i[e].shape[0] === s, function () {
          return "Batch size mismatch: input " + t.inputNames[e] + " has " + i[e].shape[0] + "; expected  " + s + " based on input " + t.inputNames[0] + "."
        })
      }, l = 0; l < i.length; l++) u(l);
    for (var c = function (e) {
        nt.assert(o[e].shape[0] === s, function () {
          return "Batch size mismatch: output " + t.outputNames[e] + " has " + o[e].shape[0] + "; expected  " + s + " based on input " + t.inputNames[0] + "."
        })
      }, p = 0; p < o.length; p++) c(p);
    return {
      xs: i,
      ys: o
    }
  }

  function zd(t, e, n) {
    if (n instanceof mt) return [n];
    if (Array.isArray(n)) return nt.assert(n.length === e.length, function () {
      return "Received an array of " + n.length + " Tensors, but expected " + e.length + " to match the " + t + " keys " + e + "."
    }), n;
    for (var r = [], a = 0, i = e; a < i.length; a++) {
      var o = i[a];
      if (null == n[o]) throw new Op("The feature data generated by the dataset lacks the required " + t + " key '" + o + "'.");
      r.push(n[o])
    }
    return r
  }

  function Ld(t, e, n) {
    return Ep(this, void 0, void 0, function () {
      var r, a, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, C, N, S, k, I, E, A, R, T, D, O, _, F, M, z;
      return Ap(this, function (L) {
        switch (L.label) {
          case 0:
            if (r = null != n.batchesPerEpoch, nt.assert(null != t.optimizer, function () {
                return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."
              }), nt.assert(null != n, function () {
                return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."
              }), nt.assert(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), function () {
                return "For fitDataset(), config.epochs is expected to be a positive integer, but got " + n.epochs
              }), nt.assert(!r || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), function () {
                return "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " + n.batchesPerEpoch
              }), nt.assert(null == n.validationSplit, function () {
                return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."
              }), t.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
            t.isTraining = !0, L.label = 1;
          case 1:
            return L.trys.push([1, , 26, 27]), a = null != n.validationData, i = void 0, o = void 0, a && (Bd(n.validationData) ? nt.assert(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), function () {
              return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " + n.validationBatches
            }) : (s = function (t) {
              if (3 === t.length) throw new _p("Validation with sample weights is not implemented yet.");
              return {
                xs: t[0],
                ys: t[1]
              }
            }(n.validationData), i = s.xs, o = s.ys)), u = t.makeTrainFunction(), l = t.getDedupedMetricsNames(), c = void 0, c = a ? l.slice().concat(l.map(function (t) {
              return "val_" + t
            })) : l.slice(), p = Hf(n.callbacks, n.yieldEvery), h = null == n.verbose ? 1 : n.verbose, f = Xf(p, h, n.epochs, null, null, function (t, e) {
              var n = null;
              return null != e.batchesPerEpoch ? n = e.batchesPerEpoch : Number.isFinite(t.size) && (n = t.size), n
            }(e, n), null, a, c), d = f.callbackList, m = f.history, d.setModel(t), t.history = m, [4, d.onTrainBegin()];
          case 2:
            return L.sent(), t.stopTraining_ = !1, g = null == n.initialEpoch ? 0 : n.initialEpoch, [4, e.iterator()];
          case 3:
            v = L.sent(), L.label = 4;
          case 4:
            return g < n.epochs ? (y = {}, [4, d.onEpochBegin(g)]) : [3, 23];
          case 5:
            return L.sent(), b = 0, x = 0, r ? [3, 7] : [4, e.iterator()];
          case 6:
            v = L.sent(), L.label = 7;
          case 7:
            return !r || b < n.batchesPerEpoch ? [4, v.next()] : [3, 21];
          case 8:
            return w = L.sent(), r && w.done ? (console.warn("You provided `batchesPerEpoch` as " + n.batchesPerEpoch + ", but your dataset iterator ran out of data after " + b + " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset."), [3, 21]) : null == w.value ? [3, 15] : (C = Md(t, w.value), N = C.xs, S = C.ys, (k = {}).batch = x, k.size = N[0].shape[0], [4, d.onBatchBegin(x, k)]);
          case 9:
            if (L.sent(), I = [], null == n.classWeight) return [3, 13];
            E = Dd(n.classWeight, t.outputNames), z = 0, L.label = 10;
          case 10:
            return z < E.length ? (R = (A = I).push, [4, Od(S[z], null, E[z])]) : [3, 13];
          case 11:
            R.apply(A, [L.sent()]), L.label = 12;
          case 12:
            return ++z, [3, 10];
          case 13:
            for (T = N.concat(S).concat(I), D = u(T), Ve(T), z = 0; z < l.length; ++z) O = l[z], _ = D[z], k[O] = _, Ue(_);
            return [4, d.onBatchEnd(x, k)];
          case 14:
            L.sent(), Pf(k), x++, b++, L.label = 15;
          case 15:
            return (r ? b >= n.batchesPerEpoch : w.done) ? a ? (F = void 0, Bd(n.validationData) ? (M = Pp, [4, t.evaluateDataset(n.validationData, {
              batches: n.validationBatches
            })]) : [3, 17]) : [3, 19] : [3, 20];
          case 16:
            return F = M.apply(void 0, [L.sent()]), [3, 18];
          case 17:
            F = Pp(t.evaluate(i, o, {
              batchSize: null == n.validationBatchSize ? Fd : n.validationBatchSize,
              verbose: 0
            })), L.label = 18;
          case 18:
            for (z = 0; z < t.metricsNames.length; ++z) y["val_" + t.metricsNames[z]] = F[z];
            L.label = 19;
          case 19:
            return [3, 21];
          case 20:
            return t.stopTraining_ ? [3, 21] : [3, 7];
          case 21:
            return [4, d.onEpochEnd(g, y)];
          case 22:
            return L.sent(), g++, t.stopTraining_ ? [3, 23] : [3, 4];
          case 23:
            return [4, d.onTrainEnd()];
          case 24:
            return L.sent(), [4, t.history.syncData()];
          case 25:
            return L.sent(), [2, t.history];
          case 26:
            return t.isTraining = !1, [7];
          case 27:
            return [2]
        }
      })
    })
  }

  function Bd(t) {
    return "function" == typeof t.iterator
  }

  function Pd(t) {
    nt.assert(t > 0 && Number.isInteger(t), function () {
      return "batchSize is required to be a positive integer, but got " + t
    })
  }

  function Wd(t, e, n) {
    return null == t ? [null] : Array.isArray(t) ? t.map(function (t) {
      return Oh(t, e, n - e)
    }) : Oh(t, e, n - e)
  }

  function Vd(t, e) {
    return We(function () {
      return null == t ? null : Array.isArray(t) ? t.map(function (t) {
        return Vd(t, e)
      }) : Wh(t, "int32" === e.dtype ? e : e.toInt())
    })
  }

  function Ud(t, e) {
    for (var n = [], r = 0, a = null; r < t;)(a = r + e) >= t && (a = t), n.push([r, a]), r = a;
    return n
  }

  function jd(t, e, n, r) {
    return void 0 === r && (r = {}), Ep(this, void 0, void 0, function () {
      var a, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, C, N, S, k;
      return Ap(this, function (I) {
        switch (I.label) {
          case 0:
            if (t.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
            t.isTraining = !0, I.label = 1;
          case 1:
            return I.trys.push([1, , 7, 8]), Pd(p = null == r.batchSize ? 32 : r.batchSize), h = !1, [4, t.standardizeUserData(e, n, r.sampleWeight, r.classWeight, h, p)];
          case 2:
            if (f = I.sent(), a = f[0], i = f[1], c = f[2], d = !1, m = void 0, !(null != r.validationData && r.validationData.length > 0)) return [3, 4];
            if (d = !0, 2 !== r.validationData.length) throw 3 === r.validationData.length ? new _p("validationData including sample weights is not supported yet.") : new Op("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + r.validationData + " is invalid.");
            return o = r.validationData[0], s = r.validationData[1], g = !0, [4, t.standardizeUserData(o, s, null, null, g, p)];
          case 3:
            return v = I.sent(), u = v[0], l = v[1], m = u.concat(l), [3, 5];
          case 4:
            null != r.validationSplit && r.validationSplit > 0 && r.validationSplit < 1 ? (d = !0, y = Math.floor(a[0].shape[0] * (1 - r.validationSplit)), b = a[0].shape[0], u = Wd(a, y, b), a = Wd(a, 0, y), l = Wd(i, y, b), i = Wd(i, 0, y), m = u.concat(l)) : null != r.validationSteps && (d = !0), I.label = 5;
          case 5:
            return x = a.concat(i).concat(c), t.checkTrainableWeightsConsistency(), w = t.makeTrainFunction(), C = t.getDedupedMetricsNames(), N = void 0, S = void 0, d ? (t.makeTestFunction(), N = t.testFunction, S = C.slice().concat(C.map(function (t) {
              return "val_" + t
            }))) : (N = null, m = [], S = C.slice()), k = Hf(r.callbacks, r.yieldEvery), [4, function (t, e, n, r, a, i, o, s, u, l, c, p, h, f, d) {
              return Ep(this, void 0, void 0, function () {
                var m, g, v, y, b, x, w, C;
                return Ap(this, function (N) {
                  switch (N.label) {
                    case 0:
                      if (null == a && (a = 32), null == i && (i = 1), null == c && (c = !0), null == h && (h = 0), m = !1, null != u && null != l && (m = !0), null != d && (m = !0, null == f)) throw new Op("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
                      return null != (g = t.checkNumSamples(n, a, f, "steps_per_epoch")) && (v = Rh(0, g)), null == o && (o = 1), y = Xf(s, o, i, h, g, f, a, m, p), b = y.callbackList, x = y.history, b.setModel(t), t.history = x, [4, b.onTrainBegin()];
                    case 1:
                      N.sent(), t.stopTraining_ = !1, w = function (i) {
                        var o, s, p, h, d;
                        return Ap(this, function (y) {
                          switch (y.label) {
                            case 0:
                              return [4, b.onEpochBegin(i)];
                            case 1:
                              if (y.sent(), o = {}, null == f) return [3, 2];
                              throw new _p("stepsPerEpoch mode is not implemented yet.");
                            case 2:
                              if ("batch" === c) throw new _p("batch shuffling is not implemneted yet");
                              c && nt.shuffle(v), s = fn(v), p = Ud(g, a), h = function (i) {
                                var c;
                                return Ap(this, function (h) {
                                  switch (h.label) {
                                    case 0:
                                      return c = {}, [4, b.onBatchBegin(i, c)];
                                    case 1:
                                      return h.sent(), We(function () {
                                        var h = p[i][0],
                                          f = p[i][1],
                                          d = Oh(s, h, f - h);
                                        c.batch = i, c.size = f - h;
                                        for (var g = Vd(n, d), v = e(g), y = 0; y < r.length; ++y) {
                                          var b = r[y],
                                            x = v[y];
                                          c[b] = x, Ue(x)
                                        }
                                        if (i === p.length - 1 && m) {
                                          var w = t.testLoop(u, l, a);
                                          for (y = 0; y < r.length; ++y) b = r[y], Ue(x = w[y]), o["val_" + b] = x
                                        }
                                      }), [4, b.onBatchEnd(i, c)];
                                    case 2:
                                      return h.sent(), Pf(c), t.stopTraining_ ? [2, "break"] : [2]
                                  }
                                })
                              }, d = 0, y.label = 3;
                            case 3:
                              return d < p.length ? [5, h(d)] : [3, 6];
                            case 4:
                              if ("break" === y.sent()) return [3, 6];
                              y.label = 5;
                            case 5:
                              return ++d, [3, 3];
                            case 6:
                              s.dispose(), y.label = 7;
                            case 7:
                              return [4, b.onEpochEnd(i, o)];
                            case 8:
                              return y.sent(), t.stopTraining_ ? [2, "break"] : [2]
                          }
                        })
                      }, C = h, N.label = 2;
                    case 2:
                      return C < i ? [5, w(C)] : [3, 5];
                    case 3:
                      if ("break" === N.sent()) return [3, 5];
                      N.label = 4;
                    case 4:
                      return ++C, [3, 2];
                    case 5:
                      return [4, b.onTrainEnd()];
                    case 6:
                      return N.sent(), [4, t.history.syncData()];
                    case 7:
                      return N.sent(), [2, t.history]
                  }
                })
              })
            }(t, w, x, C, p, r.epochs, r.verbose, k, N, m, r.shuffle, S, r.initialEpoch, null, null)];
          case 6:
            return [2, I.sent()];
          case 7:
            return t.isTraining = !1, qd(a, e), qd(i, n), qd(u, o), qd(l, s), null != c && Ve(c), [7];
          case 8:
            return [2]
        }
      })
    })
  }

  function Gd(t) {
    var e = [];
    t instanceof mt && (t = [t]);
    for (var n = 0; n < t.length; ++n) {
      var r = t[n];
      if (1 === r.rank) e.push(Dh(r, 1));
      else {
        if (0 === r.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
        e.push(r)
      }
    }
    return e
  }

  function qd(t, e) {
    if (null != t) {
      var n = [];
      if (e instanceof mt) n.push(e.id);
      else if (Array.isArray(e)) e.forEach(function (t) {
        return n.push(t.id)
      });
      else if (null != e)
        for (var r in e) {
          var a = e[r];
          n.push(a.id)
        }
      var i = [];
      if (t instanceof mt) - 1 === n.indexOf(t.id) && i.push(t);
      else if (Array.isArray(t)) t.forEach(function (t) {
        -1 === n.indexOf(t.id) && i.push(t)
      });
      else if (null != t)
        for (var o in t) {
          var s = t[o]; - 1 === n.indexOf(s.id) && i.push(s)
        }
      i.forEach(function (t) {
        t.isDisposed || t.dispose()
      })
    }
  }

  function Hd(t) {
    return Array.isArray(t)
  }

  function Kd(t) {
    return ! function (t) {
      return t instanceof mt
    }(t) && !Hd(t)
  }

  function Xd(t, e, n, r, a) {
    if (void 0 === r && (r = !0), void 0 === a && (a = ""), null == e || 0 === e.length) {
      if (null != t) {
        var i = !1;
        if (Hd(t) && t.length > 0) i = !0;
        else if (Kd(t)) {
          for (var o in t)
            if (t.hasOwnProperty(o)) {
              i = !0;
              break
            }
        } else i = !0;
        if (i) throw new Op("Error when checking model " + a + " expected no data, but got " + t)
      }
      return []
    }
    if (null == t) return e.map(function (t) {
      return null
    });
    var s;
    if (Kd(t)) {
      t = t, s = [];
      for (var u = 0, l = e; u < l.length; u++) {
        var c = l[u];
        if (null == t[c]) throw new Op('No data provided for "' + c + '". Need data for each key in: ' + e);
        s.push(t[c])
      }
    } else if (Hd(t)) {
      if ((t = t).length !== e.length) throw new Op("Error when checking model " + a + ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " + e.length + " Tensor(s), but instead got the following list of Tensor(s): " + t);
      s = t
    } else {
      if (t = t, e.length > 1) throw new Op("The model " + a + " expects " + e.length + " Tensor(s), but only received one Tensor. Found: Tensor with shape " + t.shape);
      s = [t]
    }
    if (s = Gd(s), null != n)
      for (var p = 0; p < e.length; ++p)
        if (null != n[p]) {
          var h = s[p];
          if (h.shape.length !== n[p].length) throw new Op("Error when checking " + a + ": expected " + e[p] + " to have " + n[p].length + " dimension(s). but got array with shape " + h.shape);
          for (var f = 0; f < n[p].length; ++f)
            if (0 !== f || r) {
              var d = h.shape[f],
                m = n[p][f];
              if (null != m && m >= 0 && d !== m) throw new Op("Error when checking " + a + ": expected " + e[p] + " to have shape [" + n[p] + "], but got array with shape [" + h.shape + "].")
            }
        } return s
  }

  function $d(t, e, n, r, a) {
    var i;
    if (void 0 === r && (r = !0), void 0 === a && (a = ""), Array.isArray(t)) {
      if (t.length !== e.length) throw new Op("Error when checking model " + a + ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " + e.length + " Tensor(s), but instead got " + t.length + " Tensors(s).");
      i = t
    } else {
      if (e.length > 1) throw new Op("The model expects " + e.length + " " + a + " Tensors, but only received one Tensor. Found: array with shape " + JSON.stringify(t.shape) + ".");
      i = [t]
    }
    if (null != n)
      for (var o = 0; o < e.length; ++o)
        if (null != n[o]) {
          var s = i[o];
          if (s.shape.length !== n[o].length) throw new Op("Error when checking " + a + ": expected " + e[o] + " to have " + n[o].length + " dimension(s), but got array with shape " + JSON.stringify(s.shape));
          for (var u = 0; u < n[o].length; ++u)
            if (0 !== u || r) {
              var l = s.shape[u],
                c = n[o][u];
              if (null != c && c !== l) throw new Op("Error when checking " + a + ": expected " + e[o] + " to have shape " + JSON.stringify(n[o]) + " but got array with shape " + JSON.stringify(s.shape) + ".")
            }
        }
  }
  var Yd = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.isTraining = !1, n
    }
    return Sp(e, t), e.prototype.summary = function (t, e, n) {
      if (void 0 === n && (n = console.log), !this.built) throw new Op("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
      bd(this, t, e, n)
    }, e.prototype.compile = function (t) {
      var e = this;
      if (null == t.loss && (t.loss = []), this.loss = t.loss, "string" == typeof t.optimizer) this.optimizer_ = function (t) {
        var e = {
          Adagrad: function () {
            return xp.adagrad(.01)
          },
          Adadelta: function () {
            return xp.adadelta(1, .95, Rp())
          },
          Adam: function () {
            return xp.adam(.001, .9, .999, Rp())
          },
          Adamax: function () {
            return xp.adamax(.002, .9, .999, Rp(), 0)
          },
          RMSProp: function () {
            return xp.rmsprop(.001, .9, 0, Rp())
          },
          SGD: function () {
            return xp.sgd(.01)
          }
        };
        if (e.adagrad = e.Adagrad, e.adadelta = e.Adadelta, e.adam = e.Adam, e.adamax = e.Adamax, e.rmsprop = e.RMSProp, e.sgd = e.SGD, t in e) return e[t]();
        throw new Op("Unknown Optimizer " + t)
      }(t.optimizer), this.isOptimizerOwned = !0;
      else {
        if (!(t.optimizer instanceof pp)) throw new Op("User-defined optimizer must be an instance of tf.Optimizer.");
        this.optimizer_ = t.optimizer, this.isOptimizerOwned = !1
      }
      var n = [];
      if (Array.isArray(t.loss) || "string" == typeof t.loss || "function" == typeof t.loss)
        if (Array.isArray(t.loss)) {
          if (t.loss.length !== this.outputs.length) throw new Op("When passing an Array as loss, it should have one entry per model output. The model has " + this.outputs.length + " output(s), but you passed loss=" + t.loss + ".");
          var r = t.loss;
          n = r.map(function (t) {
            return id(t)
          })
        } else {
          var a = id(t.loss);
          this.outputs.forEach(function (t) {
            n.push(a)
          })
        }
      else {
        for (var i in t.loss = t.loss, t.loss)
          if (-1 === this.outputNames.indexOf(i)) throw new Op('Unknown entry in loss dictionary: "' + i + '". Only expected the following keys: ' + this.outputNames);
        for (var o = 0, s = this.outputNames; o < s.length; o++) {
          var u = s[o];
          null == t.loss[u] && console.warn('Output "' + u + '" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' + u + " during training"), n.push(id(t.loss[u]))
        }
      }
      this.lossFunctions = n, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
      for (var l = 0; l < this.outputs.length; ++l) {
        var c = this.internalOutputShapes[l],
          p = this.outputNames[l];
        this.feedOutputNames.push(p), this.feedOutputShapes.push(c), this.feedLossFns.push(this.lossFunctions[l])
      }
      var h = [];
      this.metrics = t.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], bh("loss", function () {
        for (var t = 0; t < e.outputs.length; ++t)
          if (-1 === h.indexOf(t)) {
            var n = e.lossFunctions[t];
            e.outputs.length > 1 && (e.metricsTensors.push([n, t]), e.metricsNames.push(e.outputNames[t] + "_loss"))
          }
      });
      var f = function (t, e) {
        if (null == t || Array.isArray(t) && 0 === t.length) return e.map(function (t) {
          return []
        });
        var n;
        if ("string" == typeof t || "function" == typeof t) n = [t];
        else {
          if (!Array.isArray(t) && "object" != typeof t) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " + t);
          n = t
        }
        if (Array.isArray(n)) return e.map(function (t) {
          return n
        });
        for (var r = [], a = 0, i = e; a < i.length; a++) {
          var o = i[a],
            s = n.hasOwnProperty(o) ? n[o] : [];
          Array.isArray(s) || (s = [s]), r.push(s)
        }
        return r
      }(t.metrics, this.outputNames);
      bh("metric", function () {
        for (var t = function (t) {
            if (-1 !== h.indexOf(t)) return "continue";
            ! function (n) {
              for (var r, a, i, o = function (n) {
                  if ("string" == typeof n && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(n)) {
                    var o = e.internalOutputShapes[t];
                    1 === o[o.length - 1] || e.lossFunctions[t] === nd ? -1 !== ["accuracy", "acc"].indexOf(n) ? a = od : -1 !== ["crossentropy", "ce"].indexOf(n) && (a = pd) : e.lossFunctions[t] === ed ? -1 !== ["accuracy", "acc"].indexOf(n) ? a = hd : -1 !== ["crossentropy", "ce"].indexOf(n) && (a = dd) : -1 !== ["accuracy", "acc"].indexOf(n) ? a = sd : -1 !== ["crossentropy", "ce"].indexOf(n) && (a = fd);
                    var s = void 0; - 1 !== ["accuracy", "acc"].indexOf(n) ? s = "acc" : -1 !== ["crossentropy", "ce"].indexOf(n) && (s = "ce"), i = a, r = "" + s
                  } else {
                    var u = function (t) {
                      if ("string" == typeof t && t in md) return md[t];
                      if ("string" != typeof t && null != t) return t;
                      throw new Op("Unknown metric " + t)
                    }(n);
                    i = u, r = "" + gd(n)
                  }
                  var l;
                  bh(r, function () {
                      l = i
                    }),
                    function (t, n, r) {
                      e.outputNames.length > 1 && (n = e.outputNames[t] + "_" + n), e.metricsNames.push(n), e.metricsTensors.push([r, t])
                    }(t, r, l)
                }, s = 0, u = f[t]; s < u.length; s++) o(u[s])
            }()
          }, n = 0; n < e.outputs.length; ++n) t(n)
      }), this.collectedTrainableWeights = this.trainableWeights
    }, e.prototype.checkTrainableWeightsConsistency = function () {
      null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")
    }, e.prototype.evaluate = function (t, e, n) {
      void 0 === n && (n = {});
      var r = null == n.batchSize ? 32 : n.batchSize;
      Pd(r);
      var a = this.standardizeUserDataXY(t, e, !0, r);
      try {
        var i = a[0].concat(a[1]);
        this.makeTestFunction();
        var o = this.testFunction;
        return Bp(this.testLoop(o, i, r, n.verbose, n.steps))
      } finally {
        qd(a[0], t), qd(a[1], e)
      }
    }, e.prototype.evaluateDataset = function (t, e) {
      return Ep(this, void 0, void 0, function () {
        return Ap(this, function (n) {
          return this.makeTestFunction(), [2, function (t, e, n) {
            return Ep(this, void 0, void 0, function () {
              var r, a, i, o, s, u, l, c, p, h;
              return Ap(this, function (f) {
                switch (f.label) {
                  case 0:
                    if (r = null != (n = n || {}).batches, a = t.testFunction, i = [], n.verbose > 0) throw new _p("Verbose mode is not implemented yet.");
                    return nt.assert(!r || n.batches > 0 && Number.isInteger(n.batches), function () {
                        return "Test loop expects `batches` to be a positive integer, but received " + JSON.stringify(n.batches)
                      }),
                      function (t) {
                        return "function" == typeof t.next
                      }(e) ? (s = e, [3, 3]) : [3, 1];
                  case 1:
                    return [4, e.iterator()];
                  case 2:
                    s = f.sent(), f.label = 3;
                  case 3:
                    o = s, u = 0, l = 0, c = function () {
                      var e;
                      return Ap(this, function (s) {
                        switch (s.label) {
                          case 0:
                            return [4, o.next()];
                          case 1:
                            return e = s.sent(), i = We(function () {
                              if (e.value) {
                                var n = Md(t, e.value),
                                  r = n.xs,
                                  o = n.ys,
                                  s = r.concat(o),
                                  c = We(function () {
                                    return a(s)
                                  });
                                if (Ve(s), 0 === l)
                                  for (var p = 0; p < c.length; ++p) i.push(hn(0));
                                var h = s[0].shape[0],
                                  f = function (t) {
                                    var e = c[t],
                                      n = i[t];
                                    i[t] = We(function () {
                                      return ls(i[t], Ns(h, e))
                                    }), l > 0 && Ve(n)
                                  };
                                for (p = 0; p < c.length; ++p) f(p);
                                Ve(c), u += h, ++l
                              }
                              return i
                            }), e.done ? (r && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " + n.batches + " batches). You may need to use the repeat() function when building your dataset."), [2, "break"]) : [2]
                        }
                      })
                    }, f.label = 4;
                  case 4:
                    return !r || l < n.batches ? [5, c()] : [3, 6];
                  case 5:
                    return "break" === f.sent() ? [3, 6] : [3, 4];
                  case 6:
                    for (p = 0; p < i.length; ++p) h = i[p], i[p] = fs(i[p], u), Ve(h);
                    return [2, Bp(i)]
                }
              })
            })
          }(this, t, e)]
        })
      })
    }, e.prototype.checkNumSamples = function (t, e, n, r) {
      var a;
      if (void 0 === r && (r = "steps"), null != n) {
        if (a = null, null != e) throw new Op("If " + r + " is set, batchSize must be null or undefined.Got batchSize = " + e)
      } else {
        if (null == t) throw new Op("Either the input data should have a defined shape, or " + r + " shoud be specified.");
        a = Array.isArray(t) ? t[0].shape[0] : t.shape[0]
      }
      return a
    }, e.prototype.execute = function (t, e) {
      if (Array.isArray(e) && 0 === e.length) throw new Op("`outputs` is an empty Array, which is not allowed.");
      var n = Array.isArray(e),
        r = n ? e : [e],
        a = this.retrieveSymbolicTensors(r),
        i = new kd;
      if (t instanceof mt && (t = [t]), Array.isArray(t)) {
        if (t.length !== this.inputs.length) throw new Op("The number of inputs provided (" + t.length + ") does not match the number of inputs of this model (" + this.inputs.length + ").");
        for (var o = 0; o < this.inputs.length; ++o) i.add(this.inputs[o], t[o])
      } else
        for (var s = 0, u = this.inputs; s < u.length; s++) {
          var l = u[s],
            c = t[l.name];
          if (null == c) throw new Op("No value is provided for the model's input " + l.name);
          i.add(l, c)
        }
      var p = Ad(a, i);
      return n ? p : p[0]
    }, e.prototype.retrieveSymbolicTensors = function (t) {
      for (var e = Mp(null, t.length), n = t.length, r = 0, a = this.layers; r < a.length; r++) {
        for (var i = a[r], o = Array.isArray(i.output) ? i.output : [i.output], s = o.map(function (t) {
            return t.name
          }), u = 0; u < t.length; ++u) {
          var l = s.indexOf(t[u]);
          if (-1 !== l && (e[u] = o[l], n--), 0 === n) break
        }
        if (0 === n) break
      }
      if (n > 0) {
        var c = [];
        throw e.forEach(function (e, n) {
          null == e && c.push(t[n])
        }), new Op("Cannot find SymbolicTensors for output name(s): " + JSON.stringify(c))
      }
      return e
    }, e.prototype.predictLoop = function (t, e, n) {
      var r = this;
      return void 0 === e && (e = 32), void 0 === n && (n = !1), We(function () {
        var a = r.checkNumSamples(t);
        if (n) throw new _p("Verbose predictLoop() is not implemented yet.");
        for (var i = Ud(a, e), o = r.outputs.map(function (t) {
            return []
          }), s = function (e) {
            We(function () {
              var n = i[e][0],
                a = i[e][1],
                o = Wd(t, n, a),
                s = [];
              if (Array.isArray(o))
                for (var u = 0; u < o.length; ++u) s.push({
                  key: r.inputs[u],
                  value: o[u]
                });
              else s.push({
                key: r.inputs[0],
                value: o
              });
              var l = new kd(s);
              return Ad(r.outputs, l)
            }).forEach(function (t, e) {
              return o[e].push(t)
            })
          }, u = 0; u < i.length; ++u) s(u);
        return Bp(o.map(function (t) {
          return En(t, 0)
        }))
      })
    }, e.prototype.predict = function (t, e) {
      void 0 === e && (e = {});
      var n = Gd(t);
      $d(n, this.inputNames, this.feedInputShapes, !1);
      try {
        var r = null == e.batchSize ? 32 : e.batchSize;
        return Pd(r), this.predictLoop(n, r)
      } finally {
        qd(n, t)
      }
    }, e.prototype.predictOnBatch = function (t) {
      $d(t, this.inputNames, this.feedInputShapes, !0);
      var e = (Array.isArray(t) ? t[0] : t).shape[0];
      return this.predictLoop(t, e)
    }, e.prototype.standardizeUserDataXY = function (t, e, n, r) {
      if (void 0 === n && (n = !0), null == this.optimizer_) throw new Dp("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
      for (var a = [], i = 0; i < this.feedOutputShapes.length; ++i) {
        var o = this.feedOutputShapes[i];
        this.feedLossFns[i] === ed ? a.push(o.slice(0, o.length - 1).concat([1])) : a.push(o)
      }
      if (function (t, e, n) {
          var r = Hp(t.map(function (t) {
            return t.shape[0]
          }));
          r.sort();
          var a = Hp(e.map(function (t) {
            return t.shape[0]
          }));
          if (a.sort(), r.length > 1) throw new Op("All input Tensors (x) should have the same number of samples. Got array shapes: " + JSON.stringify(t.map(function (t) {
            return t.shape
          })));
          if (a.length > 1) throw new Op("All target Tensors (y) should have the same number of samples. Got array shapes: " + JSON.stringify(e.map(function (t) {
            return t.shape
          })));
          if (r.length > 0 && a.length > 0 && !nt.arraysEqual(r, a)) throw new Op("Input Tensors should have the same number of samples as target Tensors. Found " + r[0] + " input sample(s) and " + a[0] + " target sample(s).")
        }(t = Xd(t, this.feedInputNames, this.feedInputShapes, !1, "input"), e = Xd(e, this.feedOutputNames, a, !1, "target")), function (t, e, n) {
          for (var r = [Jf, nd, td], a = 0; a < t.length; ++a) {
            var i = t[a],
              o = e[a],
              s = n[a];
            if (null != o) {
              if (o === td && 1 === i.shape[i.shape.length - 1]) throw new Op("You are passing a target array of shape " + i.shape + " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
              if (-1 !== r.indexOf(o))
                for (var u = i.shape.slice(1), l = s.slice(1), c = 0; c < u.length; ++c) {
                  var p = u[c],
                    h = l[c];
                  if (null != h && p !== h) throw new Op("A target Tensor with shape " + i.shape + " was passed for an output of shape " + s + ", while using a loss function that expects targets to have the same shape as the output.")
                }
            }
          }
        }(e, this.feedLossFns, this.feedOutputShapes), this.stateful && null != r && r > 0 && t[0].shape[0] % r != 0) throw new Op("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + r + ". Found: " + t[0].shape[0] + " sample(s).");
      return [t, e]
    }, e.prototype.standardizeUserData = function (t, e, n, r, a, i) {
      return void 0 === a && (a = !0), Ep(this, void 0, void 0, function () {
        var o, s, u, l, c, p, h, f;
        return Ap(this, function (d) {
          switch (d.label) {
            case 0:
              if (o = this.standardizeUserDataXY(t, e, a, i), s = o[0], u = o[1], null != n) throw new Error("sample weight is not supported yet.");
              if (l = null, null == r) return [3, 4];
              c = Dd(r, this.outputNames), l = [], p = 0, d.label = 1;
            case 1:
              return p < c.length ? (f = (h = l).push, [4, Od(u[p], null, c[p])]) : [3, 4];
            case 2:
              f.apply(h, [d.sent()]), d.label = 3;
            case 3:
              return ++p, [3, 1];
            case 4:
              return [2, [s, u, l]]
          }
        })
      })
    }, e.prototype.testLoop = function (t, e, n, r, a) {
      var i = this;
      return void 0 === r && (r = 0), We(function () {
        var o = i.checkNumSamples(e, n, a, "steps"),
          s = [];
        if (r > 0) throw new _p("Verbose mode is not implemented yet.");
        if (null != a) throw new _p("steps mode in testLoop() is not implemented yet");
        for (var u = Ud(o, n), l = fn(Rh(0, o)), c = 0; c < u.length; ++c) {
          var p = u[c][0],
            h = u[c][1],
            f = Oh(l, p, h - p),
            d = Vd(e, f),
            m = t(d);
          if (0 === c)
            for (var g = 0; g < m.length; ++g) s.push(hn(0));
          for (g = 0; g < m.length; ++g) {
            var v = m[g];
            s[g] = ls(s[g], Ns(h - p, v))
          }
        }
        for (g = 0; g < s.length; ++g) s[g] = fs(s[g], o);
        return s
      })
    }, e.prototype.getDedupedMetricsNames = function () {
      for (var t = this.metricsNames, e = [], n = 0; n < t.length; ++n) {
        var r = t[n],
          a = r;
        Lp(t, r) > 1 && (a += "_" + Lp(t.slice(0, n), r)), e.push(a)
      }
      return e
    }, e.prototype.makeTrainFunction = function () {
      var t = this;
      return function (e) {
        var n = [],
          r = e.slice(0, t.inputs.length),
          a = e.slice(t.inputs.length, t.inputs.length + t.outputs.length),
          i = e.slice(t.inputs.length + t.outputs.length, t.inputs.length + 2 * t.outputs.length),
          o = [],
          s = t.collectedTrainableWeights.map(function (t) {
            return t.read()
          });
        return [t.optimizer_.minimize(function () {
          for (var e = [], s = 0; s < t.inputs.length; ++s) e.push({
            key: t.inputs[s],
            value: r[s]
          });
          var u, l = new kd(e),
            c = Ad(t.outputs, l, {
              training: !0
            });
          for (s = 0; s < t.lossFunctions.length; ++s) {
            var p = (0, t.lossFunctions[s])(a[s], c[s]);
            null != i[s] && (p = _d(p, i[s]));
            var h = Mu(p);
            n.push(h), u = 0 === s ? p : ls(u, p)
          }
          for (s = 0; s < t.metricsTensors.length; ++s) {
            var f = void 0;
            if (t.outputs.length > 1 && s < t.outputs.length) f = n[s];
            else {
              var d = t.metricsTensors[s][0],
                m = t.metricsTensors[s][1];
              f = Mu(d(a[m], c[m]))
            }
            Ue(f), o.push(f)
          }
          return u = Mu(u), t.calculateLosses().forEach(function (t) {
            u = ls(u, t)
          }), u
        }, !0, s)].concat(o)
      }
    }, e.prototype.makeTestFunction = function () {
      var t = this;
      this.testFunction = function (e) {
        return We(function () {
          for (var n, r = [], a = e.slice(0, t.inputs.length), i = e.slice(t.inputs.length, t.inputs.length + t.outputs.length), o = [], s = 0; s < t.inputs.length; ++s) o.push({
            key: t.inputs[s],
            value: a[s]
          });
          var u = new kd(o),
            l = Ad(t.outputs, u);
          for (s = 0; s < t.lossFunctions.length; ++s) {
            var c = t.lossFunctions[s],
              p = Mu(c(i[s], l[s]));
            n = 0 === s ? p : ls(n, p), r.push(n)
          }
          for (s = 0; s < t.metricsTensors.length; ++s) {
            var h = t.metricsTensors[s][0],
              f = t.metricsTensors[s][1],
              d = Mu(h(i[f], l[f]));
            r.push(d)
          }
          return r
        })
      }
    }, e.prototype.fit = function (t, e, n) {
      return void 0 === n && (n = {}), Ep(this, void 0, void 0, function () {
        return Ap(this, function (r) {
          return [2, jd(this, t, e, n)]
        })
      })
    }, e.prototype.fitDataset = function (t, e) {
      return Ep(this, void 0, void 0, function () {
        return Ap(this, function (n) {
          return [2, Ld(this, t, e)]
        })
      })
    }, e.prototype.trainOnBatch = function (t, e) {
      return Ep(this, void 0, void 0, function () {
        var n, r, a, i, o, s, u, l, c;
        return Ap(this, function (p) {
          switch (p.label) {
            case 0:
              return [4, this.standardizeUserData(t, e)];
            case 1:
              n = p.sent(), r = n[0], a = n[1], i = this.makeTrainFunction(), o = i(r.concat(a)), s = [], u = 0, l = o, p.label = 2;
            case 2:
              return u < l.length ? [4, l[u].data()] : [3, 5];
            case 3:
              c = p.sent(), s.push(c[0]), p.label = 4;
            case 4:
              return u++, [3, 2];
            case 5:
              return Ve(o), [2, Bp(s)]
          }
        })
      })
    }, e.prototype.getNamedWeights = function (t) {
      for (var e = [], n = null != t && t.trainableOnly, r = n ? this.trainableWeights : this.weights, a = this.getWeights(n), i = 0; i < r.length; ++i) n && !r[i].trainable || e.push({
        name: r[i].originalName,
        tensor: a[i]
      });
      return e
    }, Object.defineProperty(e.prototype, "stopTraining", {
      get: function () {
        return this.stopTraining_
      },
      set: function (t) {
        this.stopTraining_ = t
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "optimizer", {
      get: function () {
        return this.optimizer_
      },
      set: function (t) {
        this.optimizer_ !== t && (this.optimizer_ = t, this.isOptimizerOwned = !1)
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.dispose = function () {
      var e = t.prototype.dispose.call(this);
      if (0 === e.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
        var n = Pe().numTensors;
        this.optimizer_.dispose(), e.numDisposedVariables += n - Pe().numTensors
      }
      return e
    }, e.prototype.getLossIdentifiers = function () {
      var t;
      if ("string" == typeof this.loss) t = Wp(this.loss);
      else if (Array.isArray(this.loss)) {
        for (var e = 0, n = this.loss; e < n.length; e++)
          if ("string" != typeof n[e]) throw new Error("Serialization of non-string loss is not supported.");
        t = this.loss.map(function (t) {
          return Wp(t)
        })
      } else {
        var r = Object.keys(this.loss);
        t = {};
        for (var a = this.loss, i = 0, o = r; i < o.length; i++) {
          var s = o[i];
          if ("string" != typeof a[s]) throw new Error("Serialization of non-string loss is not supported.");
          t[s] = Wp(a[s])
        }
      }
      return t
    }, e.prototype.getMetricIdentifiers = function () {
      if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [Wp(gd(this.metrics))];
      if (Array.isArray(this.metrics)) return this.metrics.map(function (t) {
        return Wp(gd(t))
      });
      var t = {};
      for (var e in this.metrics) t[e] = Wp(gd(this.metrics[e]));
      return t
    }, e.prototype.getTrainingConfig = function () {
      return {
        loss: this.getLossIdentifiers(),
        metrics: this.getMetricIdentifiers(),
        optimizer_config: {
          class_name: this.optimizer.getClassName(),
          config: this.optimizer.getConfig()
        }
      }
    }, e.prototype.loadTrainingConfig = function (t) {
      if (null != t.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
      if (null != t.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
      if (null != t.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
      var e, n, r = $f(Sd(t.optimizer_config));
      if ("string" == typeof t.loss) e = Vp(t.loss);
      else if (Array.isArray(t.loss)) e = t.loss.map(function (t) {
        return Vp(t)
      });
      else if (null != t.loss)
        for (var a in e = {}, t.loss) e[a] = Vp(t.loss[a]);
      if (Array.isArray(t.metrics)) n = t.metrics.map(function (t) {
        return Vp(t)
      });
      else if (null != t.metrics)
        for (var a in n = {}, t.metrics) n[a] = Vp(t.metrics[a]);
      this.compile({
        loss: e,
        metrics: n,
        optimizer: r
      })
    }, e.prototype.save = function (t, e) {
      return Ep(this, void 0, void 0, function () {
        var n, r, a, i, o, s, u, l, c, p, h, f, d, m;
        return Ap(this, function (g) {
          switch (g.label) {
            case 0:
              if ("string" == typeof t) {
                if (0 === (n = $c.getSaveHandlers(t)).length) throw new Op("Cannot find any save handlers for URL '" + t + "'");
                if (n.length > 1) throw new Op("Found more than one (" + n.length + ") save handlers for URL '" + t + "'");
                t = n[0]
              }
              if (null == t.save) throw new Op("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
              return [4, $c.encodeWeights(this.getNamedWeights(e))];
            case 1:
              return r = g.sent(), a = !1, i = null, o = this.toJSON(i, a), s = {
                modelTopology: o,
                format: "layers-model",
                generatedBy: "TensorFlow.js tfjs-layers v1.5.1",
                convertedBy: null
              }, null != e && e.includeOptimizer && null != this.optimizer ? (s.trainingConfig = this.getTrainingConfig(), u = "optimizer", f = (h = $c).encodeWeights, [4, this.optimizer.getWeights()]) : [3, 4];
            case 2:
              return [4, f.apply(h, [g.sent(), u])];
            case 3:
              l = g.sent(), c = l.data, p = l.specs, (m = r.specs).push.apply(m, p), r.data = $c.concatenateArrayBuffers([r.data, c]), g.label = 4;
            case 4:
              return null != this.userDefinedMetadata && (d = !0, yd(this.userDefinedMetadata, this.name, d), s.userDefinedMetadata = this.userDefinedMetadata), s.weightData = r.data, s.weightSpecs = r.specs, [2, t.save(s)]
          }
        })
      })
    }, e.prototype.setUserDefinedMetadata = function (t) {
      yd(t, this.name), this.userDefinedMetadata = t
    }, e.prototype.getUserDefinedMetadata = function () {
      return this.userDefinedMetadata
    }, e.className = "Model", e
  }(function (t) {
    function e(n) {
      var r = t.call(this, {}) || this;
      if (r.containerNodes = new Set, r.name = n.name, null == r.name) {
        var a = r.getClassName().toLowerCase();
        r.name = bf(a)
      }
      if (r.supportsMasking = !1, r.trainable_ = !0, Array.isArray(n.inputs) ? r.inputs = n.inputs.slice() : r.inputs = [n.inputs], Array.isArray(n.outputs) ? r.outputs = n.outputs.slice() : r.outputs = [n.outputs], Hp(r.inputs).length !== r.inputs.length) throw new Op("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + r.inputs.map(function (t) {
        return t.name
      }));
      Hp(r.outputs).length !== r.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + r.outputs.map(function (t) {
        return t.name
      })), r.inputLayers = [], r.inputLayersNodeIndices = [], r.inputLayersTensorIndices = [], r.outputLayers = [], r.outputLayersNodeIndices = [], r.outputLayersTensorIndices = [], r.layers = [], r.internalContainerRefs = [];
      for (var i = 0, o = r.outputs; i < o.length; i++) {
        var s = (I = o[i]).sourceLayer,
          u = I.nodeIndex,
          l = I.tensorIndex;
        r.outputLayers.push(s), r.outputLayersNodeIndices.push(u), r.outputLayersTensorIndices.push(l)
      }
      for (var c = 0, p = r.inputs; c < p.length; c++) s = (I = p[c]).sourceLayer, u = I.nodeIndex, l = I.tensorIndex, zp(0 === u, "input layer has >1 nodes"), zp(0 === l, "input layer has >1 tensors"), r.inputLayers.push(s), r.inputLayersNodeIndices.push(u), r.inputLayersTensorIndices.push(l);
      r.inputNames = [], r.outputNames = [], r.feedInputShapes = [], r.feedInputNames = [], r.feedOutputNames = [];
      for (var h = 0; h < r.inputLayers.length; h++) {
        if (!((s = r.inputLayers[h]) instanceof zf)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: " + n.inputs + ". Input " + h + " (0-based) originates from layer type " + s.getClassName() + ".");
        r.inputNames.push(s.name), r.feedInputShapes.push(s.batchInputShape), r.feedInputNames.push(s.name)
      }
      for (var f = 0, d = r.outputLayers; f < d.length; f++) s = d[f], r.outputNames.push(s.name);
      r.internalInputShapes = r.inputs.map(function (t) {
        return t.shape
      }), r.internalOutputShapes = r.outputs.map(function (t) {
        return t.shape
      });
      for (var m = {}, g = {}, v = {}, y = {}, b = {}, x = [], w = function (t, n, a, i, o, s) {
          null != i && null != o && null != s || (i = t.sourceLayer, o = t.nodeIndex, s = t.tensorIndex);
          var u = i.inboundNodes[o];
          if (-1 !== a.indexOf(u)) throw new Dp("The tensor " + t.name + ' at layer "' + i.name + '" is part of a cycle.');
          if (-1 === n.indexOf(u)) {
            r.containerNodes.add(e.nodeKey(i, o)), i.id in b || (b[i.id] = Object.keys(b).length), -1 === a.indexOf(u) && a.push(u);
            for (var l = u.inboundLayers.length, c = 0; c < l; c++) {
              var p = u.inputTensors[c],
                h = u.inboundLayers[c],
                f = u.nodeIndices[c],
                d = u.tensorIndices[c];
              w(p, n, a, h, f, d)
            }
            for (n.push(u); a.indexOf(u) >= 0;) a.splice(a.indexOf(u), 1);
            x.push(u)
          }
        }, C = [], N = [], S = 0, k = r.outputs; S < k.length; S++) {
        var I = k[S];
        w(I, C, N)
      }
      for (var E = 0, A = x.slice().reverse(); E < A.length; E++) {
        g[(Y = A[E]).id] = Y, Y.id in m || (m[Y.id] = 0);
        var R = m[Y.id],
          T = null == v[Y.outboundLayer.id] ? 0 : v[Y.outboundLayer.id];
        for (R = Math.max(R, T), v[Y.outboundLayer.id] = R, y[Y.outboundLayer.id] = Y.outboundLayer, m[Y.id] = R, h = 0; h < Y.inboundLayers.length; h++) {
          var D = Y.inboundLayers[h],
            O = (u = Y.nodeIndices[h], D.inboundNodes[u]),
            _ = null == m[O.id] ? 0 : m[O.id];
          m[O.id] = Math.max(R + 1, _), g[O.id] = O
        }
      }
      var F = {};
      for (var M in m)(R = m[M]) in F || (F[R] = []), F[R].push(g[M]);
      var z = {};
      for (var L in v)(R = v[L]) in z || (z[R] = []), z[R].push(y[L]);
      var B = Object.keys(z).map(function (t) {
        return parseInt(t, 10)
      }).sort(qp);
      r.layers = [];
      for (var P = 0, W = B; P < W.length; P++) {
        var V = z[R = W[P]];
        V.sort(function (t, e) {
          var n = b[t.id],
            r = b[e.id];
          return n < r ? -1 : n > r ? 1 : 0
        });
        for (var U = 0, j = V; U < j.length; U++)(s = j[U]) instanceof e && r.internalContainerRefs.push(s), r.layers.push(s)
      }
      r.layersByDepth = z, B = Object.keys(F).map(function (t) {
        return parseInt(t, 10)
      }).sort(qp);
      for (var G = r.inputs.slice(), q = [], H = 0, K = B; H < K.length; H++)
        for (var X = 0, $ = F[R = K[H]]; X < $.length; X++) {
          var Y;
          if (null != (s = (Y = $[X]).outboundLayer)) {
            for (var J = 0, Z = Y.inputTensors; J < Z.length; J++)
              if (I = Z[J], -1 === G.indexOf(I)) throw new Dp("Graph disconnected: cannot obtain value for tensor " + I + ' at layer "' + s.name + '". The following previous layers were accessed without issue: ' + q);
            for (var Q = 0, tt = Y.outputTensors; Q < tt.length; Q++) I = tt[Q], G.push(I);
            q.push(s.name)
          }
        }
      r.nodesByDepth = F;
      for (var et = r.layers.map(function (t) {
          return t.name
        }), nt = function (t) {
          var e = et.filter(function (e) {
            return e === t
          }).length;
          if (1 !== e) throw new Dp('The name "' + t + '" is used ' + e + " times in the model. All layer names should be unique. Layer names: " + JSON.stringify(et))
        }, rt = 0, at = et; rt < at.length; rt++) nt(at[rt]);
      return r.outboundNodes = [], r.inboundNodes = [], new Of({
        outboundLayer: r,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: r.inputs,
        outputTensors: r.outputs,
        inputMasks: r.inputs.map(function (t) {
          return null
        }),
        outputMasks: r.outputs.map(function (t) {
          return null
        }),
        inputShapes: r.inputs.map(function (t) {
          return t.shape
        }),
        outputShapes: r.outputs.map(function (t) {
          return t.shape
        })
      }), r.built = !0, r._refCount = 1, r
    }
    return Sp(e, t), e.prototype.assertNotDisposed = function () {
      if (0 === this._refCount) throw new Error("Container '" + this.name + "' is already disposed.")
    }, e.prototype.dispose = function () {
      this.assertNotDisposed();
      var t = {
        refCountAfterDispose: null,
        numDisposedVariables: 0
      };
      if (0 == --this._refCount) {
        for (var e = 0, n = this.layers; e < n.length; e++) {
          var r = n[e];
          t.numDisposedVariables += r.dispose().numDisposedVariables
        }
        for (var a = 0, i = this.internalContainerRefs; a < i.length; a++) {
          var o = i[a];
          t.numDisposedVariables += o.dispose().numDisposedVariables
        }
      }
      return t.refCountAfterDispose = this._refCount, t
    }, Object.defineProperty(e.prototype, "trainable", {
      get: function () {
        return this.trainable_
      },
      set: function (t) {
        this.layers.forEach(function (e) {
          e._trainableWeights.forEach(function (e) {
            return e.trainable = t
          })
        }), this.trainable_ = t
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "trainableWeights", {
      get: function () {
        if (this._trainableWeights.length > 0) throw new Op("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
        if (!this.trainable) return [];
        for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
          var r = n[e];
          t = t.concat(r.trainableWeights)
        }
        return t
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
      get: function () {
        for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
          var r = n[e];
          t.push.apply(t, r.nonTrainableWeights)
        }
        if (!this.trainable) {
          for (var a = [], i = 0, o = this.layers; i < o.length; i++) r = o[i], a.push.apply(a, r.trainableWeights);
          return a.concat(t)
        }
        return t
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "weights", {
      get: function () {
        return this.trainableWeights.concat(this.nonTrainableWeights)
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.loadWeights = function (t, e) {
      void 0 === e && (e = !0);
      for (var n = {}, r = 0, a = 0, i = this.layers; a < i.length; a++)
        for (var o = 0, s = i[a].weights; o < s.length; o++) {
          var u = s[o];
          if (null != n[u.originalName]) throw new Op("Duplicate weight name: " + u.originalName);
          n[u.originalName] = u, r++
        }
      var l = [];
      for (var c in t) {
        if (null != n[c]) l.push([n[c], t[c]]);
        else if (e) throw new Op("Provided weight data has no target variable: " + c);
        delete n[c]
      }
      if (e) {
        var p = [];
        for (var h in n) p.push(h);
        if (p.length > 0) throw new Op(p.length + " of " + r + " weights are not set: " + p)
      }
      Af(l)
    }, e.prototype.updatedConfig = function () {
      var t = this.getConfig(),
        e = {};
      return e.className = this.getClassName(), e.config = t, e.kerasVersion = "tfjs-layers 1.5.1", e.backend = "TensorFlow.js", e
    }, e.prototype.toJSON = function (t, e) {
      void 0 === e && (e = !0);
      var n = function t(e, n) {
        if (null === e || void 0 === e) return null;
        if ("string" == typeof e) return Wp(e);
        if ("number" == typeof e || "boolean" == typeof e) return e;
        if (e instanceof Array) {
          for (var r = [], a = e.length, i = 0; i < a; ++i) {
            var o = e[i];
            Nd(n, i, o) ? r.push(o) : r.push(t(o, n))
          }
          return r
        }
        for (var s = {}, u = 0, l = Object.keys(e); u < l.length; u++) {
          var c = l[u],
            p = e[c];
          s[Wp(c)] = "name" !== c && "className" !== c || "string" != typeof p ? t(p, c) : p
        }
        return s
      }(this.updatedConfig());
      return e ? JSON.stringify(n) : n
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        t = Pp(t);
        for (var r = new kd, a = 0; a < n.inputs.length; ++a) r.add(n.inputs[a], t[a]);
        return Ad(n.outputs, r, e)
      })
    }, e.prototype.computeMask = function (t, e) {
      var n = this;
      return We(function () {
        var r;
        return t = Pp(t), r = null == e ? Mp(null, t.length) : Pp(e), n.runInternalGraph(t, r)[1]
      })
    }, e.prototype.computeOutputShape = function (t) {
      var e = wf(t);
      if (e.length !== this.inputLayers.length) throw new Op("Invalid inputShape argument " + t + ": model has " + this.inputLayers.length + " tensor inputs.");
      for (var n = {}, r = 0; r < e.length; r++) {
        var a = this.inputLayers[r],
          i = e[r];
        n[N = a.name + "_0_0"] = i
      }
      var o = Object.keys(this.nodesByDepth).map(function (t) {
        return parseInt(t, 10)
      }).sort(qp);
      if (o.length > 1)
        for (var s = 0, u = o; s < u.length; s++)
          for (var l = u[s], c = 0, p = this.nodesByDepth[l]; c < p.length; c++) {
            var h = p[c];
            if (a = h.outboundLayer, -1 === this.inputLayers.map(function (t) {
                return t.id
              }).indexOf(a.id)) {
              for (var f = [], d = 0; d < h.inboundLayers.length; d++) {
                var m = h.inboundLayers[d],
                  g = h.nodeIndices[d],
                  v = h.tensorIndices[d],
                  y = n[N = m.name + "_" + g + "_" + v];
                f.push(y)
              }
              var b = wf(a.computeOutputShape(Bp(f))),
                x = a.inboundNodes.indexOf(h);
              for (d = 0; d < b.length; d++) n[N = a.name + "_" + x + "_" + d] = b[d]
            }
          }
      var w = [],
        C = [];
      for (r = 0; r < this.outputLayers.length; r++) {
        a = this.outputLayers[r], x = this.outputLayersNodeIndices[r], v = this.outputLayersTensorIndices[r];
        var N = a.name + "_" + x + "_" + v;
        C.push(N)
      }
      for (r = 0; r < C.length; r++) {
        var S = C[r];
        zp(S in n), w.push(n[S])
      }
      return Bp(w)
    }, e.prototype.runInternalGraph = function (t, e) {
      null == e && (e = Mp(null, t.length));
      for (var n = {}, r = 0; r < this.inputs.length; ++r) {
        var a = this.inputs[r],
          i = t[r],
          o = e[r];
        n[a.id] = [i, o]
      }
      for (var s = 0, u = Object.keys(this.nodesByDepth).map(function (t) {
          return parseInt(t, 10)
        }).sort(qp); s < u.length; s++)
        for (var l = u[s], c = 0, p = this.nodesByDepth[l]; c < p.length; c++) {
          for (var h = p[c], f = h.outboundLayer, d = h.inputTensors, m = h.outputTensors, g = new Array, v = 0, y = d; v < y.length; v++)(a = y[v]).id in n && g.push(n[a.id]);
          if (g.length === d.length) {
            var b = {},
              x = void 0,
              w = void 0,
              C = void 0,
              N = void 0;
            if (null != h.callArgs && (b = h.callArgs), 1 === g.length) {
              var S = g[0],
                k = S[0],
                I = S[1];
              null == b.mask && (b.mask = I), C = Pp(f.call(k, b)), N = Pp(f.computeMask(k, I)), x = [k], w = [I]
            } else x = g.map(function (t) {
              return t[0]
            }), w = g.map(function (t) {
              return t[1]
            }), null == b.mask && (b.mask = w), C = Pp(f.call(x, b)), N = Pp(f.computeMask(x, w));
            if (f.activityRegularizer) throw new _p("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
            for (r = 0; r < m.length; ++r) a = m[r], i = C[r], o = N[r], n[a.id] = [i, o]
          }
        }
      for (var E = [], A = [], R = [], T = 0, D = this.outputs; T < D.length; T++) {
        zp((a = D[T]).id in n, "Could not compute output " + a.name + " : " + a.id);
        var O = n[a.id],
          _ = O[0];
        o = O[1], R.push(_.shape), E.push(_), A.push(o)
      }
      return [E, A, R]
    }, e.prototype.buildNodeConversionMap = function (t) {
      for (var n, r = {}, a = 0, i = this.layers; a < i.length; a++) {
        var o = i[a];
        n = o instanceof e ? 1 : 0;
        for (var s = 0; s < o.inboundNodes.length; s++) {
          var u = e.nodeKey(o, s);
          this.containerNodes.has(u) && (r[u] = n, n += 1)
        }
      }
      return r
    }, e.prototype.getLayer = function (t, e) {
      if (null != e) {
        if (this.layers.length <= e) throw new Op("Was asked to retrieve layer at index " + e + ", but model only has " + this.layers.length + " layer(s).");
        return this.layers[e]
      }
      if (null == t) throw new Op("Provide either a layer name or layer index");
      for (var n = 0, r = this.layers; n < r.length; n++) {
        var a = r[n];
        if (a.name === t) return a
      }
      throw new Op("No such layer: " + t)
    }, e.prototype.calculateLosses = function () {
      var t = this;
      return We(function () {
        for (var n = [], r = 0, a = t.layers; r < a.length; r++)
          for (var i = a[r], o = 0; o < i.inboundNodes.length; ++o) {
            var s = e.nodeKey(i, o);
            t.containerNodes.has(s) && n.push.apply(n, i.calculateLosses())
          }
        return n
      })
    }, e.prototype.getConfig = function () {
      for (var t = {
          name: this.name
        }, n = this.buildNodeConversionMap(this.layers), r = [], a = 0, i = this.layers; a < i.length; a++) {
        for (var o = (x = i[a]).getClassName(), s = x.getConfig(), u = [], l = 0; l < x.inboundNodes.length; l++) {
          var c = x.inboundNodes[l],
            p = e.nodeKey(x, l),
            h = {};
          if (this.containerNodes.has(p)) {
            if (c.callArgs) try {
              JSON.stringify(c.callArgs), h = c.callArgs
            } catch (t) {
              console.warn("Layer " + x.name + " was passed non-serializable keyword arguments: " + c.callArgs + ". They will not be included in the serialized model (and thus will be missing at deserialization time)."), h = {}
            }
            if (c.inboundLayers.length > 0) {
              for (var f = [], d = 0; d < c.inboundLayers.length; d++) {
                var m = c.inboundLayers[d],
                  g = c.nodeIndices[d],
                  v = c.tensorIndices[d];
                null == (C = n[e.nodeKey(m, g)]) && (C = 0), f.push([m.name, C, v, h])
              }
              u.push(f)
            }
          }
        }
        var y = {};
        y.name = x.name, y.className = o, y.config = s, y.inboundNodes = u, r.push(y)
      }
      t.layers = r;
      var b = [];
      for (d = 0; d < this.inputLayers.length; d++) {
        var x = this.inputLayers[d];
        g = this.inputLayersNodeIndices[d], p = e.nodeKey(x, g), this.containerNodes.has(p) && (null !== (C = n[p]) && void 0 !== C || (C = 0), v = this.inputLayersTensorIndices[d], b.push([x.name, C, v]))
      }
      t.inputLayers = b;
      var w = [];
      for (d = 0; d < this.outputLayers.length; d++) {
        var C;
        if (x = this.outputLayers[d], g = this.outputLayersNodeIndices[d], p = e.nodeKey(x, g), this.containerNodes.has(p)) null !== (C = n[p]) && void 0 !== C || (C = 0), v = this.outputLayersTensorIndices[d], w.push([x.name, C, v])
      }
      return t.outputLayers = w, t
    }, e.fromConfig = function (t, e, n, r) {
      void 0 === n && (n = {}), void 0 === r && (r = !1);
      var a = {},
        i = {};

      function o(t, e) {
        t.name in i ? i[t.name].push(e) : i[t.name] = [e]
      }

      function s(t, e) {
        for (var n, r = [], i = 0, s = e; i < s.length; i++) {
          var u = s[i],
            l = u[0],
            c = u[1],
            p = u[2];
          if (n = null == u[3] ? {} : u[3], !(l in a)) return void o(t, e);
          var h = a[l];
          if (h.inboundNodes.length <= c) return void o(t, e);
          var f = h.inboundNodes[c];
          r.push(f.outputTensors[p])
        }
        r.length > 0 && t.apply(Bp(r), n)
      }

      function u(t) {
        var n = t.name,
          i = $f(t, null != e.customObjects ? e.customObjects : {});
        i.setFastWeightInitDuringBuild(r), a[n] = i, t.inboundNodes.forEach(function (t) {
          if (!(t instanceof Array)) throw new Op("Corrupted configuration, expected array for nodeData: " + t);
          o(i, t)
        })
      }
      for (var l = e.name, c = e.layers, p = 0, h = c; p < h.length; p++) u(m = h[p]);
      for (; !Kp(i);)
        for (var f = 0, d = c; f < d.length; f++) {
          var m = d[f];
          if ((R = a[m.name]).name in i) {
            var g = i[R.name];
            delete i[R.name];
            for (var v = 0, y = g; v < y.length; v++) s(R, y[v])
          }
        }
      for (var b = [], x = [], w = 0, C = e.inputLayers; w < C.length; w++) {
        var N = (m = C[w])[0],
          S = m[1],
          k = m[2];
        zp(N in a);
        var I = (R = a[N]).inboundNodes[S].outputTensors;
        b.push(I[k])
      }
      for (var E = 0, A = e.outputLayers; E < A.length; E++) {
        var R;
        N = (m = A[E])[0], S = m[1], k = m[2], zp(N in a), I = (R = a[N]).inboundNodes[S].outputTensors, x.push(I[k])
      }
      return new t({
        inputs: b,
        outputs: x,
        name: l
      })
    }, Object.defineProperty(e.prototype, "stateful", {
      get: function () {
        if (this._stateful) throw new Op("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
        for (var t = 0, e = this.layers; t < e.length; t++)
          if (e[t].stateful) return !0;
        return !1
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.resetStates = function () {
      var t = this;
      We(function () {
        t.layers.forEach(function (t) {
          t.stateful && t.resetStates()
        })
      })
    }, e
  }(Ff));

  function Jd(t, e) {
    return Ep(this, void 0, void 0, function () {
      var n;
      return Ap(this, function (r) {
        if (null == e && (e = {}), "string" == typeof t) {
          if (0 === (n = $c.getLoadHandlers(t, e.onProgress)).length) n.push($c.browserHTTPRequest(t, e));
          else if (n.length > 1) throw new Op("Found more than one (" + n.length + ") load handlers for URL '" + t + "'");
          t = n[0]
        }
        return [2, function (t, e, n) {
          return Ep(this, void 0, void 0, function () {
            var r, a, i, o, s, u, l, c, p;
            return Ap(this, function (h) {
              switch (h.label) {
                case 0:
                  if (null == n && (n = {}), null == t.load) throw new Op("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                  return [4, t.load()];
                case 1:
                  if (r = h.sent(), null != (a = r.modelTopology).model_config && (a = a.model_config), i = null == n.strict || n.strict, o = null != r.weightData && null != r.weightSpecs && i, s = $f(Sd(a), e, o), null != (u = r.trainingConfig) && s.loadTrainingConfig(u), null != r.userDefinedMetadata && s.setUserDefinedMetadata(r.userDefinedMetadata), null == r.weightData) return [3, 4];
                  if (null == r.weightSpecs) throw new Op("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
                  return l = function (t, e) {
                    var n = $c.decodeWeights(t, e),
                      r = {},
                      a = [];
                    return e.forEach(function (t) {
                      "optimizer" === t.group ? a.push({
                        name: t.name,
                        tensor: n[t.name]
                      }) : r[t.name] = n[t.name]
                    }), {
                      modelWeights: r,
                      optimizerWeights: a
                    }
                  }(r.weightData, r.weightSpecs), c = l.modelWeights, p = l.optimizerWeights, s.loadWeights(c, i), null != s.optimizer && p.length > 0 ? [4, s.optimizer.setWeights(p)] : [3, 3];
                case 2:
                  h.sent(), h.label = 3;
                case 3:
                  Ve(c), Ve(p.map(function (t) {
                    return t.tensor
                  })), h.label = 4;
                case 4:
                  return [2, s]
              }
            })
          })
        }(t, void 0, e)]
      })
    })
  }
  rp.registerClass(Yd);
  var Zd = function (t) {
    function e(e) {
      var n = t.call(this, {
        inputs: [],
        outputs: []
      }) || this;
      if (e = e || {}, n.trainable = !0, n.built = !1, n.name = null != e.name ? e.name : bf("sequential_"), null != e.layers)
        for (var r = 0, a = e.layers; r < a.length; r++) {
          var i = a[r];
          n.add(i)
        }
      return n
    }
    return Sp(e, t), e.prototype.checkShape = function (t) {
      if (t.inboundNodes[0].outputTensors[0].shape.some(function (t) {
          return t < 0
        })) throw new Op("Negative dimension size caused by adding layer " + t.name + " with input shape [" + t.inboundNodes[0].inputTensors[0].shape + "]")
    }, e.prototype.add = function (t) {
      var n, r = t instanceof e || t instanceof Yd;
      if (r) {
        if (1 !== (n = t).outputs.length) throw new Op("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        if (1 !== n.inputs.length) throw new Op("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")
      }
      if (0 === this.outputs.length) {
        if (0 === t.inboundNodes.length) {
          if (null == t.batchInputShape) throw new Op("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
          var a = Lf({
            batchShape: t.batchInputShape,
            dtype: t.dtype,
            name: t.name + "_input"
          });
          t.apply(a)
        }
        if (r) this.outputs = n.outputs, this.inputs = n.inputs;
        else {
          if (1 !== t.inboundNodes.length) throw new Op("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " + t.name + " which has " + t.inboundNodes.length + " pre-existing inbound connections.");
          if (1 !== t.inboundNodes[0].outputTensors.length) throw new Op("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          this.checkShape(t), this.outputs = [t.inboundNodes[0].outputTensors[0]], this.inputs = function t(e, n, r) {
            if ((null == n || null != r && r > 0) && (n = e.sourceLayer, r = e.nodeIndex), 0 === n.inboundNodes.length) return [e];
            var a = n.inboundNodes[r];
            if (0 === a.inboundLayers.length) return a.inputTensors;
            for (var i = [], o = 0; o < a.inboundLayers.length; o++)
              for (var s = 0, u = t(a.inputTensors[o], a.inboundLayers[o], a.nodeIndices[o]); s < u.length; s++) {
                var l = u[s]; - 1 === i.indexOf(l) && i.push(l)
              }
            return i
          }(this.outputs[0])
        }
        this.inboundNodes = [], new Of({
          outboundLayer: this,
          inboundLayers: [],
          nodeIndices: [],
          tensorIndices: [],
          inputTensors: this.inputs,
          outputTensors: this.outputs,
          inputMasks: Mp(null, this.inputs.length),
          outputMasks: [null],
          inputShapes: this.inputs.map(function (t) {
            return t.shape
          }),
          outputShapes: this.outputs[0].shape
        })
      } else {
        var i = t.apply(this.outputs[0]);
        if (Array.isArray(i)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        this.checkShape(t), this.outputs = [i], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
      }
      this.layers.push(t), this.built = !1
    }, e.prototype.pop = function () {
      if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
      if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
      else {
        var t = this.layers.length - 1;
        this.layers[t].outboundNodes = [], this.outputs = [this.layers[t].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
      }
    }, e.prototype.call = function (t, e) {
      return null == this.model && this.build(), this.model.call(t, e)
    }, e.prototype.build = function (t) {
      if (Nf(t), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
      this.model = new Yd({
        inputs: this.inputs,
        outputs: this.outputs[0],
        name: this.name + "_model"
      }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0
    }, e.prototype.countParams = function () {
      return this.built || this.build(), t.prototype.countParams.call(this)
    }, e.prototype.summary = function (e, n, r) {
      void 0 === r && (r = console.log), this.built || this.build(), t.prototype.summary.call(this, e, n, r)
    }, e.prototype.setWeights = function (t) {
      null == this.model && this.build(), this.model.setWeights(t)
    }, e.prototype.evaluate = function (t, e, n) {
      if (void 0 === n && (n = {}), !this.built) throw new Dp("The model needs to be compiled before being used.");
      return this.model.evaluate(t, e, n)
    }, e.prototype.evaluateDataset = function (t, e) {
      return Ep(this, void 0, void 0, function () {
        return Ap(this, function (n) {
          if (!this.built) throw new Dp("The model needs to be compiled before being used.");
          return [2, this.model.evaluateDataset(t, e)]
        })
      })
    }, e.prototype.predict = function (t, e) {
      return void 0 === e && (e = {}), null == this.model && this.build(), this.model.predict(t, e)
    }, e.prototype.predictOnBatch = function (t) {
      return null == this.model && this.build(), this.model.predictOnBatch(t)
    }, e.prototype.compile = function (t) {
      this.build(), this.model.compile(t), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames
    }, Object.defineProperty(e.prototype, "optimizer", {
      get: function () {
        return null == this.model ? void 0 : this.model.optimizer
      },
      set: function (t) {
        this.model.optimizer = t
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.fit = function (t, e, n) {
      return void 0 === n && (n = {}), Ep(this, void 0, void 0, function () {
        return Ap(this, function (r) {
          if (!this.built) throw new Dp("The model needs to be compiled before being used.");
          return [2, this.model.fit(t, e, n)]
        })
      })
    }, e.prototype.fitDataset = function (t, e) {
      return Ep(this, void 0, void 0, function () {
        return Ap(this, function (n) {
          if (!this.built) throw new Dp("The model needs to be compiled before being used.");
          return [2, this.model.fitDataset(t, e)]
        })
      })
    }, e.prototype.trainOnBatch = function (t, e) {
      return Ep(this, void 0, void 0, function () {
        return Ap(this, function (n) {
          return [2, this.model.trainOnBatch(t, e)]
        })
      })
    }, e.fromConfig = function (t, n, r, a) {
      var i;
      void 0 === r && (r = {}), void 0 === a && (a = !1);
      var o = {};
      if (n instanceof Array) {
        if (null == n[0].className || "Merge" === n[0].className) throw new Op("Legacy serialization format not supported yet.");
        i = n
      } else nt.assert(null != n.layers, function () {
        return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."
      }), i = n.layers, delete n.layers, o = n;
      var s = new t(o);
      if (!(s instanceof e)) throw new _p("Sequential.fromConfig called on non-Sequential input: " + s);
      for (var u = 0, l = i; u < l.length; u++) {
        var c = $f(l[u], void 0, a);
        a && c.setFastWeightInitDuringBuild(!0), s.add(c)
      }
      return s
    }, Object.defineProperty(e.prototype, "stopTraining", {
      get: function () {
        if (null == this.model) throw new Op("Cannot get the stopTraining property of a sequential model before it is compiled.");
        return this.model.stopTraining
      },
      set: function (t) {
        if (null == this.model) throw new Op("Cannot set the stopTraining property of a sequential model before it is compiled.");
        this.model.stopTraining = t
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.getConfig = function () {
      for (var t = [], e = 0, n = this.layers; e < n.length; e++) {
        var r = n[e],
          a = {};
        a.className = r.getClassName(), a.config = r.getConfig(), t.push(a)
      }
      return {
        name: this.name,
        layers: t
      }
    }, e.className = "Sequential", e
  }(Yd);

  function Qd(t) {
    return Lf(t)
  }
  rp.registerClass(Zd);
  var tm = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e.prototype.getConfig = function () {
        return {}
      }, e
    }(rp.Serializable),
    em = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e.prototype.apply = function (t, e) {
        return void 0 === e && (e = 1),
          function (t, e) {
            if (void 0 === e && (e = 1), 1 !== e) throw new _p("Support for alpha values other than 1 (" + e + ") is not implemented yet.");
            return Wu(t)
          }(t, e)
      }, e.className = "elu", e
    }(tm);
  rp.registerClass(em);
  var nm = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return qu(t)
    }, e.className = "selu", e
  }(tm);
  rp.registerClass(nm);
  var rm = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return ju(t)
    }, e.className = "relu", e
  }(tm);
  rp.registerClass(rm);
  var am = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return We(function () {
        return bs(6, ju(t))
      })
    }, e.className = "relu6", e
  }(tm);
  rp.registerClass(am);
  var im = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return t
    }, e.className = "linear", e
  }(tm);
  rp.registerClass(im);
  var om = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return Do(t)
    }, e.className = "sigmoid", e
  }(tm);
  rp.registerClass(om);
  var sm = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return function (t) {
        return We(function () {
          var e = ls(.5, Ns(.2, t));
          return vo(e, 0, 1)
        })
      }(t)
    }, e.className = "hardSigmoid", e
  }(tm);
  rp.registerClass(sm);
  var um = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return Bo(t)
    }, e.className = "softplus", e
  }(tm);
  rp.registerClass(um);
  var lm = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return function (t) {
        return We(function () {
          return fs(t, uo(t).add(1))
        })
      }(t)
    }, e.className = "softsign", e
  }(tm);
  rp.registerClass(lm);
  var cm = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t) {
      return Uo(t)
    }, e.className = "tanh", e
  }(tm);
  rp.registerClass(cm);
  var pm = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      return void 0 === e && (e = -1), Wr(t, e)
    }, e.className = "softmax", e
  }(tm);
  rp.registerClass(pm);
  var hm = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.apply = function (t, e) {
      return void 0 === e && (e = -1), Vr(t, e)
    }, e.className = "logSoftmax", e
  }(tm);

  function fm(t) {
    return t.getClassName()
  }

  function dm(t, e) {
    return void 0 === e && (e = {}), Gp(t, rp.SerializationMap.getMap().classNameMap, e, "activation")
  }

  function mm(t) {
    var e;
    return null == t ? dm(e = {
      className: "linear",
      config: {}
    }) : "string" == typeof t ? ((e = {}).className = t, e.config = {}, dm(e)) : t instanceof tm ? t : dm(t)
  }

  function gm(t) {
    if (null != t && "object" != typeof t) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: " + t)
  }
  rp.registerClass(hm);
  var vm = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e
    }(rp.Serializable),
    ym = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return gm(e), n.l1 = null == e || null == e.l1 ? .01 : e.l1, n.l2 = null == e || null == e.l2 ? .01 : e.l2, n.hasL1 = 0 !== n.l1, n.hasL2 = 0 !== n.l2, n
      }
      return Sp(e, t), e.prototype.apply = function (t) {
        var e = this;
        return We(function () {
          var n = wn([1]);
          return e.hasL1 && (n = ls(n, Bu(Ns(e.l1, uo(t))))), e.hasL2 && (n = ls(n, Bu(Ns(e.l2, Vh(t))))), n.asScalar()
        })
      }, e.prototype.getConfig = function () {
        return {
          l1: this.l1,
          l2: this.l2
        }
      }, e.fromConfig = function (t, e) {
        return new t({
          l1: e.l1,
          l2: e.l2
        })
      }, e.className = "L1L2", e
    }(vm);
  rp.registerClass(ym);
  var bm = {
    l1l2: "L1L2"
  };

  function xm(t) {
    return jp(t)
  }

  function wm(t, e) {
    return void 0 === e && (e = {}), Gp(t, rp.SerializationMap.getMap().classNameMap, e, "regularizer")
  }

  function Cm(t) {
    return null == t ? null : "string" == typeof t ? wm({
      className: t in bm ? bm[t] : t,
      config: {}
    }) : t instanceof vm ? t : wm(t)
  }
  var Nm = function (t) {
    function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.supportsMasking = !0, null != e && (n.maxValue = e.maxValue), n
    }
    return Sp(e, t), e.prototype.call = function (t, e) {
      t = Cf(t);
      var n = ju(t);
      return null != this.maxValue && (n = vo(n, 0, this.maxValue)), n
    }, e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = {
          maxValue: this.maxValue
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "ReLU", e
  }(Ff);
  rp.registerClass(Nm);
  var Sm = function (t) {
    function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.DEFAULT_ALPHA = .3, null == e && (e = {}), n.alpha = null == e.alpha ? n.DEFAULT_ALPHA : e.alpha, n
    }
    return Sp(e, t), e.prototype.call = function (t, e) {
      var n = Cf(t);
      return Vu(n, this.alpha)
    }, e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = {
          alpha: this.alpha
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "LeakyReLU", e
  }(Ff);
  rp.registerClass(Sm);
  var km = function (t) {
    function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      if (n.DEFAULT_ALPHA_INITIALIZER = "zeros", null == e && (e = {}), n.supportsMasking = !0, n.alphaInitializer = df(e.alphaInitializer || n.DEFAULT_ALPHA_INITIALIZER), n.alphaRegularizer = Cm(e.alphaRegularizer), n.alphaConstraint = sh(e.alphaConstraint), null == e.sharedAxes) n.sharedAxes = null;
      else if (Array.isArray(e.sharedAxes)) n.sharedAxes = e.sharedAxes;
      else {
        if ("number" != typeof e.sharedAxes) throw new Op("Expected sharedAxes to be a number or an array of numbers, but got " + e.sharedAxes);
        n.sharedAxes = [e.sharedAxes]
      }
      return n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      var e = (t = Nf(t)).slice(1);
      if (null != this.sharedAxes)
        for (var n = 0, r = this.sharedAxes; n < r.length; n++) e[(i = r[n]) - 1] = 1;
      this.alpha = this.addWeight("alpha", e, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
      var a = {};
      if (null != this.sharedAxes)
        for (var i = 1; i < t.length; ++i) a[i] = t[i];
      this.inputSpec = [new Rf({
        ndim: t.length,
        axes: a
      })], this.built = !0
    }, e.prototype.call = function (t, e) {
      return t = Cf(t), Uu(t, this.alpha.read())
    }, e.prototype.getConfig = function () {
      var e = {
          alphaInitializer: ff(this.alphaInitializer),
          alphaRegularizer: xm(this.alphaRegularizer),
          alphaConstraint: ih(this.alphaConstraint),
          sharedAxes: this.sharedAxes
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "PReLU", e
  }(Ff);
  rp.registerClass(km);
  var Im = function (t) {
    function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      if (n.DEFAULT_ALPHA = 1, null == e && (e = {}), null != e.alpha && e.alpha !== n.DEFAULT_ALPHA) throw new _p("Non-default alpha value (" + e.alpha + ") is not supported by the ELU layer yet.");
      return n.alpha = null == e.alpha ? n.DEFAULT_ALPHA : e.alpha, n
    }
    return Sp(e, t), e.prototype.call = function (t, e) {
      var n = Cf(t);
      return Wu(n)
    }, e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = {
          alpha: this.alpha
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "ELU", e
  }(Ff);
  rp.registerClass(Im);
  var Em = function (t) {
    function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.DEFAULT_THETA = 1, null == e && (e = {}), n.theta = null == e.theta ? n.DEFAULT_THETA : e.theta, n
    }
    return Sp(e, t), e.prototype.call = function (t, e) {
      var n = Cf(t);
      return n.mul(Th(n.greater(this.theta), "float32"))
    }, e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = {
          theta: this.theta
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "ThresholdedReLU", e
  }(Ff);
  rp.registerClass(Em);
  var Am = function (t) {
    function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.DEFAULT_AXIS = 1, null == e && (e = {}), n.softmax = (new pm).apply, n.axis = null == e.axis ? n.DEFAULT_AXIS : e.axis, n
    }
    return Sp(e, t), e.prototype.call = function (t, e) {
      var n = Cf(t);
      return this.softmax(n, this.axis)
    }, e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = {
          axis: this.axis
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Softmax", e
  }(Ff);

  function Rm(t, e, n) {
    if ("number" == typeof t) return Mp(t, e);
    if (t.length !== e) throw new Op("The " + n + " argument must be an integer or tuple of " + e + " integers. Received: " + t.length + " elements.");
    for (var r = 0; r < e; ++r) {
      var a = t[r];
      if (!Sh(a)) throw new Op("The " + n + " argument must be an integer or tuple of " + e + " integers. Received: " + JSON.stringify(t) + " including a non-integer number " + a)
    }
    return t
  }

  function Tm(t, e, n, r, a) {
    return void 0 === a && (a = 1), null == t ? t : (i = "same" === n ? t : t - (e + (e - 1) * (a - 1)) + 1, Math.floor((i + r - 1) / r));
    var i
  }

  function Dm(t, e, n, r) {
    if (null == t) return null;
    if ("valid" === r) t = t * e + Ah([n - e, 0]);
    else {
      if ("same" !== r) throw new Op("Unsupport padding mode: " + r + ".");
      t *= e
    }
    return t
  }

  function Om(t, e) {
    return We(function () {
      return dh(e), "channelsFirst" === e ? Hu(t, [0, 2, 3, 1]) : t
    })
  }

  function _m(t, e) {
    return We(function () {
      return dh(e), "channelsFirst" === e ? Hu(t, [0, 2, 3, 4, 1]) : t
    })
  }

  function Fm(t, e, n, r, a, i, o, s) {
    return void 0 === r && (r = [1, 1]), void 0 === a && (a = "valid"), void 0 === s && (s = null), We(function () {
      if (null == i && (i = "channelsLast"), dh(i), 3 !== t.rank && 4 !== t.rank) throw new Op("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " + t.rank + ".");
      if (3 !== e.rank && 4 !== e.rank) throw new Op("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " + t.rank + ".");
      var u = Om(t, i);
      if ("causal" === a) throw new _p("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      return u = Hl.conv2d({
        x: u,
        filter: e,
        strides: r,
        pad: "same" === a ? "same" : "valid",
        dilations: o,
        dataFormat: "NHWC",
        bias: n,
        activation: s
      }), "channelsFirst" === i && (u = Hu(u, [0, 3, 1, 2])), u
    })
  }
  rp.registerClass(Am);
  var Mm = function (t) {
      function e(n, r) {
        var a = t.call(this, r) || this;
        if (a.bias = null, a.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", a.DEFAULT_BIAS_INITIALIZER = "zeros", e.verifyArgs(r), a.rank = n, Yp(a.rank, "rank"), 1 !== a.rank && 2 !== a.rank && 3 !== a.rank) throw new _p("Convolution layer for rank other than 1, 2, or 3 (" + a.rank + ") is not implemented yet.");
        if (a.kernelSize = Rm(r.kernelSize, n, "kernelSize"), a.strides = Rm(null == r.strides ? 1 : r.strides, n, "strides"), a.padding = null == r.padding ? "valid" : r.padding, mh(a.padding), a.dataFormat = null == r.dataFormat ? "channelsLast" : r.dataFormat, dh(a.dataFormat), a.activation = mm(r.activation), a.useBias = null == r.useBias || r.useBias, a.biasInitializer = df(r.biasInitializer || a.DEFAULT_BIAS_INITIALIZER), a.biasConstraint = sh(r.biasConstraint), a.biasRegularizer = Cm(r.biasRegularizer), a.activityRegularizer = Cm(r.activityRegularizer), a.dilationRate = Rm(null == r.dilationRate ? 1 : r.dilationRate, n, "dilationRate"), 1 === a.rank && Array.isArray(a.dilationRate) && 1 !== a.dilationRate.length) throw new Op("dilationRate must be a number or an array of a single number for 1D convolution, but received " + JSON.stringify(a.dilationRate));
        if (2 === a.rank) {
          if ("number" == typeof a.dilationRate) a.dilationRate = [a.dilationRate, a.dilationRate];
          else if (2 !== a.dilationRate.length) throw new Op("dilationRate must be a number or array of two numbers for 2D convolution, but received " + JSON.stringify(a.dilationRate))
        } else if (3 === a.rank)
          if ("number" == typeof a.dilationRate) a.dilationRate = [a.dilationRate, a.dilationRate, a.dilationRate];
          else if (3 !== a.dilationRate.length) throw new Op("dilationRate must be a number or array of three numbers for 3D convolution, but received " + JSON.stringify(a.dilationRate));
        return a
      }
      return Sp(e, t), e.verifyArgs = function (t) {
        if (zp("kernelSize" in t, "required key 'kernelSize' not in config"), "number" != typeof t.kernelSize && !$p(t.kernelSize, "number", 1, 3)) throw new Op("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " + JSON.stringify(t.kernelSize) + ".")
      }, e.prototype.getConfig = function () {
        var e = {
            kernelSize: this.kernelSize,
            strides: this.strides,
            padding: this.padding,
            dataFormat: this.dataFormat,
            dilationRate: this.dilationRate,
            activation: fm(this.activation),
            useBias: this.useBias,
            biasInitializer: ff(this.biasInitializer),
            biasRegularizer: xm(this.biasRegularizer),
            activityRegularizer: xm(this.activityRegularizer),
            biasConstraint: ih(this.biasConstraint)
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e
    }(Ff),
    zm = function (t) {
      function e(n, r) {
        var a = t.call(this, n, r) || this;
        return a.kernel = null, e.verifyArgs(r), a.filters = r.filters, Yp(a.filters, "filters"), a.kernelInitializer = df(r.kernelInitializer || a.DEFAULT_KERNEL_INITIALIZER), a.kernelConstraint = sh(r.kernelConstraint), a.kernelRegularizer = Cm(r.kernelRegularizer), a
      }
      return Sp(e, t), e.prototype.build = function (t) {
        var e;
        t = Nf(t);
        var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
        if (null == t[n]) throw new Op("The channel dimension of the input should be defined. Found " + t[n]);
        var r = t[n],
          a = this.kernelSize.concat([r, this.filters]);
        this.kernel = this.addWeight("kernel", a, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
          ndim: this.rank + 2,
          axes: (e = {}, e[n] = r, e)
        }], this.built = !0
      }, e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          var e;
          t = Cf(t);
          var r = null == n.bias ? null : n.bias.read(),
            a = Jp(n.activation.getClassName());
          if (null != a && 2 === n.rank) e = Fm(t, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, a);
          else {
            if (1 === n.rank) e = function (t, e, n, r, a, i, o) {
              return void 0 === r && (r = 1), void 0 === a && (a = "valid"), void 0 === o && (o = 1), We(function () {
                if (null == i && (i = "channelsLast"), dh(i), 3 !== t.shape.length) throw new Op("The input of a conv1dWithBias operation should be 3, but is " + t.shape.length + " instead.");
                if (3 !== e.shape.length) throw new Op("The kernel for a conv1dWithBias operation should be 3, but is " + e.shape.length + " instead");
                if (null != n && 1 !== n.shape.length) throw new Op("The bias for a conv1dWithBias operation should be 1, but is " + e.shape.length + " instead");
                if ("channelsFirst" === i && (t = Hu(t, [0, 2, 1])), "causal" === a) throw new _p("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
                var s = Js(t, e, r, "same" === a ? "same" : "valid", "NWC", o);
                return null != n && (s = jh(s, n)), s
              })
            }(t, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);
            else if (2 === n.rank) e = Fm(t, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
            else {
              if (3 !== n.rank) throw new _p("convolutions greater than 3D are not implemented yet.");
              e = function (t, e, n, r, a, i, o) {
                return void 0 === r && (r = [1, 1, 1]), void 0 === a && (a = "valid"), We(function () {
                  if (null == i && (i = "channelsLast"), dh(i), 4 !== t.rank && 5 !== t.rank) throw new Op("conv3dWithBias expects input to be of rank 4 or 5, but received " + t.rank + ".");
                  if (4 !== e.rank && 5 !== e.rank) throw new Op("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + t.rank + ".");
                  var s = _m(t, i);
                  if ("causal" === a) throw new _p("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
                  return s = Qs(s, e, r, "same" === a ? "same" : "valid", "NDHWC", o), null != n && (s = jh(s, n)), "channelsFirst" === i && (s = Hu(s, [0, 4, 1, 2, 3])), s
                })
              }(t, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate)
            }
            null != n.activation && (e = n.activation.apply(e))
          }
          return e
        })
      }, e.prototype.computeOutputShape = function (t) {
        t = Nf(t);
        for (var e = [], n = "channelsLast" === this.dataFormat ? t.slice(1, t.length - 1) : t.slice(2), r = 0; r < n.length; ++r) {
          var a = Tm(n[r], this.kernelSize[r], this.padding, this.strides[r], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]);
          e.push(a)
        }
        var i = [t[0]];
        return "channelsLast" === this.dataFormat ? (i = i.concat(e)).push(this.filters) : (i.push(this.filters), i = i.concat(e)), i
      }, e.prototype.getConfig = function () {
        var e = {
            filters: this.filters,
            kernelInitializer: ff(this.kernelInitializer),
            kernelRegularizer: xm(this.kernelRegularizer),
            kernelConstraint: ih(this.kernelConstraint)
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e.verifyArgs = function (t) {
        if (!("filters" in t) || "number" != typeof t.filters || t.filters < 1) throw new Op("Convolution layer expected config.filters to be a 'number' > 0 but got " + JSON.stringify(t.filters))
      }, e
    }(Mm),
    Lm = function (t) {
      function e(n) {
        var r = t.call(this, 2, n) || this;
        return e.verifyArgs(n), r
      }
      return Sp(e, t), e.prototype.getConfig = function () {
        var e = t.prototype.getConfig.call(this);
        return delete e.rank, e
      }, e.verifyArgs = function (t) {
        if ("number" != typeof t.kernelSize && !$p(t.kernelSize, "number", 1, 2)) throw new Op("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " + JSON.stringify(t.kernelSize) + ".")
      }, e.className = "Conv2D", e
    }(zm);
  rp.registerClass(Lm);
  var Bm = function (t) {
    function e(n) {
      var r = t.call(this, 3, n) || this;
      return e.verifyArgs(n), r
    }
    return Sp(e, t), e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this);
      return delete e.rank, e
    }, e.verifyArgs = function (t) {
      if ("number" != typeof t.kernelSize && (!Array.isArray(t.kernelSize) || 1 !== t.kernelSize.length && 3 !== t.kernelSize.length)) throw new Op("Conv3D expects config.kernelSize to be number or [number, number, number], but received " + JSON.stringify(t.kernelSize) + ".")
    }, e.className = "Conv3D", e
  }(zm);
  rp.registerClass(Bm);
  var Pm = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      if (n.inputSpec = [new Rf({
          ndim: 4
        })], "same" !== n.padding && "valid" !== n.padding) throw new Op("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " + n.padding);
      return n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      var e;
      if (4 !== (t = Nf(t)).length) throw new Op("Input should have rank 4; Received input shape: " + JSON.stringify(t));
      var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
      if (null == t[n]) throw new Op("The channel dimension of the inputs should be defined. Found `None`.");
      var r = t[n],
        a = this.kernelSize.concat([this.filters, r]);
      this.kernel = this.addWeight("kernel", a, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new Rf({
        ndim: 4,
        axes: (e = {}, e[n] = r, e)
      })], this.built = !0
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        var e = Cf(t);
        if (4 !== e.shape.length) throw new Op("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" + e.shape.length);
        var r, a, i = e.shape,
          o = i[0];
        "channelsFirst" === n.dataFormat ? (r = 2, a = 3) : (r = 1, a = 2);
        var s = i[r],
          u = i[a],
          l = n.kernelSize[0],
          c = n.kernelSize[1],
          p = n.strides[0],
          h = n.strides[1],
          f = [o, Dm(s, p, l, n.padding), Dm(u, h, c, n.padding), n.filters];
        "channelsLast" !== n.dataFormat && (e = Hu(e, [0, 2, 3, 1]));
        var d = ou(e, n.kernel.read(), f, n.strides, n.padding);
        return "channelsLast" !== n.dataFormat && (d = Hu(d, [0, 3, 1, 2])), null != n.bias && (d = jh(d, n.bias.read(), n.dataFormat)), null != n.activation && (d = n.activation.apply(d)), d
      })
    }, e.prototype.computeOutputShape = function (t) {
      var e, n, r, a = (t = Nf(t)).slice();
      "channelsFirst" === this.dataFormat ? (e = 1, n = 2, r = 3) : (e = 3, n = 1, r = 2);
      var i = this.kernelSize[0],
        o = this.kernelSize[1],
        s = this.strides[0],
        u = this.strides[1];
      return a[e] = this.filters, a[n] = Dm(a[n], s, i, this.padding), a[r] = Dm(a[r], u, o, this.padding), a
    }, e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this);
      return delete e.dilationRate, e
    }, e.className = "Conv2DTranspose", e
  }(Lm);
  rp.registerClass(Pm);
  var Wm = function (t) {
    function e(e) {
      return t.call(this, 2, e) || this
    }
    return Sp(e, t), e.className = "SeparableConv2D", e
  }(function (t) {
    function e(e, n) {
      var r = t.call(this, e, n) || this;
      if (r.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", r.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", r.depthwiseKernel = null, r.pointwiseKernel = null, null == n.filters) throw new Op("The `filters` configuration field is required by SeparableConv, but is unspecified.");
      if (null != n.kernelInitializer || null != n.kernelRegularizer || null != n.kernelConstraint) throw new Op("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
      if (null != n.padding && "same" !== n.padding && "valid" !== n.padding) throw new Op("SeparableConv" + r.rank + "D supports only padding modes: 'same' and 'valid', but received " + JSON.stringify(n.padding));
      return r.depthMultiplier = null == n.depthMultiplier ? 1 : n.depthMultiplier, r.depthwiseInitializer = df(n.depthwiseInitializer || r.DEFAULT_DEPTHWISE_INITIALIZER), r.depthwiseRegularizer = Cm(n.depthwiseRegularizer), r.depthwiseConstraint = sh(n.depthwiseConstraint), r.pointwiseInitializer = df(n.depthwiseInitializer || r.DEFAULT_POINTWISE_INITIALIZER), r.pointwiseRegularizer = Cm(n.pointwiseRegularizer), r.pointwiseConstraint = sh(n.pointwiseConstraint), r
    }
    return Sp(e, t), e.prototype.build = function (t) {
      var e;
      if ((t = Nf(t)).length < this.rank + 2) throw new Op("Inputs to SeparableConv" + this.rank + "D should have rank " + (this.rank + 2) + ", but received input shape: " + JSON.stringify(t));
      var n = "channelsFirst" === this.dataFormat ? 1 : t.length - 1;
      if (null == t[n] || t[n] < 0) throw new Op("The channel dimension of the inputs should be defined, but found " + JSON.stringify(t[n]));
      for (var r = t[n], a = this.kernelSize.concat([r, this.depthMultiplier]), i = [], o = 0; o < this.rank; ++o) i.push(1);
      i.push(r * this.depthMultiplier, this.filters), this.depthwiseKernel = this.addWeight("depthwise_kernel", a, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", i, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, !0, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.inputSpec = [new Rf({
        ndim: this.rank + 2,
        axes: (e = {}, e[n] = r, e)
      })], this.built = !0
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        var e;
        if (t = Cf(t), 1 === n.rank) throw new _p("1D separable convolution is not implemented yet.");
        return 2 === n.rank && ("channelsFirst" === n.dataFormat && (t = Hu(t, [0, 2, 3, 1])), e = iu(t, n.depthwiseKernel.read(), n.pointwiseKernel.read(), n.strides, n.padding, n.dilationRate, "NHWC")), n.useBias && (e = jh(e, n.bias.read(), n.dataFormat)), null != n.activation && (e = n.activation.apply(e)), "channelsFirst" === n.dataFormat && (e = Hu(e, [0, 3, 1, 2])), e
      })
    }, e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this);
      return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = ff(this.depthwiseInitializer), e.pointwiseInitializer = ff(this.pointwiseInitializer), e.depthwiseRegularizer = xm(this.depthwiseRegularizer), e.pointwiseRegularizer = xm(this.pointwiseRegularizer), e.depthwiseConstraint = ih(this.depthwiseConstraint), e.pointwiseConstraint = ih(this.pointwiseConstraint), e
    }, e.className = "SeparableConv", e
  }(zm));
  rp.registerClass(Wm);
  var Vm = function (t) {
    function e(n) {
      var r = t.call(this, 1, n) || this;
      return e.verifyArgs(n), r.inputSpec = [{
        ndim: 3
      }], r
    }
    return Sp(e, t), e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this);
      return delete e.rank, delete e.dataFormat, e
    }, e.verifyArgs = function (t) {
      if ("number" != typeof t.kernelSize && !$p(t.kernelSize, "number", 1, 1)) throw new Op("Conv1D expects config.kernelSize to be number or number[] with length 1, but received " + JSON.stringify(t.kernelSize) + ".")
    }, e.className = "Conv1D", e
  }(zm);
  rp.registerClass(Vm);
  var Um = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return "number" == typeof e.cropping ? n.cropping = [
        [e.cropping, e.cropping],
        [e.cropping, e.cropping]
      ] : "number" == typeof e.cropping[0] ? n.cropping = [
        [e.cropping[0], e.cropping[0]],
        [e.cropping[1], e.cropping[1]]
      ] : n.cropping = e.cropping, n.dataFormat = void 0 === e.dataFormat ? "channelsLast" : e.dataFormat, n.inputSpec = [{
        ndim: 4
      }], n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      return "channelsFirst" === this.dataFormat ? [t[0], t[1], t[2] - this.cropping[0][0] - this.cropping[0][1], t[3] - this.cropping[1][0] - this.cropping[1][1]] : [t[0], t[1] - this.cropping[0][0] - this.cropping[0][1], t[2] - this.cropping[1][0] - this.cropping[1][1], t[3]]
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        return t = Cf(t), "channelsLast" === n.dataFormat ? Fh(Fh(t, n.cropping[0][0], t.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2), n.cropping[1][0], t.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3) : Fh(Fh(t, n.cropping[0][0], t.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3), n.cropping[1][0], t.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4)
      })
    }, e.prototype.getConfig = function () {
      var e = {
          cropping: this.cropping,
          dataFormat: this.dataFormat
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Cropping2D", e
  }(Ff);
  rp.registerClass(Um);
  var jm = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.DEFAULT_SIZE = [2, 2], n.inputSpec = [{
        ndim: 4
      }], n.size = null == e.size ? n.DEFAULT_SIZE : e.size, n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      if ("channelsFirst" === this.dataFormat) {
        var e = null == t[2] ? null : this.size[0] * t[2],
          n = null == t[3] ? null : this.size[1] * t[3];
        return [t[0], t[1], e, n]
      }
      return e = null == t[1] ? null : this.size[0] * t[1], n = null == t[2] ? null : this.size[1] * t[2], [t[0], e, n, t[3]]
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        var e = Cf(t),
          r = e.shape;
        if ("channelsFirst" === n.dataFormat) {
          e = Hu(e, [0, 2, 3, 1]);
          var a = n.size[0] * r[2],
            i = n.size[1] * r[3],
            o = e.resizeNearestNeighbor([a, i]);
          return Hu(o, [0, 3, 1, 2])
        }
        return a = n.size[0] * r[1], i = n.size[1] * r[2], e.resizeNearestNeighbor([a, i])
      })
    }, e.prototype.getConfig = function () {
      var e = {
          size: this.size,
          dataFormat: this.dataFormat
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "UpSampling2D", e
  }(Ff);
  rp.registerClass(jm);
  var Gm = function (t) {
    function e(e) {
      var n = t.call(this, 2, e) || this;
      return n.depthwiseKernel = null, n.depthMultiplier = null == e.depthMultiplier ? 1 : e.depthMultiplier, n.depthwiseInitializer = df(e.depthwiseInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.depthwiseConstraint = sh(e.depthwiseConstraint), n.depthwiseRegularizer = Cm(e.depthwiseRegularizer), n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      if ((t = Nf(t)).length < 4) throw new Op("Inputs to DepthwiseConv2D should have rank 4. Received input shape: " + JSON.stringify(t) + ".");
      var e = "channelsFirst" === this.dataFormat ? 1 : 3;
      if (null == t[e] || t[e] < 0) throw new Op("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" + t[e] + ").");
      var n = t[e],
        r = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", r, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        var e = function (t, e, n, r, a, i) {
          return void 0 === n && (n = [1, 1]), void 0 === r && (r = "valid"), We(function () {
            null == a && (a = "channelsLast"), dh(a);
            var o = Om(t, a);
            if (4 !== t.rank) throw new Op("Input for depthwiseConv2d is required to be 4-D, but is instead " + t.rank + "-D");
            if (4 !== e.rank) throw new Op("depthwiseKernel is required to be 4-D, but is instead " + e.rank + "-D");
            return o = nu(o, e, n, "same" === r ? "same" : "valid", "NHWC", i), "channelsFirst" === a && (o = Hu(o, [0, 3, 1, 2])), o
          })
        }(t = Cf(t), n.depthwiseKernel.read(), n.strides, n.padding, n.dataFormat, null);
        return n.useBias && (e = jh(e, n.bias.read(), n.dataFormat)), null != n.activation && (e = n.activation.apply(e)), e
      })
    }, e.prototype.computeOutputShape = function (t) {
      t = Nf(t);
      var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
        n = "channelsFirst" === this.dataFormat ? t[3] : t[2],
        r = "channelsFirst" === this.dataFormat ? t[1] * this.depthMultiplier : t[3] * this.depthMultiplier,
        a = Tm(e, this.kernelSize[0], this.padding, this.strides[0]),
        i = Tm(n, this.kernelSize[1], this.padding, this.strides[1]);
      return "channelsFirst" === this.dataFormat ? [t[0], r, a, i] : [t[0], a, i, r]
    }, e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this);
      return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = ff(this.depthwiseInitializer), e.depthwiseRegularizer = xm(this.depthwiseRegularizer), e.depthwiseConstraint = ih(this.depthwiseRegularizer), e
    }, e.className = "DepthwiseConv2D", e
  }(Mm);
  rp.registerClass(Gm);
  var qm = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.rate = Math.max(Math.min(e.rate, 1), 0), n.noiseShape = e.noiseShape, n.seed = e.seed, n.supportsMasking = !0, n
    }
    return Sp(e, t), e.prototype.getNoiseShape = function (t) {
      if (null == this.noiseShape) return this.noiseShape;
      for (var e = t.shape, n = [], r = 0; r < this.noiseShape.length; ++r) n.push(null == this.noiseShape[r] ? e[r] : this.noiseShape[r]);
      return n
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r = Cf(t);
        if (0 < n.rate && n.rate < 1) {
          var a = null != e.training && e.training,
            i = n.getNoiseShape(r);
          return qh(function () {
            return Gh(r, n.rate, i, n.seed)
          }, function () {
            return r
          }, a)
        }
        return t
      })
    }, e.prototype.getConfig = function () {
      var e = {
          rate: this.rate,
          noiseShape: this.noiseShape,
          seed: this.seed
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.prototype.dispose = function () {
      return t.prototype.dispose.call(this)
    }, e.className = "Dropout", e
  }(Ff);
  rp.registerClass(qm);
  var Hm = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.inputSpec = [{
        ndim: 3
      }], n
    }
    return Sp(e, t), e.prototype.getNoiseShape = function (t) {
      var e = t.shape;
      return [e[0], 1, e[2]]
    }, e.className = "SpatialDropout1D", e
  }(qm);
  rp.registerClass(Hm);
  var Km = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      if (n.activation = null, n.useBias = !0, n.kernel = null, n.bias = null, n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_BIAS_INITIALIZER = "zeros", null == e.batchInputShape && null == e.inputShape && null != e.inputDim) {
        var r = null;
        null != e.batchSize && (r = e.batchSize), n.batchInputShape = [r, e.inputDim]
      }
      return n.units = e.units, Yp(n.units, "units"), n.activation = mm(e.activation), null != e.useBias && (n.useBias = e.useBias), n.kernelInitializer = df(e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.biasInitializer = df(e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelConstraint = sh(e.kernelConstraint), n.biasConstraint = sh(e.biasConstraint), n.kernelRegularizer = Cm(e.kernelRegularizer), n.biasRegularizer = Cm(e.biasRegularizer), n.activityRegularizer = Cm(e.activityRegularizer), n.supportsMasking = !0, n.inputSpec = [{
        minNDim: 2
      }], n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      var e, n = (t = Nf(t))[t.length - 1];
      null == this.kernel && (this.kernel = this.addWeight("kernel", [n, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
        minNDim: 2,
        axes: (e = {}, e[-1] = n, e)
      }], this.built = !0
    }, e.prototype.computeOutputShape = function (t) {
      var e = (t = Nf(t)).slice();
      return e[e.length - 1] = this.units, e
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r, a = Cf(t),
          i = Jp(n.activation.getClassName());
        return null != i ? r = Ph(a, n.kernel.read(), i, n.bias ? n.bias.read() : null) : (r = Ph(a, n.kernel.read()), null != n.bias && (r = jh(r, n.bias.read())), null != n.activation && (r = n.activation.apply(r))), r
      })
    }, e.prototype.getConfig = function () {
      var e = {
          units: this.units,
          activation: fm(this.activation),
          useBias: this.useBias,
          kernelInitializer: ff(this.kernelInitializer),
          biasInitializer: ff(this.biasInitializer),
          kernelRegularizer: xm(this.kernelRegularizer),
          biasRegularizer: xm(this.biasRegularizer),
          activityRegularizer: xm(this.activityRegularizer),
          kernelConstraint: ih(this.kernelConstraint),
          biasConstraint: ih(this.biasConstraint)
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Dense", e
  }(Ff);
  rp.registerClass(Km);
  var Xm = function (t) {
    function e(e) {
      var n = this;
      return e = e || {}, (n = t.call(this, e) || this).inputSpec = [{
        minNDim: 3
      }], n.dataFormat = e.dataFormat, n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      for (var e = 0, n = (t = Nf(t)).slice(1); e < n.length; e++)
        if (null == n[e]) throw new Op('The shape of the input to "Flatten" is not fully defined (got ' + t.slice(1) + '). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.');
      return [t[0], kh(t, 1)]
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r = Cf(t);
        if ("channelsFirst" === n.dataFormat && r.rank > 1) {
          for (var a = [0], i = 2; i < r.rank; ++i) a.push(i);
          a.push(1), r = r.transpose(a)
        }
        return function (t) {
          if (t.rank <= 1) throw new Op("batchFlatten requires a minimum rank of 2. Got rank: " + t.rank + ".");
          var e = [t.shape[0], kh(t.shape, 1)];
          return t.reshape(e)
        }(r)
      })
    }, e.prototype.getConfig = function () {
      var e = {};
      null != this.dataFormat && (e.dataFormat = this.dataFormat);
      var n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Flatten", e
  }(Ff);
  rp.registerClass(Xm);
  var $m = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.supportsMasking = !0, n.activation = mm(e.activation), n
    }
    return Sp(e, t), e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r = Cf(t);
        return n.activation.apply(r)
      })
    }, e.prototype.getConfig = function () {
      var e = {
          activation: fm(this.activation)
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Activation", e
  }(Ff);
  rp.registerClass($m);
  var Ym = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.n = e.n, n.inputSpec = [{
        ndim: 2
      }], n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      return [t[0], this.n, t[1]]
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        return function (t, e) {
          return We(function () {
            if (2 !== t.shape.length) throw new Op("repeat() expects a rank-2 tensor, but received a rank-" + t.shape.length + " tensor.");
            return Lh(Dh(t, 1), [1, e, 1])
          })
        }(t = Cf(t), n.n)
      })
    }, e.prototype.getConfig = function () {
      var e = {
          n: this.n
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "RepeatVector", e
  }(Ff);
  rp.registerClass(Ym);
  var Jm = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      n.targetShape = e.targetShape;
      for (var r = 0; r < n.targetShape.length; ++r) n.isUnknown(n.targetShape[r]) && (n.targetShape[r] = null);
      return n
    }
    return Sp(e, t), e.prototype.isUnknown = function (t) {
      return t < 0 || null == t
    }, e.prototype.fixUnknownDimension = function (t, e) {
      for (var n = "Total size of new array must be unchanged.", r = e.slice(), a = 1, i = null, o = 0; o < r.length; ++o) {
        var s = r[o];
        if (this.isUnknown(s)) {
          if (null !== i) throw new Op("Can only specifiy one unknown dimension.");
          i = o
        } else a *= s
      }
      var u = kh(t);
      if (null !== i) {
        if (0 === a || u % a != 0) throw new Op(n);
        r[i] = u / a
      } else if (u !== a) throw new Op(n);
      return r
    }, e.prototype.computeOutputShape = function (t) {
      for (var e = !1, n = 0; n < t.length; ++n)
        if (this.isUnknown(t[n])) {
          e = !0;
          break
        } return e ? t.slice(0, 1).concat(this.targetShape) : t.slice(0, 1).concat(this.fixUnknownDimension(t.slice(1), this.targetShape))
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r = Cf(t),
          a = r.shape,
          i = a.slice(0, 1).concat(n.fixUnknownDimension(a.slice(1), n.targetShape));
        return r.reshape(i)
      })
    }, e.prototype.getConfig = function () {
      var e = {
          targetShape: this.targetShape
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Reshape", e
  }(Ff);
  rp.registerClass(Jm);
  var Zm = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      if (null == e.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
      if (!Array.isArray(e.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received " + e.dims + " instead.");
      var r = Rh(1, e.dims.length + 1);
      if (!nt.arraysEqual(e.dims.slice().sort(), r)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
      return n.dims = e.dims, n.dimsIncludingBatch = [0].concat(n.dims), n.inputSpec = [new Rf({
        ndim: n.dims.length + 1
      })], n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      var e = (t = Nf(t)).slice();
      return this.dims.forEach(function (n, r) {
        e[r + 1] = t[n]
      }), e
    }, e.prototype.call = function (t, e) {
      return Hu(Cf(t), this.dimsIncludingBatch)
    }, e.prototype.getConfig = function () {
      var e = {
          dims: this.dims
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Permute", e
  }(Ff);
  rp.registerClass(Zm);
  var Qm = function (t) {
    function e(e) {
      var n = t.call(this, null == e ? {} : e) || this;
      return n.supportsMasking = !0, n.maskValue = null != e ? null == e.maskValue ? 0 : e.maskValue : 0, n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this),
        n = {
          maskValue: this.maskValue
        };
      return Object.assign(n, e), n
    }, e.prototype.computeMask = function (t, e) {
      var n = Cf(t);
      return Tu(Vs(n, this.maskValue), -1)
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r = Cf(t),
          a = Tu(Vs(r, n.maskValue), -1, !0);
        return r.mul(a.asType(r.dtype))
      })
    }, e.className = "Masking", e
  }(Ff);
  rp.registerClass(Qm);
  var tg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      if (n.embeddings = null, n.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == e.batchInputShape && null == e.inputShape) {
        var r = null;
        null != e.batchSize && (r = e.batchSize), null == e.inputLength ? n.batchInputShape = [r, null] : n.batchInputShape = [r].concat(Pp(e.inputLength))
      }
      return n.inputDim = e.inputDim, Yp(n.inputDim, "inputDim"), n.outputDim = e.outputDim, Yp(n.outputDim, "outputDim"), n.embeddingsInitializer = df(e.embeddingsInitializer || n.DEFAULT_EMBEDDINGS_INITIALIZER), n.embeddingsRegularizer = Cm(e.embeddingsRegularizer), n.activityRegularizer = Cm(e.activityRegularizer), n.embeddingsConstraint = sh(e.embeddingsConstraint), n.maskZero = e.maskZero, n.supportsMasking = e.maskZero, n.inputLength = e.inputLength, n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0
    }, e.prototype.warnOnIncompatibleInputShape = function (t) {}, e.prototype.computeMask = function (t, e) {
      var n = this;
      return We(function () {
        return n.maskZero ? (t = Cf(t), Vs(t, In(t))) : null
      })
    }, e.prototype.computeOutputShape = function (t) {
      if (t = Nf(t), null == this.inputLength) return t.concat([this.outputDim]);
      var e = Pp(this.inputLength);
      if (e.length !== t.length - 1) throw new Op('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + t);
      for (var n = 0, r = 0; r < e.length; ++r) {
        var a = e[r],
          i = t[r + 1];
        if (null != a && null != i && a !== i) throw new Op('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + t);
        null == a && (e[n] = i), n++
      }
      return [t[0]].concat(e, [this.outputDim])
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r = Cf(t);
        return "int32" !== r.dtype && (r = Th(r, "int32")), Wh(n.embeddings.read(), r.as1D()).reshape(Nf(n.computeOutputShape(r.shape)))
      })
    }, e.prototype.getConfig = function () {
      var e = {
          inputDim: this.inputDim,
          outputDim: this.outputDim,
          embeddingsInitializer: ff(this.embeddingsInitializer),
          embeddingsRegularizer: xm(this.embeddingsRegularizer),
          activityRegularizer: xm(this.activityRegularizer),
          embeddingsConstraint: ih(this.embeddingsConstraint),
          maskZero: this.maskZero,
          inputLength: this.inputLength
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Embedding", e
  }(Ff);
  rp.registerClass(tg);
  var eg = function (t) {
      function e(e) {
        var n = t.call(this, e || {}) || this;
        return n.supportsMasking = !0, n
      }
      return Sp(e, t), e.prototype.mergeFunction = function (t) {
        throw new _p
      }, e.prototype.computeElementwiseOpOutputShape = function (t, e) {
        if (null == t || null == e) return null;
        if (t.length < e.length) return this.computeElementwiseOpOutputShape(e, t);
        if (0 === e.length) return t;
        for (var n = t.slice(0, t.length - e.length), r = 0; r < e.length; ++r) {
          var a = t[t.length - e.length + r],
            i = e[r];
          if (null == a || null == i || a < 0 || i < 0) n.push(null);
          else if (1 === a) n.push(i);
          else if (1 === i) n.push(a);
          else {
            if (a !== i) throw new Op("Operands could not be broadcast together with shapes " + JSON.stringify(t) + " " + JSON.stringify(e));
            n.push(a)
          }
        }
        return n
      }, e.prototype.build = function (t) {
        if (Array.isArray(t) && !Array.isArray(t[0]) && (t = [Nf(t)]), (t = t).length < 2) throw new Op("A merge layer should be called on an Array of at least 2 inputs. Got " + t.length + " input(s).");
        for (var e = [], n = 0, r = t; n < r.length; n++) null != (o = r[n]) && null !== o[0] && e.push(o[0]);
        if ((e = Hp(e)).length > 1) throw new Op("Can not merge tensors with different batch sizes. Got tensors with shapes: " + JSON.stringify(t) + ".");
        for (var a = null == t[0] ? null : t[0].slice(1), i = 1; i < t.length; ++i) {
          var o = null == t[i] ? null : t[i].slice(1);
          a = this.computeElementwiseOpOutputShape(a, o)
        }
        var s = t.map(function (t) {
          return t.length
        }); - 1 === t.indexOf(null) && 1 === Hp(s).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0
      }, e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          if (t = t, n.reshapeRequired) {
            var e = [],
              r = t.map(function (t) {
                return t.rank
              });
            if (-1 === r.indexOf(null)) {
              for (var a = Ah(r), i = 0, o = t; i < o.length; i++) {
                for (var s = (h = o[i]).rank, u = 0; u < a - s; ++u) h = Dh(h, 1);
                e.push(h)
              }
              return n.mergeFunction(e)
            }
            for (var l = !1, c = 0, p = t; c < p.length; c++) {
              var h;
              if (null == (s = (h = p[c]).rank)) {
                var f = h.shape,
                  d = f[0],
                  m = f.slice(1).concat([d]),
                  g = h.reshape([d].concat(kh(f.slice(1))));
                g = (g = Hu(g, [1, 0])).reshape(m), e.push(g), l = !0
              } else if (s > 1) {
                var v = Rh(1, s).concat([0]);
                e.push(Hu(h, v)), l = !0
              } else e.push(h)
            }
            var y = n.mergeFunction(e),
              b = y.rank;
            if (l)
              if (null == b) {
                var x = y.shape;
                m = [d = x[x.length - 1]].concat(x.slice(0, x.length - 1)), y = Hu(y.reshape([-1, d]), [1, 0]).reshape(m)
              } else b > 1 && (v = [b - 1].concat(Rh(0, b - 1)), y = Hu(y, v));
            return y
          }
          return n.mergeFunction(t)
        })
      }, e.prototype.computeOutputShape = function (t) {
        var e;
        e = null == (t = t)[0] ? null : t[0].slice(1);
        for (var n = 1; n < t.length; ++n) {
          var r = null == t[n] ? null : t[n].slice(1);
          e = this.computeElementwiseOpOutputShape(e, r)
        }
        for (var a = [], i = 0, o = t; i < o.length; i++) null != (r = o[i]) && null !== r[0] && a.push(r[0]);
        return 1 === (a = Hp(a)).length ? a.concat(e) : [null].concat(e)
      }, e.prototype.computeMask = function (t, e) {
        return We(function () {
          if (null == e) return null;
          if (!Array.isArray(e)) throw new Op("`mask` should be an Array");
          if (!Array.isArray(t)) throw new Op("`inputs` should be an Array");
          if (e.length !== t.length) throw new Op("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" + t.length + " vs " + e.length + ")");
          if (e.every(function (t) {
              return null == t
            })) return null;
          for (var n = (e = e.map(function (t) {
              return null == t ? t : Qn(t, 0)
            }))[0], r = 1; r < e.length - 1; ++r) n = rs(n, e[r]);
          return n
        })
      }, e
    }(Ff),
    ng = function (t) {
      function e(e) {
        return t.call(this, e) || this
      }
      return Sp(e, t), e.prototype.mergeFunction = function (t) {
        return We(function () {
          for (var e = t[0].clone(), n = 1; n < t.length; ++n) e = ls(e, t[n]);
          return e
        })
      }, e.className = "Add", e
    }(eg);
  rp.registerClass(ng);
  var rg = function (t) {
    function e(e) {
      return t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.mergeFunction = function (t) {
      return We(function () {
        for (var e = t[0].clone(), n = 1; n < t.length; ++n) e = Ns(e, t[n]);
        return e
      })
    }, e.className = "Multiply", e
  }(eg);
  rp.registerClass(rg);
  var ag = function (t) {
    function e(e) {
      return t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.mergeFunction = function (t) {
      return We(function () {
        for (var e = t[0].clone(), n = 1; n < t.length; ++n) e = ls(e, t[n]);
        return Ns(1 / t.length, e)
      })
    }, e.className = "Average", e
  }(eg);
  rp.registerClass(ag);
  var ig = function (t) {
    function e(e) {
      return t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.mergeFunction = function (t) {
      return We(function () {
        for (var e = t[0], n = 1; n < t.length; ++n) e = vs(e, t[n]);
        return e
      })
    }, e.className = "Maximum", e
  }(eg);
  rp.registerClass(ig);
  var og = function (t) {
    function e(e) {
      return t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.mergeFunction = function (t) {
      return We(function () {
        for (var e = t[0], n = 1; n < t.length; ++n) e = bs(e, t[n]);
        return e
      })
    }, e.className = "Minimum", e
  }(eg);
  rp.registerClass(og);
  var sg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.DEFAULT_AXIS = -1, null == e && (e = {}), n.axis = null == e.axis ? n.DEFAULT_AXIS : e.axis, n.supportsMasking = !0, n.reshapeRequired = !1, n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      if (!Array.isArray(t) || !Array.isArray(t[0]) || 1 === t.length) throw new Op("A `Concatenate` layer should be called on a list of at least 2 inputs");
      for (var e = !0, n = 0, r = t = t; n < r.length; n++)
        if (null != (c = r[n])) {
          e = !1;
          break
        } if (!e) {
        for (var a = [], i = 0; i < t.length; ++i) {
          var o = t[i].slice();
          o.splice(this.axis, 1);
          for (var s = !1, u = 0, l = a; u < l.length; u++) {
            var c = l[u];
            if (nt.arraysEqual(c, o)) {
              s = !0;
              break
            }
          }
          s || a.push(o)
        }
        if (a.length > 1) throw new Op("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(t))
      }
    }, e.prototype.mergeFunction = function (t) {
      var e = this;
      return We(function () {
        return Mh(t, e.axis)
      })
    }, e.prototype.computeOutputShape = function (t) {
      if (!Array.isArray(t) || !Array.isArray(t[0])) throw new Op("A `Concatenate` layer should be called on a list of inputs.");
      for (var e = t, n = e[0].slice(), r = this.axis < 0 ? n.length + this.axis : this.axis, a = 0, i = e.slice(1); a < i.length; a++) {
        var o = i[a];
        if (null == n[r] || null == o[r]) {
          n[r] = null;
          break
        }
        n[r] += o[r]
      }
      return n
    }, e.prototype.computeMask = function (t, e) {
      var n = this;
      if (null == e) return null;
      if (!Array.isArray(e)) throw new Op("`mask` should be an array for Concatenate");
      if (!Array.isArray(t)) throw new Op("`inputs` should be an array for Concatenate");
      if (e.length !== t.length) throw new Op("Mismatch in the length of mask (" + e.length + ") and the legnth of inputs (" + t.length + ")");
      return We(function () {
        var r = !0;
        if (e.forEach(function (t) {
            null == t || (r = !1)
          }), r) return null;
        for (var a = [], i = 0; i < t.length; ++i) null == e[i] ? a.push(kn(t[i]).asType("bool")) : e[i].rank < t[i].rank ? a.push(Qn(e[i], -1)) : a.push(e[i]);
        var o = En(a, n.axis);
        return Ru(o, -1, !1)
      })
    }, e.prototype.getConfig = function () {
      var e = {
          axis: this.axis
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Concatenate", e
  }(eg);

  function ug(t, e) {
    for (; t < 0;) t += e;
    return t
  }
  rp.registerClass(sg);
  var lg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.axes = e.axes, n.normalize = null != e.normalize && e.normalize, n.supportsMasking = !0, n.reshapeRequired = !1, n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      nt.assert(Array.isArray(t) && 2 === t.length && Array.isArray(t[0]) && Array.isArray(t[1]), function () {
        return "A `Dot` layer should be called on a list of exactly 2 inputs."
      });
      var e = t[0],
        n = t[1];
      if (e.length > 3 || n.length > 3) throw new _p("Dot layer does not support tensors of 4D or higher rank yet.");
      var r = this.interpretAxes(e, n);
      if (e[r[0]] !== n[r[1]]) throw new Op("Dimension incompatibility: " + e[r[0]] + " !== " + n[r[1]])
    }, e.prototype.mergeFunction = function (t) {
      if (2 !== t.length) throw new Op("A `Dot` layer must be called on exactly 2 inputs, but received " + t.length + " input(s).");
      var e, n = t[0],
        r = t[1];
      return e = Array.isArray(this.axes) ? this.axes.map(function (e, n) {
          return ug(e, t[n].shape.length)
        }) : [ug(this.axes, n.shape.length), ug(this.axes, r.shape.length)], this.normalize && (n = Yf(n, e[0]), r = Yf(r, e[1])),
        function (t, e, n) {
          if (t.shape.length > 3 || e.shape.length > 3) throw new _p("batchDot is not implemented for tensors of 4D or higher rank yet");
          if (nt.assert(t.shape.length >= 2, function () {
              return "batchDot requires the rank of x to be >= 2, but got " + t.shape.length
            }), nt.assert(t.shape.length >= 2, function () {
              return "batchDot requires the rank of y to be >= 2, but got " + e.shape.length
            }), "number" == typeof n && (n = [n, n]), "complex64" === t.dtype || "complex64" === e.dtype) throw new _p("batchDot is not implemented for complex64-type Tensors yet.");
          var r = t.shape.length,
            a = e.shape.length;
          null == n && (n = [r - 1, a - 2]);
          var i = n;
          return We(function () {
            var n, o;
            if (r > a) {
              n = r - a;
              for (var s = [], u = 0; u < n; ++u) s.push(1);
              e = e.reshape(e.shape.concat(s))
            } else if (a > r) {
              for (n = a - r, s = [], u = 0; u < n; ++u) s.push(1);
              t = t.reshape(t.shape.concat(s))
            } else n = 0;
            if (2 === t.shape.length && 2 === e.shape.length) o = i[0] === i[1] ? t.mulStrict(e).sum(i[0]) : t.transpose([1, 0]).mulStrict(e).sum(i[1]);
            else {
              var l = i[0] !== t.shape.length - 1,
                c = i[1] === e.shape.length - 1;
              o = t.matMul(e, l, c)
            }
            if (n > 0) {
              var p, h = [];
              for (u = p = r > a ? r + a - 3 : r - 1; u < p + n; ++u) h.push(u);
              o = o.squeeze(h)
            }
            return 1 === o.shape.length && (o = o.expandDims(1)), o
          })
        }(n, r, e)
    }, e.prototype.interpretAxes = function (t, e) {
      return Array.isArray(this.axes) ? this.axes : [ug(this.axes, t.length), ug(this.axes, e.length)]
    }, e.prototype.computeOutputShape = function (t) {
      nt.assert(Array.isArray(t) && 2 === t.length && Array.isArray(t[0]) && Array.isArray(t[1]), function () {
        return "A `Dot` layer should be called on a list of exactly 2 inputs."
      });
      var e = t[0].slice(),
        n = t[1].slice();
      if (e.length > 3 || n.length > 3) throw new _p("Dot layer does not support tensors of 4D or higher rank yet.");
      var r = this.interpretAxes(e, n);
      e.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
      var a = e.concat(n);
      return 1 === a.length && a.push(1), a
    }, e.prototype.computeMask = function (t, e) {
      return null
    }, e.prototype.getConfig = function () {
      var e = {
          axes: this.axes,
          normalize: this.normalize
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "Dot", e
  }(eg);
  rp.registerClass(lg);
  var cg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.supportsMasking = !0, n.stddev = e.stddev, n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this),
        n = {
          stddev: this.stddev
        };
      return Object.assign(n, e), n
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r = Cf(t);
        return qh(function () {
          return Bh(r.shape, 0, n.stddev).add(r)
        }, function () {
          return r
        }, e.training || !1)
      })
    }, e.className = "GaussianNoise", e
  }(Ff);
  rp.registerClass(cg);
  var pg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.supportsMasking = !0, n.rate = e.rate, n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this),
        n = {
          rate: this.rate
        };
      return Object.assign(n, e), n
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        n.invokeCallHook(t, e);
        var r = Cf(t);
        return n.rate > 0 && n.rate < 1 ? qh(function () {
          var t = Math.sqrt(n.rate / (1 - n.rate));
          return r.mul(Bh(r.shape, 1, t))
        }, function () {
          return r
        }, e.training || !1) : r
      })
    }, e.className = "GaussianDropout", e
  }(Ff);
  rp.registerClass(pg);
  var hg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.supportsMasking = !0, n.rate = e.rate, n.noiseShape = e.noiseShape, n
    }
    return Sp(e, t), e.prototype._getNoiseShape = function (t) {
      return this.noiseShape || Cf(t).shape
    }, e.prototype.computeOutputShape = function (t) {
      return t
    }, e.prototype.getConfig = function () {
      var e = t.prototype.getConfig.call(this),
        n = {
          rate: this.rate
        };
      return Object.assign(n, e), n
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        if (n.rate < 1 && n.rate > 0) {
          var r = n._getNoiseShape(t);
          return qh(function () {
            var e = Cf(t),
              a = -1.7580993408473766,
              i = Fs(pr(r), n.rate);
            i = Th(i, "float32");
            var o = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(a, 2)), -.5),
              s = -o * a * n.rate;
            return e.mul(i).add(i.add(-1).mul(a)).mul(o).add(s)
          }, function () {
            return Cf(t)
          }, e.training || !1)
        }
        return t
      })
    }, e.className = "AlphaDropout", e
  }(Ff);

  function fg(t, e, n, r, a, i) {
    var o;
    if (void 0 === i && (i = .001), 2 === t.rank) o = ts(t, e, n, r, a, i);
    else if (3 === t.rank) o = es(t, e, n, r, a, i);
    else {
      if (4 !== t.rank) throw new _p("batchNormalization is not implemented for array of rank " + t.rank + " yet");
      o = ns(t, e, n, r, a, i)
    }
    return o
  }

  function dg(t, e, n, r, a) {
    return void 0 === a && (a = .001), nt.arraysEqual(r.slice().sort(), Rh(0, t.rank - 1)) ? function (t, e, n, r, a) {
      return void 0 === a && (a = .001), We(function () {
        var i = Lu(t, r),
          o = i.mean,
          s = i.variance;
        return [fg(t, o, s, n, e, a), o, s]
      })
    }(t, e, n, r, a) : function (t, e, n, r, a) {
      return void 0 === a && (a = .001), We(function () {
        for (var i = Lu(t, r), o = i.mean, s = i.variance, u = [], l = 0, c = Rh(0, t.rank); l < c.length; l++) {
          var p = c[l]; - 1 !== r.indexOf(p) ? u.push(1) : u.push(t.shape[p])
        }
        var h = o.reshape(u),
          f = s.reshape(u),
          d = null == e ? null : e.reshape(u),
          m = null == n ? null : n.reshape(u);
        return [fg(t, h, f, m, d, a), o, s]
      })
    }(t, e, n, r, a)
  }
  rp.registerClass(hg);
  var mg = function (t) {
    function e(e) {
      var n = this;
      return null == e && (e = {}), (n = t.call(this, e) || this).supportsMasking = !0, n.axis = null == e.axis ? -1 : e.axis, n.momentum = null == e.momentum ? .99 : e.momentum, n.epsilon = null == e.epsilon ? .001 : e.epsilon, n.center = null == e.center || e.center, n.scale = null == e.scale || e.scale, n.betaInitializer = df(e.betaInitializer || "zeros"), n.gammaInitializer = df(e.gammaInitializer || "ones"), n.movingMeanInitializer = df(e.movingMeanInitializer || "zeros"), n.movingVarianceInitializer = df(e.movingVarianceInitializer || "ones"), n.betaConstraint = sh(e.betaConstraint), n.gammaConstraint = sh(e.gammaConstraint), n.betaRegularizer = Cm(e.betaRegularizer), n.gammaRegularizer = Cm(e.gammaRegularizer), n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      var e;
      t = Nf(t);
      var n = this.axis >= 0 ? this.axis : this.axis + t.length,
        r = t[n];
      if (null == r) throw new Op("Axis " + n + " of input tensor should have a defined dimension but the layer received an input with shape " + JSON.stringify(t) + ".");
      this.inputSpec = [new Rf({
        ndim: t.length,
        axes: (e = {}, e[n] = r, e)
      })];
      var a = [r];
      this.scale && (this.gamma = this.addWeight("gamma", a, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", a, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", a, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", a, null, this.movingVarianceInitializer, null, !1), this.built = !0
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        var r = null != e.training && e.training,
          a = Cf(t),
          i = a.shape,
          o = i.length,
          s = Rh(0, o),
          u = n.axis >= 0 ? n.axis : n.axis + o;
        s.splice(u, 1);
        var l = Mp(1, o);
        l[u] = i[u];
        var c = s.slice();
        c.sort();
        var p = !nt.arraysEqual(c, Rh(0, o).slice(0, o - 1));
        if (!r) return function () {
          if (p) {
            var t = n.movingMean.read().reshape(l),
              e = n.movingVariance.read().reshape(l),
              r = n.center ? n.beta.read().reshape(l) : null,
              i = n.scale ? n.gamma.read().reshape(l) : null;
            return fg(a, t, e, r, i, n.epsilon)
          }
          return fg(a, n.movingMean.read(), n.movingVariance.read(), null == n.beta ? null : n.beta.read(), null == n.gamma ? null : n.gamma.read(), n.epsilon)
        }();
        var h = dg(a, n.gamma.read(), n.beta.read(), s, n.epsilon),
          f = h[0],
          d = h[1],
          m = h[2],
          g = function (t, e, n) {
            We(function () {
              var r = 1 - n,
                a = t.read(),
                i = a.sub(e).mul(r);
              t.write(a.sub(i))
            })
          };
        return g(n.movingMean, d, n.momentum), g(n.movingVariance, m, n.momentum), f
      })
    }, e.prototype.getConfig = function () {
      var e = {
          axis: this.axis,
          momentum: this.momentum,
          epsilon: this.epsilon,
          center: this.center,
          scale: this.scale,
          betaInitializer: ff(this.betaInitializer),
          gammaInitializer: ff(this.gammaInitializer),
          movingMeanInitializer: ff(this.movingMeanInitializer),
          movingVarianceInitializer: ff(this.movingVarianceInitializer),
          betaRegularizer: xm(this.betaRegularizer),
          gammaRegularizer: xm(this.gammaRegularizer),
          betaConstraint: ih(this.betaConstraint),
          gammaConstraint: ih(this.gammaConstraint)
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "BatchNormalization", e
  }(Ff);
  rp.registerClass(mg);
  var gg = function (t) {
    function e(e) {
      var n = this;
      if (null == e && (e = {}), (n = t.call(this, e) || this).axis = null == e.axis ? -1 : e.axis, "number" == typeof n.axis) {
        if (!Number.isInteger(n.axis)) throw new Error("Expected axis to be an integer, but received " + n.axis)
      } else {
        if (!Array.isArray(n.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received " + JSON.stringify(n.axis));
        for (var r = 0, a = n.axis; r < a.length; r++) {
          var i = a[r];
          if (!Number.isInteger(i)) throw new Error("Expected axis to be an array of integers, but received " + JSON.stringify(n.axis))
        }
      }
      return n.epsilon = null == e.epsilon ? .001 : e.epsilon, n.center = null == e.center || e.center, n.scale = null == e.scale || e.scale, n.betaInitializer = df(e.betaInitializer || "zeros"), n.gammaInitializer = df(e.gammaInitializer || "ones"), n.betaRegularizer = Cm(e.betaRegularizer), n.gammaRegularizer = Cm(e.gammaRegularizer), n.supportsMasking = !0, n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      var e = (t = Nf(t)).length;
      "number" == typeof this.axis && (this.axis = [this.axis]);
      for (var n = 0; n < this.axis.length; ++n) this.axis[n] < 0 && (this.axis[n] += e);
      for (var r = 0, a = this.axis; r < a.length; r++) {
        var i = a[r];
        if (i < 0 || i >= e) throw new Error("Invalid axis: " + i)
      }
      if (this.axis.length !== Hp(this.axis).length) throw new Error("Found duplicate axes in: " + this.axis);
      var o = this.axis.map(function (e) {
        return t[e]
      });
      this.scale ? this.gamma = this.addWeight("gamma", o, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", o, "float32", this.betaInitializer, this.betaRegularizer, !0) : this.beta = null, this.built = !0
    }, e.prototype.call = function (t, e) {
      var n = this,
        r = Cf(t),
        a = r.shape,
        i = a.length;
      return We(function () {
        for (var t = Lu(r, n.axis, !0), e = t.mean, o = t.variance, s = Mp(1, i), u = 0, l = n.axis; u < l.length; u++) {
          var c = l[u];
          s[c] = a[c]
        }
        for (var p = function (t) {
            return null != t && t.shape.length !== i && n.axis !== [i - 1] ? t.reshape(s) : t
          }, h = p(n.gamma.read()), f = p(n.beta.read()), d = [], m = [], g = 0; g < i; ++g) - 1 !== n.axis.indexOf(g) ? (d.push(a[g]), m.push(1)) : (d.push(1), m.push(a[g]));
        return e = e.tile(d), o = o.tile(d), h = h.tile(m), f = f.tile(m), fg(r, e, o, f, h, n.epsilon)
      })
    }, e.prototype.getConfig = function () {
      var e = {
          axis: this.axis,
          epsilon: this.epsilon,
          center: this.center,
          scale: this.scale,
          betaInitializer: ff(this.betaInitializer),
          gammaInitializer: ff(this.gammaInitializer),
          betaRegularizer: xm(this.betaRegularizer),
          gammaRegularizer: xm(this.gammaRegularizer)
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "LayerNormalization", e
  }(Ff);
  rp.registerClass(gg);
  var vg = function (t) {
    function e(e) {
      var n = this;
      if (null == e && (e = {}), (n = t.call(this, e) || this).dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, null == e.padding) n.padding = [
        [1, 1],
        [1, 1]
      ];
      else if ("number" == typeof e.padding) n.padding = [
        [e.padding, e.padding],
        [e.padding, e.padding]
      ];
      else {
        if (e.padding = e.padding, 2 !== e.padding.length) throw new Op("ZeroPadding2D expects padding to be a length-2 array, but received a length-" + e.padding.length + " array.");
        var r = void 0,
          a = void 0;
        if ("number" == typeof e.padding[0]) r = [e.padding[0], e.padding[0]], a = [e.padding[1], e.padding[1]];
        else {
          if (e.padding = e.padding, 2 !== e.padding[0].length) throw new Op("ZeroPadding2D expects height padding to be a length-2 array, but received a length-" + e.padding[0].length + " array.");
          if (r = e.padding[0], 2 !== e.padding[1].length) throw new Op("ZeroPadding2D expects width padding to be a length-2 array, but received a length-" + e.padding[1].length + " array.");
          a = e.padding[1]
        }
        n.padding = [r, a]
      }
      return n.inputSpec = [new Rf({
        ndim: 4
      })], n
    }
    return Sp(e, t), e.prototype.computeOutputShape = function (t) {
      var e, n;
      return t = Nf(t), "channelsFirst" === this.dataFormat ? (e = null != t[2] && t[2] >= 0 ? t[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != t[3] && t[3] >= 0 ? t[3] + this.padding[1][0] + this.padding[1][1] : null, [t[0], t[1], e, n]) : (e = null != t[1] && t[1] >= 0 ? t[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != t[2] && t[2] >= 0 ? t[2] + this.padding[1][0] + this.padding[1][1] : null, [t[0], e, n, t[3]])
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        return function (t, e, n) {
          return We(function () {
            if (4 !== t.rank) throw new Op("temporalPadding expects input tensor to be 4-D, but received a " + t.rank + "-D tensor.");
            if (null == e && (e = [
                [1, 1],
                [1, 1]
              ]), 2 !== e.length || 2 !== e[0].length || 2 !== e[1].length) throw new Op("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
            if (null == n && (n = "channelsLast"), "channelsLast" !== n && "channelsFirst" !== n) throw new Op("Unknown data format: " + n + ". Supported data formats are 'channelsLast' and 'channelsFirst.");
            var r;
            return r = "channelsFirst" === n ? [
              [0, 0],
              [0, 0], e[0], e[1]
            ] : [
              [0, 0], e[0], e[1],
              [0, 0]
            ], rr(t, r)
          })
        }(Cf(t), n.padding, n.dataFormat)
      })
    }, e.prototype.getConfig = function () {
      var e = {
          padding: this.padding,
          dataFormat: this.dataFormat
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "ZeroPadding2D", e
  }(Ff);

  function yg(t, e, n, r, a, i) {
    return We(function () {
      var o;
      dh(a), gh(i), mh(r), null == n && (n = [1, 1]), null == r && (r = "valid"), null == a && (a = "channelsLast"), null == i && (i = "max"), t = Om(t, a);
      var s = "same" === r ? "same" : "valid";
      return o = "max" === i ? yu(t, e, n, s) : bu(t, e, n, s), "channelsFirst" === a && (o = Hu(o, [0, 3, 1, 2])), o
    })
  }

  function bg(t, e, n, r, a, i) {
    return We(function () {
      var o;
      dh(a), gh(i), mh(r), null == n && (n = [1, 1, 1]), null == r && (r = "valid"), null == a && (a = "channelsLast"), null == i && (i = "max"), t = _m(t, a);
      var s = "same" === r ? "same" : "valid";
      return o = "max" === i ? wu(t, e, n, s) : Cu(t, e, n, s), "channelsFirst" === a && (o = Hu(o, [0, 4, 1, 2, 3])), o
    })
  }
  rp.registerClass(vg);
  var xg = function (t) {
      function e(e) {
        var n = this;
        if (null == e.poolSize && (e.poolSize = 2), n = t.call(this, e) || this, "number" == typeof e.poolSize) n.poolSize = [e.poolSize];
        else {
          if (!Array.isArray(e.poolSize) || 1 !== e.poolSize.length || "number" != typeof e.poolSize[0]) throw new Op("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(e.poolSize));
          n.poolSize = e.poolSize
        }
        if (Yp(n.poolSize, "poolSize"), null == e.strides) n.strides = n.poolSize;
        else if ("number" == typeof e.strides) n.strides = [e.strides];
        else {
          if (!Array.isArray(e.strides) || 1 !== e.strides.length || "number" != typeof e.strides[0]) throw new Op("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(e.strides));
          n.strides = e.strides
        }
        return Yp(n.strides, "strides"), n.padding = null == e.padding ? "valid" : e.padding, mh(n.padding), n.inputSpec = [new Rf({
          ndim: 3
        })], n
      }
      return Sp(e, t), e.prototype.computeOutputShape = function (t) {
        var e = Tm((t = Nf(t))[1], this.poolSize[0], this.padding, this.strides[0]);
        return [t[0], e, t[2]]
      }, e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          n.invokeCallHook(t, e), t = Dh(Cf(t), 2);
          var r = n.poolingFunction(Cf(t), [n.poolSize[0], 1], [n.strides[0], 1], n.padding, "channelsLast");
          return dr(r, [2])
        })
      }, e.prototype.getConfig = function () {
        var e = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e
    }(Ff),
    wg = function (t) {
      function e(e) {
        return t.call(this, e) || this
      }
      return Sp(e, t), e.prototype.poolingFunction = function (t, e, n, r, a) {
        return dh(a), mh(r), yg(t, e, n, r, a, "max")
      }, e.className = "MaxPooling1D", e
    }(xg);
  rp.registerClass(wg);
  var Cg = function (t) {
    function e(e) {
      return t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.poolingFunction = function (t, e, n, r, a) {
      return dh(a), mh(r), yg(t, e, n, r, a, "avg")
    }, e.className = "AveragePooling1D", e
  }(xg);
  rp.registerClass(Cg);
  var Ng = function (t) {
      function e(e) {
        var n = this;
        if (null == e.poolSize && (e.poolSize = [2, 2]), (n = t.call(this, e) || this).poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], null == e.strides) n.strides = n.poolSize;
        else if (Array.isArray(e.strides)) {
          if (2 !== e.strides.length) throw new Op("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + e.strides.length + ".");
          n.strides = e.strides
        } else n.strides = [e.strides, e.strides];
        return Yp(n.poolSize, "poolSize"), Yp(n.strides, "strides"), n.padding = null == e.padding ? "valid" : e.padding, n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, dh(n.dataFormat), mh(n.padding), n.inputSpec = [new Rf({
          ndim: 4
        })], n
      }
      return Sp(e, t), e.prototype.computeOutputShape = function (t) {
        t = Nf(t);
        var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
          n = "channelsFirst" === this.dataFormat ? t[3] : t[2];
        return e = Tm(e, this.poolSize[0], this.padding, this.strides[0]), n = Tm(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [t[0], t[1], e, n] : [t[0], e, n, t[3]]
      }, e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          return n.invokeCallHook(t, e), n.poolingFunction(Cf(t), n.poolSize, n.strides, n.padding, n.dataFormat)
        })
      }, e.prototype.getConfig = function () {
        var e = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
            dataFormat: this.dataFormat
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e
    }(Ff),
    Sg = function (t) {
      function e(e) {
        return t.call(this, e) || this
      }
      return Sp(e, t), e.prototype.poolingFunction = function (t, e, n, r, a) {
        return dh(a), mh(r), yg(t, e, n, r, a, "max")
      }, e.className = "MaxPooling2D", e
    }(Ng);
  rp.registerClass(Sg);
  var kg = function (t) {
    function e(e) {
      return t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.poolingFunction = function (t, e, n, r, a) {
      return dh(a), mh(r), yg(t, e, n, r, a, "avg")
    }, e.className = "AveragePooling2D", e
  }(Ng);
  rp.registerClass(kg);
  var Ig = function (t) {
      function e(e) {
        var n = this;
        if (null == e.poolSize && (e.poolSize = [2, 2, 2]), (n = t.call(this, e) || this).poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], null == e.strides) n.strides = n.poolSize;
        else if (Array.isArray(e.strides)) {
          if (3 !== e.strides.length) throw new Op("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + e.strides.length + ".");
          n.strides = e.strides
        } else n.strides = [e.strides, e.strides, e.strides];
        return Yp(n.poolSize, "poolSize"), Yp(n.strides, "strides"), n.padding = null == e.padding ? "valid" : e.padding, n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, dh(n.dataFormat), mh(n.padding), n.inputSpec = [new Rf({
          ndim: 5
        })], n
      }
      return Sp(e, t), e.prototype.computeOutputShape = function (t) {
        t = Nf(t);
        var e = "channelsFirst" === this.dataFormat ? t[2] : t[1],
          n = "channelsFirst" === this.dataFormat ? t[3] : t[2],
          r = "channelsFirst" === this.dataFormat ? t[4] : t[3];
        return e = Tm(e, this.poolSize[0], this.padding, this.strides[0]), n = Tm(n, this.poolSize[1], this.padding, this.strides[1]), r = Tm(r, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [t[0], t[1], e, n, r] : [t[0], e, n, r, t[4]]
      }, e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          return n.invokeCallHook(t, e), n.poolingFunction(Cf(t), n.poolSize, n.strides, n.padding, n.dataFormat)
        })
      }, e.prototype.getConfig = function () {
        var e = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
            dataFormat: this.dataFormat
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e
    }(Ff),
    Eg = function (t) {
      function e(e) {
        return t.call(this, e) || this
      }
      return Sp(e, t), e.prototype.poolingFunction = function (t, e, n, r, a) {
        return dh(a), mh(r), bg(t, e, n, r, a, "max")
      }, e.className = "MaxPooling3D", e
    }(Ig);
  rp.registerClass(Eg);
  var Ag = function (t) {
    function e(e) {
      return t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.poolingFunction = function (t, e, n, r, a) {
      return dh(a), mh(r), bg(t, e, n, r, a, "avg")
    }, e.className = "AveragePooling3D", e
  }(Ig);
  rp.registerClass(Ag);
  var Rg = function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return n.inputSpec = [new Rf({
          ndim: 3
        })], n
      }
      return Sp(e, t), e.prototype.computeOutputShape = function (t) {
        return [t[0], t[2]]
      }, e.prototype.call = function (t, e) {
        throw new _p
      }, e
    }(Ff),
    Tg = function (t) {
      function e(e) {
        return t.call(this, e || {}) || this
      }
      return Sp(e, t), e.prototype.call = function (t, e) {
        return We(function () {
          var e = Cf(t);
          return Mu(e, 1)
        })
      }, e.className = "GlobalAveragePooling1D", e
    }(Rg);
  rp.registerClass(Tg);
  var Dg = function (t) {
    function e(e) {
      return t.call(this, e || {}) || this
    }
    return Sp(e, t), e.prototype.call = function (t, e) {
      return We(function () {
        var e = Cf(t);
        return Fu(e, 1)
      })
    }, e.className = "GlobalMaxPooling1D", e
  }(Rg);
  rp.registerClass(Dg);
  var Og = function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return n.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, dh(n.dataFormat), n.inputSpec = [new Rf({
          ndim: 4
        })], n
      }
      return Sp(e, t), e.prototype.computeOutputShape = function (t) {
        return t = t, "channelsLast" === this.dataFormat ? [t[0], t[3]] : [t[0], t[1]]
      }, e.prototype.call = function (t, e) {
        throw new _p
      }, e.prototype.getConfig = function () {
        var e = {
            dataFormat: this.dataFormat
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e
    }(Ff),
    _g = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          var e = Cf(t);
          return "channelsLast" === n.dataFormat ? Mu(e, [1, 2]) : Mu(e, [2, 3])
        })
      }, e.className = "GlobalAveragePooling2D", e
    }(Og);
  rp.registerClass(_g);
  var Fg = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this
    }
    return Sp(e, t), e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        var e = Cf(t);
        return "channelsLast" === n.dataFormat ? Fu(e, [1, 2]) : Fu(e, [2, 3])
      })
    }, e.className = "GlobalMaxPooling2D", e
  }(Og);

  function Mg(t, e, n, r) {
    if (Array.isArray(t)) {
      if (null != e || null != n) throw new Op("When inputs is an array, neither initialState or constants should be provided");
      null != r && (n = t.slice(t.length - r, t.length), t = t.slice(0, t.length - r)), t.length > 1 && (e = t.slice(1, t.length)), t = t[0]
    }

    function a(t) {
      return null == t || Array.isArray(t) ? t : [t]
    }
    return {
      inputs: t,
      initialState: e = a(e),
      constants: n = a(n)
    }
  }

  function zg(t, e, n, r, a, i, o, s) {
    return void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), We(function () {
      var u = e.shape.length;
      if (u < 3) throw new Op("Input should be at least 3D, but is " + u + "D.");
      var l = [1, 0].concat(Rh(2, u));
      if (e = Hu(e, l), null != i) throw new _p("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
      o && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != a && ((a = a.asType("bool").asType("float32")).rank === u - 1 && (a = Qn(a, -1)), a = Hu(a, l)), r && (e = pu(e, 0), null != a && (a = pu(a, 0)));
      var c, p, h = [],
        f = n,
        d = e.shape[0],
        m = yr(e);
      null != a && (p = yr(a));
      for (var g, v = function (e) {
          var n = m[e],
            r = We(function () {
              return t(n, f)
            });
          if (null == a) c = r[0], f = r[1];
          else {
            var i = We(function () {
              var t = p[e],
                n = kn(t).sub(t);
              return {
                output: r[0].mul(t).addStrict(f[0].mul(n)),
                newStates: f.map(function (e, a) {
                  return r[1][a].mul(t).addStrict(e.mul(n))
                })
              }
            });
            c = i.output, f = i.newStates
          }
          s && h.push(c)
        }, y = 0; y < d; ++y) v(y);
      return s && (g = mr(h, 1)), [c, g, f]
    })
  }
  rp.registerClass(Fg);
  var Lg = function (t) {
    function e(e) {
      var n, r = t.call(this, e) || this;
      if (null == e.cell) throw new Op("cell property is missing for the constructor of RNN.");
      if (null == (n = Array.isArray(e.cell) ? new qg({
          cells: e.cell
        }) : e.cell).stateSize) throw new Op("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
      return r.cell = n, r.returnSequences = null != e.returnSequences && e.returnSequences, r.returnState = null != e.returnState && e.returnState, r.goBackwards = null != e.goBackwards && e.goBackwards, r._stateful = null != e.stateful && e.stateful, r.unroll = null != e.unroll && e.unroll, r.supportsMasking = !0, r.inputSpec = [new Rf({
        ndim: 3
      })], r.stateSpec = null, r.states_ = null, r.numConstants = null, r.keptStates = [], r
    }
    return Sp(e, t), e.prototype.getStates = function () {
      return null == this.states_ ? Rh(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function (t) {
        return null
      }) : this.states_
    }, e.prototype.setStates = function (t) {
      this.states_ = t
    }, e.prototype.computeOutputShape = function (t) {
      xf(t) && (t = t[0]), t = t;
      var e = this.cell.stateSize;
      Array.isArray(e) || (e = [e]);
      var n, r = e[0];
      if (n = this.returnSequences ? [t[0], t[1], r] : [t[0], r], this.returnState) {
        for (var a = [], i = 0, o = e; i < o.length; i++) {
          var s = o[i];
          a.push([t[0], s])
        }
        return [n].concat(a)
      }
      return n
    }, e.prototype.computeMask = function (t, e) {
      var n = this;
      return We(function () {
        Array.isArray(e) && (e = e[0]);
        var t = n.returnSequences ? e : null;
        if (n.returnState) {
          var r = n.states.map(function (t) {
            return null
          });
          return [t].concat(r)
        }
        return t
      })
    }, Object.defineProperty(e.prototype, "states", {
      get: function () {
        if (null == this.states_) {
          for (var t = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, e = [], n = 0; n < t; ++n) e.push(null);
          return e
        }
        return this.states_
      },
      set: function (t) {
        this.states_ = t
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.build = function (t) {
      if (null != this.numConstants) throw new _p("Constants support is not implemented in RNN yet.");
      xf(t) && (t = t[0]), t = t;
      var e = this.stateful ? t[0] : null,
        n = t[t.length - 1];
      this.inputSpec[0] = new Rf({
        shape: [e, null, n]
      });
      var r, a = [t[0]].concat(t.slice(2));
      if (this.cell.build(a), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
        if (!nt.arraysEqual(this.stateSpec.map(function (t) {
            return t.shape[t.shape.length - 1]
          }), r)) throw new Op("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" + this.stateSpec + "; However cell.stateSize is " + this.cell.stateSize)
      } else this.stateSpec = r.map(function (t) {
        return new Rf({
          shape: [null, t]
        })
      });
      this.stateful && this.resetStates()
    }, e.prototype.resetStates = function (t, e) {
      var n = this;
      void 0 === e && (e = !1), We(function () {
        if (!n.stateful) throw new Tp("Cannot call resetStates() on an RNN Layer that is not stateful.");
        var r = n.inputSpec[0].shape[0];
        if (null == r) throw new Op("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        if (null == n.states_) Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function (t) {
          return wn([r, t])
        }) : n.states_ = [wn([r, n.cell.stateSize])];
        else if (null == t) Ve(n.states_), null != n.keptStates && (Ve(n.keptStates), n.keptStates = []), Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function (t) {
          return wn([r, t])
        }) : n.states_[0] = wn([r, n.cell.stateSize]);
        else {
          if (Array.isArray(t) || (t = [t]), t.length !== n.states_.length) throw new Op("Layer " + n.name + " expects " + n.states_.length + " state(s), but it received " + t.length + " state value(s). Input received: " + t);
          !0 === e ? n.keptStates.push(n.states_.slice()) : Ve(n.states_);
          for (var a = 0; a < n.states_.length; ++a) {
            var i = t[a],
              o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize[a] : n.cell.stateSize,
              s = [r, o];
            if (!nt.arraysEqual(i.shape, s)) throw new Op("State " + a + " is incompatible with layer " + n.name + ": expected shape=" + s + ", received shape=" + i.shape);
            n.states_[a] = i
          }
        }
        n.states_ = n.states_.map(function (t) {
          return Ue(t.clone())
        })
      })
    }, e.prototype.apply = function (e, n) {
      var r = null == n ? null : n.initialState,
        a = null == n ? null : n.constants;
      null == n && (n = {});
      var i = Mg(e, r, a, this.numConstants);
      e = i.inputs, r = i.initialState, a = i.constants;
      var o = [],
        s = [];
      if (null != r) {
        n.initialState = r, o = o.concat(r), this.stateSpec = [];
        for (var u = 0, l = r; u < l.length; u++) {
          var c = l[u];
          this.stateSpec.push(new Rf({
            shape: c.shape
          }))
        }
        s = s.concat(this.stateSpec)
      }
      if (null != a && (n.constants = a, o = o.concat(a), this.numConstants = a.length), o[0] instanceof Tf) {
        var p = [e].concat(o),
          h = this.inputSpec.concat(s),
          f = this.inputSpec;
        this.inputSpec = h;
        var d = t.prototype.apply.call(this, p, n);
        return this.inputSpec = f, d
      }
      return t.prototype.apply.call(this, e, n)
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        var r = null == e ? null : e.mask,
          a = null == e ? null : e.training,
          i = null == e ? null : e.initialState;
        t = Cf(t), null == i && (i = n.stateful ? n.states_ : n.getInitialState(t));
        var o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
        if (i.length !== o) throw new Op("RNN Layer has " + o + " state(s) but was passed " + i.length + " initial state(s).");
        n.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
        var s = {
            training: a
          },
          u = zg(function (t, e) {
            var r = n.cell.call([t].concat(e), s);
            return [r[0], r.slice(1)]
          }, t, i, n.goBackwards, r, null, n.unroll, n.returnSequences),
          l = u[0],
          c = u[1],
          p = u[2];
        n.stateful && n.resetStates(p, a);
        var h = n.returnSequences ? c : l;
        return n.returnState ? [h].concat(p) : h
      })
    }, e.prototype.getInitialState = function (t) {
      var e = this;
      return We(function () {
        var n = wn(t.shape);
        return n = Dh(n = Bu(n, [1, 2])), Array.isArray(e.cell.stateSize) ? e.cell.stateSize.map(function (t) {
          return t > 1 ? Lh(n, [1, t]) : n
        }) : e.cell.stateSize > 1 ? [Lh(n, [1, e.cell.stateSize])] : [n]
      })
    }, Object.defineProperty(e.prototype, "trainableWeights", {
      get: function () {
        return this.trainable ? this.cell.trainableWeights : []
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
      get: function () {
        return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.setFastWeightInitDuringBuild = function (e) {
      t.prototype.setFastWeightInitDuringBuild.call(this, e), null != this.cell && this.cell.setFastWeightInitDuringBuild(e)
    }, e.prototype.getConfig = function () {
      var e = {
        returnSequences: this.returnSequences,
        returnState: this.returnState,
        goBackwards: this.goBackwards,
        stateful: this.stateful,
        unroll: this.unroll
      };
      null != this.numConstants && (e.numConstants = this.numConstants);
      var n = this.cell.getConfig();
      e.cell = {
        className: this.cell.getClassName(),
        config: n
      };
      var r = t.prototype.getConfig.call(this);
      return Object.assign(e, r), e
    }, e.fromConfig = function (t, e, n) {
      void 0 === n && (n = {});
      var r = $f(e.cell, n);
      return new t(Object.assign(e, {
        cell: r
      }))
    }, e.className = "RNN", e
  }(Ff);
  rp.registerClass(Lg);
  var Bg = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Sp(e, t), e
    }(Ff),
    Pg = function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = e.units, Yp(n.units, "units"), n.activation = mm(null == e.activation ? n.DEFAULT_ACTIVATION : e.activation), n.useBias = null == e.useBias || e.useBias, n.kernelInitializer = df(e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = df(e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = df(e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = Cm(e.kernelRegularizer), n.recurrentRegularizer = Cm(e.recurrentRegularizer), n.biasRegularizer = Cm(e.biasRegularizer), n.kernelConstraint = sh(e.kernelConstraint), n.recurrentConstraint = sh(e.recurrentConstraint), n.biasConstraint = sh(e.biasConstraint), n.dropout = Eh([1, Ah([0, null == e.dropout ? 0 : e.dropout])]), n.recurrentDropout = Eh([1, Ah([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n
      }
      return Sp(e, t), e.prototype.build = function (t) {
        t = Nf(t), this.kernel = this.addWeight("kernel", [t[t.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
      }, e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          if (2 !== (t = t).length) throw new Op("SimpleRNNCell expects 2 input Tensors, got " + t.length + ".");
          var r = t[1];
          t = t[0];
          var a, i = null != e.training && e.training;
          0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = Hg(function () {
            return kn(t)
          }, n.dropout, i)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = Hg(function () {
            return kn(r)
          }, n.recurrentDropout, i));
          var o = n.dropoutMask,
            s = n.recurrentDropoutMask;
          a = Ph(null != o ? Ns(t, o) : t, n.kernel.read()), null != n.bias && (a = jh(a, n.bias.read())), null != s && (r = Ns(r, s));
          var u = ls(a, Ph(r, n.recurrentKernel.read()));
          return null != n.activation && (u = n.activation.apply(u)), [u, u]
        })
      }, e.prototype.getConfig = function () {
        var e = {
            units: this.units,
            activation: fm(this.activation),
            useBias: this.useBias,
            kernelInitializer: ff(this.kernelInitializer),
            recurrentInitializer: ff(this.recurrentInitializer),
            biasInitializer: ff(this.biasInitializer),
            kernelRegularizer: xm(this.kernelRegularizer),
            recurrentRegularizer: xm(this.recurrentRegularizer),
            biasRegularizer: xm(this.biasRegularizer),
            activityRegularizer: xm(this.activityRegularizer),
            kernelConstraint: ih(this.kernelConstraint),
            recurrentConstraint: ih(this.recurrentConstraint),
            biasConstraint: ih(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e.className = "SimpleRNNCell", e
    }(Bg);
  rp.registerClass(Pg);
  var Wg = function (t) {
    function e(e) {
      return e.cell = new Pg(e), t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.call = function (e, n) {
      var r = this;
      return We(function () {
        null != r.cell.dropoutMask && (Ve(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Ve(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
        var a = null == n ? null : n.mask,
          i = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
        return t.prototype.call.call(r, e, {
          mask: a,
          training: i,
          initialState: o
        })
      })
    }, Object.defineProperty(e.prototype, "units", {
      get: function () {
        return this.cell.units
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "activation", {
      get: function () {
        return this.cell.activation
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "useBias", {
      get: function () {
        return this.cell.useBias
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelInitializer", {
      get: function () {
        return this.cell.kernelInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentInitializer", {
      get: function () {
        return this.cell.recurrentInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasInitializer", {
      get: function () {
        return this.cell.biasInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelRegularizer", {
      get: function () {
        return this.cell.kernelRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentRegularizer", {
      get: function () {
        return this.cell.recurrentRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasRegularizer", {
      get: function () {
        return this.cell.biasRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelConstraint", {
      get: function () {
        return this.cell.kernelConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentConstraint", {
      get: function () {
        return this.cell.recurrentConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasConstraint", {
      get: function () {
        return this.cell.biasConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "dropout", {
      get: function () {
        return this.cell.dropout
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentDropout", {
      get: function () {
        return this.cell.recurrentDropout
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.getConfig = function () {
      var e = {
          units: this.units,
          activation: fm(this.activation),
          useBias: this.useBias,
          kernelInitializer: ff(this.kernelInitializer),
          recurrentInitializer: ff(this.recurrentInitializer),
          biasInitializer: ff(this.biasInitializer),
          kernelRegularizer: xm(this.kernelRegularizer),
          recurrentRegularizer: xm(this.recurrentRegularizer),
          biasRegularizer: xm(this.biasRegularizer),
          activityRegularizer: xm(this.activityRegularizer),
          kernelConstraint: ih(this.kernelConstraint),
          recurrentConstraint: ih(this.recurrentConstraint),
          biasConstraint: ih(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout
        },
        n = t.prototype.getConfig.call(this);
      return delete n.cell, Object.assign(e, n), e
    }, e.fromConfig = function (t, e) {
      return new t(e)
    }, e.className = "SimpleRNN", e
  }(Lg);
  rp.registerClass(Wg);
  var Vg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = e.units, Yp(n.units, "units"), n.activation = mm(void 0 === e.activation ? n.DEFAULT_ACTIVATION : e.activation), n.recurrentActivation = mm(void 0 === e.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), n.useBias = null == e.useBias || e.useBias, n.kernelInitializer = df(e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = df(e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = df(e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = Cm(e.kernelRegularizer), n.recurrentRegularizer = Cm(e.recurrentRegularizer), n.biasRegularizer = Cm(e.biasRegularizer), n.kernelConstraint = sh(e.kernelConstraint), n.recurrentConstraint = sh(e.recurrentConstraint), n.biasConstraint = sh(e.biasConstraint), n.dropout = Eh([1, Ah([0, null == e.dropout ? 0 : e.dropout])]), n.recurrentDropout = Eh([1, Ah([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), n.implementation = e.implementation, n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      var e = (t = Nf(t))[t.length - 1];
      this.kernel = this.addWeight("kernel", [e, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        if (2 !== (t = t).length) throw new Op("GRUCell expects 2 input Tensors (inputs, h, c), got " + t.length + ".");
        var r = null != e.training && e.training,
          a = t[1];
        t = t[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = Hg(function () {
          return kn(t)
        }, n.dropout, r, 3)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = Hg(function () {
          return kn(a)
        }, n.recurrentDropout, r, 3));
        var i, o, s, u = n.dropoutMask,
          l = n.recurrentDropoutMask;
        0 < n.dropout && n.dropout < 1 && (t = Ns(t, u[0]));
        var c = Ph(t, n.kernel.read());
        n.useBias && (c = jh(c, n.bias.read())), 0 < n.recurrentDropout && n.recurrentDropout < 1 && (a = Ns(a, l[0]));
        var p = n.recurrentKernel.read(),
          h = On(p, [2 * n.units, n.units], p.rank - 1),
          f = h[0],
          d = h[1],
          m = Ph(a, f),
          g = On(c, 3, c.rank - 1),
          v = g[0],
          y = g[1],
          b = g[2],
          x = On(m, 2, m.rank - 1),
          w = x[0],
          C = x[1];
        i = n.recurrentActivation.apply(ls(v, w)), o = n.recurrentActivation.apply(ls(y, C));
        var N = Ph(Ns(o, a), d);
        s = n.activation.apply(ls(b, N));
        var S = ls(Ns(i, a), Ns(ls(1, Eo(i)), s));
        return [S, S]
      })
    }, e.prototype.getConfig = function () {
      var e = {
          units: this.units,
          activation: fm(this.activation),
          recurrentActivation: fm(this.recurrentActivation),
          useBias: this.useBias,
          kernelInitializer: ff(this.kernelInitializer),
          recurrentInitializer: ff(this.recurrentInitializer),
          biasInitializer: ff(this.biasInitializer),
          kernelRegularizer: xm(this.kernelRegularizer),
          recurrentRegularizer: xm(this.recurrentRegularizer),
          biasRegularizer: xm(this.biasRegularizer),
          activityRegularizer: xm(this.activityRegularizer),
          kernelConstraint: ih(this.kernelConstraint),
          recurrentConstraint: ih(this.recurrentConstraint),
          biasConstraint: ih(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout,
          implementation: this.implementation
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "GRUCell", e
  }(Bg);
  rp.registerClass(Vg);
  var Ug = function (t) {
    function e(e) {
      return 0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Vg(e), t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.call = function (e, n) {
      var r = this;
      return We(function () {
        null != r.cell.dropoutMask && (Ve(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Ve(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
        var a = null == n ? null : n.mask,
          i = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
        return t.prototype.call.call(r, e, {
          mask: a,
          training: i,
          initialState: o
        })
      })
    }, Object.defineProperty(e.prototype, "units", {
      get: function () {
        return this.cell.units
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "activation", {
      get: function () {
        return this.cell.activation
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentActivation", {
      get: function () {
        return this.cell.recurrentActivation
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "useBias", {
      get: function () {
        return this.cell.useBias
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelInitializer", {
      get: function () {
        return this.cell.kernelInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentInitializer", {
      get: function () {
        return this.cell.recurrentInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasInitializer", {
      get: function () {
        return this.cell.biasInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelRegularizer", {
      get: function () {
        return this.cell.kernelRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentRegularizer", {
      get: function () {
        return this.cell.recurrentRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasRegularizer", {
      get: function () {
        return this.cell.biasRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelConstraint", {
      get: function () {
        return this.cell.kernelConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentConstraint", {
      get: function () {
        return this.cell.recurrentConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasConstraint", {
      get: function () {
        return this.cell.biasConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "dropout", {
      get: function () {
        return this.cell.dropout
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentDropout", {
      get: function () {
        return this.cell.recurrentDropout
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "implementation", {
      get: function () {
        return this.cell.implementation
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.getConfig = function () {
      var e = {
          units: this.units,
          activation: fm(this.activation),
          recurrentActivation: fm(this.recurrentActivation),
          useBias: this.useBias,
          kernelInitializer: ff(this.kernelInitializer),
          recurrentInitializer: ff(this.recurrentInitializer),
          biasInitializer: ff(this.biasInitializer),
          kernelRegularizer: xm(this.kernelRegularizer),
          recurrentRegularizer: xm(this.recurrentRegularizer),
          biasRegularizer: xm(this.biasRegularizer),
          activityRegularizer: xm(this.activityRegularizer),
          kernelConstraint: ih(this.kernelConstraint),
          recurrentConstraint: ih(this.recurrentConstraint),
          biasConstraint: ih(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout,
          implementation: this.implementation
        },
        n = t.prototype.getConfig.call(this);
      return delete n.cell, Object.assign(e, n), e
    }, e.fromConfig = function (t, e) {
      return 0 === e.implmentation && (e.implementation = 1), new t(e)
    }, e.className = "GRU", e
  }(Lg);
  rp.registerClass(Ug);
  var jg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = e.units, Yp(n.units, "units"), n.activation = mm(void 0 === e.activation ? n.DEFAULT_ACTIVATION : e.activation), n.recurrentActivation = mm(void 0 === e.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), n.useBias = null == e.useBias || e.useBias, n.kernelInitializer = df(e.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = df(e.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = df(e.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.unitForgetBias = e.unitForgetBias, n.kernelRegularizer = Cm(e.kernelRegularizer), n.recurrentRegularizer = Cm(e.recurrentRegularizer), n.biasRegularizer = Cm(e.biasRegularizer), n.kernelConstraint = sh(e.kernelConstraint), n.recurrentConstraint = sh(e.recurrentConstraint), n.biasConstraint = sh(e.biasConstraint), n.dropout = Eh([1, Ah([0, null == e.dropout ? 0 : e.dropout])]), n.recurrentDropout = Eh([1, Ah([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), n.implementation = e.implementation, n.stateSize = [n.units, n.units], n.dropoutMask = null, n.recurrentDropoutMask = null, n
    }
    return Sp(e, t), e.prototype.build = function (t) {
      var e, n, r = (t = Nf(t))[t.length - 1];
      if (this.kernel = this.addWeight("kernel", [r, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
        if (this.unitForgetBias) {
          var a = this.biasInitializer,
            i = this.units;
          n = new((e = function (t) {
            function e() {
              return null !== t && t.apply(this, arguments) || this
            }
            return Sp(e, t), e.prototype.apply = function (t, e) {
              var n = a.apply([i]),
                r = (new Yh).apply([i]),
                o = a.apply([2 * i]);
              return zh(zh(n, r), o)
            }, e
          }(Xh)).className = "CustomInit", e)
        } else n = this.biasInitializer;
        this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint)
      } else this.bias = null;
      this.built = !0
    }, e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        var r = null != e.training && e.training;
        if (3 !== (t = t).length) throw new Op("LSTMCell expects 3 input Tensors (inputs, h, c), got " + t.length + ".");
        var a = t[1],
          i = t[2];
        t = t[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = Hg(function () {
          return kn(t)
        }, n.dropout, r, 4)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = Hg(function () {
          return kn(a)
        }, n.recurrentDropout, r, 4));
        var o, s, u, l, c = n.dropoutMask,
          p = n.recurrentDropoutMask;
        0 < n.dropout && n.dropout < 1 && (t = Ns(t, c[0]));
        var h = Ph(t, n.kernel.read());
        0 < n.recurrentDropout && n.recurrentDropout < 1 && (a = Ns(a, p[0])), h = ls(h, Ph(a, n.recurrentKernel.read())), n.useBias && (h = jh(h, n.bias.read()));
        var f = On(h, 4, h.rank - 1),
          d = f[0],
          m = f[1],
          g = f[2],
          v = f[3];
        o = n.recurrentActivation.apply(d), s = n.recurrentActivation.apply(m), u = ls(Ns(s, i), Ns(o, n.activation.apply(g))), l = n.recurrentActivation.apply(v);
        var y = Ns(l, n.activation.apply(u));
        return [y, y, u]
      })
    }, e.prototype.getConfig = function () {
      var e = {
          units: this.units,
          activation: fm(this.activation),
          recurrentActivation: fm(this.recurrentActivation),
          useBias: this.useBias,
          kernelInitializer: ff(this.kernelInitializer),
          recurrentInitializer: ff(this.recurrentInitializer),
          biasInitializer: ff(this.biasInitializer),
          unitForgetBias: this.unitForgetBias,
          kernelRegularizer: xm(this.kernelRegularizer),
          recurrentRegularizer: xm(this.recurrentRegularizer),
          biasRegularizer: xm(this.biasRegularizer),
          activityRegularizer: xm(this.activityRegularizer),
          kernelConstraint: ih(this.kernelConstraint),
          recurrentConstraint: ih(this.recurrentConstraint),
          biasConstraint: ih(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout,
          implementation: this.implementation
        },
        n = t.prototype.getConfig.call(this);
      return Object.assign(e, n), e
    }, e.className = "LSTMCell", e
  }(Bg);
  rp.registerClass(jg);
  var Gg = function (t) {
    function e(e) {
      return 0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new jg(e), t.call(this, e) || this
    }
    return Sp(e, t), e.prototype.call = function (e, n) {
      var r = this;
      return We(function () {
        null != r.cell.dropoutMask && (Ve(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Ve(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
        var a = null == n ? null : n.mask,
          i = null == n ? null : n.training,
          o = null == n ? null : n.initialState;
        return t.prototype.call.call(r, e, {
          mask: a,
          training: i,
          initialState: o
        })
      })
    }, Object.defineProperty(e.prototype, "units", {
      get: function () {
        return this.cell.units
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "activation", {
      get: function () {
        return this.cell.activation
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentActivation", {
      get: function () {
        return this.cell.recurrentActivation
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "useBias", {
      get: function () {
        return this.cell.useBias
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelInitializer", {
      get: function () {
        return this.cell.kernelInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentInitializer", {
      get: function () {
        return this.cell.recurrentInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasInitializer", {
      get: function () {
        return this.cell.biasInitializer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "unitForgetBias", {
      get: function () {
        return this.cell.unitForgetBias
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelRegularizer", {
      get: function () {
        return this.cell.kernelRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentRegularizer", {
      get: function () {
        return this.cell.recurrentRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasRegularizer", {
      get: function () {
        return this.cell.biasRegularizer
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "kernelConstraint", {
      get: function () {
        return this.cell.kernelConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentConstraint", {
      get: function () {
        return this.cell.recurrentConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "biasConstraint", {
      get: function () {
        return this.cell.biasConstraint
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "dropout", {
      get: function () {
        return this.cell.dropout
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "recurrentDropout", {
      get: function () {
        return this.cell.recurrentDropout
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "implementation", {
      get: function () {
        return this.cell.implementation
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.getConfig = function () {
      var e = {
          units: this.units,
          activation: fm(this.activation),
          recurrentActivation: fm(this.recurrentActivation),
          useBias: this.useBias,
          kernelInitializer: ff(this.kernelInitializer),
          recurrentInitializer: ff(this.recurrentInitializer),
          biasInitializer: ff(this.biasInitializer),
          unitForgetBias: this.unitForgetBias,
          kernelRegularizer: xm(this.kernelRegularizer),
          recurrentRegularizer: xm(this.recurrentRegularizer),
          biasRegularizer: xm(this.biasRegularizer),
          activityRegularizer: xm(this.activityRegularizer),
          kernelConstraint: ih(this.kernelConstraint),
          recurrentConstraint: ih(this.recurrentConstraint),
          biasConstraint: ih(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout,
          implementation: this.implementation
        },
        n = t.prototype.getConfig.call(this);
      return delete n.cell, Object.assign(e, n), e
    }, e.fromConfig = function (t, e) {
      return 0 === e.implmentation && (e.implementation = 1), new t(e)
    }, e.className = "LSTM", e
  }(Lg);
  rp.registerClass(Gg);
  var qg = function (t) {
    function e(e) {
      var n = t.call(this, e) || this;
      return n.cells = e.cells, n
    }
    return Sp(e, t), Object.defineProperty(e.prototype, "stateSize", {
      get: function () {
        for (var t = [], e = 0, n = this.cells.slice().reverse(); e < n.length; e++) {
          var r = n[e];
          Array.isArray(r.stateSize) ? t.push.apply(t, r.stateSize) : t.push(r.stateSize)
        }
        return t
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.call = function (t, e) {
      var n = this;
      return We(function () {
        for (var r = (t = t).slice(1), a = [], i = 0, o = n.cells.slice().reverse(); i < o.length; i++) {
          var s = o[i];
          Array.isArray(s.stateSize) ? a.push(r.splice(0, s.stateSize.length)) : a.push(r.splice(0, 1))
        }
        a.reverse();
        for (var u, l = [], c = 0; c < n.cells.length; ++c) s = n.cells[c], r = a[c], u = 0 === c ? [t[0]].concat(r) : [u[0]].concat(r), u = s.call(u, e), l.push(u.slice(1));
        r = [];
        for (var p = 0, h = l.slice().reverse(); p < h.length; p++) {
          var f = h[p];
          r.push.apply(r, f)
        }
        return [u[0]].concat(r)
      })
    }, e.prototype.build = function (t) {
      var e;
      xf(t) && (t = t[0]), t = t, this.cells.forEach(function (n, r) {
        bh("RNNCell_" + r, function () {
          n.build(t), e = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, t = [t[0], e]
        })
      }), this.built = !0
    }, e.prototype.getConfig = function () {
      for (var e = [], n = 0, r = this.cells; n < r.length; n++) {
        var a = r[n];
        e.push({
          className: a.getClassName(),
          config: a.getConfig()
        })
      }
      var i = {
          cells: e
        },
        o = t.prototype.getConfig.call(this);
      return Object.assign(i, o), i
    }, e.fromConfig = function (t, e, n) {
      void 0 === n && (n = {});
      for (var r = [], a = 0, i = e.cells; a < i.length; a++) {
        var o = i[a];
        r.push($f(o, n))
      }
      return new t({
        cells: r
      })
    }, Object.defineProperty(e.prototype, "trainableWeights", {
      get: function () {
        if (!this.trainable) return [];
        for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
          var r = n[e];
          t.push.apply(t, r.trainableWeights)
        }
        return t
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
      get: function () {
        for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
          var r = n[e];
          t.push.apply(t, r.nonTrainableWeights)
        }
        if (!this.trainable) {
          for (var a = [], i = 0, o = this.cells; i < o.length; i++) r = o[i], a.push.apply(a, r.trainableWeights);
          return a.concat(t)
        }
        return t
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.getWeights = function () {
      for (var t = [], e = 0, n = this.cells; e < n.length; e++) {
        var r = n[e];
        t.push.apply(t, r.weights)
      }
      return Ef(t)
    }, e.prototype.setWeights = function (t) {
      for (var e = [], n = 0, r = this.cells; n < r.length; n++)
        for (var a = r[n], i = a.weights.length, o = t.splice(i), s = 0; s < a.weights.length; ++s) e.push([a.weights[s], o[s]]);
      Af(e)
    }, e.className = "StackedRNNCells", e
  }(Bg);

  function Hg(t, e, n, r) {
    function a() {
      return Gh(t(), e)
    }
    if (void 0 === n && (n = null), void 0 === r && (r = 1), r > 1) {
      for (var i = [], o = 0; o < r; o++) i.push(qh(a, t, n));
      return i.map(function (t) {
        return Ue(t.clone())
      })
    }
    return Ue(qh(a, t, n).clone())
  }
  rp.registerClass(qg);
  var Kg = function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return n.layer = e.layer, n
      }
      return Sp(e, t), e.prototype.build = function (t) {
        this.built = !0
      }, Object.defineProperty(e.prototype, "trainable", {
        get: function () {
          return null != this.layer && this.layer.trainable
        },
        set: function (t) {
          null != this.layer && (this.layer.trainable = t)
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "trainableWeights", {
        get: function () {
          return this.layer.trainableWeights
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
        get: function () {
          return this.layer.nonTrainableWeights
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "updates", {
        get: function () {
          return this.layer._updates
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "losses", {
        get: function () {
          return this.layer.losses
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.getWeights = function () {
        return this.layer.getWeights()
      }, e.prototype.setWeights = function (t) {
        this.layer.setWeights(t)
      }, e.prototype.getConfig = function () {
        var e = {
            layer: {
              className: this.layer.getClassName(),
              config: this.layer.getConfig()
            }
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e.prototype.setFastWeightInitDuringBuild = function (e) {
        t.prototype.setFastWeightInitDuringBuild.call(this, e), null != this.layer && this.layer.setFastWeightInitDuringBuild(e)
      }, e.fromConfig = function (t, e, n) {
        void 0 === n && (n = {});
        var r = $f(e.layer, n);
        delete e.layer;
        var a = {
          layer: r
        };
        return Object.assign(a, e), new t(a)
      }, e
    }(Ff),
    Xg = function (t) {
      function e(e) {
        var n = t.call(this, e) || this;
        return n.supportsMasking = !0, n
      }
      return Sp(e, t), e.prototype.build = function (e) {
        if ((e = Nf(e)).length < 3) throw new Op("TimeDistributed layer expects an input shape >= 3D, but received input shape " + JSON.stringify(e));
        this.inputSpec = [{
          shape: e
        }];
        var n = [e[0]].concat(e.slice(2));
        this.layer.built || (this.layer.build(n), this.layer.built = !0), t.prototype.build.call(this, e)
      }, e.prototype.computeOutputShape = function (t) {
        var e = [(t = Nf(t))[0]].concat(t.slice(2)),
          n = this.layer.computeOutputShape(e),
          r = t[1];
        return [n[0], r].concat(n.slice(1))
      }, e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          return zg(function (t, r) {
            return [Cf(n.layer.call(t, e)), []]
          }, t = Cf(t), [], !1, null, null, !1, !0)[1]
        })
      }, e.className = "TimeDistributed", e
    }(Kg);
  rp.registerClass(Xg);
  var $g = "concat",
    Yg = function (t) {
      function e(e) {
        var n = t.call(this, e) || this,
          r = e.layer.getConfig(),
          a = {};
        a.className = e.layer.getClassName(), a.config = r, n.forwardLayer = $f(a), r.goBackwards = !0 !== r.goBackwards;
        var i = {};
        if (i.className = e.layer.getClassName(), i.config = r, n.backwardLayer = $f(i), n.forwardLayer.name = "forward_" + n.forwardLayer.name, n.backwardLayer.name = "backward_" + n.backwardLayer.name, n.mergeMode = void 0 === e.mergeMode ? $g : e.mergeMode, function (t) {
            Xp(hh, "BidirectionalMergeMode", t)
          }(n.mergeMode), e.weights) throw new _p("weights support is not implemented for Bidirectional layer yet.");
        return n._stateful = e.layer.stateful, n.returnSequences = e.layer.returnSequences, n.returnState = e.layer.returnState, n.supportsMasking = !0, n._trainable = !0, n.inputSpec = e.layer.inputSpec, n.numConstants = null, n
      }
      return Sp(e, t), Object.defineProperty(e.prototype, "trainable", {
        get: function () {
          return this._trainable
        },
        set: function (t) {
          this._trainable = t, null != this.forwardLayer && (this.forwardLayer.trainable = t), null != this.backwardLayer && (this.backwardLayer.trainable = t)
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.getWeights = function () {
        return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())
      }, e.prototype.setWeights = function (t) {
        var e = t.length,
          n = Math.floor(e / 2);
        this.forwardLayer.setWeights(t.slice(0, n)), this.backwardLayer.setWeights(t.slice(n))
      }, e.prototype.computeOutputShape = function (t) {
        var e, n, r, a = this.forwardLayer.computeOutputShape(t);
        return Array.isArray(a) && Array.isArray(a[0]) || (a = [a]), a = a, this.returnState ? (r = a.slice(1), e = a[0]) : e = a[0], e = e, "concat" === this.mergeMode ? (e[e.length - 1] *= 2, n = [e]) : n = null == this.mergeMode ? [e, e.slice()] : [e], this.returnState ? null == this.mergeMode ? n.concat(r).concat(r.slice()) : [e].concat(r).concat(r.slice()) : Bp(n)
      }, e.prototype.apply = function (e, n) {
        var r = null == n ? null : n.initialState,
          a = null == n ? null : n.constants;
        null == n && (n = {});
        var i = Mg(e, r, a, this.numConstants);
        if (e = i.inputs, r = i.initialState, a = i.constants, Array.isArray(e) && (r = e.slice(1), e = e[0]), (null == r || 0 === r.length) && null == a) return t.prototype.apply.call(this, e, n);
        var o = [],
          s = [];
        if (null != r) {
          var u = r.length;
          if (u % 2 > 0) throw new Op("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
          n.initialState = r, o.push.apply(o, r);
          var l = r.map(function (t) {
            return new Rf({
              shape: t.shape
            })
          });
          this.forwardLayer.stateSpec = l.slice(0, u / 2), this.backwardLayer.stateSpec = l.slice(u / 2), s.push.apply(s, l)
        }
        if (null != a) throw new _p("Support for constants in Bidirectional layers is not implemented yet.");
        for (var c = o[0] instanceof Tf, p = 0, h = o; p < h.length; p++)
          if (h[p] instanceof Tf !== c) throw new Op("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
        if (c) {
          var f = [e].concat(o),
            d = this.inputSpec.concat(s),
            m = this.inputSpec;
          this.inputSpec = d;
          var g = t.prototype.apply.call(this, f, n);
          return this.inputSpec = m, g
        }
        return t.prototype.apply.call(this, e, n)
      }, e.prototype.call = function (t, e) {
        var n = this;
        return We(function () {
          var r, a, i, o, s = e.initialState;
          if (null == s) r = n.forwardLayer.call(t, e), a = n.backwardLayer.call(t, e);
          else {
            var u = s.slice(0, s.length / 2),
              l = s.slice(s.length / 2);
            r = n.forwardLayer.call(t, Object.assign(e, {
              initialState: u
            })), a = n.backwardLayer.call(t, Object.assign(e, {
              initialState: l
            }))
          }
          return n.returnState && (Array.isArray(r) && (i = r.slice(1).concat(a.slice(1))), r = r[0], a = a[0]), n.returnSequences && (a = pu(a, 1)), "concat" === n.mergeMode ? o = Mh([r, a]) : "sum" === n.mergeMode ? o = ls(r, a) : "ave" === n.mergeMode ? o = Ns(.5, ls(r, a)) : "mul" === n.mergeMode ? o = Ns(r, a) : null == n.mergeMode && (o = [r, a]), n.returnState ? null == n.mergeMode ? o.concat(i) : [o].concat(i) : o
        })
      }, e.prototype.resetStates = function (t) {
        this.forwardLayer.resetStates(), this.backwardLayer.resetStates()
      }, e.prototype.build = function (t) {
        var e = this;
        bh(this.forwardLayer.name, function () {
          e.forwardLayer.build(t)
        }), bh(this.backwardLayer.name, function () {
          e.backwardLayer.build(t)
        }), this.built = !0
      }, e.prototype.computeMask = function (t, e) {
        var n;
        if (Array.isArray(e) && (e = e[0]), n = this.returnSequences ? null == this.mergeMode ? [e, e] : e : null == this.mergeMode ? [null, null] : null, this.returnState) {
          var r = this.forwardLayer.states.map(function (t) {
            return null
          });
          return Array.isArray(n) ? n.concat(r).concat(r) : [n].concat(r).concat(r)
        }
        return n
      }, Object.defineProperty(e.prototype, "trainableWeights", {
        get: function () {
          return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(e.prototype, "nonTrainableWeights", {
        get: function () {
          return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.setFastWeightInitDuringBuild = function (e) {
        t.prototype.setFastWeightInitDuringBuild.call(this, e), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(e), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(e)
      }, e.prototype.getConfig = function () {
        var e = {
            mergeMode: this.mergeMode
          },
          n = t.prototype.getConfig.call(this);
        return Object.assign(e, n), e
      }, e.fromConfig = function (t, e) {
        var n = $f(e.layer);
        if (delete e.layer, null != e.numConstants) throw new _p("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
        var r = e;
        return r.layer = n, new t(r)
      }, e.className = "Bidirectional", e
    }(Kg);

  function Jg(t) {
    return new Cg(t)
  }

  function Zg(t) {
    return new kg(t)
  }

  function Qg(t) {
    return new Ag(t)
  }

  function tv(t) {
    return new Dg(t)
  }

  function ev(t) {
    return new Fg(t)
  }

  function nv(t) {
    return new wg(t)
  }

  function rv(t) {
    return new Sg(t)
  }
  rp.registerClass(Yg);
  var av = tv,
    iv = ev,
    ov = nv,
    sv = rv;
  var uv = Object.freeze({
    inputLayer: function (t) {
      return new zf(t)
    },
    elu: function (t) {
      return new Im(t)
    },
    reLU: function (t) {
      return new Nm(t)
    },
    leakyReLU: function (t) {
      return new Sm(t)
    },
    prelu: function (t) {
      return new km(t)
    },
    softmax: function (t) {
      return new Am(t)
    },
    thresholdedReLU: function (t) {
      return new Em(t)
    },
    conv1d: function (t) {
      return new Vm(t)
    },
    conv2d: function (t) {
      return new Lm(t)
    },
    conv2dTranspose: function (t) {
      return new Pm(t)
    },
    conv3d: function (t) {
      return new Bm(t)
    },
    separableConv2d: function (t) {
      return new Wm(t)
    },
    cropping2D: function (t) {
      return new Um(t)
    },
    upSampling2d: function (t) {
      return new jm(t)
    },
    depthwiseConv2d: function (t) {
      return new Gm(t)
    },
    activation: function (t) {
      return new $m(t)
    },
    dense: function (t) {
      return new Km(t)
    },
    dropout: function (t) {
      return new qm(t)
    },
    spatialDropout1d: function (t) {
      return new Hm(t)
    },
    flatten: function (t) {
      return new Xm(t)
    },
    repeatVector: function (t) {
      return new Ym(t)
    },
    reshape: function (t) {
      return new Jm(t)
    },
    permute: function (t) {
      return new Zm(t)
    },
    embedding: function (t) {
      return new tg(t)
    },
    add: function (t) {
      return new ng(t)
    },
    average: function (t) {
      return new ag(t)
    },
    concatenate: function (t) {
      return new sg(t)
    },
    maximum: function (t) {
      return new ig(t)
    },
    minimum: function (t) {
      return new og(t)
    },
    multiply: function (t) {
      return new rg(t)
    },
    dot: function (t) {
      return new lg(t)
    },
    batchNormalization: function (t) {
      return new mg(t)
    },
    layerNormalization: function (t) {
      return new gg(t)
    },
    zeroPadding2d: function (t) {
      return new vg(t)
    },
    averagePooling1d: Jg,
    avgPool1d: function (t) {
      return Jg(t)
    },
    avgPooling1d: function (t) {
      return Jg(t)
    },
    averagePooling2d: Zg,
    avgPool2d: function (t) {
      return Zg(t)
    },
    avgPooling2d: function (t) {
      return Zg(t)
    },
    averagePooling3d: Qg,
    avgPool3d: function (t) {
      return Qg(t)
    },
    avgPooling3d: function (t) {
      return Qg(t)
    },
    globalAveragePooling1d: function (t) {
      return new Tg(t)
    },
    globalAveragePooling2d: function (t) {
      return new _g(t)
    },
    globalMaxPooling1d: tv,
    globalMaxPooling2d: ev,
    maxPooling1d: nv,
    maxPooling2d: rv,
    maxPooling3d: function (t) {
      return new Eg(t)
    },
    gru: function (t) {
      return new Ug(t)
    },
    gruCell: function (t) {
      return new Vg(t)
    },
    lstm: function (t) {
      return new Gg(t)
    },
    lstmCell: function (t) {
      return new jg(t)
    },
    simpleRNN: function (t) {
      return new Wg(t)
    },
    simpleRNNCell: function (t) {
      return new Pg(t)
    },
    rnn: function (t) {
      return new Lg(t)
    },
    stackedRNNCells: function (t) {
      return new qg(t)
    },
    bidirectional: function (t) {
      return new Yg(t)
    },
    timeDistributed: function (t) {
      return new Xg(t)
    },
    globalMaxPool1d: av,
    globalMaxPool2d: iv,
    maxPool1d: ov,
    maxPool2d: sv,
    Layer: Ff,
    RNN: Lg,
    RNNCell: Bg,
    input: Qd,
    gaussianNoise: function (t) {
      return new cg(t)
    },
    gaussianDropout: function (t) {
      return new pg(t)
    },
    alphaDropout: function (t) {
      return new hg(t)
    },
    masking: function (t) {
      return new Qm(t)
    }
  });
  var lv = Object.freeze({
      binaryAccuracy: function (t, e) {
        return od(t, e)
      },
      binaryCrossentropy: function (t, e) {
        return pd(t, e)
      },
      sparseCategoricalAccuracy: function (t, e) {
        return hd(t, e)
      },
      categoricalAccuracy: function (t, e) {
        return sd(t, e)
      },
      categoricalCrossentropy: function (t, e) {
        return fd(t, e)
      },
      precision: function (t, e) {
        return ld(t, e)
      },
      recall: function (t, e) {
        return cd(t, e)
      },
      cosineProximity: function (t, e) {
        return rd(t, e)
      },
      meanAbsoluteError: function (t, e) {
        return Zf(t, e)
      },
      meanAbsolutePercentageError: function (t, e) {
        return Qf(t, e)
      },
      MAPE: function (t, e) {
        return Qf(t, e)
      },
      mape: function (t, e) {
        return Qf(t, e)
      },
      meanSquaredError: function (t, e) {
        return Jf(t, e)
      },
      MSE: function (t, e) {
        return Jf(t, e)
      },
      mse: function (t, e) {
        return Jf(t, e)
      }
    }),
    cv = Object.freeze({
      modelFromJSON: function (t, e) {
        return Ep(this, void 0, void 0, function () {
          var n, r, a, i, o, s, u, l;
          return Ap(this, function (c) {
            switch (c.label) {
              case 0:
                return "modelTopology" in t || (t = {
                  modelTopology: t
                }), null != (n = (t = t).modelTopology).model_config && (n = n.model_config), r = Sd(n), a = $f(r, e), null == t.weightsManifest ? [3, 2] : [4, $c.loadWeights(t.weightsManifest, t.pathPrefix, a.weights.map(function (t) {
                  return t.originalName
                }))];
              case 1:
                for (i = c.sent(), o = {}, s = 0, u = a.weights; s < u.length; s++) l = u[s], o[l.originalName] = i[l.originalName];
                a.loadWeights(o), Ve(i), c.label = 2;
              case 2:
                return [2, a]
            }
          })
        })
      }
    });
  var pv = Object.freeze({
      l1l2: function (t) {
        return new ym(t)
      },
      l1: function (t) {
        return function (t) {
          return gm(t), new ym({
            l1: null != t ? t.l1 : null,
            l2: 0
          })
        }(t)
      },
      l2: function (t) {
        return function (t) {
          return gm(t), new ym({
            l2: null != t ? t.l2 : null,
            l1: 0
          })
        }(t)
      }
    }),
    hv = function (t) {
      function e() {
        var e = null !== t && t.apply(this, arguments) || this;
        return e.model = null, e
      }
      return Sp(e, t), e.prototype.setModel = function (t) {
        if (!(t instanceof Yd)) throw new Error("model must be a LayersModel, not some other Container");
        this.model = t
      }, e
    }(Vf);

  function fv(t, e) {
    return t < e
  }

  function dv(t, e) {
    return t > e
  }
  var mv = function (t) {
    function e(e) {
      var n = t.call(this) || this;
      if (null == e && (e = {}), e.restoreBestWeights) throw new _p("restoreBestWeights = True is not implemented in EarlyStopping yet.");
      return n.monitor = e.monitor || "val_loss", n.minDelta = Math.abs(e.minDelta || 0), n.patience = e.patience || 0, n.verbose = e.verbose || 0, n.mode = e.mode || "auto", n.baseline = e.baseline, -1 === ["auto", "min", "max"].indexOf(n.mode) && (console.warn("EarlyStopping mode '" + n.mode + "' is invalid. Falling back to mode 'auto'."), n.mode = "auto"), "min" === n.mode ? n.monitorFunc = fv : "max" === n.mode ? n.monitorFunc = dv : -1 !== n.monitor.indexOf("acc") ? n.monitorFunc = dv : n.monitorFunc = fv, n.monitorFunc === fv && (n.minDelta *= -1), n
    }
    return Sp(e, t), e.prototype.onTrainBegin = function (t) {
      return Ep(this, void 0, void 0, function () {
        return Ap(this, function (t) {
          return this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === fv ? 1 / 0 : -1 / 0, [2]
        })
      })
    }, e.prototype.onEpochEnd = function (t, e) {
      return Ep(this, void 0, void 0, function () {
        var n;
        return Ap(this, function (r) {
          switch (r.label) {
            case 0:
              return [4, Bf(e)];
            case 1:
              return r.sent(), null == (n = this.getMonitorValue(e)) ? [2] : (this.monitorFunc(n - this.minDelta, this.best) ? (this.best = n, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = t, this.model.stopTraining = !0)), [2])
          }
        })
      })
    }, e.prototype.onTrainEnd = function (t) {
      return Ep(this, void 0, void 0, function () {
        return Ap(this, function (t) {
          return this.stoppedEpoch > 0 && this.verbose && console.log("Epoch " + this.stoppedEpoch + ": early stopping."), [2]
        })
      })
    }, e.prototype.getMonitorValue = function (t) {
      null == t && (t = {});
      var e = t[this.monitor];
      return null == e && console.warn("Metric for EarlyStopping " + this.monitor + " is not available. Available metrics are: " + Object.keys(t)), e
    }, e
  }(hv);
  var gv, vv, yv = {
      earlyStopping: function (t) {
        return new mv(t)
      }
    },
    bv = function () {
      return (bv = Object.assign || function (t) {
        for (var e, n = 1, r = arguments.length; n < r; n++)
          for (var a in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a]);
        return t
      }).apply(this, arguments)
    };

  function xv(t, e, n, r) {
    return new(n || (n = Promise))(function (a, i) {
      function o(t) {
        try {
          u(r.next(t))
        } catch (t) {
          i(t)
        }
      }

      function s(t) {
        try {
          u(r.throw(t))
        } catch (t) {
          i(t)
        }
      }

      function u(t) {
        t.done ? a(t.value) : new n(function (e) {
          e(t.value)
        }).then(o, s)
      }
      u((r = r.apply(t, e || [])).next())
    })
  }

  function wv(t, e) {
    var n, r, a, i, o = {
      label: 0,
      sent: function () {
        if (1 & a[0]) throw a[1];
        return a[1]
      },
      trys: [],
      ops: []
    };
    return i = {
      next: s(0),
      throw: s(1),
      return: s(2)
    }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
      return this
    }), i;

    function s(i) {
      return function (s) {
        return function (i) {
          if (n) throw new TypeError("Generator is already executing.");
          for (; o;) try {
            if (n = 1, r && (a = 2 & i[0] ? r.return : i[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, i[1])).done) return a;
            switch (r = 0, a && (i = [2 & i[0], a.value]), i[0]) {
              case 0:
              case 1:
                a = i;
                break;
              case 4:
                return o.label++, {
                  value: i[1],
                  done: !1
                };
              case 5:
                o.label++, r = i[1], i = [0];
                continue;
              case 7:
                i = o.ops.pop(), o.trys.pop();
                continue;
              default:
                if (!(a = (a = o.trys).length > 0 && a[a.length - 1]) && (6 === i[0] || 2 === i[0])) {
                  o = 0;
                  continue
                }
                if (3 === i[0] && (!a || i[1] > a[0] && i[1] < a[3])) {
                  o.label = i[1];
                  break
                }
                if (6 === i[0] && o.label < a[1]) {
                  o.label = a[1], a = i;
                  break
                }
                if (a && o.label < a[2]) {
                  o.label = a[2], o.ops.push(i);
                  break
                }
                a[2] && o.ops.pop(), o.trys.pop();
                continue
            }
            i = e.call(t, o)
          } catch (t) {
            i = [6, t], r = 0
          } finally {
            n = a = 0
          }
          if (5 & i[0]) throw i[1];
          return {
            value: i[0] ? i[1] : void 0,
            done: !0
          }
        }([i, s])
      }
    }
  }! function (t) {
    t[t.DT_INVALID = 0] = "DT_INVALID", t[t.DT_FLOAT = 1] = "DT_FLOAT", t[t.DT_DOUBLE = 2] = "DT_DOUBLE", t[t.DT_INT32 = 3] = "DT_INT32", t[t.DT_UINT8 = 4] = "DT_UINT8", t[t.DT_INT16 = 5] = "DT_INT16", t[t.DT_INT8 = 6] = "DT_INT8", t[t.DT_STRING = 7] = "DT_STRING", t[t.DT_COMPLEX64 = 8] = "DT_COMPLEX64", t[t.DT_INT64 = 9] = "DT_INT64", t[t.DT_BOOL = 10] = "DT_BOOL", t[t.DT_QINT8 = 11] = "DT_QINT8", t[t.DT_QUINT8 = 12] = "DT_QUINT8", t[t.DT_QINT32 = 13] = "DT_QINT32", t[t.DT_BFLOAT16 = 14] = "DT_BFLOAT16", t[t.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", t[t.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", t[t.DT_INT32_REF = 103] = "DT_INT32_REF", t[t.DT_UINT8_REF = 104] = "DT_UINT8_REF", t[t.DT_INT16_REF = 105] = "DT_INT16_REF", t[t.DT_INT8_REF = 106] = "DT_INT8_REF", t[t.DT_STRING_REF = 107] = "DT_STRING_REF", t[t.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", t[t.DT_INT64_REF = 109] = "DT_INT64_REF", t[t.DT_BOOL_REF = 110] = "DT_BOOL_REF", t[t.DT_QINT8_REF = 111] = "DT_QINT8_REF", t[t.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", t[t.DT_QINT32_REF = 113] = "DT_QINT32_REF", t[t.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF"
  }(gv || (gv = {})),
  function (t) {
    ! function (t) {
      t[t.LEGACY = 0] = "LEGACY", t[t.V1 = 1] = "V1", t[t.V2 = 2] = "V2"
    }(t.CheckpointFormatVersion || (t.CheckpointFormatVersion = {}))
  }(vv || (vv = {}));
  var Cv = {};

  function Nv(t) {
    return Cv[t]
  }

  function Sv(t, e, n, r) {
    var a = e.inputParams[t];
    if (a && void 0 !== a.inputIndexStart) {
      var i = a.inputIndexStart,
        o = 0 === a.inputIndexEnd ? void 0 : void 0 === a.inputIndexEnd ? i + 1 : a.inputIndexEnd;
      if ("tensor" === a.type) return kv(e.inputNames[a.inputIndexStart], n, r);
      if ("tensors" === a.type) return e.inputNames.slice(i, o).map(function (t) {
        return kv(t, n, r)
      });
      var s = Array.prototype.slice.call(kv(e.inputNames.slice(i)[0], n, r).dataSync());
      return "number" === a.type ? s[0] : s
    }
    var u = e.attrParams[t];
    return u && u.value
  }

  function kv(t, e, n) {
    var r = Av(t),
      a = r[0],
      i = r[1],
      o = n.currentContextIds.find(function (t) {
        return !!e[Ev(a, t)]
      });
    return void 0 !== o ? e[Ev(a, o)][i] : void 0
  }

  function Iv(t, e) {
    var n = Av(t),
      r = n[0],
      a = n[1];
    return [Ev(r, e && e.currentContextId), a]
  }

  function Ev(t, e) {
    return e ? t + "-" + e : t
  }

  function Av(t) {
    var e = t.lastIndexOf(":");
    return -1 === e ? [t, 0] : [t.substring(0, e), Number(t.substring(e + 1))]
  }

  function Rv(t, e) {
    for (var n = [], r = 0; r < t.length; r += e) n.push(t.slice(r, r + e));
    return n
  }
  var Tv = Object.freeze({
      json: [{
        tfOpName: "Add",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "AddV2",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "AddN",
        category: "arithmetic",
        inputs: [{
          start: 0,
          end: 0,
          name: "tensors",
          type: "tensors"
        }]
      }, {
        tfOpName: "BiasAdd",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Sub",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "RealDiv",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Div",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "DivNoNan",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "FloorDiv",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Mul",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Maximum",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }]
      }, {
        tfOpName: "Minimum",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }]
      }, {
        tfOpName: "Pow",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "SquaredDifference",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Mod",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "FloorMod",
        category: "arithmetic",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }]
    }),
    Dv = Object.freeze({
      json: [{
        tfOpName: "Abs",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Acos",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Asin",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Atan",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Atan2",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "y",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Ceil",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "ClipByValue",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "clip_value_min",
          name: "clipValueMin",
          type: "number"
        }, {
          tfName: "clip_value_max",
          name: "clipValueMax",
          type: "number"
        }]
      }, {
        tfOpName: "Complex",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "real",
          type: "tensor"
        }, {
          start: 1,
          name: "imag",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "ComplexAbs",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Cos",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Cosh",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Elu",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Exp",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Floor",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Log",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Imag",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "Tout",
          name: "outputType",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Neg",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Real",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "Tout",
          name: "outputType",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Prelu",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "alpha",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Relu",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Relu6",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "clipValueMin",
          name: "clipValueMin",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "clipValueMax",
          name: "clipValueMax",
          type: "number",
          defaultValue: 6
        }]
      }, {
        tfOpName: "Selu",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Sigmoid",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Sin",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Sinh",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Sqrt",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Rsqrt",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Square",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Tan",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Tanh",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Sign",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Round",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Expm1",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Log1p",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Reciprocal",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Softplus",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Asinh",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Acosh",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Atanh",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Erf",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Prod",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axes",
          type: "number[]"
        }],
        attrs: [{
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool",
          notSupported: !0
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "LeakyRelu",
        category: "basic_math",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "alpha",
          name: "alpha",
          type: "number",
          defaultValue: .2
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }]
    }),
    Ov = Object.freeze({
      json: [{
        tfOpName: "LoopCond",
        category: "control",
        inputs: [{
          start: 0,
          name: "pred",
          type: "tensor"
        }]
      }, {
        tfOpName: "Switch",
        category: "control",
        inputs: [{
          start: 0,
          name: "data",
          type: "tensor"
        }, {
          start: 1,
          name: "pred",
          type: "tensor"
        }]
      }, {
        tfOpName: "Merge",
        category: "control",
        inputs: [{
          start: 0,
          end: 0,
          name: "tensors",
          type: "tensors"
        }]
      }, {
        tfOpName: "Enter",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensor",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "frame_name",
          name: "frameName",
          type: "string"
        }, {
          tfName: "is_constant",
          name: "isConstant",
          type: "bool"
        }]
      }, {
        tfOpName: "Exit",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensor",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "NextIteration",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensor",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "TensorArrayV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "size",
          type: "number"
        }],
        attrs: [{
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }, {
          tfName: "element_shape",
          name: "elementShape",
          type: "shape"
        }, {
          tfName: "dynamic_size",
          name: "dynamicSize",
          type: "bool"
        }, {
          tfName: "clear_after_read",
          name: "clearAfterRead",
          type: "bool"
        }, {
          tfName: "identical_element_shapes",
          name: "identicalElementShapes",
          type: "bool"
        }, {
          tfName: "tensor_array_name",
          name: "name",
          type: "string"
        }]
      }, {
        tfOpName: "TensorArrayWriteV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensorArrayId",
          type: "number"
        }, {
          start: 1,
          name: "index",
          type: "number"
        }, {
          start: 2,
          name: "tensor",
          type: "tensor"
        }, {
          start: 3,
          name: "flowIn",
          type: "number"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "TensorArrayReadV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensorArrayId",
          type: "number"
        }, {
          start: 1,
          name: "index",
          type: "number"
        }, {
          start: 2,
          name: "flowIn",
          type: "number"
        }],
        attrs: [{
          tfName: "dtype",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "TensorArrayGatherV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensorArrayId",
          type: "number"
        }, {
          start: 1,
          name: "indices",
          type: "number[]"
        }, {
          start: 2,
          name: "flowIn",
          type: "number"
        }],
        attrs: [{
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }, {
          tfName: "element_shape",
          name: "elementShape",
          type: "shape"
        }]
      }, {
        tfOpName: "TensorArrayScatterV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensorArrayId",
          type: "number"
        }, {
          start: 1,
          name: "indices",
          type: "number[]"
        }, {
          start: 2,
          name: "tensor",
          type: "tensor"
        }, {
          start: 3,
          name: "flowIn",
          type: "number"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "TensorArrayConcatV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensorArrayId",
          type: "number"
        }, {
          start: 1,
          name: "flowIn",
          type: "number"
        }],
        attrs: [{
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }, {
          tfName: "element_shape_except0",
          name: "elementShapeExcept0",
          type: "shape",
          notSupported: !0
        }]
      }, {
        tfOpName: "TensorArraySplitV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensorArrayId",
          type: "number"
        }, {
          start: 1,
          name: "tensor",
          type: "tensor"
        }, {
          start: 2,
          name: "lengths",
          type: "number[]"
        }, {
          start: 3,
          name: "flowIn",
          type: "number"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "TensorArraySizeV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensorArrayId",
          type: "number"
        }, {
          start: 1,
          name: "flowIn",
          type: "number"
        }]
      }, {
        tfOpName: "TensorArrayCloseV3",
        category: "control",
        inputs: [{
          start: 0,
          name: "tensorArrayId",
          type: "number"
        }]
      }]
    }),
    _v = Object.freeze({
      json: [{
        tfOpName: "AvgPool",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: !0
        }, {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "MaxPool",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: !0
        }, {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "AvgPool3D",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: !0
        }, {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "MaxPool3D",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: !0
        }, {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Conv1D",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "filter",
          type: "tensor"
        }],
        attrs: [{
          tfName: "stride",
          name: "stride",
          type: "number"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NWC"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "dilation",
          name: "dilation",
          type: "number",
          defaultValue: 1
        }]
      }, {
        tfOpName: "Conv2D",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "filter",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "useCudnnOnGpu",
          name: "useCudnnOnGpu",
          type: "bool"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        }, {
          tfName: "dilations",
          name: "dilations",
          type: "number[]"
        }]
      }, {
        tfOpName: "_FusedConv2D",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "filter",
          type: "tensor"
        }, {
          start: 2,
          end: 0,
          name: "args",
          type: "tensors"
        }],
        attrs: [{
          tfName: "num_args",
          name: "numArgs",
          type: "number"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "explicit_paddings",
          name: "explicitPaddings",
          type: "number[]",
          defaultValue: []
        }, {
          tfName: "use_cudnn_on_gpu",
          name: "useCudnnOnGpu",
          type: "bool",
          defaultValue: !0
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        }, {
          tfName: "dilations",
          name: "dilations",
          type: "number[]",
          defaultValue: [1, 1, 1, 1]
        }, {
          tfName: "fused_ops",
          name: "fusedOps",
          type: "string[]",
          defaultValue: []
        }, {
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: 1e-4
        }]
      }, {
        tfOpName: "Conv2DBackpropInput",
        category: "convolution",
        inputs: [{
          start: 2,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "filter",
          type: "tensor"
        }, {
          start: 0,
          name: "outputShape",
          type: "number[]"
        }],
        attrs: [{
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: !0
        }]
      }, {
        tfOpName: "DepthwiseConv2d",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "input",
          type: "tensor"
        }, {
          start: 1,
          name: "filter",
          type: "tensor"
        }],
        attrs: [{
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        }, {
          tfName: "dilations",
          name: "dilations",
          type: "number[]"
        }]
      }, {
        tfOpName: "DepthwiseConv2dNative",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "input",
          type: "tensor"
        }, {
          start: 1,
          name: "filter",
          type: "tensor"
        }],
        attrs: [{
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        }, {
          tfName: "dilations",
          name: "dilations",
          type: "number[]"
        }]
      }, {
        tfOpName: "FusedDepthwiseConv2dNative",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "filter",
          type: "tensor"
        }, {
          start: 2,
          end: 0,
          name: "args",
          type: "tensors"
        }],
        attrs: [{
          tfName: "num_args",
          name: "numArgs",
          type: "number"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        }, {
          tfName: "dilations",
          name: "dilations",
          type: "number[]",
          defaultValue: [1, 1, 1, 1]
        }, {
          tfName: "fused_ops",
          name: "fusedOps",
          type: "string[]",
          defaultValue: []
        }]
      }, {
        tfOpName: "Conv3D",
        category: "convolution",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "filter",
          type: "tensor"
        }],
        attrs: [{
          tfName: "strides",
          name: "strides",
          type: "number[]"
        }, {
          tfName: "padding",
          name: "pad",
          type: "string"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        }, {
          tfName: "dilations",
          name: "dilations",
          type: "number[]"
        }]
      }]
    }),
    Fv = Object.freeze({
      json: [{
        tfOpName: "Fill",
        category: "creation",
        inputs: [{
          start: 0,
          name: "shape",
          type: "number[]"
        }, {
          start: 1,
          name: "value",
          type: "number"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "LinSpace",
        category: "creation",
        inputs: [{
          start: 0,
          name: "start",
          type: "number"
        }, {
          start: 1,
          name: "stop",
          type: "number"
        }, {
          start: 2,
          name: "num",
          type: "number"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "OneHot",
        category: "creation",
        inputs: [{
          start: 0,
          name: "indices",
          type: "tensor"
        }, {
          start: 1,
          name: "depth",
          type: "number"
        }, {
          start: 2,
          name: "onValue",
          type: "number",
          defaultValue: 1
        }, {
          start: 3,
          name: "offValue",
          type: "number",
          defaultValue: 0
        }],
        attrs: [{
          tfName: "axis",
          name: "axis",
          type: "number",
          notSupported: !0
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Ones",
        category: "creation",
        inputs: [{
          start: 0,
          name: "shape",
          type: "number[]"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "OnesLike",
        category: "creation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "RandomUniform",
        category: "creation",
        inputs: [{
          start: 0,
          name: "shape",
          type: "number[]"
        }],
        attrs: [{
          tfName: "minval",
          name: "minval",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "maxval",
          name: "maxval",
          type: "number",
          defaultValue: 1
        }, {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }, {
          tfName: "seed",
          name: "seed",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "seed2",
          name: "seed2",
          type: "number",
          defaultValue: 0,
          notSupported: !0
        }, {
          tfName: "T",
          name: "T",
          type: "number",
          notSupported: !0
        }]
      }, {
        tfOpName: "Range",
        category: "creation",
        inputs: [{
          start: 0,
          name: "start",
          type: "number"
        }, {
          start: 1,
          name: "stop",
          type: "number"
        }, {
          start: 2,
          name: "step",
          type: "number",
          defaultValue: 0
        }],
        attrs: [{
          tfName: "Tidx",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "TruncatedNormal",
        category: "creation",
        inputs: [{
          start: 0,
          name: "shape",
          type: "number[]"
        }],
        attrs: [{
          tfName: "means",
          name: "mean",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "stddev",
          name: "stdDev",
          type: "number",
          defaultValue: 1
        }, {
          tfName: "seed",
          name: "seed",
          type: "number"
        }, {
          tfName: "seed2",
          name: "seed2",
          type: "number",
          defaultValue: 0,
          notSupported: !0
        }, {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }, {
          tfName: "T",
          name: "T",
          type: "number",
          notSupported: !0
        }]
      }, {
        tfOpName: "Zeros",
        category: "creation",
        inputs: [{
          start: 0,
          name: "shape",
          type: "number[]"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "ZerosLike",
        category: "creation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "Multinomial",
        category: "creation",
        inputs: [{
          start: 0,
          name: "logits",
          type: "tensor"
        }, {
          start: 1,
          name: "numSamples",
          type: "number"
        }],
        attrs: [{
          tfName: "seed",
          name: "seed",
          type: "number"
        }, {
          tfName: "seed2",
          name: "seed2",
          type: "number"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }, {
          tfName: "output_dtype",
          name: "output_dtype",
          type: "dtype"
        }]
      }]
    }),
    Mv = Object.freeze({
      json: [{
        tfOpName: "NonMaxSuppressionV2",
        category: "dynamic",
        inputs: [{
          start: 0,
          name: "boxes",
          type: "tensor"
        }, {
          start: 1,
          name: "scores",
          type: "tensor"
        }, {
          start: 2,
          name: "maxOutputSize",
          type: "number"
        }, {
          start: 3,
          name: "iouThreshold",
          type: "number"
        }]
      }, {
        tfOpName: "NonMaxSuppressionV3",
        category: "dynamic",
        inputs: [{
          start: 0,
          name: "boxes",
          type: "tensor"
        }, {
          start: 1,
          name: "scores",
          type: "tensor"
        }, {
          start: 2,
          name: "maxOutputSize",
          type: "number"
        }, {
          start: 3,
          name: "iouThreshold",
          type: "number"
        }, {
          start: 4,
          name: "scoreThreshold",
          type: "number"
        }]
      }, {
        tfOpName: "Where",
        category: "dynamic",
        inputs: [{
          start: 0,
          name: "condition",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "ListDiff",
        category: "dynamic",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "y",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }]
    }),
    zv = Object.freeze({
      json: [{
        tfOpName: "TopKV2",
        category: "evaluation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "k",
          type: "number"
        }],
        attrs: [{
          tfName: "sorted",
          name: "sorted",
          type: "bool"
        }]
      }]
    }),
    Lv = Object.freeze({
      json: [{
        tfOpName: "PlaceholderWithDefault",
        category: "graph",
        inputs: [{
          start: 0,
          name: "default",
          type: "tensor"
        }],
        attrs: [{
          tfName: "shape",
          name: "shape",
          type: "shape"
        }, {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "Placeholder",
        category: "graph",
        attrs: [{
          tfName: "shape",
          name: "shape",
          type: "shape"
        }, {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "Const",
        category: "graph"
      }, {
        tfOpName: "Identity",
        category: "graph",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "IdentityN",
        category: "graph",
        inputs: [{
          start: 0,
          end: 0,
          name: "x",
          type: "tensors"
        }]
      }, {
        tfOpName: "Snapshot",
        category: "graph",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "Rank",
        category: "graph",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "Size",
        category: "graph",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "Shape",
        category: "graph",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "ShapeN",
        category: "graph",
        inputs: [{
          start: 0,
          end: 0,
          name: "x",
          type: "tensors"
        }]
      }, {
        tfOpName: "Print",
        category: "graph",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "data",
          type: "tensors"
        }],
        attrs: [{
          tfName: "message",
          name: "message",
          type: "string"
        }, {
          tfName: "first_n",
          name: "firstN",
          type: "number",
          notSupported: !0
        }, {
          tfName: "summarize",
          name: "summarize",
          type: "number",
          defaultValue: 3
        }]
      }, {
        tfOpName: "NoOp",
        category: "graph",
        inputs: []
      }, {
        tfOpName: "StopGradient",
        category: "graph",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "FakeQuantWithMinMaxVars",
        category: "graph",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "min",
          name: "min",
          type: "number"
        }, {
          tfName: "max",
          name: "max",
          type: "number"
        }]
      }]
    }),
    Bv = Object.freeze({
      json: [{
        tfOpName: "ResizeBilinear",
        category: "image",
        inputs: [{
          start: 0,
          name: "images",
          type: "tensor"
        }, {
          start: 1,
          name: "size",
          type: "number[]"
        }],
        attrs: [{
          tfName: "align_corners",
          name: "alignCorners",
          type: "bool"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "ResizeNearestNeighbor",
        category: "image",
        inputs: [{
          start: 0,
          name: "images",
          type: "tensor"
        }, {
          start: 1,
          name: "size",
          type: "number[]"
        }],
        attrs: [{
          tfName: "align_corners",
          name: "alignCorners",
          type: "bool"
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "CropAndResize",
        category: "image",
        inputs: [{
          start: 0,
          name: "image",
          type: "tensor"
        }, {
          start: 1,
          name: "boxes",
          type: "tensor"
        }, {
          start: 2,
          name: "boxInd",
          type: "tensor"
        }, {
          start: 3,
          name: "cropSize",
          type: "number[]"
        }],
        attrs: [{
          tfName: "method",
          name: "method",
          type: "string"
        }, {
          tfName: "extrapolation_value",
          name: "extrapolationValue",
          type: "number"
        }]
      }]
    }),
    Pv = Object.freeze({
      json: [{
        tfOpName: "Equal",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "NotEqual",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Greater",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "GreaterEqual",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Less",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "LessEqual",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "LogicalAnd",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "LogicalNot",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "LogicalOr",
        category: "logical",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Select",
        category: "logical",
        inputs: [{
          start: 0,
          name: "condition",
          type: "tensor"
        }, {
          start: 1,
          name: "a",
          type: "tensor"
        }, {
          start: 2,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }]
    }),
    Wv = Object.freeze({
      json: [{
        tfOpName: "_FusedMatMul",
        category: "matrices",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }, {
          start: 2,
          end: 0,
          name: "args",
          type: "tensors"
        }],
        attrs: [{
          tfName: "num_args",
          name: "numArgs",
          type: "number"
        }, {
          tfName: "fused_ops",
          name: "fusedOps",
          type: "string[]",
          defaultValue: []
        }, {
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: 1e-4
        }, {
          tfName: "transpose_a",
          name: "transposeA",
          type: "bool",
          defaultValue: !1
        }, {
          tfName: "transpose_b",
          name: "transposeB",
          type: "bool",
          defaultValue: !1
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "MatMul",
        category: "matrices",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "transpose_a",
          name: "transposeA",
          type: "bool",
          defaultValue: !1
        }, {
          tfName: "transpose_b",
          name: "transposeB",
          type: "bool",
          defaultValue: !1
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "BatchMatMul",
        category: "matrices",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "adj_x",
          name: "transposeA",
          type: "bool",
          defaultValue: !1
        }, {
          tfName: "adj_y",
          name: "transposeB",
          type: "bool",
          defaultValue: !1
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "BatchMatMulV2",
        category: "matrices",
        inputs: [{
          start: 0,
          name: "a",
          type: "tensor"
        }, {
          start: 1,
          name: "b",
          type: "tensor"
        }],
        attrs: [{
          tfName: "adj_x",
          name: "transposeA",
          type: "bool",
          defaultValue: !1
        }, {
          tfName: "adj_y",
          name: "transposeB",
          type: "bool",
          defaultValue: !1
        }, {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }, {
        tfOpName: "Transpose",
        category: "matrices",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "perm",
          type: "number[]"
        }],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: !0
        }]
      }]
    }),
    Vv = Object.freeze({
      json: [{
        tfOpName: "FusedBatchNorm",
        category: "normalization",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "scale",
          type: "tensor"
        }, {
          start: 2,
          name: "offset",
          type: "tensor"
        }, {
          start: 3,
          name: "mean",
          type: "tensor"
        }, {
          start: 4,
          name: "variance",
          type: "tensor"
        }],
        attrs: [{
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: .001
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: !0
        }]
      }, {
        tfOpName: "FusedBatchNormV2",
        category: "normalization",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "scale",
          type: "tensor"
        }, {
          start: 2,
          name: "offset",
          type: "tensor"
        }, {
          start: 3,
          name: "mean",
          type: "tensor"
        }, {
          start: 4,
          name: "variance",
          type: "tensor"
        }],
        attrs: [{
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: .001
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: !0
        }]
      }, {
        tfOpName: "FusedBatchNormV3",
        category: "normalization",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "scale",
          type: "tensor"
        }, {
          start: 2,
          name: "offset",
          type: "tensor"
        }, {
          start: 3,
          name: "mean",
          type: "tensor"
        }, {
          start: 4,
          name: "variance",
          type: "tensor"
        }],
        attrs: [{
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: .001
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: !0
        }]
      }, {
        tfOpName: "LRN",
        category: "normalization",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "depth_radius",
          name: "radius",
          type: "number",
          defaultValue: 5
        }, {
          tfName: "bias",
          name: "bias",
          type: "number",
          defaultValue: 1
        }, {
          tfName: "alpha",
          name: "alpha",
          type: "number",
          defaultValue: 1
        }, {
          tfName: "beta",
          name: "beta",
          type: "number",
          defaultValue: .5
        }]
      }, {
        tfOpName: "Softmax",
        category: "normalization",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "LogSoftmax",
        category: "normalization",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "SparseToDense",
        category: "normalization",
        inputs: [{
          start: 0,
          name: "sparseIndices",
          type: "tensor"
        }, {
          start: 1,
          name: "outputShape",
          type: "number[]"
        }, {
          start: 2,
          name: "sparseValues",
          type: "tensor"
        }, {
          start: 3,
          name: "defaultValue",
          type: "tensor"
        }],
        attrs: [{
          tfName: "validate_indices",
          name: "validateIndices",
          type: "bool",
          defaultValue: !0,
          notSupported: !0
        }]
      }]
    }),
    Uv = Object.freeze({
      json: [{
        tfOpName: "Max",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number[]"
        }],
        attrs: [{
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }]
      }, {
        tfOpName: "Mean",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number[]"
        }],
        attrs: [{
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }]
      }, {
        tfOpName: "Min",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number[]"
        }],
        attrs: [{
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }]
      }, {
        tfOpName: "Sum",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number[]"
        }],
        attrs: [{
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }]
      }, {
        tfOpName: "All",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number[]"
        }],
        attrs: [{
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }]
      }, {
        tfOpName: "Any",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number[]"
        }],
        attrs: [{
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }]
      }, {
        tfOpName: "ArgMax",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number"
        }]
      }, {
        tfOpName: "ArgMin",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number"
        }]
      }, {
        tfOpName: "Prod",
        category: "reduction",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number[]"
        }],
        attrs: [{
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }]
      }]
    }),
    jv = Object.freeze({
      json: [{
        tfOpName: "ConcatV2",
        category: "slice_join",
        inputs: [{
          start: 0,
          end: -1,
          name: "tensors",
          type: "tensors"
        }, {
          start: -1,
          name: "axis",
          type: "number"
        }],
        attrs: [{
          tfName: "N",
          name: "n",
          type: "number",
          defaultValue: 2
        }]
      }, {
        tfOpName: "Concat",
        category: "slice_join",
        inputs: [{
          start: 1,
          end: 0,
          name: "tensors",
          type: "tensors"
        }, {
          start: 0,
          name: "axis",
          type: "number"
        }],
        attrs: [{
          tfName: "N",
          name: "n",
          type: "number",
          defaultValue: 2
        }]
      }, {
        tfOpName: "GatherV2",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "indices",
          type: "tensor"
        }, {
          start: 2,
          name: "axis",
          type: "number",
          defaultValue: 0
        }]
      }, {
        tfOpName: "Gather",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "indices",
          type: "tensor"
        }],
        attrs: [{
          tfName: "axis",
          name: "axis",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "validate_indices",
          name: "validateIndices",
          type: "bool",
          notSupported: !0
        }]
      }, {
        tfOpName: "Reverse",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "dims",
          type: "bool",
          notSupported: !0
        }]
      }, {
        tfOpName: "ReverseV2",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number[]"
        }]
      }, {
        tfOpName: "Slice",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "begin",
          type: "number[]"
        }, {
          start: 2,
          name: "size",
          type: "number[]"
        }]
      }, {
        tfOpName: "StridedSlice",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "begin",
          type: "number[]"
        }, {
          start: 2,
          name: "end",
          type: "number[]"
        }, {
          start: 3,
          name: "strides",
          type: "number[]"
        }],
        attrs: [{
          tfName: "begin_mask",
          name: "beginMask",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "end_mask",
          name: "endMask",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "new_axis_mask",
          name: "newAxisMask",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "ellipsis_mask",
          name: "ellipsisMask",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "shrink_axis_mask",
          name: "shrinkAxisMask",
          type: "number",
          defaultValue: 0
        }]
      }, {
        tfOpName: "Pack",
        category: "slice_join",
        inputs: [{
          start: 0,
          end: 0,
          name: "tensors",
          type: "tensors"
        }],
        attrs: [{
          tfName: "axis",
          name: "axis",
          type: "number",
          defaultValue: 0
        }]
      }, {
        tfOpName: "Unpack",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "tensor",
          type: "tensor"
        }],
        attrs: [{
          tfName: "axis",
          name: "axis",
          type: "number",
          defaultValue: 0
        }, {
          tfName: "num",
          name: "num",
          type: "number",
          defaultValue: 0,
          notSupported: !0
        }]
      }, {
        tfOpName: "Tile",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "reps",
          type: "number[]"
        }]
      }, {
        tfOpName: "Split",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "axis",
          type: "number",
          defaultValue: 0
        }, {
          start: 1,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "num_split",
          name: "numOrSizeSplits",
          type: "number",
          defaultValue: 1
        }]
      }, {
        tfOpName: "SplitV",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "numOrSizeSplits",
          type: "number[]"
        }, {
          start: 2,
          name: "axis",
          type: "number",
          defaultValue: 0
        }]
      }, {
        tfOpName: "ScatterNd",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "indices",
          type: "tensor"
        }, {
          start: 1,
          name: "values",
          type: "tensor"
        }, {
          start: 2,
          name: "shape",
          type: "number[]"
        }]
      }, {
        tfOpName: "GatherNd",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "indices",
          type: "tensor"
        }]
      }, {
        tfOpName: "SparseToDense",
        category: "slice_join",
        inputs: [{
          start: 0,
          name: "sparseIndices",
          type: "tensor"
        }, {
          start: 1,
          name: "outputShape",
          type: "number[]"
        }, {
          start: 2,
          name: "sparseValues",
          type: "tensor"
        }, {
          start: 3,
          name: "defaultValue",
          type: "tensor"
        }],
        attrs: [{
          tfName: "validate_indices",
          name: "validateIndices",
          type: "bool",
          defaultValue: !1,
          notSupported: !0
        }]
      }]
    }),
    Gv = Object.freeze({
      json: [{
        tfOpName: "FFT",
        category: "spectral",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "IFFT",
        category: "spectral",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }]
      }, {
        tfOpName: "RFFT",
        category: "spectral",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "fft_length",
          type: "number",
          notSupported: !0
        }]
      }, {
        tfOpName: "IRFFT",
        category: "spectral",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "fft_length",
          type: "number",
          notSupported: !0
        }]
      }]
    }),
    qv = Object.freeze({
      json: [{
        tfOpName: "Cast",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "SrcT",
          name: "sdtype",
          type: "dtype",
          notSupported: !0
        }, {
          tfName: "DstT",
          name: "dtype",
          type: "dtype"
        }]
      }, {
        tfOpName: "ExpandDims",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "axis",
          type: "number"
        }]
      }, {
        tfOpName: "Pad",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "padding",
          type: "number[]"
        }],
        attrs: [{
          tfName: "constant_value",
          name: "constantValue",
          type: "number",
          defaultValue: 0
        }]
      }, {
        tfOpName: "PadV2",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "padding",
          type: "number[]"
        }, {
          start: 2,
          name: "constantValue",
          type: "number",
          defaultValue: 0
        }]
      }, {
        tfOpName: "Reshape",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "shape",
          type: "number[]"
        }]
      }, {
        tfOpName: "Squeeze",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "axis",
          tfDeprecatedName: "squeeze_dims",
          name: "axis",
          type: "number[]"
        }]
      }, {
        tfOpName: "SpaceToBatchND",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "blockShape",
          type: "number[]"
        }, {
          start: 2,
          name: "paddings",
          type: "number[]"
        }]
      }, {
        tfOpName: "BatchToSpaceND",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }, {
          start: 1,
          name: "blockShape",
          type: "number[]"
        }, {
          start: 2,
          name: "crops",
          type: "number[]"
        }]
      }, {
        tfOpName: "DepthToSpace",
        category: "transformation",
        inputs: [{
          start: 0,
          name: "x",
          type: "tensor"
        }],
        attrs: [{
          tfName: "block_size",
          name: "blockSize",
          type: "number"
        }, {
          tfName: "data_format",
          name: "dataFormat",
          type: "string"
        }]
      }]
    }),
    Hv = function () {
      function t() {
        var t = [Tv, Dv, Ov, _v, Fv, Mv, zv, Pv, Bv, Lv, Wv, Vv, Uv, jv, Gv, qv],
          e = [].concat.apply([], t.map(function (t) {
            return t.json
          }));
        this.opMappers = e.reduce(function (t, e) {
          return t[e.tfOpName] = e, t
        }, {})
      }
      return Object.defineProperty(t, "Instance", {
        get: function () {
          return this._instance || (this._instance = new this)
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.transformGraph = function (t, e) {
        var n = this;
        void 0 === e && (e = {});
        var r = [],
          a = [],
          i = t.node.reduce(function (t, e) {
            return t[e.name] = n.mapNode(e), e.op.startsWith("Placeholder") && r.push(t[e.name]), "Const" === e.op && a.push(t[e.name]), t
          }, {}),
          o = [],
          s = [],
          u = {},
          l = {};
        null != e && (u = this.mapSignatureEntries(e.inputs), l = this.mapSignatureEntries(e.outputs));
        var c = Object.keys(i);
        return c.forEach(function (t) {
          var e = i[t];
          e.inputNames.forEach(function (t) {
            var n = Iv(t)[0];
            e.inputs.push(i[n]), i[n].children.push(e)
          })
        }), 0 === Object.keys(l).length ? c.forEach(function (t) {
          var e = i[t];
          0 === e.children.length && s.push(e)
        }) : Object.keys(l).forEach(function (t) {
          var e = Iv(t)[0],
            n = i[e];
          null != n && (n.signatureKey = l[t], s.push(n))
        }), Object.keys(u).length > 0 ? Object.keys(u).forEach(function (t) {
          var e = Iv(t)[0],
            n = i[e];
          n && (n.signatureKey = u[t], o.push(n))
        }) : o = r, {
          nodes: i,
          inputs: o,
          outputs: s,
          weights: a,
          placeholders: r,
          signature: e
        }
      }, t.prototype.mapSignatureEntries = function (t) {
        return Object.keys(t || {}).reduce(function (e, n) {
          return e[t[n].name] = n, e
        }, {})
      }, t.prototype.mapNode = function (t) {
        var e = Nv(t.op) || this.opMappers[t.op] || {};
        null == t.attr && (t.attr = {});
        var n = {
          name: t.name,
          op: t.op,
          category: e.category,
          inputNames: (t.input || []).map(function (t) {
            return t.startsWith("^") ? t.substr(1) : t
          }),
          inputs: [],
          children: [],
          inputParams: {},
          attrParams: {},
          rawAttrs: t.attr
        };
        return null != e.inputs && (n.inputParams = e.inputs.reduce(function (t, e) {
          return t[e.name] = {
            type: e.type,
            inputIndexStart: e.start,
            inputIndexEnd: e.end
          }, t
        }, {})), null != e.attrs && (n.attrParams = e.attrs.reduce(function (e, n) {
          var r = n.type,
            a = void 0;
          switch (n.type) {
            case "string":
              void 0 === (a = Xv(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Xv(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "string[]":
              void 0 === (a = ry(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = ry(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "number":
              void 0 === (a = Yv(t.attr, n.tfName, n.defaultValue || 0)) && n.tfDeprecatedName && (a = Yv(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "number[]":
              void 0 === (a = ny(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = ny(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "bool":
              void 0 === (a = $v(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = $v(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "bool[]":
              void 0 === (a = iy(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = iy(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "shape":
              void 0 === (a = ey(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = ey(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "shape[]":
              void 0 === (a = ay(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = ay(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "dtype":
              void 0 === (a = Zv(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Zv(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "dtype[]":
              void 0 === (a = Qv(t.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Qv(t.attr, n.tfDeprecatedName, n.defaultValue));
              break;
            case "tensor":
            case "tensors":
              break;
            default:
              throw new Error("Unsupported param type: " + n.type + " for op: " + t.op)
          }
          return e[n.name] = {
            value: a,
            type: r
          }, e
        }, {})), n
      }, t
    }();

  function Kv(t, e) {
    var n = Array.isArray(t) ? String.fromCharCode.apply(null, t) : function (t) {
      var e = o().global;
      if (void 0 !== e.atob) return e.atob(t);
      if ("undefined" != typeof Buffer) return new Buffer(t, "base64").toString();
      throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")
    }(t);
    return e ? n : n.toLowerCase()
  }

  function Xv(t, e, n, r) {
    void 0 === r && (r = !1);
    var a = t[e];
    return null != a ? Kv(a.s, r) : n
  }

  function $v(t, e, n) {
    var r = t[e];
    return r ? r.b : n
  }

  function Yv(t, e, n) {
    var r = t[e] || {},
      a = null != r.i ? r.i : null != r.f ? r.f : n;
    return "number" == typeof a ? a : parseInt(a, 10)
  }

  function Jv(t) {
    switch ("string" == typeof t && (t = gv[t]), t) {
      case gv.DT_FLOAT:
        return "float32";
      case gv.DT_INT32:
      case gv.DT_INT64:
        return "int32";
      case gv.DT_BOOL:
        return "bool";
      case gv.DT_DOUBLE:
        return "float32";
      case gv.DT_STRING:
        return "string";
      default:
        return null
    }
  }

  function Zv(t, e, n) {
    var r = t[e];
    return r && r.type ? Jv(r.type) : n
  }

  function Qv(t, e, n) {
    var r = t[e];
    return r && r.list && r.list.type ? r.list.type.map(function (t) {
      return Jv(t)
    }) : n
  }

  function ty(t) {
    if (!t.unknownRank) return null != t.dim ? t.dim.map(function (t) {
      return "number" == typeof t.size ? t.size : parseInt(t.size, 10)
    }) : []
  }

  function ey(t, e, n) {
    var r = t[e];
    return r && r.shape ? ty(r.shape) : n
  }

  function ny(t, e, n) {
    var r = t[e];
    return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function (t) {
      return "number" == typeof t ? t : parseInt(t, 10)
    }) : n
  }

  function ry(t, e, n, r) {
    void 0 === r && (r = !1);
    var a = t[e];
    return a && a.list && a.list.s ? a.list.s.map(function (t) {
      return Kv(t, r)
    }) : n
  }

  function ay(t, e, n) {
    var r = t[e];
    return r && r.list && r.list.shape ? r.list.shape.map(function (t) {
      return ty(t)
    }) : n
  }

  function iy(t, e, n) {
    var r = t[e];
    return r && r.list && r.list.b ? r.list.b : n
  }
  var oy = function () {
      function t(t, e, n) {
        var r = this;
        this.node = t, this.tensorMap = e, this.context = n, this.inputs = [], this.attrs = {}, this.inputs = t.inputNames.map(function (t) {
          return r.getInput(t)
        }), null != t.rawAttrs && (this.attrs = Object.keys(t.rawAttrs).reduce(function (t, e) {
          return t[e] = r.getAttr(e), t
        }, {}))
      }
      return t.prototype.getInput = function (t) {
        return kv(t, this.tensorMap, this.context)
      }, t.prototype.getAttr = function (t, e) {
        var n = this.node.rawAttrs[t];
        if (null != n.tensor) return kv(t, this.tensorMap, this.context);
        if (null != n.i || null != n.f) return Yv(this.node.rawAttrs, t, e);
        if (null != n.s) return Xv(this.node.rawAttrs, t, e);
        if (null != n.b) return $v(this.node.rawAttrs, t, e);
        if (null != n.shape) return ey(this.node.rawAttrs, t, e);
        if (null != n.type) return Zv(this.node.rawAttrs, t, e);
        if (null != n.list) {
          if (null != n.list.i || null != n.list.f) return ny(this.node.rawAttrs, t, e);
          if (null != n.list.s) return ry(this.node.rawAttrs, t, e);
          if (null != n.list.shape) return ay(this.node.rawAttrs, t, e);
          if (null != n.list.b) return iy(this.node.rawAttrs, t, e);
          if (null != n.list.type) return Qv(this.node.rawAttrs, t, e)
        }
        return e
      }, t
    }(),
    sy = function (t, e, n) {
      switch (t.op) {
        case "BiasAdd":
        case "AddV2":
        case "Add":
          return [ls(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "AddN":
          return [cs(Sv("tensors", t, e, n))];
        case "FloorMod":
        case "Mod":
          return [ws(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "Mul":
          return [Ns(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "RealDiv":
        case "Div":
          return [fs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "DivNoNan":
          return [ds(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "FloorDiv":
          return [gs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "Sub":
          return [Rs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "Minimum":
          return [bs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "Maximum":
          return [vs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "Pow":
          return [ks(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "SquaredDifference":
          return [Es(Sv("a", t, e, n), Sv("b", t, e, n))];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    uy = function (t, e, n) {
      switch (t.op) {
        case "Abs":
        case "ComplexAbs":
          return [uo(Sv("x", t, e, n))];
        case "Acos":
          return [lo(Sv("x", t, e, n))];
        case "Acosh":
          return [co(Sv("x", t, e, n))];
        case "Asin":
          return [po(Sv("x", t, e, n))];
        case "Asinh":
          return [ho(Sv("x", t, e, n))];
        case "Atan":
          return [fo(Sv("x", t, e, n))];
        case "Atan2":
          return [hs(Sv("x", t, e, n), Sv("y", t, e, n))];
        case "Atanh":
          return [mo(Sv("x", t, e, n))];
        case "Ceil":
          return [go(Sv("x", t, e, n))];
        case "Complex":
          return [sn(Sv("real", t, e, n), Sv("imag", t, e, n))];
        case "Cos":
          return [yo(Sv("x", t, e, n))];
        case "Cosh":
          return [bo(Sv("x", t, e, n))];
        case "Elu":
          return [Wu(Sv("x", t, e, n))];
        case "Erf":
          return [xo(Sv("x", t, e, n))];
        case "Exp":
          return [wo(Sv("x", t, e, n))];
        case "Expm1":
          return [Co(Sv("x", t, e, n))];
        case "Floor":
          return [No(Sv("x", t, e, n))];
        case "Log":
          return [So(Sv("x", t, e, n))];
        case "Log1p":
          return [ko(Sv("x", t, e, n))];
        case "Imag":
          return [ln(Sv("x", t, e, n))];
        case "Neg":
          return [Eo(Sv("x", t, e, n))];
        case "Reciprocal":
          return [Ao(Sv("x", t, e, n))];
        case "Real":
          return [un(Sv("x", t, e, n))];
        case "Relu":
          return [ju(Sv("x", t, e, n))];
        case "Round":
          return [Ro(Sv("x", t, e, n))];
        case "Selu":
          return [qu(Sv("x", t, e, n))];
        case "Sigmoid":
          return [Do(Sv("x", t, e, n))];
        case "Sin":
          return [zo(Sv("x", t, e, n))];
        case "Sign":
          return [Oo(Sv("x", t, e, n))];
        case "Sinh":
          return [Lo(Sv("x", t, e, n))];
        case "Softplus":
          return [Bo(Sv("x", t, e, n))];
        case "Sqrt":
          return [Po(Sv("x", t, e, n))];
        case "Square":
          return [so(Sv("x", t, e, n))];
        case "Tanh":
          return [Uo(Sv("x", t, e, n))];
        case "Tan":
          return [Vo(Sv("x", t, e, n))];
        case "Relu6":
        case "ClipByValue":
          return [vo(Sv("x", t, e, n), Sv("clipValueMin", t, e, n), Sv("clipValueMax", t, e, n))];
        case "Rsqrt":
          return [To(kv(t.inputNames[0], e, n))];
        case "Prod":
          return [Pu(Sv("x", t, e, n), Sv("axes", t, e, n))];
        case "LeakyRelu":
          return [Vu(Sv("x", t, e, n), Sv("alpha", t, e, n))];
        case "Prelu":
          return [Uu(Sv("x", t, e, n), Sv("alpha", t, e, n))];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    ly = function () {
      function t(e, n, r, a, i, o, s) {
        this.name = e, this.dtype = n, this.maxSize = r, this.elementShape = a, this.identicalElementShapes = i, this.dynamicSize = o, this.clearAfterRead = s, this.tensors = [], this.closed_ = !1, this.id = t.nextId++
      }
      return Object.defineProperty(t.prototype, "closed", {
        get: function () {
          return this.closed_
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.clearAndClose = function () {
        this.tensors.forEach(function (t) {
          return t.tensor.dispose()
        }), this.tensors = [], this.closed_ = !0
      }, t.prototype.size = function () {
        return this.tensors.length
      }, t.prototype.read = function (t) {
        if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
        if (t < 0 || t >= this.tensors.length) throw new Error("Tried to read from index " + t + ", but array size is: " + this.tensors.length);
        var e = this.tensors[t];
        if (e.cleared) throw new Error("TensorArray " + this.name + ": Could not read index " + t + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
        return this.clearAfterRead && (e.cleared = !0), e.read = !0, e.tensor
      }, t.prototype.readMany = function (t) {
        var e = this;
        return t.map(function (t) {
          return e.read(t)
        })
      }, t.prototype.write = function (t, e) {
        if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
        if (t < 0 || !this.dynamicSize && t >= this.maxSize) throw new Error("Tried to write to index " + t + ", but array is not resizeable and size is: " + this.maxSize);
        var n = this.tensors[t] || {};
        if (e.dtype !== this.dtype) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + t + ",\n          because the value dtype is " + e.dtype + ", but TensorArray dtype is " + this.dtype + ".");
        if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = e.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, e.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + t + "."), n && n.read) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + t + ", because it has already been read.");
        if (n && n.written) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + t + ", because it has already been written.");
        n.tensor = e, n.written = !0, this.tensors[t] = n
      }, t.prototype.writeMany = function (t, e) {
        var n = this;
        if (t.length !== e.length) throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + t.length + " is not the same as tensors size: " + e.length + ".");
        t.forEach(function (t, r) {
          return n.write(t, e[r])
        })
      }, t.prototype.gather = function (t, e) {
        if (e && e !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + e);
        if (!t) {
          t = [];
          for (var n = 0; n < this.size(); n++) t.push(n)
        }
        if (0 === t.length) return cn([], [0].concat(this.elementShape));
        var r = this.readMany(t);
        return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), mr(r, 0)
      }, t.prototype.concat = function (t) {
        if (t && t !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + t);
        if (0 === this.size()) return cn([], [0].concat(this.elementShape));
        for (var e = [], n = 0; n < this.size(); n++) e.push(n);
        var r = this.readMany(e);
        return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r[0].shape + ")"), En(r, 0)
      }, t.prototype.scatter = function (t, e) {
        if (e.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + e.dtype);
        if (t.length !== e.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + t.length + " vs. " + e.shape[0]);
        var n = Math.max.apply(Math, t);
        if (!this.dynamicSize && n >= this.maxSize) throw new Error("Max index must be < array size (" + n + "  vs. " + this.maxSize + ")");
        this.writeMany(t, yr(e, 0))
      }, t.prototype.split = function (t, e) {
        var n = this;
        if (e.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + e.dtype);
        var r = 0,
          a = t.map(function (t) {
            return r += t
          });
        if (r !== e.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r + ", and tensor's shape is: " + e.shape);
        if (!this.dynamicSize && t.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + t.length + "), and the TensorArray is not marked as dynamically resizeable");
        var i = 0 === r ? 0 : e.size / r,
          o = [];
        We(function () {
          e = e.reshape([1, r, i]);
          for (var s = 0; s < t.length; ++s) {
            var u = [0, 0 === s ? 0 : a[s - 1], 0],
              l = [1, t[s], i];
            o[s] = Nu(e, u, l).reshape(n.elementShape)
          }
          return o
        });
        for (var s = [], u = 0; u < t.length; u++) s[u] = u;
        this.writeMany(s, o)
      }, t.prototype.assertShapesMatchAllowUndefinedSize = function (t, e, n) {
        void 0 === n && (n = ""), nt.assert(this.shapesEqualAllowUndefinedSize(t, e), function () {
          return n + " Shapes " + t + " and " + e + " must match"
        })
      }, t.prototype.shapesEqualAllowUndefinedSize = function (t, e) {
        if (t.length !== e.length) return !1;
        for (var n = 0; n < t.length; n++)
          if (-1 !== t[n] && -1 !== e[n] && t[n] !== e[n]) return !1;
        return !0
      }, t.nextId = 0, t
    }();
  var cy = function (t, e, n) {
      switch (t.op) {
        case "Conv1D":
          var r = Sv("stride", t, e, n),
            a = Sv("pad", t, e, n),
            i = Sv("dataFormat", t, e, n).toUpperCase(),
            o = Sv("dilation", t, e, n);
          return [Js(Sv("x", t, e, n), Sv("filter", t, e, n), r, a, i, o)];
        case "Conv2D":
          r = Sv("strides", t, e, n), a = Sv("pad", t, e, n), i = Sv("dataFormat", t, e, n).toUpperCase();
          var s = Sv("dilations", t, e, n);
          return [Zs(Sv("x", t, e, n), Sv("filter", t, e, n), [r[1], r[2]], a, i, [s[1], s[2]])];
        case "_FusedConv2D":
        case "FusedDepthwiseConv2dNative":
          var u = Sv("fusedOps", t, e, n),
            l = u[0],
            c = u[1],
            p = "biasadd" === l,
            h = "prelu" === c,
            f = "fusedbatchnorm" === l,
            d = Sv("numArgs", t, e, n);
          if (p) {
            if (h && 2 !== d) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
            if (!h && 1 !== d) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")
          }
          if (f) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");
          r = Sv("strides", t, e, n), a = Sv("pad", t, e, n), i = Sv("dataFormat", t, e, n).toUpperCase(), s = Sv("dilations", t, e, n);
          var m = Sv("args", t, e, n),
            g = m[0],
            v = m[1];
          return [("_FusedConv2D" === t.op ? Hl.conv2d : Hl.depthwiseConv2d)({
            x: Sv("x", t, e, n),
            filter: Sv("filter", t, e, n),
            strides: [r[1], r[2]],
            pad: a,
            dataFormat: i,
            dilations: [s[1], s[2]],
            bias: g,
            activation: c,
            preluActivationWeights: v
          })];
        case "Conv2DBackpropInput":
        case "Conv2dTranspose":
          var y = Sv("outputShape", t, e, n);
          return r = Sv("strides", t, e, n), a = Sv("pad", t, e, n), [ou(Sv("x", t, e, n), Sv("filter", t, e, n), y, [r[1], r[2]], a)];
        case "DepthwiseConv2dNative":
        case "DepthwiseConv2d":
          return r = Sv("strides", t, e, n), a = Sv("pad", t, e, n), s = Sv("dilations", t, e, n), i = Sv("dataFormat", t, e, n).toUpperCase(), [nu(Sv("input", t, e, n), Sv("filter", t, e, n), [r[1], r[2]], a, i, [s[1], s[2]])];
        case "Conv3D":
          return r = Sv("strides", t, e, n), a = Sv("pad", t, e, n), i = Sv("dataFormat", t, e, n).toUpperCase(), s = Sv("dilations", t, e, n), [Qs(Sv("x", t, e, n), Sv("filter", t, e, n), [r[1], r[2], r[3]], a, i, [s[1], s[2], s[3]])];
        case "AvgPool":
          r = Sv("strides", t, e, n), a = Sv("pad", t, e, n);
          var b = Sv("kernelSize", t, e, n);
          return [bu(Sv("x", t, e, n), [b[1], b[2]], [r[1], r[2]], a)];
        case "MaxPool":
          return r = Sv("strides", t, e, n), a = Sv("pad", t, e, n), b = Sv("kernelSize", t, e, n), [yu(Sv("x", t, e, n), [b[1], b[2]], [r[1], r[2]], a)];
        case "AvgPool3D":
          return r = Sv("strides", t, e, n), a = Sv("pad", t, e, n), b = Sv("kernelSize", t, e, n), [Cu(Sv("x", t, e, n), [b[1], b[2], b[3]], [r[1], r[2], r[3]], a)];
        case "MaxPool3D":
          return r = Sv("strides", t, e, n), a = Sv("pad", t, e, n), b = Sv("kernelSize", t, e, n), [wu(Sv("x", t, e, n), [b[1], b[2], b[3]], [r[1], r[2], r[3]], a)];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    py = function (t, e, n) {
      switch (t.op) {
        case "Fill":
          var r = Sv("shape", t, e, n),
            a = Sv("dtype", t, e, n);
          return [Cn(r, Sv("value", t, e, n), a)];
        case "LinSpace":
          var i = Sv("start", t, e, n);
          return [Nn(i, Sv("stop", t, e, n), Sv("num", t, e, n))];
        case "Multinomial":
          var o = Sv("logits", t, e, n),
            s = Sv("numSamples", t, e, n),
            u = Sv("seed", t, e, n);
          return [er(o, s, u)];
        case "OneHot":
          var l = Sv("indices", t, e, n),
            c = Sv("depth", t, e, n),
            p = Sv("onValue", t, e, n),
            h = Sv("offValue", t, e, n);
          return [nr(l, c, p, h)];
        case "Ones":
          return [xn(Sv("shape", t, e, n), Sv("dtype", t, e, n))];
        case "OnesLike":
          return [kn(Sv("x", t, e, n))];
        case "RandomUniform":
          return [pr(Sv("shape", t, e, n), Sv("minval", t, e, n), Sv("maxval", t, e, n), Sv("dtype", t, e, n))];
        case "Range":
          return [Sn(i = Sv("start", t, e, n), Sv("stop", t, e, n), Sv("step", t, e, n), Sv("dtype", t, e, n))];
        case "TruncatedNormal":
          r = Sv("shape", t, e, n);
          var f = Sv("mean", t, e, n),
            d = Sv("stdDev", t, e, n);
          return u = Sv("seed", t, e, n), [vr(r, f, d, Sv("dtype", t, e, n), u)];
        case "Zeros":
          return [wn(Sv("shape", t, e, n), Sv("dtype", t, e, n))];
        case "ZerosLike":
          return [In(Sv("x", t, e, n))];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    };
  var hy = function (t, e, n) {
      switch (t.op) {
        case "TopKV2":
          var r = Sv("x", t, e, n),
            a = Sv("k", t, e, n),
            i = Sv("sorted", t, e, n),
            o = Qu(r, a, i);
          return [o.values, o.indices];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    fy = function (t, e, n) {
      switch (t.op) {
        case "Const":
          return e[t.name];
        case "PlaceholderWithDefault":
          var r = Sv("default", t, e, n);
          return [kv(t.name, e, n) || r];
        case "Placeholder":
          return [kv(t.name, e, n)];
        case "Identity":
        case "StopGradient":
        case "FakeQuantWithMinMaxVars":
          return [Sv("x", t, e, n).clone()];
        case "IdentityN":
          return Sv("x", t, e, n).map(function (t) {
            return t.clone()
          });
        case "Snapshot":
          return [Sv("x", t, e, n).clone()];
        case "Shape":
          return [fn(Sv("x", t, e, n).shape, "int32")];
        case "ShapeN":
          return Sv("x", t, e, n).map(function (t) {
            return fn(t.shape)
          });
        case "Size":
          return [hn(Sv("x", t, e, n).size, "int32")];
        case "Rank":
          return [hn(Sv("x", t, e, n).rank, "int32")];
        case "NoOp":
          return [hn(1)];
        case "Print":
          var a = Sv("x", t, e, n),
            i = Sv("data", t, e, n),
            o = Sv("message", t, e, n),
            s = Sv("summarize", t, e, n);
          console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o);
          for (var u = 0; u < i.length; u++) console.log(Array.prototype.slice.call(i[u].dataSync()).slice(0, s));
          return [a];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    dy = function (t, e, n) {
      switch (t.op) {
        case "ResizeBilinear":
          var r = Sv("images", t, e, n),
            a = Sv("size", t, e, n),
            i = Sv("alignCorners", t, e, n);
          return [Bl.resizeBilinear(r, [a[0], a[1]], i)];
        case "ResizeNearestNeighbor":
          return r = Sv("images", t, e, n), a = Sv("size", t, e, n), i = Sv("alignCorners", t, e, n), [Bl.resizeNearestNeighbor(r, [a[0], a[1]], i)];
        case "CropAndResize":
          var o = Sv("image", t, e, n),
            s = Sv("boxes", t, e, n),
            u = Sv("boxInd", t, e, n),
            l = Sv("cropSize", t, e, n),
            c = Sv("method", t, e, n),
            p = Sv("extrapolationValue", t, e, n);
          return [Bl.cropAndResize(o, s, u, l, c, p)];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    my = function (t, e, n) {
      switch (t.op) {
        case "Equal":
          return [Ds(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "NotEqual":
          return [Vs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "Greater":
          return [_s(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "GreaterEqual":
          return [Fs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "Less":
          return [Ls(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "LessEqual":
          return [Bs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "LogicalAnd":
          return [rs(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "LogicalNot":
          return [as(Sv("a", t, e, n))];
        case "LogicalOr":
          return [is(Sv("a", t, e, n), Sv("b", t, e, n))];
        case "Select":
          return [ss(Sv("condition", t, e, n), Sv("a", t, e, n), Sv("b", t, e, n))];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    gy = function (t, e, n) {
      switch (t.op) {
        case "BatchMatMul":
        case "BatchMatMulV2":
        case "MatMul":
          return [uu(Sv("a", t, e, n), Sv("b", t, e, n), Sv("transposeA", t, e, n), Sv("transposeB", t, e, n))];
        case "Transpose":
          return [Hu(Sv("x", t, e, n), Sv("perm", t, e, n))];
        case "_FusedMatMul":
          var r = Sv("fusedOps", t, e, n),
            a = r[0],
            i = r[1],
            o = "biasadd" === a,
            s = "prelu" === i,
            u = Sv("numArgs", t, e, n);
          if (o) {
            if (s && 2 !== u) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
            if (!s && 1 !== u) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")
          }
          var l = Sv("args", t, e, n),
            c = l[0],
            p = l[1];
          return [Hl.matMul({
            a: Sv("a", t, e, n),
            b: Sv("b", t, e, n),
            transposeA: Sv("transposeA", t, e, n),
            transposeB: Sv("transposeB", t, e, n),
            bias: c,
            activation: i,
            preluActivationWeights: p
          })];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    vy = function (t, e, n) {
      switch (t.op) {
        case "FusedBatchNorm":
        case "FusedBatchNormV2":
        case "FusedBatchNormV3":
          return [Qo(Sv("x", t, e, n), Sv("mean", t, e, n), Sv("variance", t, e, n), Sv("offset", t, e, n), Sv("scale", t, e, n), Sv("epsilon", t, e, n))];
        case "LRN":
          return [Ku(Sv("x", t, e, n), Sv("radius", t, e, n), Sv("bias", t, e, n), Sv("alpha", t, e, n), Sv("beta", t, e, n))];
        case "Softmax":
          return [Wr(Sv("x", t, e, n))];
        case "LogSoftmax":
          return [Vr(Sv("x", t, e, n))];
        case "SparseToDense":
          return [ol(Sv("sparseIndices", t, e, n), Sv("outputShape", t, e, n), Sv("sparseValues", t, e, n), Sv("defaultValue", t, e, n))];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    yy = function (t, e, n) {
      switch (t.op) {
        case "Max":
          var r = Sv("axis", t, e, n),
            a = Sv("keepDims", t, e, n);
          return [Fu(Sv("x", t, e, n), r, a)];
        case "Mean":
          return r = Sv("axis", t, e, n), a = Sv("keepDims", t, e, n), [Mu(Sv("x", t, e, n), r, a)];
        case "Min":
          return r = Sv("axis", t, e, n), a = Sv("keepDims", t, e, n), [zu(Sv("x", t, e, n), r, a)];
        case "Sum":
          return r = Sv("axis", t, e, n), a = Sv("keepDims", t, e, n), [Bu(Sv("x", t, e, n), r, a)];
        case "All":
          return r = Sv("axis", t, e, n), a = Sv("keepDims", t, e, n), [Ru(Sv("x", t, e, n), r, a)];
        case "Any":
          return r = Sv("axis", t, e, n), a = Sv("keepDims", t, e, n), [Tu(Sv("x", t, e, n), r, a)];
        case "ArgMax":
          return r = Sv("axis", t, e, n), [Du(Sv("x", t, e, n), r)];
        case "ArgMin":
          return r = Sv("axis", t, e, n), [Ou(Sv("x", t, e, n), r)];
        case "Prod":
          return r = Sv("axis", t, e, n), a = Sv("keepDims", t, e, n), [Pu(Sv("x", t, e, n), r, a)];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    by = function (t, e, n) {
      switch (t.op) {
        case "ConcatV2":
        case "Concat":
          var r = Sv("n", t, e, n),
            a = Sv("axis", t, e, n),
            i = Sv("tensors", t, e, n);
          return i = i.slice(0, r), [En(i, a)];
        case "GatherV2":
        case "Gather":
          a = Sv("axis", t, e, n);
          var o = Sv("x", t, e, n),
            s = Sv("indices", t, e, n);
          return [qs(o, s.asType("int32"), a)];
        case "ReverseV2":
        case "Reverse":
          return a = Sv("axis", t, e, n), o = Sv("x", t, e, n), [pu(o, a)];
        case "Slice":
          var u = Sv("begin", t, e, n),
            l = Sv("size", t, e, n);
          return [Nu(Sv("x", t, e, n), u, l)];
        case "StridedSlice":
          u = Sv("begin", t, e, n);
          var c = Sv("end", t, e, n),
            p = Sv("strides", t, e, n),
            h = Sv("beginMask", t, e, n),
            f = Sv("endMask", t, e, n),
            d = Sv("ellipsisMask", t, e, n),
            m = Sv("newAxisMask", t, e, n),
            g = Sv("shrinkAxisMask", t, e, n),
            v = Sv("x", t, e, n);
          if (1 === u.length && v.shape.length > 1)
            for (var y = 1; y < v.shape.length; y++) u.push(0), c.push(v.shape[y]), p.push(p[0]);
          return [Zu(v, u, c, p, h, f, d, m, g)];
        case "Pack":
          return We(function () {
            var r = Sv("axis", t, e, n),
              a = Sv("tensors", t, e, n),
              i = a[0].shape,
              o = a[0].squeeze().shape,
              s = a.map(function (t) {
                var e = nt.arraysEqual(t.shape, i);
                if (!e && !nt.arraysEqual(t.squeeze().shape, o)) throw new Error("the input tensors shape does not match");
                return e ? t : t.reshape(i)
              });
            return [mr(s, r)]
          });
        case "Unpack":
          return We(function () {
            var r = Sv("axis", t, e, n),
              a = Sv("tensor", t, e, n);
            return yr(a, r)
          });
        case "Tile":
          var b = Sv("reps", t, e, n);
          return [gr(Sv("x", t, e, n), b)];
        case "Split":
        case "SplitV":
          a = Sv("axis", t, e, n);
          var x = Sv("numOrSizeSplits", t, e, n);
          return On(Sv("x", t, e, n), x, a);
        case "ScatterNd":
          s = Sv("indices", t, e, n);
          var w = Sv("values", t, e, n),
            C = Sv("shape", t, e, n);
          return [tl(s, w, C)];
        case "GatherNd":
          var N = Sv("x", t, e, n);
          return s = Sv("indices", t, e, n), [sl(N, s)];
        case "SparseToDense":
          s = Sv("sparseIndices", t, e, n), C = Sv("outputShape", t, e, n);
          var S = Sv("sparseValues", t, e, n),
            k = Sv("defaultValue", t, e, n);
          return [ol(s, S, C, S.dtype === k.dtype ? k : k.asType(S.dtype))];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    xy = function (t, e, n) {
      switch (t.op) {
        case "FFT":
          return [el(Sv("x", t, e, n))];
        case "IFFT":
          return [nl(Sv("x", t, e, n))];
        case "RFFT":
          return [rl(Sv("x", t, e, n))];
        case "IRFFT":
          return [al(Sv("x", t, e, n))];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    },
    wy = function (t, e, n) {
      switch (t.op) {
        case "Cast":
          return [$n(Sv("x", t, e, n), Sv("dtype", t, e, n))];
        case "ExpandDims":
          var r = Sv("axis", t, e, n);
          return [Qn(Sv("x", t, e, n), r)];
        case "Squeeze":
          return r = Sv("axis", t, e, n), [dr(Sv("x", t, e, n), r)];
        case "Reshape":
          return [hr(Sv("x", t, e, n), Sv("shape", t, e, n))];
        case "PadV2":
        case "Pad":
          return [rr(Sv("x", t, e, n), Rv(Sv("padding", t, e, n), 2), Sv("constantValue", t, e, n))];
        case "SpaceToBatchND":
          var a = Sv("blockShape", t, e, n),
            i = Rv(Sv("paddings", t, e, n), 2);
          return [fr(Sv("x", t, e, n), a, i)];
        case "BatchToSpaceND":
          a = Sv("blockShape", t, e, n);
          var o = Rv(Sv("crops", t, e, n), 2);
          return [Kn(Sv("x", t, e, n), a, o)];
        case "DepthToSpace":
          var s = Sv("blockSize", t, e, n),
            u = Sv("dataFormat", t, e, n).toUpperCase();
          return [Zn(Sv("x", t, e, n), s, u)];
        default:
          throw TypeError("Node type " + t.op + " is not implemented")
      }
    };

  function Cy(t, e, n) {
    var r = function (t, e, n) {
      switch (t.category) {
        case "arithmetic":
          return sy(t, e, n);
        case "basic_math":
          return uy(t, e, n);
        case "control":
          return function (t, e, n) {
            return xv(this, void 0, void 0, function () {
              var r, a, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b, x, w, C, N, S, k, I, E, A, R, T, D, O, _, F, M, z;
              return wv(this, function (L) {
                switch (L.label) {
                  case 0:
                    switch (t.op) {
                      case "LoopCond":
                        return [3, 1];
                      case "Switch":
                        return [3, 2];
                      case "Merge":
                        return [3, 4];
                      case "Enter":
                        return [3, 5];
                      case "Exit":
                        return [3, 6];
                      case "NextIteration":
                        return [3, 7];
                      case "TensorArrayV3":
                        return [3, 8];
                      case "TensorArrayWriteV3":
                        return [3, 9];
                      case "TensorArrayReadV3":
                        return [3, 10];
                      case "TensorArrayGatherV3":
                        return [3, 11];
                      case "TensorArrayScatterV3":
                        return [3, 12];
                      case "TensorArrayConcatV3":
                        return [3, 13];
                      case "TensorArraySplitV3":
                        return [3, 14];
                      case "TensorArraySizeV3":
                        return [3, 15];
                      case "TensorArrayCloseV3":
                        return [3, 16]
                    }
                    return [3, 17];
                  case 1:
                    return [2, [Sv("pred", t, e, n).clone()]];
                  case 2:
                    return r = Sv("pred", t, e, n), a = Sv("data", t, e, n), [4, r.data()];
                  case 3:
                    return [2, L.sent()[0] ? [void 0, a.clone()] : [a.clone(), void 0]];
                  case 4:
                    return [2, (i = t.inputNames.find(function (t) {
                      return void 0 !== kv(t, e, n)
                    })) ? [kv(i, e, n).clone()] : void 0];
                  case 5:
                    return o = Sv("frameName", t, e, n), s = Sv("tensor", t, e, n), n.enterFrame(o), [2, [s.clone()]];
                  case 6:
                    return u = Sv("tensor", t, e, n), n.exitFrame(), [2, [u.clone()]];
                  case 7:
                    return l = Sv("tensor", t, e, n), n.nextIteration(), [2, [l.clone()]];
                  case 8:
                    return c = Sv("size", t, e, n), p = Sv("dtype", t, e, n), h = Sv("elementShape", t, e, n), f = Sv("dynamicSize", t, e, n), d = Sv("clearAfterRead", t, e, n), m = Sv("identicalElementShapes", t, e, n), g = Sv("name", t, e, n), v = new ly(g, p, c, h, m, f, d), n.addTensorArray(v), [2, [hn(v.id), hn(1)]];
                  case 9:
                    return y = Sv("tensorArrayId", t, e, n), b = Sv("index", t, e, n), x = Sv("tensor", t, e, n), n.getTensorArray(y).write(b, x), [2, [hn(1)]];
                  case 10:
                    return w = Sv("tensorArrayId", t, e, n), C = Sv("index", t, e, n), [2, [n.getTensorArray(w).read(C)]];
                  case 11:
                    return N = Sv("tensorArrayId", t, e, n), S = Sv("indices", t, e, n), k = Sv("dtype", t, e, n), [2, [n.getTensorArray(N).gather(S, k)]];
                  case 12:
                    return I = Sv("tensorArrayId", t, e, n), E = Sv("indices", t, e, n), A = Sv("tensor", t, e, n), n.getTensorArray(I).scatter(E, A), [2, [hn(1)]];
                  case 13:
                    return R = Sv("tensorArrayId", t, e, n), T = n.getTensorArray(R), D = Sv("dtype", t, e, n), [2, [T.concat(D)]];
                  case 14:
                    return O = Sv("tensorArrayId", t, e, n), _ = Sv("tensor", t, e, n), F = Sv("lengths", t, e, n), n.getTensorArray(O).split(F, _), [2, [hn(1)]];
                  case 15:
                    return M = Sv("tensorArrayId", t, e, n), [2, [hn(n.getTensorArray(M).size(), "int32")]];
                  case 16:
                    return z = Sv("tensorArrayId", t, e, n), n.getTensorArray(z).clearAndClose(), [2, [hn(0)]];
                  case 17:
                    throw TypeError("Node type " + t.op + " is not implemented")
                }
              })
            })
          }(t, e, n);
        case "convolution":
          return cy(t, e, n);
        case "creation":
          return py(t, e, n);
        case "dynamic":
          return function (t, e, n) {
            return xv(this, void 0, void 0, function () {
              var r, a, i, o, s;
              return wv(this, function (u) {
                switch (u.label) {
                  case 0:
                    switch (t.op) {
                      case "NonMaxSuppressionV3":
                      case "NonMaxSuppressionV2":
                        return [3, 1];
                      case "Where":
                        return [3, 3];
                      case "ListDiff":
                        return [3, 5]
                    }
                    return [3, 6];
                  case 1:
                    return r = Sv("boxes", t, e, n), a = Sv("scores", t, e, n), i = Sv("maxOutputSize", t, e, n), o = Sv("iouThreshold", t, e, n), s = Sv("scoreThreshold", t, e, n), [4, Bl.nonMaxSuppressionAsync(r, a, i, o, s)];
                  case 2:
                    return [2, [u.sent()]];
                  case 3:
                    return [4, us(Sv("condition", t, e, n).asType("bool"))];
                  case 4:
                    return [2, [u.sent()]];
                  case 5:
                    return [2, br(Sv("x", t, e, n), Sv("y", t, e, n))];
                  case 6:
                    throw TypeError("Node type " + t.op + " is not implemented")
                }
              })
            })
          }(t, e, n);
        case "evaluation":
          return hy(t, e, n);
        case "image":
          return dy(t, e, n);
        case "graph":
          return fy(t, e, n);
        case "logical":
          return my(t, e, n);
        case "matrices":
          return gy(t, e, n);
        case "normalization":
          return vy(t, e, n);
        case "reduction":
          return yy(t, e, n);
        case "slice_join":
          return by(t, e, n);
        case "spectral":
          return xy(t, e, n);
        case "transformation":
          return wy(t, e, n);
        case "custom":
          var r = Nv(t.op);
          if (r && r.customExecutor) return r.customExecutor(new oy(t, e, n));
          throw TypeError("Custom op " + t.op + " is not registered.");
        default:
          throw TypeError("Unknown op '" + t.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")
      }
    }(t, e, n);
    return r instanceof Promise ? r.then(function (t) {
      return [].concat(t)
    }) : [].concat(r)
  }
  var Ny = function () {
    function t(t, e) {
      this.weightMap = t, this.tensorArrayMap = e, this.rootContext = {
        id: 0,
        frameName: "",
        iterationId: 0
      }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds()
    }
    return t.prototype.newFrame = function (t, e) {
      return {
        id: t,
        frameName: e,
        iterationId: 0
      }
    }, Object.defineProperty(t.prototype, "currentContext", {
      get: function () {
        return this.contexts
      },
      set: function (t) {
        this.contexts !== t && (this.contexts = t, this.generateCurrentContextIds())
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(t.prototype, "currentContextId", {
      get: function () {
        return this._currentContextIds[0]
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(t.prototype, "currentContextIds", {
      get: function () {
        return this._currentContextIds
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.generateCurrentContextIds = function () {
      for (var t = [], e = 0; e < this.contexts.length - 1; e++) {
        var n = this.contexts.slice(0, this.contexts.length - e);
        t.push(this.contextIdforContexts(n))
      }
      t.push(""), this._currentContextIds = t
    }, t.prototype.contextIdforContexts = function (t) {
      return t ? t.map(function (t) {
        return 0 === t.id && 0 === t.iterationId ? "" : t.frameName + "-" + t.iterationId
      }).join("/") : ""
    }, t.prototype.enterFrame = function (t) {
      this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, t)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))
    }, t.prototype.exitFrame = function () {
      if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
      this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift()
    }, t.prototype.nextIteration = function () {
      if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
      this.contexts = this.contexts.slice(), this.lastId++;
      var t = Object.assign({}, this.contexts[this.contexts.length - 1]);
      t.iterationId += 1, t.id = this.lastId, this.contexts.splice(-1, 1, t), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts))
    }, t.prototype.getWeight = function (t) {
      return this.weightMap[t]
    }, t.prototype.addTensorArray = function (t) {
      this.tensorArrayMap[t.id] = t
    }, t.prototype.getTensorArray = function (t) {
      return this.tensorArrayMap[t]
    }, t
  }();

  function Sy(t, e, n) {
    for (var r = new Set, a = [], i = null, o = null, s = new Set, u = Object.keys(t).map(function (t) {
        return Av(t)[0]
      }), l = e.slice(); l.length > 0;) {
      var c = l.pop();
      (Ey(c) || Ay(c)) && null == i && (o = (i = c).children.map(function (t) {
        return t.name
      }).filter(function (t) {
        return r.has(t)
      })), r.add(c.name), null == n[c.name] && -1 === u.indexOf(c.name) && (0 !== c.inputs.length ? c.inputs.forEach(function (t) {
        s.has(t.name) || (s.add(t.name), l.push(t))
      }) : a.push(c.name))
    }
    return {
      inputs: t,
      outputs: e,
      usedNodes: r,
      missingInputs: a,
      dynamicNode: i,
      syncInputs: o
    }
  }
  var ky = ["Switch", "Merge", "Enter", "Exit", "NextIteration"],
    Iy = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "Where"];

  function Ey(t) {
    return ky.indexOf(t.op) >= 0
  }

  function Ay(t) {
    return Iy.indexOf(t.op) >= 0
  }
  var Ry = function () {
      function t(t) {
        this.graph = t, this.compiledMap = new Map, this._weightMap = {}, this.SEPERATOR = ",", this._outputs = t.outputs, this._inputs = t.inputs, this._signature = t.signature
      }
      return Object.defineProperty(t.prototype, "weightMap", {
        get: function () {
          return this._weightMap
        },
        set: function (t) {
          var e = Object.keys(t).map(function (e) {
            return t[e].map(function (t) {
              return t.id
            })
          });
          this.weightIds = [].concat.apply([], e), this._weightMap = t
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "inputs", {
        get: function () {
          return this._inputs.map(function (t) {
            return {
              name: t.name,
              shape: t.attrParams.shape ? t.attrParams.shape.value : void 0,
              dtype: t.attrParams.dtype ? t.attrParams.dtype.value : void 0
            }
          })
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "outputs", {
        get: function () {
          return this._outputs.map(function (t) {
            return {
              name: t.name,
              shape: t.attrParams.shape ? t.attrParams.shape.value : void 0,
              dtype: t.attrParams.dtype ? t.attrParams.dtype.value : void 0
            }
          })
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "inputNodes", {
        get: function () {
          return this._inputs.map(function (t) {
            return t.signatureKey || t.name
          })
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "outputNodes", {
        get: function () {
          return this._outputs.map(function (t) {
            return t.signatureKey || t.name
          })
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.getCompilationKey = function (t, e) {
        var n = t.map(function (t) {
            return t.name
          }).sort(),
          r = e.map(function (t) {
            return t.name
          }).sort();
        return n.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR)
      }, t.prototype.compile = function (t, e) {
        var n = Sy(t, e, this.weightMap),
          r = n.missingInputs,
          a = n.dynamicNode,
          i = n.syncInputs;
        if (null != a) throw new Error("This execution contains the node '" + a.name + "', which has the dynamic op '" + a.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + i + "]");
        if (r.length > 0) {
          var o = e.map(function (t) {
              return t.name
            }),
            s = Object.keys(t);
          throw new Error("Cannot compute the outputs [" + o + "] from the provided inputs [" + s + "]. Missing the following inputs: [" + r + "]")
        }
        return function (t, e, n) {
          var r = n.usedNodes,
            a = n.inputs,
            i = [];
          Object.keys(a).map(function (t) {
            return Av(t)[0]
          }).map(function (e) {
            return t.nodes[e]
          }).forEach(function (t) {
            r.has(t.name) && i.push(t)
          }), t.weights.forEach(function (t) {
            r.has(t.name) && i.push(t)
          });
          for (var o = new Set, s = []; i.length > 0;) {
            var u = i.pop();
            o.add(u.name), e[u.name] || s.push(u), u.children.forEach(function (t) {
              !o.has(t.name) && r.has(t.name) && t.inputs.every(function (t) {
                return o.has(t.name)
              }) && i.push(t)
            })
          }
          return s
        }(this.graph, this.weightMap, n)
      }, t.prototype.execute = function (t, e) {
        var n = this;
        t = this.mapInputs(t);
        var r = Object.keys(t).sort();
        this.checkInputs(t), this.checkInputShapeAndType(t), e = this.mapOutputs(e), this.checkOutputs(e);
        var a = r.map(function (t) {
            return n.graph.nodes[Av(t)[0]]
          }),
          i = e.map(function (t) {
            return n.graph.nodes[Av(t)[0]]
          }),
          o = this.getCompilationKey(a, i),
          s = this.compiledMap.get(o);
        null == s && (s = this.compile(t, i), this.compiledMap.set(o, s));
        var u = {};
        return We(function () {
          var r = new Ny(n._weightMap, u),
            a = bv({}, n.weightMap);
          Object.keys(t).forEach(function (e) {
            var n = Av(e),
              r = n[0],
              i = [];
            i[n[1]] = t[e], a[r] = i
          });
          for (var i = n.getFrozenTensorIds(a), o = {}, l = 0; l < s.length; l++) {
            var c = s[l];
            if (!a[c.name]) {
              var p = Cy(c, a, r);
              if (p instanceof Promise) throw new Error("The execution of the op '" + c.op + "' returned a promise. Please use model.executeAsync() instead.");
              a[c.name] = p, n.checkTensorForDisposal(c.name, c, a, r, i, e, o)
            }
          }
          return e.map(function (t) {
            return kv(t, a, r)
          })
        })
      }, t.prototype.getFrozenTensorIds = function (t) {
        var e = [].concat.apply([], Object.keys(t).map(function (e) {
          return t[e]
        }).map(function (t) {
          return t.map(function (t) {
            return t.id
          })
        }));
        return new Set(e)
      }, t.prototype.checkTensorForDisposal = function (t, e, n, r, a, i, o) {
        "control" !== e.category && -1 === i.indexOf(t) && (n[t].forEach(function (t) {
          null != t && (o[t.id] = (o[t.id] || 0) + e.children.length)
        }), e.inputs.forEach(function (t) {
          if ("control" !== t.category) {
            var e = function (t, e, n) {
              return e[Ev(t, n.currentContextId)]
            }(t.name, n, r);
            null != e && e.forEach(function (t) {
              if (t && !a.has(t.id)) {
                var e = o[t.id];
                1 === e ? (t.dispose(), delete o[t.id]) : null != e && o[t.id]--
              }
            })
          }
        }))
      }, t.prototype.executeAsync = function (t, e) {
        return xv(this, void 0, void 0, function () {
          var n, r, a, i, o, s, u = this;
          return wv(this, function (l) {
            switch (l.label) {
              case 0:
                return t = this.mapInputs(t), this.checkInputs(t), this.checkInputShapeAndType(t), e = this.mapOutputs(e), this.checkOutputs(e), n = {}, r = new Ny(this._weightMap, n), [4, this.executeWithControlFlow(t, r, e)];
              case 1:
                return a = l.sent(), i = e.map(function (t) {
                  return kv(t, a, r)
                }), o = new Set(i.map(function (t) {
                  return t.id
                })), s = new Set(Object.keys(t).map(function (e) {
                  return t[e].id
                })), Object.keys(a).forEach(function (t) {
                  a[t].forEach(function (t) {
                    !t || t.isDisposed || o.has(t.id) || s.has(t.id) || -1 !== u.weightIds.indexOf(t.id) || t.dispose()
                  })
                }), [2, i]
            }
          })
        })
      }, t.prototype.executeWithControlFlow = function (t, e, n) {
        return xv(this, void 0, void 0, function () {
          var r, a, i, o, s, u, l, c, p, h, f, d, m, g, v, y, b = this;
          return wv(this, function (x) {
            switch (x.label) {
              case 0:
                r = Object.keys(t), a = r.map(function (t) {
                  return b.graph.nodes[Av(t)[0]]
                }), i = n.map(function (t) {
                  return b.graph.nodes[Av(t)[0]]
                }), o = Sy(t, i, this.weightMap), s = o.usedNodes, u = o.missingInputs, l = o.dynamicNode, c = o.syncInputs, p = a.concat(this.graph.weights).map(function (t) {
                  return {
                    node: t,
                    contexts: e.currentContext
                  }
                }), h = bv({}, this.weightMap), Object.keys(t).forEach(function (e) {
                  var n = Av(e),
                    r = n[0],
                    a = [];
                  a[n[1]] = t[e], h[r] = a
                }), f = {}, d = this.getFrozenTensorIds(h), m = {}, x.label = 1;
              case 1:
                return p.length > 0 ? (g = this.processStack(a, p, e, h, m, d, n, f, s), [4, Promise.all(g)]) : [3, 3];
              case 2:
                return x.sent(), [3, 1];
              case 3:
                if (null == l && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (v = i.filter(function (t) {
                    return !Ey(t) && !kv(t.name, h, e)
                  }).map(function (t) {
                    return t.name
                  })).length > 0) throw y = "", null != l && (y = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + c + "]"), new Error("Cannot compute the outputs [" + v + "] from the provided inputs [" + r + "]. Consider providing the following inputs: [" + u + "]. " + y);
                return [2, h]
            }
          })
        })
      }, t.prototype.processStack = function (t, e, n, r, a, i, o, s, u) {
        for (var l = this, c = [], p = function () {
            var p = e.pop();
            n.currentContext = p.contexts;
            var f = "";
            if ("Enter" === p.node.op && Sv("isConstant", p.node, r, n) && (f = Iv(p.node.name, n)[0]), -1 === t.indexOf(p.node)) {
              var d = Cy(p.node, r, n);
              f || (f = Iv(p.node.name, n)[0]);
              var m = n.currentContext;
              d instanceof Promise ? c.push(d.then(function (t) {
                return r[f] = t, n.currentContext = m, l.checkTensorForDisposal(f, p.node, r, n, i, o, s), l.processChildNodes(p.node, e, n, r, a, u), t
              })) : (r[f] = d, h.checkTensorForDisposal(f, p.node, r, n, i, o, s), h.processChildNodes(p.node, e, n, r, a, u))
            } else h.processChildNodes(p.node, e, n, r, a, u)
          }, h = this; e.length > 0;) p();
        return c
      }, t.prototype.processChildNodes = function (t, e, n, r, a, i) {
        t.children.forEach(function (t) {
          var o = Iv(t.name, n)[0];
          !a[o] && i.has(t.name) && ("Merge" === t.op ? t.inputNames.some(function (t) {
            return !!kv(t, r, n)
          }) && (a[o] = !0, e.push({
            contexts: n.currentContext,
            node: t
          })) : t.inputNames.every(function (t) {
            return !!kv(t, r, n)
          }) && (a[o] = !0, e.push({
            contexts: n.currentContext,
            node: t
          })))
        })
      }, t.prototype.dispose = function () {
        var t = this;
        Object.keys(this.weightMap).forEach(function (e) {
          return t.weightMap[e].forEach(function (t) {
            return t.dispose()
          })
        })
      }, t.prototype.checkInputShapeAndType = function (t) {
        var e = this;
        Object.keys(t).forEach(function (n) {
          var r = t[n],
            a = Av(n)[0],
            i = e.graph.nodes[a];
          if (i.attrParams.shape && i.attrParams.shape.value) {
            var o = i.attrParams.shape.value,
              s = o.length === r.shape.length && r.shape.every(function (t, e) {
                return -1 === o[e] || o[e] === t
              });
            nt.assert(s, function () {
              return "The shape of dict['" + i.name + "'] provided in model.execute(dict) must be [" + o + "], but was [" + r.shape + "]"
            })
          }
          i.attrParams.dtype && i.attrParams.dtype.value && nt.assert(r.dtype === i.attrParams.dtype.value, function () {
            return "The dtype of dict['" + i.name + "'] provided in model.execute(dict) must be " + i.attrParams.dtype.value + ", but was " + r.dtype
          })
        })
      }, t.prototype.mapInputs = function (t) {
        var e = {};
        for (var n in t) null != this._signature && null != this._signature.inputs && null != this._signature.inputs[n] ? e[this._signature.inputs[n].name] = t[n] : e[n] = t[n];
        return e
      }, t.prototype.checkInputs = function (t) {
        var e = this,
          n = Object.keys(t).filter(function (t) {
            var n = Av(t)[0];
            return null == e.graph.nodes[n]
          });
        if (n.length > 0) throw new Error("The dict provided in model.execute(dict) has keys: [" + n + "] that are not part of graph")
      }, t.prototype.mapOutputs = function (t) {
        var e = this;
        return t.map(function (t) {
          return null != e._signature && null != e._signature.outputs && null != e._signature.outputs[t] ? e._signature.outputs[t].name : t
        }, {})
      }, t.prototype.checkOutputs = function (t) {
        var e = this;
        t.forEach(function (t) {
          var n = Av(t)[0];
          if (!e.graph.nodes[n]) throw new Error("The output '" + t + "' is not found in the graph")
        })
      }, t
    }(),
    Ty = "?tfjs-format=file",
    Dy = "model.json",
    Oy = function () {
      function t(t, e) {
        void 0 === e && (e = {}), this.modelUrl = t, this.loadOptions = e, this.version = "n/a", null == e && (this.loadOptions = {})
      }
      return Object.defineProperty(t.prototype, "modelVersion", {
        get: function () {
          return this.version
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "inputNodes", {
        get: function () {
          return this.executor.inputNodes
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "outputNodes", {
        get: function () {
          return this.executor.outputNodes
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "inputs", {
        get: function () {
          return this.executor.inputs
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "outputs", {
        get: function () {
          return this.executor.outputs
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(t.prototype, "weights", {
        get: function () {
          return this.executor.weightMap
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.findIOHandler = function () {
        var t = this.modelUrl;
        if (null != t.load) this.handler = t;
        else if (null != this.loadOptions.requestInit) this.handler = $c.browserHTTPRequest(t, this.loadOptions);
        else {
          var e = $c.getLoadHandlers(t, this.loadOptions.onProgress);
          if (0 === e.length) e.push($c.browserHTTPRequest(t, this.loadOptions));
          else if (e.length > 1) throw new Error("Found more than one (" + e.length + ") load handlers for URL '" + [t] + "'");
          this.handler = e[0]
        }
      }, t.prototype.load = function () {
        return xv(this, void 0, void 0, function () {
          var t, e, n, r;
          return wv(this, function (a) {
            switch (a.label) {
              case 0:
                if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                return [4, this.handler.load()];
              case 1:
                return t = a.sent(), e = t.modelTopology, n = {}, null != t.userDefinedMetadata && (n = t.userDefinedMetadata.signature), this.version = e.versions.producer + "." + e.versions.minConsumer, r = $c.decodeWeights(t.weightData, t.weightSpecs), this.executor = new Ry(Hv.Instance.transformGraph(e, n)), this.executor.weightMap = this.convertTensorMapToTensorsMap(r), [2, !0]
            }
          })
        })
      }, t.prototype.predict = function (t, e) {
        return this.execute(t, this.outputNodes)
      }, t.prototype.normalizeInputs = function (t) {
        if (!(t instanceof mt || Array.isArray(t))) return t;
        if ((t = Array.isArray(t) ? t : [t]).length !== this.inputNodes.length) throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + t.length + " input tensors.");
        return this.inputNodes.reduce(function (e, n, r) {
          return e[n] = t[r], e
        }, {})
      }, t.prototype.normalizeOutputs = function (t) {
        return t = t || this.outputNodes, Array.isArray(t) ? t : [t]
      }, t.prototype.execute = function (t, e) {
        t = this.normalizeInputs(t), e = this.normalizeOutputs(e);
        var n = this.executor.execute(t, e);
        return n.length > 1 ? n : n[0]
      }, t.prototype.executeAsync = function (t, e) {
        return xv(this, void 0, void 0, function () {
          var n;
          return wv(this, function (r) {
            switch (r.label) {
              case 0:
                return t = this.normalizeInputs(t), e = this.normalizeOutputs(e), [4, this.executor.executeAsync(t, e)];
              case 1:
                return [2, (n = r.sent()).length > 1 ? n : n[0]]
            }
          })
        })
      }, t.prototype.convertTensorMapToTensorsMap = function (t) {
        return Object.keys(t).reduce(function (e, n) {
          return e[n] = [t[n]], e
        }, {})
      }, t.prototype.dispose = function () {
        this.executor.dispose()
      }, t
    }();
  var _y = function (t, e) {
    return (_y = Object.setPrototypeOf || {
        __proto__: []
      }
      instanceof Array && function (t, e) {
        t.__proto__ = e
      } || function (t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
      })(t, e)
  };

  function Fy(t, e) {
    function n() {
      this.constructor = t
    }
    _y(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
  }

  function My(t, e, n, r) {
    return new(n || (n = Promise))(function (a, i) {
      function o(t) {
        try {
          u(r.next(t))
        } catch (t) {
          i(t)
        }
      }

      function s(t) {
        try {
          u(r.throw(t))
        } catch (t) {
          i(t)
        }
      }

      function u(t) {
        t.done ? a(t.value) : new n(function (e) {
          e(t.value)
        }).then(o, s)
      }
      u((r = r.apply(t, e || [])).next())
    })
  }

  function zy(t, e) {
    var n, r, a, i, o = {
      label: 0,
      sent: function () {
        if (1 & a[0]) throw a[1];
        return a[1]
      },
      trys: [],
      ops: []
    };
    return i = {
      next: s(0),
      throw: s(1),
      return: s(2)
    }, "function" == typeof Symbol && (i[Symbol.iterator] = function () {
      return this
    }), i;

    function s(i) {
      return function (s) {
        return function (i) {
          if (n) throw new TypeError("Generator is already executing.");
          for (; o;) try {
            if (n = 1, r && (a = 2 & i[0] ? r.return : i[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, i[1])).done) return a;
            switch (r = 0, a && (i = [2 & i[0], a.value]), i[0]) {
              case 0:
              case 1:
                a = i;
                break;
              case 4:
                return o.label++, {
                  value: i[1],
                  done: !1
                };
              case 5:
                o.label++, r = i[1], i = [0];
                continue;
              case 7:
                i = o.ops.pop(), o.trys.pop();
                continue;
              default:
                if (!(a = (a = o.trys).length > 0 && a[a.length - 1]) && (6 === i[0] || 2 === i[0])) {
                  o = 0;
                  continue
                }
                if (3 === i[0] && (!a || i[1] > a[0] && i[1] < a[3])) {
                  o.label = i[1];
                  break
                }
                if (6 === i[0] && o.label < a[1]) {
                  o.label = a[1], a = i;
                  break
                }
                if (a && o.label < a[2]) {
                  o.label = a[2], o.ops.push(i);
                  break
                }
                a[2] && o.ops.pop(), o.trys.pop();
                continue
            }
            i = e.call(t, o)
          } catch (t) {
            i = [6, t], r = 0
          } finally {
            n = a = 0
          }
          if (5 & i[0]) throw i[1];
          return {
            value: i[0] ? i[1] : void 0,
            done: !0
          }
        }([i, s])
      }
    }
  }

  function Ly(t, e) {
    return t(e = {
      exports: {}
    }, e.exports), e.exports
  }
  var By = Ly(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e
        }

        function a(t, e) {
          var n = new function (t) {
              var e, n = this,
                r = (e = 4022871197, function (t) {
                  t = t.toString();
                  for (var n = 0; n < t.length; n++) {
                    var r = .02519603282416938 * (e += t.charCodeAt(n));
                    r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e)
                  }
                  return 2.3283064365386963e-10 * (e >>> 0)
                });
              n.next = function () {
                var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;
                return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t)
              }, n.c = 1, n.s0 = r(" "), n.s1 = r(" "), n.s2 = r(" "), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null
            }(t),
            a = e && e.state,
            i = n.next;
          return i.int32 = function () {
            return 4294967296 * n.next() | 0
          }, i.double = function () {
            return i() + 1.1102230246251565e-16 * (2097152 * i() | 0)
          }, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.alea = a
      }(0, t)
    }),
    Py = Ly(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e
        }

        function a(t, e) {
          var n = new function (t) {
              var e = this,
                n = "";
              e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {
                var t = e.x ^ e.x << 11;
                return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8
              }, t === (0 | t) ? e.x = t : n += t;
              for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next()
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.xor128 = a
      }(0, t)
    }),
    Wy = Ly(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e
        }

        function a(t, e) {
          var n = new function (t) {
              var e = this,
                n = "";
              e.next = function () {
                var t = e.x ^ e.x >>> 2;
                return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0
              }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;
              for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next()
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.xorwow = a
      }(0, t)
    }),
    Vy = Ly(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.x = t.x.slice(), e.i = t.i, e
        }

        function a(t, e) {
          null == t && (t = +new Date);
          var n = new function (t) {
              var e = this;
              e.next = function () {
                  var t, n, r = e.x,
                    a = e.i;
                  return t = r[a], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[a + 1 & 7]) ^ t >>> 10, n ^= (t = r[a + 3 & 7]) ^ t >>> 3, n ^= (t = r[a + 4 & 7]) ^ t << 7, t = r[a + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[a] = n, e.i = a + 1 & 7, n
                },
                function (t, e) {
                  var n, r = [];
                  if (e === (0 | e)) r[0] = e;
                  else
                    for (e = "" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;
                  for (; r.length < 8;) r.push(0);
                  for (n = 0; n < 8 && 0 === r[n]; ++n);
                  for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next()
                }(e, t)
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && (a.x && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.xorshift7 = a
      }(0, t)
    }),
    Uy = Ly(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e
        }

        function a(t, e) {
          null == t && (t = +new Date);
          var n = new function (t) {
              var e = this;
              e.next = function () {
                  var t, n, r = e.w,
                    a = e.X,
                    i = e.i;
                  return e.w = r = r + 1640531527 | 0, n = a[i + 34 & 127], t = a[i = i + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = a[i] = n ^ t, e.i = i, n + (r ^ r >>> 16) | 0
                },
                function (t, e) {
                  var n, r, a, i, o, s = [],
                    u = 128;
                  for (e === (0 | e) ? (r = e, e = null) : (e += "\0", r = 0, u = Math.max(u, e.length)), a = 0, i = -32; i < u; ++i) e && (r ^= e.charCodeAt((i + 32) % e.length)), 0 === i && (o = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, i >= 0 && (o = o + 1640531527 | 0, a = 0 == (n = s[127 & i] ^= r + o) ? a + 1 : 0);
                  for (a >= 128 && (s[127 & (e && e.length || 0)] = -1), a = 127, i = 512; i > 0; --i) r = s[a + 34 & 127], n = s[a = a + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[a] = r ^ n;
                  t.w = o, t.X = s, t.i = a
                }(e, t)
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && (a.X && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.xor4096 = a
      }(0, t)
    }),
    jy = Ly(function (t) {
      ! function (t, e, n) {
        function r(t, e) {
          return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e
        }

        function a(t, e) {
          var n = new function (t) {
              var e = this,
                n = "";
              e.next = function () {
                var t = e.b,
                  n = e.c,
                  r = e.d,
                  a = e.a;
                return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ a, a = a - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ a, e.a = a - t | 0
              }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;
              for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next()
            }(t),
            a = e && e.state,
            i = function () {
              return (n.next() >>> 0) / 4294967296
            };
          return i.double = function () {
            do {
              var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
            } while (0 === t);
            return t
          }, i.int32 = n.next, i.quick = i, a && ("object" == typeof a && r(a, n), i.state = function () {
            return r(n, {})
          }), i
        }
        e && e.exports ? e.exports = a : this.tychei = a
      }(0, t)
    }),
    Gy = Ly(function (t) {
      ! function (e, n) {
        var r, a = this,
          i = 256,
          o = 6,
          s = "random",
          u = n.pow(i, o),
          l = n.pow(2, 52),
          c = 2 * l,
          p = i - 1;

        function h(t, h, g) {
          var v = [],
            y = d(function t(e, n) {
              var r, a = [],
                i = typeof e;
              if (n && "object" == i)
                for (r in e) try {
                  a.push(t(e[r], n - 1))
                } catch (t) {}
              return a.length ? a : "string" == i ? e : e + "\0"
            }((h = 1 == h ? {
              entropy: !0
            } : h || {}).entropy ? [t, m(e)] : null == t ? function () {
              try {
                var t;
                return r && (t = r.randomBytes) ? t = t(i) : (t = new Uint8Array(i), (a.crypto || a.msCrypto).getRandomValues(t)), m(t)
              } catch (t) {
                var n = a.navigator,
                  o = n && n.plugins;
                return [+new Date, a, o, a.screen, m(e)]
              }
            }() : t, 3), v),
            b = new function (t) {
              var e, n = t.length,
                r = this,
                a = 0,
                o = r.i = r.j = 0,
                s = r.S = [];
              for (n || (t = [n++]); a < i;) s[a] = a++;
              for (a = 0; a < i; a++) s[a] = s[o = p & o + t[a % n] + (e = s[a])], s[o] = e;
              (r.g = function (t) {
                for (var e, n = 0, a = r.i, o = r.j, s = r.S; t--;) e = s[a = p & a + 1], n = n * i + s[p & (s[a] = s[o = p & o + e]) + (s[o] = e)];
                return r.i = a, r.j = o, n
              })(i)
            }(v),
            x = function () {
              for (var t = b.g(o), e = u, n = 0; t < l;) t = (t + n) * i, e *= i, n = b.g(1);
              for (; t >= c;) t /= 2, e /= 2, n >>>= 1;
              return (t + n) / e
            };
          return x.int32 = function () {
            return 0 | b.g(4)
          }, x.quick = function () {
            return b.g(4) / 4294967296
          }, x.double = x, d(m(b.S), e), (h.pass || g || function (t, e, r, a) {
            return a && (a.S && f(a, b), t.state = function () {
              return f(b, {})
            }), r ? (n[s] = t, e) : t
          })(x, y, "global" in h ? h.global : this == n, h.state)
        }

        function f(t, e) {
          return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
        }

        function d(t, e) {
          for (var n, r = t + "", a = 0; a < r.length;) e[p & a] = p & (n ^= 19 * e[p & a]) + r.charCodeAt(a++);
          return m(e)
        }

        function m(t) {
          return String.fromCharCode.apply(0, t)
        }
        if (n["seed" + s] = h, d(n.random(), e), t.exports) {
          t.exports = h;
          try {
            r = require("crypto")
          } catch (t) {}
        }
      }([], Math)
    });
  Gy.alea = By, Gy.xor128 = Py, Gy.xorwow = Wy, Gy.xorshift7 = Vy, Gy.xor4096 = Uy, Gy.tychei = jy;
  var qy = Gy.alea;

  function Hy(t, e, n, r) {
    if (void 0 === n && (n = new Map), void 0 === r && (r = new Set), null == t) return null;
    if (r.has(t)) throw new Error("Circular references are not supported.");
    if (n.has(t)) return n.get(t);
    var a = e(t);
    if (a.recurse && null !== a.value) throw new Error("A deep map function may not return both a value and recurse=true.");
    if (a.recurse) {
      if (Yy(t)) {
        var i = Array.isArray(t) ? [] : {};
        for (var o in r.add(t), t) {
          var s = Hy(t[o], e, n, r);
          i[o] = s
        }
        return r.delete(t), i
      }
      throw new Error("Can't recurse into non-iterable type: " + t)
    }
    return n.set(t, a.value), a.value
  }

  function Ky(t, e) {
    return void 0 === e && (e = Xy),
      function t(e, n, r) {
        void 0 === r && (r = new Set);
        var a = e[0];
        if (r.has(a)) throw new Error("Circular references are not supported.");
        var i = n(e);
        if (i.recurse && null !== i.value) throw new Error("A deep zip function may not return both a value and recurse=true.");
        if (i.recurse) {
          if (Yy(a)) {
            var o = Array.isArray(a) ? [] : {};
            r.add(a);
            var s = function (a) {
              var i = t(e.map(function (t) {
                return t[a]
              }), n, r);
              o[a] = i
            };
            for (var u in a) s(u);
            return r.delete(a), o
          }
          throw new Error("Can't recurse into non-iterable type: " + a)
        }
        return i.value
      }(t, e)
  }

  function Xy(t) {
    return null === t ? null : Yy(t[0]) ? {
      value: null,
      recurse: !0
    } : {
      value: t,
      recurse: !1
    }
  }

  function $y(t, e) {
    return My(this, void 0, void 0, function () {
      var n, r, a, i, o, s;
      return zy(this, function (u) {
        switch (u.label) {
          case 0:
            n = new Map, Hy(t, e, n), r = 0, a = Array.from(n.keys()), u.label = 1;
          case 1:
            return r < a.length ? (i = a[r], (o = n.get(i)) instanceof Promise ? [4, o] : [3, 3]) : [3, 4];
          case 2:
            s = u.sent(), n.set(i, s), u.label = 3;
          case 3:
            return r++, [3, 1];
          case 4:
            return [2, Hy(t, e, n)]
        }
      })
    })
  }

  function Yy(t) {
    return null != t && !ArrayBuffer.isView(t) && (Array.isArray(t) || "object" == typeof t && !(t instanceof mt))
  }

  function Jy(t) {
    return function (t, e) {
      return Hy(t, e)
    }(t, Zy)
  }

  function Zy(t) {
    return t instanceof mt ? {
      value: t.clone(),
      recurse: !1
    } : Yy(t) ? {
      value: null,
      recurse: !0
    } : {
      value: t,
      recurse: !1
    }
  }
  var Qy = function () {
      function t(t) {
        if (this.capacity = t, this.begin = 0, this.end = 0, null == t) throw new RangeError("Can't create a ring buffer of unknown capacity.");
        if (t < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
        this.data = new Array(t), this.doubledCapacity = 2 * t
      }
      return t.prototype.wrap = function (t) {
        for (; t < 0;) t += this.doubledCapacity;
        return t % this.doubledCapacity
      }, t.prototype.get = function (t) {
        if (t < 0) throw new RangeError("Can't get item at a negative index.");
        return this.data[t % this.capacity]
      }, t.prototype.set = function (t, e) {
        if (t < 0) throw new RangeError("Can't set item at a negative index.");
        this.data[t % this.capacity] = e
      }, t.prototype.length = function () {
        var t = this.end - this.begin;
        return t < 0 && (t = this.doubledCapacity + t), t
      }, t.prototype.isFull = function () {
        return this.length() === this.capacity
      }, t.prototype.isEmpty = function () {
        return 0 === this.length()
      }, t.prototype.push = function (t) {
        if (this.isFull()) throw new RangeError("Ring buffer is full.");
        this.set(this.end, t), this.end = this.wrap(this.end + 1)
      }, t.prototype.pushAll = function (t) {
        for (var e = 0, n = t; e < n.length; e++) {
          var r = n[e];
          this.push(r)
        }
      }, t.prototype.pop = function () {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        this.end = this.wrap(this.end - 1);
        var t = this.get(this.end);
        return this.set(this.end, void 0), t
      }, t.prototype.unshift = function (t) {
        if (this.isFull()) throw new RangeError("Ring buffer is full.");
        this.begin = this.wrap(this.begin - 1), this.set(this.begin, t)
      }, t.prototype.shift = function () {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        var t = this.get(this.begin);
        return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), t
      }, t.prototype.shuffleExcise = function (t) {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        var e = this.wrap(this.begin + t),
          n = this.get(e);
        return this.set(e, this.pop()), n
      }, t
    }(),
    tb = function (t) {
      function e() {
        return t.call(this, e.INITIAL_CAPACITY) || this
      }
      return Fy(e, t), e.prototype.isFull = function () {
        return !1
      }, e.prototype.push = function (e) {
        t.prototype.isFull.call(this) && this.expand(), t.prototype.push.call(this, e)
      }, e.prototype.unshift = function (e) {
        t.prototype.isFull.call(this) && this.expand(), t.prototype.unshift.call(this, e)
      }, e.prototype.expand = function () {
        for (var t = 2 * this.capacity, e = new Array(t), n = this.length(), r = 0; r < n; r++) e[r] = this.get(this.wrap(this.begin + r));
        this.data = e, this.capacity = t, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = n
      }, e.INITIAL_CAPACITY = 32, e
    }(Qy);

  function eb(t) {
    return new ib(t)
  }

  function nb(t) {
    return new ob(t)
  }
  var rb, ab = function () {
      function t() {}
      return t.prototype.toArray = function () {
        return My(this, void 0, void 0, function () {
          var t, e;
          return zy(this, function (n) {
            switch (n.label) {
              case 0:
                return t = [], [4, this.next()];
              case 1:
                e = n.sent(), n.label = 2;
              case 2:
                return e.done ? [3, 4] : (t.push(e.value), [4, this.next()]);
              case 3:
                return e = n.sent(), [3, 2];
              case 4:
                return [2, t]
            }
          })
        })
      }, t.prototype.toArrayForTest = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n;
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                return t = this.prefetch(100), e = [], [4, t.next()];
              case 1:
                n = r.sent(), r.label = 2;
              case 2:
                return n.done ? [3, 4] : (e.push(n.value), [4, t.next()]);
              case 3:
                return n = r.sent(), [3, 2];
              case 4:
                return [2, e]
            }
          })
        })
      }, t.prototype.resolveFully = function () {
        return My(this, void 0, void 0, function () {
          var t;
          return zy(this, function (e) {
            switch (e.label) {
              case 0:
                return [4, this.next()];
              case 1:
                t = e.sent(), e.label = 2;
              case 2:
                return t.done ? [3, 4] : [4, this.next()];
              case 3:
                return t = e.sent(), [3, 2];
              case 4:
                return [2]
            }
          })
        })
      }, t.prototype.resolveWhile = function (t) {
        return My(this, void 0, void 0, function () {
          var e, n;
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                return [4, this.next()];
              case 1:
                e = r.sent(), n = t(e.value), r.label = 2;
              case 2:
                return e.done || !n ? [3, 4] : [4, this.next()];
              case 3:
                return e = r.sent(), n = t(e.value), [3, 2];
              case 4:
                return [2]
            }
          })
        })
      }, t.prototype.handleErrors = function (t) {
        return new fb(this, t)
      }, t.prototype.filter = function (t) {
        return new pb(this, t)
      }, t.prototype.map = function (t) {
        return new hb(this, t)
      }, t.prototype.mapAsync = function (t) {
        return new db(this, t)
      }, t.prototype.serialMapAsync = function (t) {
        return new db(this, t).serial()
      }, t.prototype.flatmap = function (t) {
        return new gb(this, t)
      }, t.prototype.forEachAsync = function (t) {
        return My(this, void 0, void 0, function () {
          return zy(this, function (e) {
            return [2, this.map(t).resolveFully()]
          })
        })
      }, t.prototype.serialForEach = function (t) {
        return My(this, void 0, void 0, function () {
          return zy(this, function (e) {
            return [2, this.serialMapAsync(t).resolveWhile(function (t) {
              return !0 === t
            })]
          })
        })
      }, t.prototype.rowMajorBatch = function (t, e) {
        return void 0 === e && (e = !0), new cb(this, t, e)
      }, t.prototype.columnMajorBatch = function (t, e, n) {
        return void 0 === e && (e = !0), void 0 === n && (n = Xy), this.rowMajorBatch(t, e).map(function (t) {
          return Ky(t, n)
        })
      }, t.prototype.concatenate = function (t, e) {
        return new vb(eb([this, t]), e)
      }, t.prototype.take = function (t) {
        return t < 0 || null == t ? this : new lb(this, t)
      }, t.prototype.skip = function (t) {
        return t < 0 || null == t ? this : new ub(this, t)
      }, t.prototype.prefetch = function (t) {
        return new bb(this, t)
      }, t.prototype.shuffle = function (t, e) {
        return new xb(this, t, e)
      }, t.prototype.serial = function () {
        return new sb(this)
      }, t
    }(),
    ib = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return n.items = e, n.trav = 0, n
      }
      return Fy(e, t), e.prototype.summary = function () {
        return "Array of " + this.items.length + " items"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t;
          return zy(this, function (e) {
            return this.trav >= this.items.length ? [2, {
              value: null,
              done: !0
            }] : (t = this.items[this.trav], this.trav++, [2, {
              value: Jy(t),
              done: !1
            }])
          })
        })
      }, e
    }(ab),
    ob = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return n.nextFn = e, n
      }
      return Fy(e, t), e.prototype.summary = function () {
        return "Function call"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            try {
              return [2, this.nextFn()]
            } catch (t) {
              throw t.message = "Error thrown while iterating through a dataset: " + t.message, t
            }
            return [2]
          })
        })
      }, e
    }(ab),
    sb = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return n.upstream = e, n.lastRead = Promise.resolve({
          value: null,
          done: !1
        }), n
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Serial"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t = this;
          return zy(this, function (e) {
            return this.lastRead = this.lastRead.then(function () {
              return t.serialNext()
            }), [2, this.lastRead]
          })
        })
      }, e.prototype.serialNext = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            return [2, this.upstream.next()]
          })
        })
      }, e
    }(ab),
    ub = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.maxCount = n, r.count = 0, r.lastRead = Promise.resolve({
          value: null,
          done: !1
        }), r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Skip"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t = this;
          return zy(this, function (e) {
            return this.lastRead = this.lastRead.then(function () {
              return t.serialNext()
            }), [2, this.lastRead]
          })
        })
      }, e.prototype.serialNext = function () {
        return My(this, void 0, void 0, function () {
          var t;
          return zy(this, function (e) {
            switch (e.label) {
              case 0:
                return this.count++ < this.maxCount ? [4, this.upstream.next()] : [3, 2];
              case 1:
                return (t = e.sent()).done ? [2, t] : (Ve(t.value), [3, 0]);
              case 2:
                return [2, this.upstream.next()]
            }
          })
        })
      }, e
    }(ab),
    lb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.maxCount = n, r.count = 0, r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Take"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            return this.count++ >= this.maxCount ? [2, {
              value: null,
              done: !0
            }] : [2, this.upstream.next()]
          })
        })
      }, e
    }(ab),
    cb = function (t) {
      function e(e, n, r) {
        void 0 === r && (r = !0);
        var a = t.call(this) || this;
        return a.upstream = e, a.batchSize = n, a.enableSmallLastBatch = r, a.lastRead = Promise.resolve({
          value: null,
          done: !1
        }), a
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> RowMajorBatch"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t = this;
          return zy(this, function (e) {
            return this.lastRead = this.lastRead.then(function () {
              return t.serialNext()
            }), [2, this.lastRead]
          })
        })
      }, e.prototype.serialNext = function () {
        return My(this, void 0, void 0, function () {
          var t, e;
          return zy(this, function (n) {
            switch (n.label) {
              case 0:
                t = [], n.label = 1;
              case 1:
                return t.length < this.batchSize ? [4, this.upstream.next()] : [3, 3];
              case 2:
                return (e = n.sent()).done ? this.enableSmallLastBatch && t.length > 0 ? [2, {
                  value: t,
                  done: !1
                }] : [2, {
                  value: null,
                  done: !0
                }] : (t.push(e.value), [3, 1]);
              case 3:
                return [2, {
                  value: t,
                  done: !1
                }]
            }
          })
        })
      }, e
    }(ab),
    pb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.predicate = n, r.lastRead = Promise.resolve({
          value: null,
          done: !1
        }), r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Filter"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t = this;
          return zy(this, function (e) {
            return this.lastRead = this.lastRead.then(function () {
              return t.serialNext()
            }), [2, this.lastRead]
          })
        })
      }, e.prototype.serialNext = function () {
        return My(this, void 0, void 0, function () {
          var t;
          return zy(this, function (e) {
            switch (e.label) {
              case 0:
                return [4, this.upstream.next()];
              case 1:
                return (t = e.sent()).done || this.predicate(t.value) ? [2, t] : (Ve(t.value), [3, 0]);
              case 2:
                return [2]
            }
          })
        })
      }, e
    }(ab),
    hb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.transform = n, r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Map"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n, r, a, i, o;
          return zy(this, function (s) {
            switch (s.label) {
              case 0:
                return [4, this.upstream.next()];
              case 1:
                if ((t = s.sent()).done) return [2, {
                  value: null,
                  done: !0
                }];
                for (e = At.getTensorsInContainer(t.value), n = this.transform(t.value), r = At.getTensorsInContainer(n), a = 0, i = e; a < i.length; a++) o = i[a], At.isTensorInList(o, r) || o.dispose();
                return [2, {
                  value: n,
                  done: !1
                }]
            }
          })
        })
      }, e
    }(ab),
    fb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.handler = n, r.count = 0, r.lastRead = Promise.resolve({
          value: null,
          done: !1
        }), r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> handleErrors"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t = this;
          return zy(this, function (e) {
            return this.lastRead = this.lastRead.then(function () {
              return t.serialNext()
            }), [2, this.lastRead]
          })
        })
      }, e.prototype.serialNext = function () {
        return My(this, void 0, void 0, function () {
          var t;
          return zy(this, function (e) {
            switch (e.label) {
              case 0:
                e.label = 1;
              case 1:
                return e.trys.push([1, 3, , 4]), [4, this.upstream.next()];
              case 2:
                return [2, e.sent()];
              case 3:
                return t = e.sent(), this.handler(t) ? [3, 4] : [2, {
                  value: null,
                  done: !0
                }];
              case 4:
                return [3, 0];
              case 5:
                return [2]
            }
          })
        })
      }, e
    }(ab),
    db = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.transform = n, r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> AsyncMap"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n, r, a, i, o;
          return zy(this, function (s) {
            switch (s.label) {
              case 0:
                return [4, this.upstream.next()];
              case 1:
                return (t = s.sent()).done ? [2, {
                  value: null,
                  done: !0
                }] : (e = At.getTensorsInContainer(t.value), [4, this.transform(t.value)]);
              case 2:
                for (n = s.sent(), r = At.getTensorsInContainer(n), a = 0, i = e; a < i.length; a++) o = i[a], At.isTensorInList(o, r) || o.dispose();
                return [2, {
                  value: n,
                  done: !1
                }]
            }
          })
        })
      }, e
    }(ab),
    mb = function (t) {
      function e() {
        var e = t.call(this) || this;
        return e.outputQueue = new tb, e.lastRead = Promise.resolve({
          value: null,
          done: !1
        }), e
      }
      return Fy(e, t), e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t = this;
          return zy(this, function (e) {
            return this.lastRead = this.lastRead.then(function () {
              return t.serialNext()
            }), [2, this.lastRead]
          })
        })
      }, e.prototype.serialNext = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            switch (t.label) {
              case 0:
                return 0 !== this.outputQueue.length() ? [3, 2] : [4, this.pump()];
              case 1:
                return t.sent() ? [3, 0] : [2, {
                  value: null,
                  done: !0
                }];
              case 2:
                return [2, {
                  value: this.outputQueue.shift(),
                  done: !1
                }]
            }
          })
        })
      }, e
    }(ab),
    gb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.transform = n, r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Flatmap"
      }, e.prototype.pump = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n, r, a, i, o;
          return zy(this, function (s) {
            switch (s.label) {
              case 0:
                return [4, this.upstream.next()];
              case 1:
                if ((t = s.sent()).done) return [2, !1];
                for (e = At.getTensorsInContainer(t.value), n = this.transform(t.value), r = At.getTensorsInContainer(n), this.outputQueue.pushAll(n), a = 0, i = e; a < i.length; a++) o = i[a], At.isTensorInList(o, r) || o.dispose();
                return [2, !0]
            }
          })
        })
      }, e
    }(mb),
    vb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.baseErrorHandler = n, r.lastRead = null, r.iterator = null, r.moreIterators = e, r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return "TODO: fill in upstream of chained summaries -> Chained"
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            return this.lastRead = this.readFromChain(this.lastRead), [2, this.lastRead]
          })
        })
      }, e.prototype.readFromChain = function (t) {
        return My(this, void 0, void 0, function () {
          var e, n;
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                return [4, t];
              case 1:
                return r.sent(), null != this.iterator ? [3, 3] : [4, this.moreIterators.next()];
              case 2:
                if ((e = r.sent()).done) return [2, {
                  value: null,
                  done: !0
                }];
                this.iterator = e.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler)), r.label = 3;
              case 3:
                return [4, this.iterator.next()];
              case 4:
                return (n = r.sent()).done ? (this.iterator = null, [2, this.readFromChain(t)]) : [2, n]
            }
          })
        })
      }, e
    }(ab);
  ! function (t) {
    t[t.FAIL = 0] = "FAIL", t[t.SHORTEST = 1] = "SHORTEST", t[t.LONGEST = 2] = "LONGEST"
  }(rb || (rb = {}));
  var yb = function (t) {
      function e(e, n) {
        void 0 === n && (n = rb.FAIL);
        var r = t.call(this) || this;
        return r.iterators = e, r.mismatchMode = n, r.count = 0, r.currentPromise = null, r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return "{TODO: fill in upstream of zip summaries} -> Zip"
      }, e.prototype.nextState = function (t) {
        return My(this, void 0, void 0, function () {
          function e(t) {
            return t instanceof ab ? {
              value: t.next().then(function (t) {
                return n++, t.done && r++, t.value
              }),
              recurse: !1
            } : {
              value: null,
              recurse: !0
            }
          }
          var n, r, a;
          return zy(this, function (i) {
            switch (i.label) {
              case 0:
                return [4, t];
              case 1:
                return i.sent(), n = 0, r = 0, [4, $y(this.iterators, e)];
              case 2:
                if (a = i.sent(), n === r) return [2, {
                  value: null,
                  done: !0
                }];
                if (r > 0) switch (this.mismatchMode) {
                  case rb.FAIL:
                    throw new Error("Zipped streams should have the same length. Mismatched at element " + this.count + ".");
                  case rb.SHORTEST:
                    return [2, {
                      value: null,
                      done: !0
                    }];
                  case rb.LONGEST:
                }
                return this.count++, [2, {
                  value: a,
                  done: !1
                }]
            }
          })
        })
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            return this.currentPromise = this.nextState(this.currentPromise), [2, this.currentPromise]
          })
        })
      }, e
    }(ab),
    bb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.bufferSize = n, r.buffer = new Qy(n), r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Prefetch"
      }, e.prototype.refill = function () {
        for (; !this.buffer.isFull();) {
          var t = this.upstream.next();
          this.buffer.push(t)
        }
      }, e.prototype.next = function () {
        return this.refill(), this.buffer.shift()
      }, e
    }(ab),
    xb = function (t) {
      function e(e, n, r) {
        var a = t.call(this, e, n) || this;
        return a.upstream = e, a.windowSize = n, a.upstreamExhausted = !1, a.random = qy(r || nt.now().toString()), a.lastRead = Promise.resolve({
          value: null,
          done: !1
        }), a
      }
      return Fy(e, t), e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t = this;
          return zy(this, function (e) {
            return this.lastRead = this.lastRead.then(function () {
              return t.serialNext()
            }), [2, this.lastRead]
          })
        })
      }, e.prototype.randomInt = function (t) {
        return Math.floor(this.random() * t)
      }, e.prototype.chooseIndex = function () {
        return this.randomInt(this.buffer.length())
      }, e.prototype.serialNext = function () {
        return My(this, void 0, void 0, function () {
          var t, e;
          return zy(this, function (n) {
            switch (n.label) {
              case 0:
                this.upstreamExhausted || this.refill(), n.label = 1;
              case 1:
                return this.buffer.isEmpty() ? [3, 3] : (t = this.chooseIndex(), [4, this.buffer.shuffleExcise(t)]);
              case 2:
                return (e = n.sent()).done ? (this.upstreamExhausted = !0, [3, 1]) : (this.refill(), [2, e]);
              case 3:
                return [2, {
                  value: null,
                  done: !0
                }]
            }
          })
        })
      }, e
    }(bb),
    wb = function () {
      function t() {
        this.size = null
      }
      return t.prototype.batch = function (t, e) {
        var n = this;
        void 0 === e && (e = !0);
        var r = this;
        return nt.assert(t > 0, function () {
          return "batchSize needs to be positive, but it is\n      " + t
        }), Cb(function () {
          return My(n, void 0, void 0, function () {
            return zy(this, function (n) {
              switch (n.label) {
                case 0:
                  return [4, r.iterator()];
                case 1:
                  return [2, n.sent().columnMajorBatch(t, e, Nb)]
              }
            })
          })
        }, this.size === 1 / 0 || null == this.size ? this.size : e ? Math.ceil(this.size / t) : Math.floor(this.size / t))
      }, t.prototype.concatenate = function (t) {
        var e = this,
          n = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            var e, r;
            return zy(this, function (a) {
              switch (a.label) {
                case 0:
                  return [4, n.iterator()];
                case 1:
                  return r = (e = a.sent()).concatenate, [4, t.iterator()];
                case 2:
                  return [2, r.apply(e, [a.sent()])]
              }
            })
          })
        }, this.size === 1 / 0 || t.size === 1 / 0 ? 1 / 0 : null != this.size && null != t.size ? this.size + t.size : null)
      }, t.prototype.filter = function (t) {
        var e = this,
          n = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            return zy(this, function (e) {
              switch (e.label) {
                case 0:
                  return [4, n.iterator()];
                case 1:
                  return [2, e.sent().filter(function (e) {
                    return We(function () {
                      return t(e)
                    })
                  })]
              }
            })
          })
        }, this.size === 1 / 0 ? 1 / 0 : null)
      }, t.prototype.forEachAsync = function (t) {
        return My(this, void 0, void 0, function () {
          return zy(this, function (e) {
            switch (e.label) {
              case 0:
                return [4, this.iterator()];
              case 1:
                return [2, e.sent().forEachAsync(t)]
            }
          })
        })
      }, t.prototype.forEach = function (t) {
        return My(this, void 0, void 0, function () {
          return zy(this, function (e) {
            return Be("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"), [2, this.forEachAsync(t)]
          })
        })
      }, t.prototype.map = function (t) {
        var e = this,
          n = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            return zy(this, function (e) {
              switch (e.label) {
                case 0:
                  return [4, n.iterator()];
                case 1:
                  return [2, e.sent().map(function (e) {
                    return We(function () {
                      return t(e)
                    })
                  })]
              }
            })
          })
        }, this.size)
      }, t.prototype.mapAsync = function (t) {
        var e = this,
          n = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            return zy(this, function (e) {
              switch (e.label) {
                case 0:
                  return [4, n.iterator()];
                case 1:
                  return [2, e.sent().mapAsync(t)]
              }
            })
          })
        }, this.size)
      }, t.prototype.prefetch = function (t) {
        var e = this;
        if (null == t) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
        var n = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            return zy(this, function (e) {
              switch (e.label) {
                case 0:
                  return [4, n.iterator()];
                case 1:
                  return [2, e.sent().prefetch(t)]
              }
            })
          })
        }, this.size)
      }, t.prototype.repeat = function (t) {
        var e = this,
          n = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            var e = this;
            return zy(this, function (r) {
              return [2, function (t, e) {
                return new vb(t, e)
              }(nb(function () {
                return My(e, void 0, void 0, function () {
                  var t;
                  return zy(this, function (e) {
                    switch (e.label) {
                      case 0:
                        return t = {}, [4, n.iterator()];
                      case 1:
                        return [2, (t.value = e.sent(), t.done = !1, t)]
                    }
                  })
                })
              }).take(t))]
            })
          })
        }, null != this.size && t > 0 ? this.size * t : 0 === t ? 0 : null != this.size && (void 0 === t || t < 0) ? 1 / 0 : null)
      }, t.prototype.skip = function (t) {
        var e = this,
          n = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            return zy(this, function (e) {
              switch (e.label) {
                case 0:
                  return [4, n.iterator()];
                case 1:
                  return [2, e.sent().skip(t)]
              }
            })
          })
        }, null != this.size && t >= 0 && this.size >= t ? this.size - t : null != this.size && (this.size < t || void 0 === t || t < 0) ? 0 : null)
      }, t.prototype.shuffle = function (t, e, n) {
        var r = this;
        if (void 0 === n && (n = !0), null == t || t < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" + this.size + " elements)");
        var a = this,
          i = qy(e || nt.now().toString());
        return Cb(function () {
          return My(r, void 0, void 0, function () {
            var e;
            return zy(this, function (r) {
              switch (r.label) {
                case 0:
                  return e = i.int32(), n && (e += i.int32()), [4, a.iterator()];
                case 1:
                  return [2, r.sent().shuffle(t, e.toString())]
              }
            })
          })
        }, this.size)
      }, t.prototype.take = function (t) {
        var e = this,
          n = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            return zy(this, function (e) {
              switch (e.label) {
                case 0:
                  return [4, n.iterator()];
                case 1:
                  return [2, e.sent().take(t)]
              }
            })
          })
        }, null != this.size && this.size > t ? t : null != this.size && this.size <= t ? this.size : null)
      }, t.prototype.toArray = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            switch (t.label) {
              case 0:
                if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
                return [4, this.iterator()];
              case 1:
                return [2, t.sent().toArray()]
            }
          })
        })
      }, t.prototype.toArrayForTest = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            switch (t.label) {
              case 0:
                if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
                return [4, this.iterator()];
              case 1:
                return [2, t.sent().toArrayForTest()]
            }
          })
        })
      }, t.MAX_BUFFER_SIZE = 1e4, t
    }();

  function Cb(t, e) {
    return void 0 === e && (e = null), new(function (n) {
      function r() {
        var t = null !== n && n.apply(this, arguments) || this;
        return t.size = e, t
      }
      return Fy(r, n), r.prototype.iterator = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (e) {
            return [2, t()]
          })
        })
      }, r
    }(wb))
  }

  function Nb(t) {
    return null === t ? null : function (t) {
      return null == t || function (t) {
        return null === t || "object" != typeof t && "function" != typeof t
      }(t) || Array.isArray(t) || "object" == typeof t && t instanceof mt || nt.isTypedArray(t)
    }(t[0]) ? {
      value: function (t) {
        if (0 === t.length) throw new Error("Can't make a batch of zero elements.");
        return t[0] instanceof mt ? mr(t) : cn(t)
      }(t),
      recurse: !1
    } : {
      value: null,
      recurse: !0
    }
  }
  var Sb = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return n.input = e, n
      }
      return Fy(e, t), e.prototype.iterator = function () {
        return My(this, void 0, void 0, function () {
          var t;
          return zy(this, function (e) {
            switch (e.label) {
              case 0:
                return [4, this.input.iterator()];
              case 1:
                return t = e.sent(), [2, t.decodeUTF8().split("\n").map(function (t) {
                  return t.endsWith("\r") && (t = t.slice(0, -1)), t
                })]
            }
          })
        })
      }, e
    }(wb),
    kb = Symbol("out"),
    Ib = Symbol("field"),
    Eb = Symbol("quote"),
    Ab = Symbol("quoteafterquote"),
    Rb = Symbol("quoteinquote"),
    Tb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.input = e, r.hasHeader = !0, r.fullColumnNames = null, r.columnNamesValidated = !1, r.columnConfigs = null, r.configuredColumnsOnly = !1, r.delimiter = ",", r.delimWhitespace = !1, r.base = new Sb(e), n || (n = {}), r.hasHeader = !1 !== n.hasHeader, r.fullColumnNames = n.columnNames, r.columnConfigs = n.columnConfigs, r.configuredColumnsOnly = n.configuredColumnsOnly, n.delimWhitespace ? (nt.assert(null == n.delimiter, function () {
          return "Delimiter should not be provided when delimWhitespace is true."
        }), r.delimWhitespace = !0, r.delimiter = " ") : r.delimiter = n.delimiter ? n.delimiter : ",", r
      }
      return Fy(e, t), e.prototype.columnNames = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            switch (t.label) {
              case 0:
                return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];
              case 1:
                t.sent(), t.label = 2;
              case 2:
                return [2, this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames]
            }
          })
        })
      }, e.prototype.setColumnNames = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n, r, a, i, o = this;
          return zy(this, function (s) {
            switch (s.label) {
              case 0:
                return [4, this.maybeReadHeaderLine()];
              case 1:
                if (t = s.sent(), !this.fullColumnNames && !t) throw new Error("Column names must be provided if there is no header line.");
                if (this.fullColumnNames && t && nt.assert(t.length === this.fullColumnNames.length, function () {
                    return "The length of provided columnNames (" + o.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t.length.toString() + ")."
                  }), this.fullColumnNames || (this.fullColumnNames = t), e = this.fullColumnNames.reduce(function (t, e) {
                    return t[e] = t[e] + 1 || 1, t
                  }, {}), n = Object.keys(e).filter(function (t) {
                    return e[t] > 1
                  }), nt.assert(0 === n.length, function () {
                    return "Duplicate column names found: " + n.toString()
                  }), this.columnConfigs)
                  for (r = 0, a = Object.keys(this.columnConfigs); r < a.length; r++)
                    if (i = a[r], -1 === this.fullColumnNames.indexOf(i)) throw new Error('The key "' + i + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
                return this.columnNamesValidated = !0, [2]
            }
          })
        })
      }, e.prototype.maybeReadHeaderLine = function () {
        return My(this, void 0, void 0, function () {
          var t, e;
          return zy(this, function (n) {
            switch (n.label) {
              case 0:
                return this.hasHeader ? [4, this.base.iterator()] : [3, 3];
              case 1:
                return [4, n.sent().next()];
              case 2:
                if ((t = n.sent()).done) throw new Error("No data was found for CSV parsing.");
                return e = t.value, [2, this.parseRow(e, !1)];
              case 3:
                return [2, null]
            }
          })
        })
      }, e.prototype.iterator = function () {
        return My(this, void 0, void 0, function () {
          var t, e = this;
          return zy(this, function (n) {
            switch (n.label) {
              case 0:
                return this.columnNamesValidated ? [3, 2] : [4, this.setColumnNames()];
              case 1:
                n.sent(), n.label = 2;
              case 2:
                return [4, this.base.iterator()];
              case 3:
                return t = n.sent(), this.hasHeader && (t = t.skip(1)), [2, t.map(function (t) {
                  return e.makeDataElement(t)
                })]
            }
          })
        })
      }, e.prototype.makeDataElement = function (t) {
        for (var e = this.parseRow(t), n = {}, r = {}, a = 0; a < this.fullColumnNames.length; a++) {
          var i = this.fullColumnNames[a],
            o = this.columnConfigs ? this.columnConfigs[i] : null;
          if (!this.configuredColumnsOnly || o) {
            var s = e[a],
              u = null;
            if ("" === s)
              if (o && void 0 !== o.default) u = o.default;
              else {
                if (o && (o.required || o.isLabel)) throw new Error("Required column " + i + " is empty in this line: " + t);
                u = void 0
              }
            else {
              var l = Number(s);
              if (isNaN(l)) u = o && "bool" === o.dtype ? this.getBoolean(s) : s;
              else if (o && o.dtype) switch (o.dtype) {
                case "float32":
                  u = l;
                  break;
                case "int32":
                  u = Math.floor(l);
                  break;
                case "bool":
                  u = this.getBoolean(s);
                  break;
                default:
                  u = l
              } else u = l
            }
            o && o.isLabel ? r[i] = u : n[i] = u
          }
        }
        return 0 === Object.keys(r).length ? n : {
          xs: n,
          ys: r
        }
      }, e.prototype.getBoolean = function (t) {
        return "1" === t || "true" === t.toLowerCase() ? 1 : 0
      }, e.prototype.parseRow = function (t, e) {
        void 0 === e && (e = !0);
        for (var n = [], r = 0, a = t.length, i = kb, o = 0; o < a; o++) switch (i) {
          case kb:
            switch (t.charAt(o)) {
              case '"':
                r = o + 1, i = Eb;
                break;
              case this.delimiter:
                if (r = o + 1, " " === this.delimiter && this.delimWhitespace) break;
                n.push(""), i = kb;
                break;
              default:
                i = Ib, r = o
            }
            break;
          case Ib:
            switch (t.charAt(o)) {
              case this.delimiter:
                n.push(t.substring(r, o)), i = kb, r = o + 1
            }
            break;
          case Eb:
            switch (t.charAt(o)) {
              case '"':
                i = Ab
            }
            break;
          case Ab:
            switch (t.charAt(o)) {
              case this.delimiter:
                n.push(t.substring(r, o - 1)), i = kb, r = o + 1;
                break;
              case '"':
                i = Eb;
                break;
              default:
                i = Rb
            }
            break;
          case Rb:
            switch (t.charAt(o)) {
              case '"':
                i = Eb
            }
        }
        if (i === Ab ? n.push(t.substring(r, a - 1)) : n.push(t.substring(r)), e && n.length !== this.fullColumnNames.length) throw new Error("Invalid row in csv file. Should have " + this.fullColumnNames.length + " elements in a row, but got " + n);
        return n
      }, e
    }(wb),
    Db = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        n.microphoneConfig = e, n.isClosed = !1, n.fftSize = e.fftSize || 1024;
        var r = Math.log2(n.fftSize);
        if (n.fftSize < 0 || r < 4 || r > 14 || !Number.isInteger(r)) throw new Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " + n.fftSize);
        if (n.numFrames = e.numFramesPerSpectrogram || 43, n.sampleRateHz = e.sampleRateHz, n.columnTruncateLength = e.columnTruncateLength || n.fftSize, n.audioTrackConstraints = e.audioTrackConstraints, n.smoothingTimeConstant = e.smoothingTimeConstant || 0, n.includeSpectrogram = !1 !== e.includeSpectrogram, n.includeWaveform = !0 === e.includeWaveform, !n.includeSpectrogram && !n.includeWaveform) throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
        return n
      }
      return Fy(e, t), e.prototype.summary = function () {
        return "microphone"
      }, e.create = function (t) {
        return void 0 === t && (t = {}), My(this, void 0, void 0, function () {
          var n;
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                if (o().get("IS_NODE")) throw new Error("microphone API is only supported in browser environment.");
                return [4, (n = new e(t)).start()];
              case 1:
                return r.sent(), [2, n]
            }
          })
        })
      }, e.prototype.start = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n, r;
          return zy(this, function (a) {
            switch (a.label) {
              case 0:
                return a.trys.push([0, 2, , 3]), t = this, [4, navigator.mediaDevices.getUserMedia({
                  audio: null == this.audioTrackConstraints || this.audioTrackConstraints,
                  video: !1
                })];
              case 1:
                return t.stream = a.sent(), [3, 3];
              case 2:
                throw e = a.sent(), new Error("Error thrown while initializing video stream: " + e.message);
              case 3:
                if (!this.stream) throw new Error("Could not obtain audio from microphone.");
                if (n = window.AudioContext || window.webkitAudioContext, this.audioContext = new n, this.sampleRateHz) {
                  if (this.audioContext.sampleRate !== this.sampleRateHz) throw new Error("Mismatch in sampling rate: Expected: " + this.sampleRateHz + "; Actual: " + this.audioContext.sampleRate)
                } else this.sampleRateHz = this.audioContext.sampleRate;
                return r = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, r.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), [2]
            }
          })
        })
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n, r, a;
          return zy(this, function (i) {
            switch (i.label) {
              case 0:
                return this.isClosed ? [2, {
                  value: null,
                  done: !0
                }] : [4, this.getAudioData()];
              case 1:
                return n = i.sent(), this.includeSpectrogram && (r = this.flattenQueue(n.freqDataQueue), t = this.getTensorFromAudioDataArray(r, [this.numFrames, this.columnTruncateLength, 1])), this.includeWaveform && (a = this.flattenQueue(n.timeDataQueue), e = this.getTensorFromAudioDataArray(a, [this.numFrames * this.fftSize, 1])), [2, {
                  value: {
                    spectrogram: t,
                    waveform: e
                  },
                  done: !1
                }]
            }
          })
        })
      }, e.prototype.capture = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.next()];
              case 1:
                return [2, t.sent().value]
            }
          })
        })
      }, e.prototype.getAudioData = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n, r = this;
          return zy(this, function (a) {
            return t = [], e = [], n = 0, [2, new Promise(function (a) {
              var i = setInterval(function () {
                r.includeSpectrogram && (r.analyser.getFloatFrequencyData(r.freqData), r.freqData[0] === -1 / 0 && a({
                  freqDataQueue: t,
                  timeDataQueue: e
                }), t.push(r.freqData.slice(0, r.columnTruncateLength))), r.includeWaveform && (r.analyser.getFloatTimeDomainData(r.timeData), e.push(r.timeData.slice())), ++n === r.numFrames && (clearInterval(i), a({
                  freqDataQueue: t,
                  timeDataQueue: e
                }))
              }, r.fftSize / r.sampleRateHz * 1e3)
            })]
          })
        })
      }, e.prototype.stop = function () {
        this.isClosed || (this.isClosed = !0, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop())
      }, e.prototype.toArray = function () {
        throw new Error("Can not convert infinite audio stream to array.")
      }, e.prototype.getSampleRate = function () {
        return this.sampleRateHz
      }, e.prototype.flattenQueue = function (t) {
        var e = t[0].length,
          n = new Float32Array(t.length * e);
        return t.forEach(function (t, r) {
          return n.set(t, r * e)
        }), n
      }, e.prototype.getTensorFromAudioDataArray = function (t, e) {
        var n = new Float32Array(nt.sizeFromShape(e));
        return n.set(t, n.length - t.length), cn(n, e)
      }, e
    }(ab),
    Ob = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        if (r.webcamVideoElement = e, r.webcamConfig = n, r.isClosed = !0, r.resize = !1, r.needToResize())
          if (r.resize = !0, r.cropSize = [r.webcamConfig.resizeHeight, r.webcamConfig.resizeWidth], r.cropBoxInd = fn([0], "int32"), r.webcamConfig.centerCrop) {
            var a = 1 * r.webcamConfig.resizeWidth / r.webcamVideoElement.width,
              i = 1 * r.webcamConfig.resizeHeight / r.webcamVideoElement.height,
              o = (1 - a) / 2,
              s = (1 - i) / 2,
              u = o + a,
              l = i + s;
            r.cropBox = dn([s, o, l, u], [1, 4])
          } else r.cropBox = dn([0, 0, 1, 1], [1, 4]);
        return r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return "webcam"
      }, e.create = function (t, n) {
        return void 0 === n && (n = {}), My(this, void 0, void 0, function () {
          var r;
          return zy(this, function (a) {
            switch (a.label) {
              case 0:
                if (o().get("IS_NODE")) throw new Error("tf.data.webcam is only supported in browser environment.");
                if (!t) {
                  if (t = document.createElement("video"), !n.resizeWidth || !n.resizeHeight) throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
                  t.width = n.resizeWidth, t.height = n.resizeHeight
                }
                return [4, (r = new e(t, n)).start()];
              case 1:
                return a.sent(), [2, r]
            }
          })
        })
      }, e.prototype.start = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n = this;
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                this.webcamConfig.facingMode && nt.assert("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, function () {
                  return "Invalid webcam facing mode: " + n.webcamConfig.facingMode + ". Please provide 'user' or 'environment'"
                }), r.label = 1;
              case 1:
                return r.trys.push([1, 3, , 4]), t = this, [4, navigator.mediaDevices.getUserMedia({
                  video: {
                    deviceId: this.webcamConfig.deviceId,
                    facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
                    width: this.webcamVideoElement.width,
                    height: this.webcamVideoElement.height
                  }
                })];
              case 2:
                return t.stream = r.sent(), [3, 4];
              case 3:
                throw (e = r.sent()).message = "Error thrown while initializing video stream: " + e.message, e;
              case 4:
                if (!this.stream) throw new Error("Could not obtain video from webcam.");
                try {
                  this.webcamVideoElement.srcObject = this.stream
                } catch (t) {
                  console.log(t), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream)
                }
                return this.webcamVideoElement.play(), this.isClosed = !1, [2, new Promise(function (t) {
                  n.webcamVideoElement.onloadedmetadata = function () {
                    t()
                  }
                })]
            }
          })
        })
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t;
          return zy(this, function (e) {
            if (this.isClosed) return [2, {
              value: null,
              done: !0
            }];
            try {
              t = Qc.fromPixels(this.webcamVideoElement)
            } catch (t) {
              throw new Error("Error thrown converting video to pixels: " + JSON.stringify(t))
            }
            if (!this.resize) return [2, {
              value: t,
              done: !1
            }];
            try {
              return [2, {
                value: this.cropAndResizeFrame(t),
                done: !1
              }]
            } catch (t) {
              throw new Error("Error thrown cropping the video: " + t.message)
            } finally {
              t.dispose()
            }
            return [2]
          })
        })
      }, e.prototype.needToResize = function () {
        return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight)
      }, e.prototype.cropAndResizeFrame = function (t) {
        var e = this;
        return We(function () {
          var n, r = t.toFloat().expandDims(0),
            a = (n = Bl.cropAndResize(r, e.cropBox, e.cropBoxInd, e.cropSize, "bilinear")).shape;
          return n.reshape(a.slice(1))
        })
      }, e.prototype.capture = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            switch (t.label) {
              case 0:
                return [4, this.next()];
              case 1:
                return [2, t.sent().value]
            }
          })
        })
      }, e.prototype.stop = function () {
        this.stream.getTracks().forEach(function (t) {
          return t.stop()
        });
        try {
          this.webcamVideoElement.srcObject = null
        } catch (t) {
          console.log(t), this.webcamVideoElement.src = null
        }
        this.isClosed = !0
      }, e.prototype.toArray = function () {
        throw new Error("Can not convert infinite video stream to array.")
      }, e
    }(ab),
    _b = function () {},
    Fb = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Fy(e, t), e.prototype.split = function (t) {
        return new Mb(this, t)
      }, e
    }(ab),
    Mb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.impl = new zb(e, n), r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.impl.summary()
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            return [2, this.impl.next()]
          })
        })
      }, e
    }(Fb),
    zb = function (t) {
      function e(e, n) {
        var r = t.call(this) || this;
        return r.upstream = e, r.separator = n, r.carryover = "", r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Split('" + this.separator + "')"
      }, e.prototype.pump = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n, r, a;
          return zy(this, function (i) {
            switch (i.label) {
              case 0:
                return [4, this.upstream.next()];
              case 1:
                if ((t = i.sent()).done) return "" === this.carryover ? [2, !1] : (this.outputQueue.push(this.carryover), this.carryover = "", [2, !0]);
                for ((e = t.value.split(this.separator))[0] = this.carryover + e[0], n = 0, r = e.slice(0, -1); n < r.length; n++) a = r[n], this.outputQueue.push(a);
                return this.carryover = e[e.length - 1], [2, !0]
            }
          })
        })
      }, e
    }(mb),
    Lb = function (t) {
      function e() {
        return null !== t && t.apply(this, arguments) || this
      }
      return Fy(e, t), e.prototype.decodeUTF8 = function () {
        return new Bb(this)
      }, e
    }(ab),
    Bb = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        return n.upstream = e, n.impl = new Pb(e), n
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.impl.summary()
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            return [2, this.impl.next()]
          })
        })
      }, e
    }(Fb),
    Pb = function (t) {
      function e(e) {
        var n = t.call(this) || this;
        if (n.upstream = e, o().get("IS_BROWSER")) n.decoder = new TextDecoder("utf-8");
        else {
          var r = require("string_decoder").StringDecoder;
          n.decoder = new r("utf8")
        }
        return n
      }
      return Fy(e, t), e.prototype.summary = function () {
        return this.upstream.summary() + " -> Utf8"
      }, e.prototype.pump = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n;
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                return [4, this.upstream.next()];
              case 1:
                return (t = r.sent()).done ? [2, !1] : (e = t.value, n = o().get("IS_BROWSER") ? this.decoder.decode(e, {
                  stream: !0
                }) : this.decoder.write(Buffer.from(e.buffer)), this.outputQueue.push(n), [2, !0])
            }
          })
        })
      }, e
    }(mb),
    Wb = function (t) {
      function e(e, n) {
        void 0 === n && (n = {});
        var r = t.call(this) || this;
        return r.file = e, r.options = n, nt.assert(e instanceof Uint8Array || !!o().get("IS_BROWSER") && (e instanceof File || e instanceof Blob), function () {
          return "FileChunkIterator only supports File, Blob and Uint8Array right now."
        }), r.offset = n.offset || 0, r.chunkSize = n.chunkSize || 1048576, r
      }
      return Fy(e, t), e.prototype.summary = function () {
        return "FileChunks " + this.file
      }, e.prototype.next = function () {
        return My(this, void 0, void 0, function () {
          var t, e, n = this;
          return zy(this, function (r) {
            switch (r.label) {
              case 0:
                return this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size) ? [2, {
                  value: null,
                  done: !0
                }] : (t = new Promise(function (t, e) {
                  var r = n.offset + n.chunkSize;
                  if (n.file instanceof Uint8Array) t(new Uint8Array(n.file.slice(n.offset, r)));
                  else {
                    var a = new FileReader;
                    a.onload = function (n) {
                      var r = a.result;
                      if (r instanceof ArrayBuffer && (r = new Uint8Array(r)), !(r instanceof Uint8Array)) return e(new TypeError("FileReader returned unknown type."));
                      t(r)
                    }, a.onabort = function (t) {
                      return e(new Error("Aborted"))
                    }, a.onerror = function (t) {
                      return e(new Error(t.type))
                    };
                    var i = n.file.slice(n.offset, r);
                    a.readAsArrayBuffer(i)
                  }
                  n.offset = r
                }), e = {}, [4, t]);
              case 1:
                return [2, (e.value = r.sent(), e.done = !1, e)]
            }
          })
        })
      }, e
    }(Lb);
  var Vb = function (t) {
    return {
      method: t.method,
      headers: t.headers,
      body: t.body,
      mode: t.mode,
      credentials: t.credentials,
      cache: t.cache,
      redirect: t.redirect,
      referrer: t.referrer,
      integrity: t.integrity
    }
  };

  function Ub(t) {
    return "string" == typeof t && "file://" === t.substr(0, 7)
  }
  var jb = function (t) {
      function e(e, n) {
        void 0 === n && (n = {});
        var r = t.call(this) || this;
        return r.input = e, r.options = n, r
      }
      return Fy(e, t), e.prototype.iterator = function () {
        return My(this, void 0, void 0, function () {
          var t;
          return zy(this, function (e) {
            return Ub(this.input) && o().get("IS_NODE") && (t = require("fs"), this.input = t.readFileSync(this.input.substr(7))), [2, new Wb(this.input, this.options)]
          })
        })
      }, e
    }(_b),
    Gb = function (t) {
      function e(e, n) {
        void 0 === n && (n = {});
        var r = t.call(this) || this;
        return r.url = e, r.fileOptions = n, r
      }
      return Fy(e, t), e.prototype.iterator = function () {
        return My(this, void 0, void 0, function () {
          return zy(this, function (t) {
            return Ub(this.url) ? [2, new jb(this.url, this.fileOptions).iterator()] : [2, function (t, e) {
              return void 0 === e && (e = {}), My(this, void 0, void 0, function () {
                var n, r, a, i, o;
                return zy(this, function (s) {
                  switch (s.label) {
                    case 0:
                      return "string" == typeof t ? n = t : (n = t.url, r = Vb(t)), [4, nt.fetch(n, r)];
                    case 1:
                      return (a = s.sent()).ok ? (o = Uint8Array.bind, [4, a.arrayBuffer()]) : [3, 3];
                    case 2:
                      return i = new(o.apply(Uint8Array, [void 0, s.sent()])), [2, new Wb(i, e)];
                    case 3:
                      throw new Error(a.statusText)
                  }
                })
              })
            }(this.url, this.fileOptions)]
          })
        })
      }, e
    }(_b);
  var qb = Object.freeze({
      array: function (t) {
        var e = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            return zy(this, function (e) {
              return [2, eb(t)]
            })
          })
        }, t.length)
      },
      Dataset: wb,
      zip: function (t) {
        var e, n = this;
        if (!Yy(t)) throw new Error("The argument to zip() must be an object or array.");
        if (Array.isArray(t))
          for (var r = 0; r < t.length; r++) e = null == e ? t[r].size : Math.min(e, t[r].size);
        else if (t instanceof Object)
          for (var a in t) e = null == e ? t[a].size : Math.min(e, t[a].size);
        return Cb(function () {
          return My(n, void 0, void 0, function () {
            return zy(this, function (e) {
              switch (e.label) {
                case 0:
                  return [4, $y(t, function (t) {
                    if (t instanceof wb) return {
                      value: t.iterator(),
                      recurse: !1
                    };
                    if (Yy(t)) return {
                      value: null,
                      recurse: !0
                    };
                    throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")
                  })];
                case 1:
                  return [2, function (t, e) {
                    return void 0 === e && (e = rb.FAIL), new yb(t, e)
                  }(e.sent(), rb.SHORTEST)]
              }
            })
          })
        }, e)
      },
      CSVDataset: Tb,
      TextLineDataset: Sb,
      csv: function (t, e) {
        return void 0 === e && (e = {}), new Tb(new Gb(t), e)
      },
      func: function (t) {
        var e = this,
          n = nb(t);
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            return zy(this, function (t) {
              return [2, n]
            })
          })
        })
      },
      generator: function (t) {
        var e = this;
        return Cb(function () {
          return My(e, void 0, void 0, function () {
            var e;
            return zy(this, function (n) {
              switch (n.label) {
                case 0:
                  return [4, t()];
                case 1:
                  return e = n.sent(), [2, nb(function () {
                    return e.next()
                  })]
              }
            })
          })
        })
      },
      microphone: function (t) {
        return My(this, void 0, void 0, function () {
          return zy(this, function (e) {
            return [2, Db.create(t)]
          })
        })
      },
      webcam: function (t, e) {
        return My(this, void 0, void 0, function () {
          return zy(this, function (n) {
            return [2, Ob.create(t, e)]
          })
        })
      },
      FileDataSource: jb,
      URLDataSource: Gb,
      version_data: "1.5.1"
    }),
    Hb = {
      "tfjs-core": "1.5.1",
      "tfjs-data": "1.5.1",
      "tfjs-layers": "1.5.1",
      "tfjs-converter": "1.5.1",
      tfjs: "1.5.1"
    };
  t.data = qb, t.version = Hb, t.AdadeltaOptimizer = hp, t.AdagradOptimizer = fp, t.AdamOptimizer = dp, t.AdamaxOptimizer = mp, t.DataStorage = Ur, t.Environment = i, t.KernelBackend = jr, t.MomentumOptimizer = vp, t.Optimizer = pp, t.RMSPropOptimizer = yp, t.SGDOptimizer = gp, t.Tensor = mt, t.TensorBuffer = pt, t.Variable = xt, t.abs = uo, t.acos = lo, t.acosh = co, t.add = ls, t.addN = cs, t.addStrict = ps, t.all = Ru, t.any = Tu, t.argMax = Du, t.argMin = Ou, t.asin = po, t.asinh = ho, t.atan = fo, t.atan2 = hs, t.atanh = mo, t.avgPool = bu, t.avgPool3d = Cu, t.backend = je, t.backend_util = la, t.basicLSTMCell = $u, t.batchNorm = Qo, t.batchNorm2d = ts, t.batchNorm3d = es, t.batchNorm4d = ns, t.batchNormalization = Zo, t.batchNormalization2d = $o, t.batchNormalization3d = Yo, t.batchNormalization4d = Jo, t.batchToSpaceND = Kn, t.booleanMaskAsync = Ks, t.broadcastTo = Xn, t.browser = Qc, t.buffer = qn, t.cast = $n, t.ceil = go, t.clipByValue = vo, t.clone = Yn, t.complex = sn, t.concat = En, t.concat1d = An, t.concat2d = Rn, t.concat3d = Tn, t.concat4d = Dn, t.conv1d = Js, t.conv2d = Zs, t.conv2dTranspose = ou, t.conv3d = Qs, t.conv3dTranspose = su, t.cos = yo, t.cosh = bo, t.cumsum = Jn, t.customGrad = Br, t.deprecationWarn = Be, t.depthToSpace = Zn, t.depthwiseConv2d = nu, t.diag = ul, t.disableDeprecationWarnings = function () {
    o().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.")
  }, t.dispose = Ve, t.disposeVariables = function () {
    Dt.disposeVariables()
  }, t.div = fs, t.divNoNan = ds, t.divStrict = ms, t.dot = lu, t.dropout = ll, t.elu = Wu, t.enableDebugMode = function () {
    o().set("DEBUG", !0)
  }, t.enableProdMode = function () {
    o().set("PROD", !0)
  }, t.engine = function () {
    return Dt
  }, t.env = o, t.equal = Ds, t.equalStrict = Os, t.erf = xo, t.exp = wo, t.expandDims = Qn, t.expm1 = Co, t.eye = tr, t.fft = el, t.fill = Cn, t.findBackend = function (t) {
    return Dt.findBackend(t)
  }, t.findBackendFactory = function (t) {
    return Dt.findBackendFactory(t)
  }, t.floor = No, t.floorDiv = gs, t.frame = fl, t.fused = Hl, t.gather = qs, t.gatherND = sl, t.getBackend = function () {
    return Dt.backendName
  }, t.getGradient = c, t.getKernel = l, t.getKernelsForBackend = p, t.grad = function (t) {
    return b(q(t), function () {
        return "The f passed in grad(f) must be a function"
      }),
      function (e, n) {
        var r = Ke(e, "x", "tf.grad", null),
          a = null != n ? Ke(n, "dy", "tf.grad") : null;
        return Dt.tidy(function () {
          var e = Dt.gradients(function () {
              return t(r)
            }, [r], a),
            n = e.value,
            i = e.grads;
          return null != a && x(n.shape, a.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), Pr(i), i[0]
        })
      }
  }, t.grads = function (t) {
    return b(q(t), function () {
        return "The f passed in grads(f) must be a function"
      }),
      function (e, n) {
        b(Array.isArray(e), function () {
          return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"
        });
        var r = Xe(e, "args", "tf.grads", null),
          a = null != n ? Ke(n, "dy", "tf.grads") : null;
        return Dt.tidy(function () {
          var e = Dt.gradients(function () {
              return t.apply(void 0, r)
            }, r, a),
            n = e.value,
            i = e.grads;
          return null != a && x(n.shape, a.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), Pr(i), i
        })
      }
  }, t.greater = _s, t.greaterEqual = Fs, t.greaterEqualStrict = Ms, t.greaterStrict = zs, t.hammingWindow = hl, t.hannWindow = pl, t.ifft = nl, t.imag = ln, t.image = Bl, t.inTopKAsync = gl, t.io = $c, t.irfft = al, t.isFinite = Mo, t.isInf = Fo, t.isNaN = _o, t.keep = Ue, t.leakyRelu = Vu, t.less = Ls, t.lessEqual = Bs, t.lessEqualStrict = Ps, t.lessStrict = Ws, t.linalg = Dl, t.linspace = Nn, t.localResponseNormalization = Ku, t.log = So, t.log1p = ko, t.logSigmoid = Io, t.logSoftmax = Vr, t.logSumExp = _u, t.logicalAnd = rs, t.logicalNot = as, t.logicalOr = is, t.logicalXor = os, t.losses = Il, t.matMul = uu, t.math = Jc, t.max = Fu, t.maxPool = yu, t.maxPool3d = wu, t.maximum = vs, t.maximumStrict = ys, t.mean = Mu, t.memory = Pe, t.min = zu, t.minimum = bs, t.minimumStrict = xs, t.mod = ws, t.modStrict = Cs, t.moments = Lu, t.movingAverage = Ju, t.mul = Ns, t.mulStrict = Ss, t.multiRNNCell = Yu, t.multinomial = er, t.neg = Eo, t.nextFrame = Cp, t.norm = Xu, t.notEqual = Vs, t.notEqualStrict = Us, t.oneHot = nr, t.ones = xn, t.onesLike = kn, t.op = on, t.outerProduct = cu, t.pad = rr, t.pad1d = ar, t.pad2d = ir, t.pad3d = or, t.pad4d = sr, t.pool = xu, t.pow = ks, t.powStrict = Is, t.prelu = Uu, t.print = Hn, t.prod = Pu, t.profile = function (t) {
    return Dt.profile(t)
  }, t.rand = ur, t.randomGamma = cr, t.randomNormal = lr, t.randomUniform = pr, t.range = Sn, t.ready = function () {
    return Dt.ready()
  }, t.real = un, t.reciprocal = Ao, t.registerBackend = function (t, e, n) {
    return void 0 === n && (n = 1), Dt.registerBackend(t, e, n)
  }, t.registerGradient = f, t.registerKernel = h, t.relu = ju, t.relu6 = Gu, t.removeBackend = function (t) {
    Dt.removeBackend(t)
  }, t.reshape = hr, t.reverse = pu, t.reverse1d = hu, t.reverse2d = fu, t.reverse3d = du, t.reverse4d = mu, t.rfft = rl, t.round = Ro, t.rsqrt = To, t.scalar = hn, t.scatterND = tl, t.selu = qu, t.separableConv2d = iu, t.serialization = rp, t.setBackend = function (t) {
    return Dt.setBackend(t)
  }, t.setPlatform = function (t, e) {
    o().setPlatform(t, e)
  }, t.setdiff1dAsync = br, t.sigmoid = Do, t.sign = Oo, t.signal = ml, t.sin = zo, t.sinh = Lo, t.slice = Nu, t.slice1d = Su, t.slice2d = ku, t.slice3d = Iu, t.slice4d = Eu, t.slice_util = zr, t.softmax = Wr, t.softplus = Bo, t.spaceToBatchND = fr, t.sparseToDense = ol, t.spectral = il, t.split = On, t.sqrt = Po, t.square = so, t.squaredDifference = Es, t.squaredDifferenceStrict = As, t.squeeze = dr, t.stack = mr, t.step = Wo, t.stft = dl, t.stridedSlice = Zu, t.sub = Rs, t.subStrict = Ts, t.sum = Bu, t.tan = Vo, t.tanh = Uo, t.tensor = cn, t.tensor1d = fn, t.tensor2d = dn, t.tensor3d = mn, t.tensor4d = gn, t.tensor5d = vn, t.tensor6d = yn, t.tensor_util = At, t.test_util = lp, t.tidy = We, t.tile = gr, t.time = function (t) {
    return Dt.time(t)
  }, t.topk = Qu, t.train = xp, t.transpose = Hu, t.truncatedNormal = vr, t.unregisterGradient = function (t) {
    if (!u.has(t)) throw new Error("The gradient '" + t + "' for backend is not registered");
    u.delete(t)
  }, t.unregisterKernel = function (t, e) {
    var n = d(t, e);
    if (!s.has(n)) throw new Error("The kernel '" + t + "' for backend '" + e + "' is not registered");
    s.delete(n)
  }, t.unsortedSegmentSum = Hs, t.unstack = yr, t.util = nt, t.valueAndGrad = function (t) {
    return b(q(t), function () {
        return "The f passed in valueAndGrad(f) must be a function"
      }),
      function (e, n) {
        b(e instanceof mt, function () {
          return "The x passed in valueAndGrad(f)(x) must be a tensor"
        }), b(null == n || n instanceof mt, function () {
          return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor"
        });
        var r = Dt.gradients(function () {
            return t(e)
          }, [e], n),
          a = r.grads,
          i = r.value;
        return Pr(a), {
          grad: a[0],
          value: i
        }
      }
  }, t.valueAndGrads = function (t) {
    return b(q(t), function () {
        return "The f passed in valueAndGrads(f) must be a function"
      }),
      function (e, n) {
        b(Array.isArray(e) && e.every(function (t) {
          return t instanceof mt
        }), function () {
          return "The args passed in valueAndGrads(f)(args) must be array of tensors"
        }), b(null == n || n instanceof mt, function () {
          return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor"
        });
        var r = Dt.gradients(function () {
          return t.apply(void 0, e)
        }, e, n);
        return null != n && x(r.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), Pr(r.grads), r
      }
  }, t.variable = bn, t.variableGrads = Lr, t.version_core = "1.5.1", t.webgl = cp, t.where = ss, t.whereAsync = us, t.zeros = wn, t.zerosLike = In, t.constraints = uh, t.initializers = mf, t.layers = uv, t.metrics = lv, t.models = cv, t.regularizers = pv, t.CallbackList = Uf, t.CustomCallback = qf, t.History = Gf, t.Callback = hv, t.callbacks = yv, t.EarlyStopping = mv, t.InputSpec = Rf, t.SymbolicTensor = Tf, t.LayersModel = Yd, t.input = Qd, t.loadLayersModel = function (t, e) {
    return null == e && (e = {}), Jd(t, e)
  }, t.model = function (t) {
    return new Yd(t)
  }, t.registerCallbackConstructor = function (t, e) {
    Kf.registerCallbackConstructor(t, e)
  }, t.sequential = function (t) {
    return new Zd(t)
  }, t.RNN = Lg, t.Sequential = Zd, t.LayerVariable = If, t.version_layers = "1.5.1", t.GraphModel = Oy, t.loadGraphModel = function (t, e) {
    return void 0 === e && (e = {}), xv(this, void 0, void 0, function () {
      var n;
      return wv(this, function (r) {
        switch (r.label) {
          case 0:
            if (null == t) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
            return null == e && (e = {}), e.fromTFHub && null == t.load && (t.endsWith("/") || (t += "/"), t = "" + t + Dy + Ty), [4, (n = new Oy(t, e)).load()];
          case 1:
            return r.sent(), [2, n]
        }
      })
    })
  }, t.deregisterOp = function (t) {
    delete Cv[t]
  }, t.registerOp = function (t, e) {
    var n = {
      tfOpName: t,
      category: "custom",
      inputs: [],
      attrs: [],
      customExecutor: e
    };
    Cv[t] = n
  }, t.version_converter = "1.5.1", Object.defineProperty(t, "__esModule", {
    value: !0
  })
});
//# sourceMappingURL=tf.min.js.map
! function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.stringSimilarity = e() : t.stringSimilarity = e()
}(window, (function () {
  return function (t) {
    var e = {};

    function n(r) {
      if (e[r]) return e[r].exports;
      var o = e[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return t[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports
    }
    return n.m = t, n.c = e, n.d = function (t, e, r) {
      n.o(t, e) || Object.defineProperty(t, e, {
        enumerable: !0,
        get: r
      })
    }, n.r = function (t) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(t, "__esModule", {
        value: !0
      })
    }, n.t = function (t, e) {
      if (1 & e && (t = n(t)), 8 & e) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var r = Object.create(null);
      if (n.r(r), Object.defineProperty(r, "default", {
          enumerable: !0,
          value: t
        }), 2 & e && "string" != typeof t)
        for (var o in t) n.d(r, o, function (e) {
          return t[e]
        }.bind(null, o));
      return r
    }, n.n = function (t) {
      var e = t && t.__esModule ? function () {
        return t.default
      } : function () {
        return t
      };
      return n.d(e, "a", e), e
    }, n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e)
    }, n.p = "", n(n.s = 0)
  }([function (t, e) {
    function n(t, e) {
      if (t = t.replace(/\s+/g, ""), e = e.replace(/\s+/g, ""), !t.length && !e.length) return 1;
      if (!t.length || !e.length) return 0;
      if (t === e) return 1;
      if (1 === t.length && 1 === e.length) return 0;
      if (t.length < 2 || e.length < 2) return 0;
      let n = new Map;
      for (let e = 0; e < t.length - 1; e++) {
        const r = t.substring(e, e + 2),
          o = n.has(r) ? n.get(r) + 1 : 1;
        n.set(r, o)
      }
      let r = 0;
      for (let t = 0; t < e.length - 1; t++) {
        const o = e.substring(t, t + 2),
          i = n.has(o) ? n.get(o) : 0;
        i > 0 && (n.set(o, i - 1), r++)
      }
      return 2 * r / (t.length + e.length - 2)
    }
    t.exports = {
      compareTwoStrings: n,
      findBestMatch: function (t, e) {
        if (! function (t, e) {
            return "string" == typeof t && (!!Array.isArray(e) && (!!e.length && !e.find(t => "string" != typeof t)))
          }(t, e)) throw new Error("Bad arguments: First argument should be a string, second should be an array of strings");
        const r = [];
        let o = 0;
        for (let i = 0; i < e.length; i++) {
          const u = e[i],
            f = n(t, u);
          r.push({
            target: u,
            rating: f
          }), f > r[o].rating && (o = i)
        }
        const i = r[o];
        return {
          ratings: r,
          bestMatch: i,
          bestMatchIndex: o
        }
      }
    }
  }])
}));
/*
 * jsrsasign(all) 8.0.24 (2020-08-18) (c) 2010-2020 Kenji Urushima | kjur.github.com/jsrsasign/license
 */

/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
if (YAHOO === undefined) {
  var YAHOO = {}
}
YAHOO.lang = {
  extend: function (g, h, f) {
    if (!h || !g) {
      throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.")
    }
    var d = function () {};
    d.prototype = h.prototype;
    g.prototype = new d();
    g.prototype.constructor = g;
    g.superclass = h.prototype;
    if (h.prototype.constructor == Object.prototype.constructor) {
      h.prototype.constructor = h
    }
    if (f) {
      var b;
      for (b in f) {
        g.prototype[b] = f[b]
      }
      var e = function () {},
        c = ["toString", "valueOf"];
      try {
        if (/MSIE/.test(navigator.userAgent)) {
          e = function (j, i) {
            for (b = 0; b < c.length; b = b + 1) {
              var l = c[b],
                k = i[l];
              if (typeof k === "function" && k != Object.prototype[l]) {
                j[l] = k
              }
            }
          }
        }
      } catch (a) {}
      e(g.prototype, f)
    }
  }
};

/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
var CryptoJS = CryptoJS || (function (e, g) {
  var a = {};
  var b = a.lib = {};
  var j = b.Base = (function () {
    function n() {}
    return {
      extend: function (p) {
        n.prototype = this;
        var o = new n();
        if (p) {
          o.mixIn(p)
        }
        if (!o.hasOwnProperty("init")) {
          o.init = function () {
            o.$super.init.apply(this, arguments)
          }
        }
        o.init.prototype = o;
        o.$super = this;
        return o
      },
      create: function () {
        var o = this.extend();
        o.init.apply(o, arguments);
        return o
      },
      init: function () {},
      mixIn: function (p) {
        for (var o in p) {
          if (p.hasOwnProperty(o)) {
            this[o] = p[o]
          }
        }
        if (p.hasOwnProperty("toString")) {
          this.toString = p.toString
        }
      },
      clone: function () {
        return this.init.prototype.extend(this)
      }
    }
  }());
  var l = b.WordArray = j.extend({
    init: function (o, n) {
      o = this.words = o || [];
      if (n != g) {
        this.sigBytes = n
      } else {
        this.sigBytes = o.length * 4
      }
    },
    toString: function (n) {
      return (n || h).stringify(this)
    },
    concat: function (t) {
      var q = this.words;
      var p = t.words;
      var n = this.sigBytes;
      var s = t.sigBytes;
      this.clamp();
      if (n % 4) {
        for (var r = 0; r < s; r++) {
          var o = (p[r >>> 2] >>> (24 - (r % 4) * 8)) & 255;
          q[(n + r) >>> 2] |= o << (24 - ((n + r) % 4) * 8)
        }
      } else {
        for (var r = 0; r < s; r += 4) {
          q[(n + r) >>> 2] = p[r >>> 2]
        }
      }
      this.sigBytes += s;
      return this
    },
    clamp: function () {
      var o = this.words;
      var n = this.sigBytes;
      o[n >>> 2] &= 4294967295 << (32 - (n % 4) * 8);
      o.length = e.ceil(n / 4)
    },
    clone: function () {
      var n = j.clone.call(this);
      n.words = this.words.slice(0);
      return n
    },
    random: function (p) {
      var o = [];
      for (var n = 0; n < p; n += 4) {
        o.push((e.random() * 4294967296) | 0)
      }
      return new l.init(o, p)
    }
  });
  var m = a.enc = {};
  var h = m.Hex = {
    stringify: function (p) {
      var r = p.words;
      var o = p.sigBytes;
      var q = [];
      for (var n = 0; n < o; n++) {
        var s = (r[n >>> 2] >>> (24 - (n % 4) * 8)) & 255;
        q.push((s >>> 4).toString(16));
        q.push((s & 15).toString(16))
      }
      return q.join("")
    },
    parse: function (p) {
      var n = p.length;
      var q = [];
      for (var o = 0; o < n; o += 2) {
        q[o >>> 3] |= parseInt(p.substr(o, 2), 16) << (24 - (o % 8) * 4)
      }
      return new l.init(q, n / 2)
    }
  };
  var d = m.Latin1 = {
    stringify: function (q) {
      var r = q.words;
      var p = q.sigBytes;
      var n = [];
      for (var o = 0; o < p; o++) {
        var s = (r[o >>> 2] >>> (24 - (o % 4) * 8)) & 255;
        n.push(String.fromCharCode(s))
      }
      return n.join("")
    },
    parse: function (p) {
      var n = p.length;
      var q = [];
      for (var o = 0; o < n; o++) {
        q[o >>> 2] |= (p.charCodeAt(o) & 255) << (24 - (o % 4) * 8)
      }
      return new l.init(q, n)
    }
  };
  var c = m.Utf8 = {
    stringify: function (n) {
      try {
        return decodeURIComponent(escape(d.stringify(n)))
      } catch (o) {
        throw new Error("Malformed UTF-8 data")
      }
    },
    parse: function (n) {
      return d.parse(unescape(encodeURIComponent(n)))
    }
  };
  var i = b.BufferedBlockAlgorithm = j.extend({
    reset: function () {
      this._data = new l.init();
      this._nDataBytes = 0
    },
    _append: function (n) {
      if (typeof n == "string") {
        n = c.parse(n)
      }
      this._data.concat(n);
      this._nDataBytes += n.sigBytes
    },
    _process: function (w) {
      var q = this._data;
      var x = q.words;
      var n = q.sigBytes;
      var t = this.blockSize;
      var v = t * 4;
      var u = n / v;
      if (w) {
        u = e.ceil(u)
      } else {
        u = e.max((u | 0) - this._minBufferSize, 0)
      }
      var s = u * t;
      var r = e.min(s * 4, n);
      if (s) {
        for (var p = 0; p < s; p += t) {
          this._doProcessBlock(x, p)
        }
        var o = x.splice(0, s);
        q.sigBytes -= r
      }
      return new l.init(o, r)
    },
    clone: function () {
      var n = j.clone.call(this);
      n._data = this._data.clone();
      return n
    },
    _minBufferSize: 0
  });
  var f = b.Hasher = i.extend({
    cfg: j.extend(),
    init: function (n) {
      this.cfg = this.cfg.extend(n);
      this.reset()
    },
    reset: function () {
      i.reset.call(this);
      this._doReset()
    },
    update: function (n) {
      this._append(n);
      this._process();
      return this
    },
    finalize: function (n) {
      if (n) {
        this._append(n)
      }
      var o = this._doFinalize();
      return o
    },
    blockSize: 512 / 32,
    _createHelper: function (n) {
      return function (p, o) {
        return new n.init(o).finalize(p)
      }
    },
    _createHmacHelper: function (n) {
      return function (p, o) {
        return new k.HMAC.init(n, o).finalize(p)
      }
    }
  });
  var k = a.algo = {};
  return a
}(Math));
/*
CryptoJS v3.1.2 x64-core-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (g) {
  var a = CryptoJS,
    f = a.lib,
    e = f.Base,
    h = f.WordArray,
    a = a.x64 = {};
  a.Word = e.extend({
    init: function (b, c) {
      this.high = b;
      this.low = c
    }
  });
  a.WordArray = e.extend({
    init: function (b, c) {
      b = this.words = b || [];
      this.sigBytes = c != g ? c : 8 * b.length
    },
    toX32: function () {
      for (var b = this.words, c = b.length, a = [], d = 0; d < c; d++) {
        var e = b[d];
        a.push(e.high);
        a.push(e.low)
      }
      return h.create(a, this.sigBytes)
    },
    clone: function () {
      for (var b = e.clone.call(this), c = b.words = this.words.slice(0), a = c.length, d = 0; d < a; d++) c[d] = c[d].clone();
      return b
    }
  })
})();

/*
CryptoJS v3.1.2 cipher-core.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
CryptoJS.lib.Cipher || function (u) {
  var g = CryptoJS,
    f = g.lib,
    k = f.Base,
    l = f.WordArray,
    q = f.BufferedBlockAlgorithm,
    r = g.enc.Base64,
    v = g.algo.EvpKDF,
    n = f.Cipher = q.extend({
      cfg: k.extend(),
      createEncryptor: function (a, b) {
        return this.create(this._ENC_XFORM_MODE, a, b)
      },
      createDecryptor: function (a, b) {
        return this.create(this._DEC_XFORM_MODE, a, b)
      },
      init: function (a, b, c) {
        this.cfg = this.cfg.extend(c);
        this._xformMode = a;
        this._key = b;
        this.reset()
      },
      reset: function () {
        q.reset.call(this);
        this._doReset()
      },
      process: function (a) {
        this._append(a);
        return this._process()
      },
      finalize: function (a) {
        a && this._append(a);
        return this._doFinalize()
      },
      keySize: 4,
      ivSize: 4,
      _ENC_XFORM_MODE: 1,
      _DEC_XFORM_MODE: 2,
      _createHelper: function (a) {
        return {
          encrypt: function (b, c, d) {
            return ("string" == typeof c ? s : j).encrypt(a, b, c, d)
          },
          decrypt: function (b, c, d) {
            return ("string" == typeof c ? s : j).decrypt(a, b, c, d)
          }
        }
      }
    });
  f.StreamCipher = n.extend({
    _doFinalize: function () {
      return this._process(!0)
    },
    blockSize: 1
  });
  var m = g.mode = {},
    t = function (a, b, c) {
      var d = this._iv;
      d ? this._iv = u : d = this._prevBlock;
      for (var e =
          0; e < c; e++) a[b + e] ^= d[e]
    },
    h = (f.BlockCipherMode = k.extend({
      createEncryptor: function (a, b) {
        return this.Encryptor.create(a, b)
      },
      createDecryptor: function (a, b) {
        return this.Decryptor.create(a, b)
      },
      init: function (a, b) {
        this._cipher = a;
        this._iv = b
      }
    })).extend();
  h.Encryptor = h.extend({
    processBlock: function (a, b) {
      var c = this._cipher,
        d = c.blockSize;
      t.call(this, a, b, d);
      c.encryptBlock(a, b);
      this._prevBlock = a.slice(b, b + d)
    }
  });
  h.Decryptor = h.extend({
    processBlock: function (a, b) {
      var c = this._cipher,
        d = c.blockSize,
        e = a.slice(b, b + d);
      c.decryptBlock(a,
        b);
      t.call(this, a, b, d);
      this._prevBlock = e
    }
  });
  m = m.CBC = h;
  h = (g.pad = {}).Pkcs7 = {
    pad: function (a, b) {
      for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, e = [], f = 0; f < c; f += 4) e.push(d);
      c = l.create(e, c);
      a.concat(c)
    },
    unpad: function (a) {
      a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255
    }
  };
  f.BlockCipher = n.extend({
    cfg: n.cfg.extend({
      mode: m,
      padding: h
    }),
    reset: function () {
      n.reset.call(this);
      var a = this.cfg,
        b = a.iv,
        a = a.mode;
      if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;
      else c = a.createDecryptor, this._minBufferSize = 1;
      this._mode = c.call(a, this, b && b.words)
    },
    _doProcessBlock: function (a, b) {
      this._mode.processBlock(a, b)
    },
    _doFinalize: function () {
      var a = this.cfg.padding;
      if (this._xformMode == this._ENC_XFORM_MODE) {
        a.pad(this._data, this.blockSize);
        var b = this._process(!0)
      } else b = this._process(!0), a.unpad(b);
      return b
    },
    blockSize: 4
  });
  var p = f.CipherParams = k.extend({
      init: function (a) {
        this.mixIn(a)
      },
      toString: function (a) {
        return (a || this.formatter).stringify(this)
      }
    }),
    m = (g.format = {}).OpenSSL = {
      stringify: function (a) {
        var b = a.ciphertext;
        a = a.salt;
        return (a ? l.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(r)
      },
      parse: function (a) {
        a = r.parse(a);
        var b = a.words;
        if (1398893684 == b[0] && 1701076831 == b[1]) {
          var c = l.create(b.slice(2, 4));
          b.splice(0, 4);
          a.sigBytes -= 16
        }
        return p.create({
          ciphertext: a,
          salt: c
        })
      }
    },
    j = f.SerializableCipher = k.extend({
      cfg: k.extend({
        format: m
      }),
      encrypt: function (a, b, c, d) {
        d = this.cfg.extend(d);
        var e = a.createEncryptor(c, d);
        b = e.finalize(b);
        e = e.cfg;
        return p.create({
          ciphertext: b,
          key: c,
          iv: e.iv,
          algorithm: a,
          mode: e.mode,
          padding: e.padding,
          blockSize: a.blockSize,
          formatter: d.format
        })
      },
      decrypt: function (a, b, c, d) {
        d = this.cfg.extend(d);
        b = this._parse(b, d.format);
        return a.createDecryptor(c, d).finalize(b.ciphertext)
      },
      _parse: function (a, b) {
        return "string" == typeof a ? b.parse(a, this) : a
      }
    }),
    g = (g.kdf = {}).OpenSSL = {
      execute: function (a, b, c, d) {
        d || (d = l.random(8));
        a = v.create({
          keySize: b + c
        }).compute(a, d);
        c = l.create(a.words.slice(b), 4 * c);
        a.sigBytes = 4 * b;
        return p.create({
          key: a,
          iv: c,
          salt: d
        })
      }
    },
    s = f.PasswordBasedCipher = j.extend({
      cfg: j.cfg.extend({
        kdf: g
      }),
      encrypt: function (a,
        b, c, d) {
        d = this.cfg.extend(d);
        c = d.kdf.execute(c, a.keySize, a.ivSize);
        d.iv = c.iv;
        a = j.encrypt.call(this, a, b, c.key, d);
        a.mixIn(c);
        return a
      },
      decrypt: function (a, b, c, d) {
        d = this.cfg.extend(d);
        b = this._parse(b, d.format);
        c = d.kdf.execute(c, a.keySize, a.ivSize, b.salt);
        d.iv = c.iv;
        return j.decrypt.call(this, a, b, c.key, d)
      }
    })
}();

/*
CryptoJS v3.1.2 aes.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  for (var q = CryptoJS, x = q.lib.BlockCipher, r = q.algo, j = [], y = [], z = [], A = [], B = [], C = [], s = [], u = [], v = [], w = [], g = [], k = 0; 256 > k; k++) g[k] = 128 > k ? k << 1 : k << 1 ^ 283;
  for (var n = 0, l = 0, k = 0; 256 > k; k++) {
    var f = l ^ l << 1 ^ l << 2 ^ l << 3 ^ l << 4,
      f = f >>> 8 ^ f & 255 ^ 99;
    j[n] = f;
    y[f] = n;
    var t = g[n],
      D = g[t],
      E = g[D],
      b = 257 * g[f] ^ 16843008 * f;
    z[n] = b << 24 | b >>> 8;
    A[n] = b << 16 | b >>> 16;
    B[n] = b << 8 | b >>> 24;
    C[n] = b;
    b = 16843009 * E ^ 65537 * D ^ 257 * t ^ 16843008 * n;
    s[f] = b << 24 | b >>> 8;
    u[f] = b << 16 | b >>> 16;
    v[f] = b << 8 | b >>> 24;
    w[f] = b;
    n ? (n = t ^ g[g[g[E ^ t]]], l ^= g[g[l]]) : n = l = 1
  }
  var F = [0, 1, 2, 4, 8,
      16, 32, 64, 128, 27, 54
    ],
    r = r.AES = x.extend({
      _doReset: function () {
        for (var c = this._key, e = c.words, a = c.sigBytes / 4, c = 4 * ((this._nRounds = a + 6) + 1), b = this._keySchedule = [], h = 0; h < c; h++)
          if (h < a) b[h] = e[h];
          else {
            var d = b[h - 1];
            h % a ? 6 < a && 4 == h % a && (d = j[d >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[d & 255]) : (d = d << 8 | d >>> 24, d = j[d >>> 24] << 24 | j[d >>> 16 & 255] << 16 | j[d >>> 8 & 255] << 8 | j[d & 255], d ^= F[h / a | 0] << 24);
            b[h] = b[h - a] ^ d
          } e = this._invKeySchedule = [];
        for (a = 0; a < c; a++) h = c - a, d = a % 4 ? b[h] : b[h - 4], e[a] = 4 > a || 4 >= h ? d : s[j[d >>> 24]] ^ u[j[d >>> 16 & 255]] ^ v[j[d >>>
          8 & 255]] ^ w[j[d & 255]]
      },
      encryptBlock: function (c, e) {
        this._doCryptBlock(c, e, this._keySchedule, z, A, B, C, j)
      },
      decryptBlock: function (c, e) {
        var a = c[e + 1];
        c[e + 1] = c[e + 3];
        c[e + 3] = a;
        this._doCryptBlock(c, e, this._invKeySchedule, s, u, v, w, y);
        a = c[e + 1];
        c[e + 1] = c[e + 3];
        c[e + 3] = a
      },
      _doCryptBlock: function (c, e, a, b, h, d, j, m) {
        for (var n = this._nRounds, f = c[e] ^ a[0], g = c[e + 1] ^ a[1], k = c[e + 2] ^ a[2], p = c[e + 3] ^ a[3], l = 4, t = 1; t < n; t++) var q = b[f >>> 24] ^ h[g >>> 16 & 255] ^ d[k >>> 8 & 255] ^ j[p & 255] ^ a[l++],
          r = b[g >>> 24] ^ h[k >>> 16 & 255] ^ d[p >>> 8 & 255] ^ j[f & 255] ^ a[l++],
          s =
          b[k >>> 24] ^ h[p >>> 16 & 255] ^ d[f >>> 8 & 255] ^ j[g & 255] ^ a[l++],
          p = b[p >>> 24] ^ h[f >>> 16 & 255] ^ d[g >>> 8 & 255] ^ j[k & 255] ^ a[l++],
          f = q,
          g = r,
          k = s;
        q = (m[f >>> 24] << 24 | m[g >>> 16 & 255] << 16 | m[k >>> 8 & 255] << 8 | m[p & 255]) ^ a[l++];
        r = (m[g >>> 24] << 24 | m[k >>> 16 & 255] << 16 | m[p >>> 8 & 255] << 8 | m[f & 255]) ^ a[l++];
        s = (m[k >>> 24] << 24 | m[p >>> 16 & 255] << 16 | m[f >>> 8 & 255] << 8 | m[g & 255]) ^ a[l++];
        p = (m[p >>> 24] << 24 | m[f >>> 16 & 255] << 16 | m[g >>> 8 & 255] << 8 | m[k & 255]) ^ a[l++];
        c[e] = q;
        c[e + 1] = r;
        c[e + 2] = s;
        c[e + 3] = p
      },
      keySize: 8
    });
  q.AES = x._createHelper(r)
})();

/*
CryptoJS v3.1.2 tripledes-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  function j(b, c) {
    var a = (this._lBlock >>> b ^ this._rBlock) & c;
    this._rBlock ^= a;
    this._lBlock ^= a << b
  }

  function l(b, c) {
    var a = (this._rBlock >>> b ^ this._lBlock) & c;
    this._lBlock ^= a;
    this._rBlock ^= a << b
  }
  var h = CryptoJS,
    e = h.lib,
    n = e.WordArray,
    e = e.BlockCipher,
    g = h.algo,
    q = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
    p = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47,
      55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
    ],
    r = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
    s = [{
      "0": 8421888,
      268435456: 32768,
      536870912: 8421378,
      805306368: 2,
      1073741824: 512,
      1342177280: 8421890,
      1610612736: 8389122,
      1879048192: 8388608,
      2147483648: 514,
      2415919104: 8389120,
      2684354560: 33280,
      2952790016: 8421376,
      3221225472: 32770,
      3489660928: 8388610,
      3758096384: 0,
      4026531840: 33282,
      134217728: 0,
      402653184: 8421890,
      671088640: 33282,
      939524096: 32768,
      1207959552: 8421888,
      1476395008: 512,
      1744830464: 8421378,
      2013265920: 2,
      2281701376: 8389120,
      2550136832: 33280,
      2818572288: 8421376,
      3087007744: 8389122,
      3355443200: 8388610,
      3623878656: 32770,
      3892314112: 514,
      4160749568: 8388608,
      1: 32768,
      268435457: 2,
      536870913: 8421888,
      805306369: 8388608,
      1073741825: 8421378,
      1342177281: 33280,
      1610612737: 512,
      1879048193: 8389122,
      2147483649: 8421890,
      2415919105: 8421376,
      2684354561: 8388610,
      2952790017: 33282,
      3221225473: 514,
      3489660929: 8389120,
      3758096385: 32770,
      4026531841: 0,
      134217729: 8421890,
      402653185: 8421376,
      671088641: 8388608,
      939524097: 512,
      1207959553: 32768,
      1476395009: 8388610,
      1744830465: 2,
      2013265921: 33282,
      2281701377: 32770,
      2550136833: 8389122,
      2818572289: 514,
      3087007745: 8421888,
      3355443201: 8389120,
      3623878657: 0,
      3892314113: 33280,
      4160749569: 8421378
    }, {
      "0": 1074282512,
      16777216: 16384,
      33554432: 524288,
      50331648: 1074266128,
      67108864: 1073741840,
      83886080: 1074282496,
      100663296: 1073758208,
      117440512: 16,
      134217728: 540672,
      150994944: 1073758224,
      167772160: 1073741824,
      184549376: 540688,
      201326592: 524304,
      218103808: 0,
      234881024: 16400,
      251658240: 1074266112,
      8388608: 1073758208,
      25165824: 540688,
      41943040: 16,
      58720256: 1073758224,
      75497472: 1074282512,
      92274688: 1073741824,
      109051904: 524288,
      125829120: 1074266128,
      142606336: 524304,
      159383552: 0,
      176160768: 16384,
      192937984: 1074266112,
      209715200: 1073741840,
      226492416: 540672,
      243269632: 1074282496,
      260046848: 16400,
      268435456: 0,
      285212672: 1074266128,
      301989888: 1073758224,
      318767104: 1074282496,
      335544320: 1074266112,
      352321536: 16,
      369098752: 540688,
      385875968: 16384,
      402653184: 16400,
      419430400: 524288,
      436207616: 524304,
      452984832: 1073741840,
      469762048: 540672,
      486539264: 1073758208,
      503316480: 1073741824,
      520093696: 1074282512,
      276824064: 540688,
      293601280: 524288,
      310378496: 1074266112,
      327155712: 16384,
      343932928: 1073758208,
      360710144: 1074282512,
      377487360: 16,
      394264576: 1073741824,
      411041792: 1074282496,
      427819008: 1073741840,
      444596224: 1073758224,
      461373440: 524304,
      478150656: 0,
      494927872: 16400,
      511705088: 1074266128,
      528482304: 540672
    }, {
      "0": 260,
      1048576: 0,
      2097152: 67109120,
      3145728: 65796,
      4194304: 65540,
      5242880: 67108868,
      6291456: 67174660,
      7340032: 67174400,
      8388608: 67108864,
      9437184: 67174656,
      10485760: 65792,
      11534336: 67174404,
      12582912: 67109124,
      13631488: 65536,
      14680064: 4,
      15728640: 256,
      524288: 67174656,
      1572864: 67174404,
      2621440: 0,
      3670016: 67109120,
      4718592: 67108868,
      5767168: 65536,
      6815744: 65540,
      7864320: 260,
      8912896: 4,
      9961472: 256,
      11010048: 67174400,
      12058624: 65796,
      13107200: 65792,
      14155776: 67109124,
      15204352: 67174660,
      16252928: 67108864,
      16777216: 67174656,
      17825792: 65540,
      18874368: 65536,
      19922944: 67109120,
      20971520: 256,
      22020096: 67174660,
      23068672: 67108868,
      24117248: 0,
      25165824: 67109124,
      26214400: 67108864,
      27262976: 4,
      28311552: 65792,
      29360128: 67174400,
      30408704: 260,
      31457280: 65796,
      32505856: 67174404,
      17301504: 67108864,
      18350080: 260,
      19398656: 67174656,
      20447232: 0,
      21495808: 65540,
      22544384: 67109120,
      23592960: 256,
      24641536: 67174404,
      25690112: 65536,
      26738688: 67174660,
      27787264: 65796,
      28835840: 67108868,
      29884416: 67109124,
      30932992: 67174400,
      31981568: 4,
      33030144: 65792
    }, {
      "0": 2151682048,
      65536: 2147487808,
      131072: 4198464,
      196608: 2151677952,
      262144: 0,
      327680: 4198400,
      393216: 2147483712,
      458752: 4194368,
      524288: 2147483648,
      589824: 4194304,
      655360: 64,
      720896: 2147487744,
      786432: 2151678016,
      851968: 4160,
      917504: 4096,
      983040: 2151682112,
      32768: 2147487808,
      98304: 64,
      163840: 2151678016,
      229376: 2147487744,
      294912: 4198400,
      360448: 2151682112,
      425984: 0,
      491520: 2151677952,
      557056: 4096,
      622592: 2151682048,
      688128: 4194304,
      753664: 4160,
      819200: 2147483648,
      884736: 4194368,
      950272: 4198464,
      1015808: 2147483712,
      1048576: 4194368,
      1114112: 4198400,
      1179648: 2147483712,
      1245184: 0,
      1310720: 4160,
      1376256: 2151678016,
      1441792: 2151682048,
      1507328: 2147487808,
      1572864: 2151682112,
      1638400: 2147483648,
      1703936: 2151677952,
      1769472: 4198464,
      1835008: 2147487744,
      1900544: 4194304,
      1966080: 64,
      2031616: 4096,
      1081344: 2151677952,
      1146880: 2151682112,
      1212416: 0,
      1277952: 4198400,
      1343488: 4194368,
      1409024: 2147483648,
      1474560: 2147487808,
      1540096: 64,
      1605632: 2147483712,
      1671168: 4096,
      1736704: 2147487744,
      1802240: 2151678016,
      1867776: 4160,
      1933312: 2151682048,
      1998848: 4194304,
      2064384: 4198464
    }, {
      "0": 128,
      4096: 17039360,
      8192: 262144,
      12288: 536870912,
      16384: 537133184,
      20480: 16777344,
      24576: 553648256,
      28672: 262272,
      32768: 16777216,
      36864: 537133056,
      40960: 536871040,
      45056: 553910400,
      49152: 553910272,
      53248: 0,
      57344: 17039488,
      61440: 553648128,
      2048: 17039488,
      6144: 553648256,
      10240: 128,
      14336: 17039360,
      18432: 262144,
      22528: 537133184,
      26624: 553910272,
      30720: 536870912,
      34816: 537133056,
      38912: 0,
      43008: 553910400,
      47104: 16777344,
      51200: 536871040,
      55296: 553648128,
      59392: 16777216,
      63488: 262272,
      65536: 262144,
      69632: 128,
      73728: 536870912,
      77824: 553648256,
      81920: 16777344,
      86016: 553910272,
      90112: 537133184,
      94208: 16777216,
      98304: 553910400,
      102400: 553648128,
      106496: 17039360,
      110592: 537133056,
      114688: 262272,
      118784: 536871040,
      122880: 0,
      126976: 17039488,
      67584: 553648256,
      71680: 16777216,
      75776: 17039360,
      79872: 537133184,
      83968: 536870912,
      88064: 17039488,
      92160: 128,
      96256: 553910272,
      100352: 262272,
      104448: 553910400,
      108544: 0,
      112640: 553648128,
      116736: 16777344,
      120832: 262144,
      124928: 537133056,
      129024: 536871040
    }, {
      "0": 268435464,
      256: 8192,
      512: 270532608,
      768: 270540808,
      1024: 268443648,
      1280: 2097152,
      1536: 2097160,
      1792: 268435456,
      2048: 0,
      2304: 268443656,
      2560: 2105344,
      2816: 8,
      3072: 270532616,
      3328: 2105352,
      3584: 8200,
      3840: 270540800,
      128: 270532608,
      384: 270540808,
      640: 8,
      896: 2097152,
      1152: 2105352,
      1408: 268435464,
      1664: 268443648,
      1920: 8200,
      2176: 2097160,
      2432: 8192,
      2688: 268443656,
      2944: 270532616,
      3200: 0,
      3456: 270540800,
      3712: 2105344,
      3968: 268435456,
      4096: 268443648,
      4352: 270532616,
      4608: 270540808,
      4864: 8200,
      5120: 2097152,
      5376: 268435456,
      5632: 268435464,
      5888: 2105344,
      6144: 2105352,
      6400: 0,
      6656: 8,
      6912: 270532608,
      7168: 8192,
      7424: 268443656,
      7680: 270540800,
      7936: 2097160,
      4224: 8,
      4480: 2105344,
      4736: 2097152,
      4992: 268435464,
      5248: 268443648,
      5504: 8200,
      5760: 270540808,
      6016: 270532608,
      6272: 270540800,
      6528: 270532616,
      6784: 8192,
      7040: 2105352,
      7296: 2097160,
      7552: 0,
      7808: 268435456,
      8064: 268443656
    }, {
      "0": 1048576,
      16: 33555457,
      32: 1024,
      48: 1049601,
      64: 34604033,
      80: 0,
      96: 1,
      112: 34603009,
      128: 33555456,
      144: 1048577,
      160: 33554433,
      176: 34604032,
      192: 34603008,
      208: 1025,
      224: 1049600,
      240: 33554432,
      8: 34603009,
      24: 0,
      40: 33555457,
      56: 34604032,
      72: 1048576,
      88: 33554433,
      104: 33554432,
      120: 1025,
      136: 1049601,
      152: 33555456,
      168: 34603008,
      184: 1048577,
      200: 1024,
      216: 34604033,
      232: 1,
      248: 1049600,
      256: 33554432,
      272: 1048576,
      288: 33555457,
      304: 34603009,
      320: 1048577,
      336: 33555456,
      352: 34604032,
      368: 1049601,
      384: 1025,
      400: 34604033,
      416: 1049600,
      432: 1,
      448: 0,
      464: 34603008,
      480: 33554433,
      496: 1024,
      264: 1049600,
      280: 33555457,
      296: 34603009,
      312: 1,
      328: 33554432,
      344: 1048576,
      360: 1025,
      376: 34604032,
      392: 33554433,
      408: 34603008,
      424: 0,
      440: 34604033,
      456: 1049601,
      472: 1024,
      488: 33555456,
      504: 1048577
    }, {
      "0": 134219808,
      1: 131072,
      2: 134217728,
      3: 32,
      4: 131104,
      5: 134350880,
      6: 134350848,
      7: 2048,
      8: 134348800,
      9: 134219776,
      10: 133120,
      11: 134348832,
      12: 2080,
      13: 0,
      14: 134217760,
      15: 133152,
      2147483648: 2048,
      2147483649: 134350880,
      2147483650: 134219808,
      2147483651: 134217728,
      2147483652: 134348800,
      2147483653: 133120,
      2147483654: 133152,
      2147483655: 32,
      2147483656: 134217760,
      2147483657: 2080,
      2147483658: 131104,
      2147483659: 134350848,
      2147483660: 0,
      2147483661: 134348832,
      2147483662: 134219776,
      2147483663: 131072,
      16: 133152,
      17: 134350848,
      18: 32,
      19: 2048,
      20: 134219776,
      21: 134217760,
      22: 134348832,
      23: 131072,
      24: 0,
      25: 131104,
      26: 134348800,
      27: 134219808,
      28: 134350880,
      29: 133120,
      30: 2080,
      31: 134217728,
      2147483664: 131072,
      2147483665: 2048,
      2147483666: 134348832,
      2147483667: 133152,
      2147483668: 32,
      2147483669: 134348800,
      2147483670: 134217728,
      2147483671: 134219808,
      2147483672: 134350880,
      2147483673: 134217760,
      2147483674: 134219776,
      2147483675: 0,
      2147483676: 133120,
      2147483677: 2080,
      2147483678: 131104,
      2147483679: 134350848
    }],
    t = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
    m = g.DES = e.extend({
      _doReset: function () {
        for (var b = this._key.words, c = [], a = 0; 56 > a; a++) {
          var f = q[a] - 1;
          c[a] = b[f >>> 5] >>> 31 - f % 32 & 1
        }
        b = this._subKeys = [];
        for (f = 0; 16 > f; f++) {
          for (var d = b[f] = [], e = r[f], a = 0; 24 > a; a++) d[a / 6 | 0] |= c[(p[a] - 1 + e) % 28] << 31 - a % 6, d[4 + (a / 6 | 0)] |= c[28 + (p[a + 24] - 1 + e) % 28] << 31 - a % 6;
          d[0] = d[0] << 1 | d[0] >>> 31;
          for (a = 1; 7 > a; a++) d[a] >>>=
            4 * (a - 1) + 3;
          d[7] = d[7] << 5 | d[7] >>> 27
        }
        c = this._invSubKeys = [];
        for (a = 0; 16 > a; a++) c[a] = b[15 - a]
      },
      encryptBlock: function (b, c) {
        this._doCryptBlock(b, c, this._subKeys)
      },
      decryptBlock: function (b, c) {
        this._doCryptBlock(b, c, this._invSubKeys)
      },
      _doCryptBlock: function (b, c, a) {
        this._lBlock = b[c];
        this._rBlock = b[c + 1];
        j.call(this, 4, 252645135);
        j.call(this, 16, 65535);
        l.call(this, 2, 858993459);
        l.call(this, 8, 16711935);
        j.call(this, 1, 1431655765);
        for (var f = 0; 16 > f; f++) {
          for (var d = a[f], e = this._lBlock, h = this._rBlock, g = 0, k = 0; 8 > k; k++) g |= s[k][((h ^
            d[k]) & t[k]) >>> 0];
          this._lBlock = h;
          this._rBlock = e ^ g
        }
        a = this._lBlock;
        this._lBlock = this._rBlock;
        this._rBlock = a;
        j.call(this, 1, 1431655765);
        l.call(this, 8, 16711935);
        l.call(this, 2, 858993459);
        j.call(this, 16, 65535);
        j.call(this, 4, 252645135);
        b[c] = this._lBlock;
        b[c + 1] = this._rBlock
      },
      keySize: 2,
      ivSize: 2,
      blockSize: 2
    });
  h.DES = e._createHelper(m);
  g = g.TripleDES = e.extend({
    _doReset: function () {
      var b = this._key.words;
      this._des1 = m.createEncryptor(n.create(b.slice(0, 2)));
      this._des2 = m.createEncryptor(n.create(b.slice(2, 4)));
      this._des3 =
        m.createEncryptor(n.create(b.slice(4, 6)))
    },
    encryptBlock: function (b, c) {
      this._des1.encryptBlock(b, c);
      this._des2.decryptBlock(b, c);
      this._des3.encryptBlock(b, c)
    },
    decryptBlock: function (b, c) {
      this._des3.decryptBlock(b, c);
      this._des2.encryptBlock(b, c);
      this._des1.decryptBlock(b, c)
    },
    keySize: 6,
    ivSize: 2,
    blockSize: 2
  });
  h.TripleDES = e._createHelper(g)
})();

/*
CryptoJS v3.1.2 enc-base64.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  var h = CryptoJS,
    j = h.lib.WordArray;
  h.enc.Base64 = {
    stringify: function (b) {
      var e = b.words,
        f = b.sigBytes,
        c = this._map;
      b.clamp();
      b = [];
      for (var a = 0; a < f; a += 3)
        for (var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++) b.push(c.charAt(d >>> 6 * (3 - g) & 63));
      if (e = c.charAt(64))
        for (; b.length % 4;) b.push(e);
      return b.join("")
    },
    parse: function (b) {
      var e = b.length,
        f = this._map,
        c = f.charAt(64);
      c && (c = b.indexOf(c), -1 != c && (e = c));
      for (var c = [], a = 0, d = 0; d <
        e; d++)
        if (d % 4) {
          var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4),
            h = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4);
          c[a >>> 2] |= (g | h) << 24 - 8 * (a % 4);
          a++
        } return j.create(c, a)
    },
    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
  }
})();

/*
CryptoJS v3.1.2 md5.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (E) {
  function h(a, f, g, j, p, h, k) {
    a = a + (f & g | ~f & j) + p + k;
    return (a << h | a >>> 32 - h) + f
  }

  function k(a, f, g, j, p, h, k) {
    a = a + (f & j | g & ~j) + p + k;
    return (a << h | a >>> 32 - h) + f
  }

  function l(a, f, g, j, h, k, l) {
    a = a + (f ^ g ^ j) + h + l;
    return (a << k | a >>> 32 - k) + f
  }

  function n(a, f, g, j, h, k, l) {
    a = a + (g ^ (f | ~j)) + h + l;
    return (a << k | a >>> 32 - k) + f
  }
  for (var r = CryptoJS, q = r.lib, F = q.WordArray, s = q.Hasher, q = r.algo, a = [], t = 0; 64 > t; t++) a[t] = 4294967296 * E.abs(E.sin(t + 1)) | 0;
  q = q.MD5 = s.extend({
    _doReset: function () {
      this._hash = new F.init([1732584193, 4023233417, 2562383102, 271733878])
    },
    _doProcessBlock: function (m, f) {
      for (var g = 0; 16 > g; g++) {
        var j = f + g,
          p = m[j];
        m[j] = (p << 8 | p >>> 24) & 16711935 | (p << 24 | p >>> 8) & 4278255360
      }
      var g = this._hash.words,
        j = m[f + 0],
        p = m[f + 1],
        q = m[f + 2],
        r = m[f + 3],
        s = m[f + 4],
        t = m[f + 5],
        u = m[f + 6],
        v = m[f + 7],
        w = m[f + 8],
        x = m[f + 9],
        y = m[f + 10],
        z = m[f + 11],
        A = m[f + 12],
        B = m[f + 13],
        C = m[f + 14],
        D = m[f + 15],
        b = g[0],
        c = g[1],
        d = g[2],
        e = g[3],
        b = h(b, c, d, e, j, 7, a[0]),
        e = h(e, b, c, d, p, 12, a[1]),
        d = h(d, e, b, c, q, 17, a[2]),
        c = h(c, d, e, b, r, 22, a[3]),
        b = h(b, c, d, e, s, 7, a[4]),
        e = h(e, b, c, d, t, 12, a[5]),
        d = h(d, e, b, c, u, 17, a[6]),
        c = h(c, d, e, b, v, 22, a[7]),
        b = h(b, c, d, e, w, 7, a[8]),
        e = h(e, b, c, d, x, 12, a[9]),
        d = h(d, e, b, c, y, 17, a[10]),
        c = h(c, d, e, b, z, 22, a[11]),
        b = h(b, c, d, e, A, 7, a[12]),
        e = h(e, b, c, d, B, 12, a[13]),
        d = h(d, e, b, c, C, 17, a[14]),
        c = h(c, d, e, b, D, 22, a[15]),
        b = k(b, c, d, e, p, 5, a[16]),
        e = k(e, b, c, d, u, 9, a[17]),
        d = k(d, e, b, c, z, 14, a[18]),
        c = k(c, d, e, b, j, 20, a[19]),
        b = k(b, c, d, e, t, 5, a[20]),
        e = k(e, b, c, d, y, 9, a[21]),
        d = k(d, e, b, c, D, 14, a[22]),
        c = k(c, d, e, b, s, 20, a[23]),
        b = k(b, c, d, e, x, 5, a[24]),
        e = k(e, b, c, d, C, 9, a[25]),
        d = k(d, e, b, c, r, 14, a[26]),
        c = k(c, d, e, b, w, 20, a[27]),
        b = k(b, c, d, e, B, 5, a[28]),
        e = k(e, b,
          c, d, q, 9, a[29]),
        d = k(d, e, b, c, v, 14, a[30]),
        c = k(c, d, e, b, A, 20, a[31]),
        b = l(b, c, d, e, t, 4, a[32]),
        e = l(e, b, c, d, w, 11, a[33]),
        d = l(d, e, b, c, z, 16, a[34]),
        c = l(c, d, e, b, C, 23, a[35]),
        b = l(b, c, d, e, p, 4, a[36]),
        e = l(e, b, c, d, s, 11, a[37]),
        d = l(d, e, b, c, v, 16, a[38]),
        c = l(c, d, e, b, y, 23, a[39]),
        b = l(b, c, d, e, B, 4, a[40]),
        e = l(e, b, c, d, j, 11, a[41]),
        d = l(d, e, b, c, r, 16, a[42]),
        c = l(c, d, e, b, u, 23, a[43]),
        b = l(b, c, d, e, x, 4, a[44]),
        e = l(e, b, c, d, A, 11, a[45]),
        d = l(d, e, b, c, D, 16, a[46]),
        c = l(c, d, e, b, q, 23, a[47]),
        b = n(b, c, d, e, j, 6, a[48]),
        e = n(e, b, c, d, v, 10, a[49]),
        d = n(d, e, b, c,
          C, 15, a[50]),
        c = n(c, d, e, b, t, 21, a[51]),
        b = n(b, c, d, e, A, 6, a[52]),
        e = n(e, b, c, d, r, 10, a[53]),
        d = n(d, e, b, c, y, 15, a[54]),
        c = n(c, d, e, b, p, 21, a[55]),
        b = n(b, c, d, e, w, 6, a[56]),
        e = n(e, b, c, d, D, 10, a[57]),
        d = n(d, e, b, c, u, 15, a[58]),
        c = n(c, d, e, b, B, 21, a[59]),
        b = n(b, c, d, e, s, 6, a[60]),
        e = n(e, b, c, d, z, 10, a[61]),
        d = n(d, e, b, c, q, 15, a[62]),
        c = n(c, d, e, b, x, 21, a[63]);
      g[0] = g[0] + b | 0;
      g[1] = g[1] + c | 0;
      g[2] = g[2] + d | 0;
      g[3] = g[3] + e | 0
    },
    _doFinalize: function () {
      var a = this._data,
        f = a.words,
        g = 8 * this._nDataBytes,
        j = 8 * a.sigBytes;
      f[j >>> 5] |= 128 << 24 - j % 32;
      var h = E.floor(g /
        4294967296);
      f[(j + 64 >>> 9 << 4) + 15] = (h << 8 | h >>> 24) & 16711935 | (h << 24 | h >>> 8) & 4278255360;
      f[(j + 64 >>> 9 << 4) + 14] = (g << 8 | g >>> 24) & 16711935 | (g << 24 | g >>> 8) & 4278255360;
      a.sigBytes = 4 * (f.length + 1);
      this._process();
      a = this._hash;
      f = a.words;
      for (g = 0; 4 > g; g++) j = f[g], f[g] = (j << 8 | j >>> 24) & 16711935 | (j << 24 | j >>> 8) & 4278255360;
      return a
    },
    clone: function () {
      var a = s.clone.call(this);
      a._hash = this._hash.clone();
      return a
    }
  });
  r.MD5 = s._createHelper(q);
  r.HmacMD5 = s._createHmacHelper(q)
})(Math);

/*
CryptoJS v3.1.2 sha1-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  var k = CryptoJS,
    b = k.lib,
    m = b.WordArray,
    l = b.Hasher,
    d = [],
    b = k.algo.SHA1 = l.extend({
      _doReset: function () {
        this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
      },
      _doProcessBlock: function (n, p) {
        for (var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b = a[4], c = 0; 80 > c; c++) {
          if (16 > c) d[c] = n[p + c] | 0;
          else {
            var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16];
            d[c] = g << 1 | g >>> 31
          }
          g = (e << 5 | e >>> 27) + b + d[c];
          g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^
            j) - 899497514);
          b = j;
          j = h;
          h = f << 30 | f >>> 2;
          f = e;
          e = g
        }
        a[0] = a[0] + e | 0;
        a[1] = a[1] + f | 0;
        a[2] = a[2] + h | 0;
        a[3] = a[3] + j | 0;
        a[4] = a[4] + b | 0
      },
      _doFinalize: function () {
        var b = this._data,
          d = b.words,
          a = 8 * this._nDataBytes,
          e = 8 * b.sigBytes;
        d[e >>> 5] |= 128 << 24 - e % 32;
        d[(e + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296);
        d[(e + 64 >>> 9 << 4) + 15] = a;
        b.sigBytes = 4 * d.length;
        this._process();
        return this._hash
      },
      clone: function () {
        var b = l.clone.call(this);
        b._hash = this._hash.clone();
        return b
      }
    });
  k.SHA1 = l._createHelper(b);
  k.HmacSHA1 = l._createHmacHelper(b)
})();

/*
CryptoJS v3.1.2 sha256-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (k) {
  for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t = [], u = function (q) {
      return 4294967296 * (q - (q | 0)) | 0
    }, l = 2, b = 0; 64 > b;) {
    var d;
    a: {
      d = l;
      for (var w = k.sqrt(d), r = 2; r <= w; r++)
        if (!(d % r)) {
          d = !1;
          break a
        } d = !0
    }
    d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t[b] = u(k.pow(l, 1 / 3)), b++);
    l++
  }
  var n = [],
    h = h.SHA256 = j.extend({
      _doReset: function () {
        this._hash = new v.init(s.slice(0))
      },
      _doProcessBlock: function (q, h) {
        for (var a = this._hash.words, c = a[0], d = a[1], b = a[2], k = a[3], f = a[4], g = a[5], j = a[6], l = a[7], e = 0; 64 > e; e++) {
          if (16 > e) n[e] =
            q[h + e] | 0;
          else {
            var m = n[e - 15],
              p = n[e - 2];
            n[e] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n[e - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[e - 16]
          }
          m = l + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g ^ ~f & j) + t[e] + n[e];
          p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d ^ c & b ^ d & b);
          l = j;
          j = g;
          g = f;
          f = k + m | 0;
          k = b;
          b = d;
          d = c;
          c = m + p | 0
        }
        a[0] = a[0] + c | 0;
        a[1] = a[1] + d | 0;
        a[2] = a[2] + b | 0;
        a[3] = a[3] + k | 0;
        a[4] = a[4] + f | 0;
        a[5] = a[5] + g | 0;
        a[6] = a[6] + j | 0;
        a[7] = a[7] + l | 0
      },
      _doFinalize: function () {
        var d = this._data,
          b = d.words,
          a = 8 * this._nDataBytes,
          c = 8 * d.sigBytes;
        b[c >>> 5] |= 128 << 24 - c % 32;
        b[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296);
        b[(c + 64 >>> 9 << 4) + 15] = a;
        d.sigBytes = 4 * b.length;
        this._process();
        return this._hash
      },
      clone: function () {
        var b = j.clone.call(this);
        b._hash = this._hash.clone();
        return b
      }
    });
  g.SHA256 = j._createHelper(h);
  g.HmacSHA256 = j._createHmacHelper(h)
})(Math);

/*
CryptoJS v3.1.2 sha224-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  var b = CryptoJS,
    d = b.lib.WordArray,
    a = b.algo,
    c = a.SHA256,
    a = a.SHA224 = c.extend({
      _doReset: function () {
        this._hash = new d.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
      },
      _doFinalize: function () {
        var a = c._doFinalize.call(this);
        a.sigBytes -= 4;
        return a
      }
    });
  b.SHA224 = c._createHelper(a);
  b.HmacSHA224 = c._createHmacHelper(a)
})();

/*
CryptoJS v3.1.2 sha512-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  function a() {
    return d.create.apply(d, arguments)
  }
  for (var n = CryptoJS, r = n.lib.Hasher, e = n.x64, d = e.Word, T = e.WordArray, e = n.algo, ea = [a(1116352408, 3609767458), a(1899447441, 602891725), a(3049323471, 3964484399), a(3921009573, 2173295548), a(961987163, 4081628472), a(1508970993, 3053834265), a(2453635748, 2937671579), a(2870763221, 3664609560), a(3624381080, 2734883394), a(310598401, 1164996542), a(607225278, 1323610764), a(1426881987, 3590304994), a(1925078388, 4068182383), a(2162078206, 991336113), a(2614888103, 633803317),
      a(3248222580, 3479774868), a(3835390401, 2666613458), a(4022224774, 944711139), a(264347078, 2341262773), a(604807628, 2007800933), a(770255983, 1495990901), a(1249150122, 1856431235), a(1555081692, 3175218132), a(1996064986, 2198950837), a(2554220882, 3999719339), a(2821834349, 766784016), a(2952996808, 2566594879), a(3210313671, 3203337956), a(3336571891, 1034457026), a(3584528711, 2466948901), a(113926993, 3758326383), a(338241895, 168717936), a(666307205, 1188179964), a(773529912, 1546045734), a(1294757372, 1522805485), a(1396182291,
        2643833823), a(1695183700, 2343527390), a(1986661051, 1014477480), a(2177026350, 1206759142), a(2456956037, 344077627), a(2730485921, 1290863460), a(2820302411, 3158454273), a(3259730800, 3505952657), a(3345764771, 106217008), a(3516065817, 3606008344), a(3600352804, 1432725776), a(4094571909, 1467031594), a(275423344, 851169720), a(430227734, 3100823752), a(506948616, 1363258195), a(659060556, 3750685593), a(883997877, 3785050280), a(958139571, 3318307427), a(1322822218, 3812723403), a(1537002063, 2003034995), a(1747873779, 3602036899),
      a(1955562222, 1575990012), a(2024104815, 1125592928), a(2227730452, 2716904306), a(2361852424, 442776044), a(2428436474, 593698344), a(2756734187, 3733110249), a(3204031479, 2999351573), a(3329325298, 3815920427), a(3391569614, 3928383900), a(3515267271, 566280711), a(3940187606, 3454069534), a(4118630271, 4000239992), a(116418474, 1914138554), a(174292421, 2731055270), a(289380356, 3203993006), a(460393269, 320620315), a(685471733, 587496836), a(852142971, 1086792851), a(1017036298, 365543100), a(1126000580, 2618297676), a(1288033470,
        3409855158), a(1501505948, 4234509866), a(1607167915, 987167468), a(1816402316, 1246189591)
    ], v = [], w = 0; 80 > w; w++) v[w] = a();
  e = e.SHA512 = r.extend({
    _doReset: function () {
      this._hash = new T.init([new d.init(1779033703, 4089235720), new d.init(3144134277, 2227873595), new d.init(1013904242, 4271175723), new d.init(2773480762, 1595750129), new d.init(1359893119, 2917565137), new d.init(2600822924, 725511199), new d.init(528734635, 4215389547), new d.init(1541459225, 327033209)])
    },
    _doProcessBlock: function (a, d) {
      for (var f = this._hash.words,
          F = f[0], e = f[1], n = f[2], r = f[3], G = f[4], H = f[5], I = f[6], f = f[7], w = F.high, J = F.low, X = e.high, K = e.low, Y = n.high, L = n.low, Z = r.high, M = r.low, $ = G.high, N = G.low, aa = H.high, O = H.low, ba = I.high, P = I.low, ca = f.high, Q = f.low, k = w, g = J, z = X, x = K, A = Y, y = L, U = Z, B = M, l = $, h = N, R = aa, C = O, S = ba, D = P, V = ca, E = Q, m = 0; 80 > m; m++) {
        var s = v[m];
        if (16 > m) var j = s.high = a[d + 2 * m] | 0,
          b = s.low = a[d + 2 * m + 1] | 0;
        else {
          var j = v[m - 15],
            b = j.high,
            p = j.low,
            j = (b >>> 1 | p << 31) ^ (b >>> 8 | p << 24) ^ b >>> 7,
            p = (p >>> 1 | b << 31) ^ (p >>> 8 | b << 24) ^ (p >>> 7 | b << 25),
            u = v[m - 2],
            b = u.high,
            c = u.low,
            u = (b >>> 19 | c << 13) ^ (b <<
              3 | c >>> 29) ^ b >>> 6,
            c = (c >>> 19 | b << 13) ^ (c << 3 | b >>> 29) ^ (c >>> 6 | b << 26),
            b = v[m - 7],
            W = b.high,
            t = v[m - 16],
            q = t.high,
            t = t.low,
            b = p + b.low,
            j = j + W + (b >>> 0 < p >>> 0 ? 1 : 0),
            b = b + c,
            j = j + u + (b >>> 0 < c >>> 0 ? 1 : 0),
            b = b + t,
            j = j + q + (b >>> 0 < t >>> 0 ? 1 : 0);
          s.high = j;
          s.low = b
        }
        var W = l & R ^ ~l & S,
          t = h & C ^ ~h & D,
          s = k & z ^ k & A ^ z & A,
          T = g & x ^ g & y ^ x & y,
          p = (k >>> 28 | g << 4) ^ (k << 30 | g >>> 2) ^ (k << 25 | g >>> 7),
          u = (g >>> 28 | k << 4) ^ (g << 30 | k >>> 2) ^ (g << 25 | k >>> 7),
          c = ea[m],
          fa = c.high,
          da = c.low,
          c = E + ((h >>> 14 | l << 18) ^ (h >>> 18 | l << 14) ^ (h << 23 | l >>> 9)),
          q = V + ((l >>> 14 | h << 18) ^ (l >>> 18 | h << 14) ^ (l << 23 | h >>> 9)) + (c >>> 0 < E >>> 0 ? 1 :
            0),
          c = c + t,
          q = q + W + (c >>> 0 < t >>> 0 ? 1 : 0),
          c = c + da,
          q = q + fa + (c >>> 0 < da >>> 0 ? 1 : 0),
          c = c + b,
          q = q + j + (c >>> 0 < b >>> 0 ? 1 : 0),
          b = u + T,
          s = p + s + (b >>> 0 < u >>> 0 ? 1 : 0),
          V = S,
          E = D,
          S = R,
          D = C,
          R = l,
          C = h,
          h = B + c | 0,
          l = U + q + (h >>> 0 < B >>> 0 ? 1 : 0) | 0,
          U = A,
          B = y,
          A = z,
          y = x,
          z = k,
          x = g,
          g = c + b | 0,
          k = q + s + (g >>> 0 < c >>> 0 ? 1 : 0) | 0
      }
      J = F.low = J + g;
      F.high = w + k + (J >>> 0 < g >>> 0 ? 1 : 0);
      K = e.low = K + x;
      e.high = X + z + (K >>> 0 < x >>> 0 ? 1 : 0);
      L = n.low = L + y;
      n.high = Y + A + (L >>> 0 < y >>> 0 ? 1 : 0);
      M = r.low = M + B;
      r.high = Z + U + (M >>> 0 < B >>> 0 ? 1 : 0);
      N = G.low = N + h;
      G.high = $ + l + (N >>> 0 < h >>> 0 ? 1 : 0);
      O = H.low = O + C;
      H.high = aa + R + (O >>> 0 < C >>> 0 ? 1 : 0);
      P = I.low = P + D;
      I.high = ba + S + (P >>> 0 < D >>> 0 ? 1 : 0);
      Q = f.low = Q + E;
      f.high = ca + V + (Q >>> 0 < E >>> 0 ? 1 : 0)
    },
    _doFinalize: function () {
      var a = this._data,
        d = a.words,
        f = 8 * this._nDataBytes,
        e = 8 * a.sigBytes;
      d[e >>> 5] |= 128 << 24 - e % 32;
      d[(e + 128 >>> 10 << 5) + 30] = Math.floor(f / 4294967296);
      d[(e + 128 >>> 10 << 5) + 31] = f;
      a.sigBytes = 4 * d.length;
      this._process();
      return this._hash.toX32()
    },
    clone: function () {
      var a = r.clone.call(this);
      a._hash = this._hash.clone();
      return a
    },
    blockSize: 32
  });
  n.SHA512 = r._createHelper(e);
  n.HmacSHA512 = r._createHmacHelper(e)
})();

/*
CryptoJS v3.1.2 sha384-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  var c = CryptoJS,
    a = c.x64,
    b = a.Word,
    e = a.WordArray,
    a = c.algo,
    d = a.SHA512,
    a = a.SHA384 = d.extend({
      _doReset: function () {
        this._hash = new e.init([new b.init(3418070365, 3238371032), new b.init(1654270250, 914150663), new b.init(2438529370, 812702999), new b.init(355462360, 4144912697), new b.init(1731405415, 4290775857), new b.init(2394180231, 1750603025), new b.init(3675008525, 1694076839), new b.init(1203062813, 3204075428)])
      },
      _doFinalize: function () {
        var a = d._doFinalize.call(this);
        a.sigBytes -= 16;
        return a
      }
    });
  c.SHA384 =
    d._createHelper(a);
  c.HmacSHA384 = d._createHmacHelper(a)
})();

/*
CryptoJS v3.1.2 ripemd160-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/*

(c) 2012 by Cedric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  var q = CryptoJS,
    d = q.lib,
    n = d.WordArray,
    p = d.Hasher,
    d = q.algo,
    x = n.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
    y = n.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
    z = n.create([11, 14, 15, 12,
      5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
    ]),
    A = n.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
    B = n.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
    C = n.create([1352829926, 1548603684, 1836072691,
      2053994217, 0
    ]),
    d = d.RIPEMD160 = p.extend({
      _doReset: function () {
        this._hash = n.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
      },
      _doProcessBlock: function (e, v) {
        for (var b = 0; 16 > b; b++) {
          var c = v + b,
            f = e[c];
          e[c] = (f << 8 | f >>> 24) & 16711935 | (f << 24 | f >>> 8) & 4278255360
        }
        var c = this._hash.words,
          f = B.words,
          d = C.words,
          n = x.words,
          q = y.words,
          p = z.words,
          w = A.words,
          t, g, h, j, r, u, k, l, m, s;
        u = t = c[0];
        k = g = c[1];
        l = h = c[2];
        m = j = c[3];
        s = r = c[4];
        for (var a, b = 0; 80 > b; b += 1) a = t + e[v + n[b]] | 0, a = 16 > b ? a + ((g ^ h ^ j) + f[0]) : 32 > b ? a + ((g & h | ~g & j) + f[1]) : 48 > b ?
          a + (((g | ~h) ^ j) + f[2]) : 64 > b ? a + ((g & j | h & ~j) + f[3]) : a + ((g ^ (h | ~j)) + f[4]), a |= 0, a = a << p[b] | a >>> 32 - p[b], a = a + r | 0, t = r, r = j, j = h << 10 | h >>> 22, h = g, g = a, a = u + e[v + q[b]] | 0, a = 16 > b ? a + ((k ^ (l | ~m)) + d[0]) : 32 > b ? a + ((k & m | l & ~m) + d[1]) : 48 > b ? a + (((k | ~l) ^ m) + d[2]) : 64 > b ? a + ((k & l | ~k & m) + d[3]) : a + ((k ^ l ^ m) + d[4]), a |= 0, a = a << w[b] | a >>> 32 - w[b], a = a + s | 0, u = s, s = m, m = l << 10 | l >>> 22, l = k, k = a;
        a = c[1] + h + m | 0;
        c[1] = c[2] + j + s | 0;
        c[2] = c[3] + r + u | 0;
        c[3] = c[4] + t + k | 0;
        c[4] = c[0] + g + l | 0;
        c[0] = a
      },
      _doFinalize: function () {
        var e = this._data,
          d = e.words,
          b = 8 * this._nDataBytes,
          c = 8 * e.sigBytes;
        d[c >>> 5] |= 128 << 24 - c % 32;
        d[(c + 64 >>> 9 << 4) + 14] = (b << 8 | b >>> 24) & 16711935 | (b << 24 | b >>> 8) & 4278255360;
        e.sigBytes = 4 * (d.length + 1);
        this._process();
        e = this._hash;
        d = e.words;
        for (b = 0; 5 > b; b++) c = d[b], d[b] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;
        return e
      },
      clone: function () {
        var d = p.clone.call(this);
        d._hash = this._hash.clone();
        return d
      }
    });
  q.RIPEMD160 = p._createHelper(d);
  q.HmacRIPEMD160 = p._createHmacHelper(d)
})(Math);

/*
CryptoJS v3.1.2 hmac.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  var c = CryptoJS,
    k = c.enc.Utf8;
  c.algo.HMAC = c.lib.Base.extend({
    init: function (a, b) {
      a = this._hasher = new a.init;
      "string" == typeof b && (b = k.parse(b));
      var c = a.blockSize,
        e = 4 * c;
      b.sigBytes > e && (b = a.finalize(b));
      b.clamp();
      for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c; d++) h[d] ^= 1549556828, j[d] ^= 909522486;
      f.sigBytes = g.sigBytes = e;
      this.reset()
    },
    reset: function () {
      var a = this._hasher;
      a.reset();
      a.update(this._iKey)
    },
    update: function (a) {
      this._hasher.update(a);
      return this
    },
    finalize: function (a) {
      var b =
        this._hasher;
      a = b.finalize(a);
      b.reset();
      return b.finalize(this._oKey.clone().concat(a))
    }
  })
})();

/*
CryptoJS v3.1.2 pbkdf2-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
  var b = CryptoJS,
    a = b.lib,
    d = a.Base,
    m = a.WordArray,
    a = b.algo,
    q = a.HMAC,
    l = a.PBKDF2 = d.extend({
      cfg: d.extend({
        keySize: 4,
        hasher: a.SHA1,
        iterations: 1
      }),
      init: function (a) {
        this.cfg = this.cfg.extend(a)
      },
      compute: function (a, b) {
        for (var c = this.cfg, f = q.create(c.hasher, a), g = m.create(), d = m.create([1]), l = g.words, r = d.words, n = c.keySize, c = c.iterations; l.length < n;) {
          var h = f.update(b).finalize(d);
          f.reset();
          for (var j = h.words, s = j.length, k = h, p = 1; p < c; p++) {
            k = f.finalize(k);
            f.reset();
            for (var t = k.words, e = 0; e < s; e++) j[e] ^= t[e]
          }
          g.concat(h);
          r[0]++
        }
        g.sigBytes = 4 * n;
        return g
      }
    });
  b.PBKDF2 = function (a, b, c) {
    return l.create(c).compute(a, b)
  }
})();

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";

function hex2b64(d) {
  var b;
  var e;
  var a = "";
  for (b = 0; b + 3 <= d.length; b += 3) {
    e = parseInt(d.substring(b, b + 3), 16);
    a += b64map.charAt(e >> 6) + b64map.charAt(e & 63)
  }
  if (b + 1 == d.length) {
    e = parseInt(d.substring(b, b + 1), 16);
    a += b64map.charAt(e << 2)
  } else {
    if (b + 2 == d.length) {
      e = parseInt(d.substring(b, b + 2), 16);
      a += b64map.charAt(e >> 2) + b64map.charAt((e & 3) << 4)
    }
  }
  if (b64pad) {
    while ((a.length & 3) > 0) {
      a += b64pad
    }
  }
  return a
}

function b64tohex(f) {
  var d = "";
  var e;
  var b = 0;
  var c;
  var a;
  for (e = 0; e < f.length; ++e) {
    if (f.charAt(e) == b64pad) {
      break
    }
    a = b64map.indexOf(f.charAt(e));
    if (a < 0) {
      continue
    }
    if (b == 0) {
      d += int2char(a >> 2);
      c = a & 3;
      b = 1
    } else {
      if (b == 1) {
        d += int2char((c << 2) | (a >> 4));
        c = a & 15;
        b = 2
      } else {
        if (b == 2) {
          d += int2char(c);
          d += int2char(a >> 2);
          c = a & 3;
          b = 3
        } else {
          d += int2char((c << 2) | (a >> 4));
          d += int2char(a & 15);
          b = 0
        }
      }
    }
  }
  if (b == 1) {
    d += int2char(c << 2)
  }
  return d
}

function b64toBA(e) {
  var d = b64tohex(e);
  var c;
  var b = new Array();
  for (c = 0; 2 * c < d.length; ++c) {
    b[c] = parseInt(d.substring(2 * c, 2 * c + 2), 16)
  }
  return b
};
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var dbits;
var canary = 244837814094590;
var j_lm = ((canary & 16777215) == 15715070);

function BigInteger(e, d, f) {
  if (e != null) {
    if ("number" == typeof e) {
      this.fromNumber(e, d, f)
    } else {
      if (d == null && "string" != typeof e) {
        this.fromString(e, 256)
      } else {
        this.fromString(e, d)
      }
    }
  }
}

function nbi() {
  return new BigInteger(null)
}

function am1(f, a, b, e, h, g) {
  while (--g >= 0) {
    var d = a * this[f++] + b[e] + h;
    h = Math.floor(d / 67108864);
    b[e++] = d & 67108863
  }
  return h
}

function am2(f, q, r, e, o, a) {
  var k = q & 32767,
    p = q >> 15;
  while (--a >= 0) {
    var d = this[f] & 32767;
    var g = this[f++] >> 15;
    var b = p * d + g * k;
    d = k * d + ((b & 32767) << 15) + r[e] + (o & 1073741823);
    o = (d >>> 30) + (b >>> 15) + p * g + (o >>> 30);
    r[e++] = d & 1073741823
  }
  return o
}

function am3(f, q, r, e, o, a) {
  var k = q & 16383,
    p = q >> 14;
  while (--a >= 0) {
    var d = this[f] & 16383;
    var g = this[f++] >> 14;
    var b = p * d + g * k;
    d = k * d + ((b & 16383) << 14) + r[e] + o;
    o = (d >> 28) + (b >> 14) + p * g;
    r[e++] = d & 268435455
  }
  return o
}
if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
  BigInteger.prototype.am = am2;
  dbits = 30
} else {
  if (j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26
  } else {
    BigInteger.prototype.am = am3;
    dbits = 28
  }
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) {
  BI_RC[rr++] = vv
}
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
  BI_RC[rr++] = vv
}
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
  BI_RC[rr++] = vv
}

function int2char(a) {
  return BI_RM.charAt(a)
}

function intAt(b, a) {
  var d = BI_RC[b.charCodeAt(a)];
  return (d == null) ? -1 : d
}

function bnpCopyTo(b) {
  for (var a = this.t - 1; a >= 0; --a) {
    b[a] = this[a]
  }
  b.t = this.t;
  b.s = this.s
}

function bnpFromInt(a) {
  this.t = 1;
  this.s = (a < 0) ? -1 : 0;
  if (a > 0) {
    this[0] = a
  } else {
    if (a < -1) {
      this[0] = a + this.DV
    } else {
      this.t = 0
    }
  }
}

function nbv(a) {
  var b = nbi();
  b.fromInt(a);
  return b
}

function bnpFromString(h, c) {
  var e;
  if (c == 16) {
    e = 4
  } else {
    if (c == 8) {
      e = 3
    } else {
      if (c == 256) {
        e = 8
      } else {
        if (c == 2) {
          e = 1
        } else {
          if (c == 32) {
            e = 5
          } else {
            if (c == 4) {
              e = 2
            } else {
              this.fromRadix(h, c);
              return
            }
          }
        }
      }
    }
  }
  this.t = 0;
  this.s = 0;
  var g = h.length,
    d = false,
    f = 0;
  while (--g >= 0) {
    var a = (e == 8) ? h[g] & 255 : intAt(h, g);
    if (a < 0) {
      if (h.charAt(g) == "-") {
        d = true
      }
      continue
    }
    d = false;
    if (f == 0) {
      this[this.t++] = a
    } else {
      if (f + e > this.DB) {
        this[this.t - 1] |= (a & ((1 << (this.DB - f)) - 1)) << f;
        this[this.t++] = (a >> (this.DB - f))
      } else {
        this[this.t - 1] |= a << f
      }
    }
    f += e;
    if (f >= this.DB) {
      f -= this.DB
    }
  }
  if (e == 8 && (h[0] & 128) != 0) {
    this.s = -1;
    if (f > 0) {
      this[this.t - 1] |= ((1 << (this.DB - f)) - 1) << f
    }
  }
  this.clamp();
  if (d) {
    BigInteger.ZERO.subTo(this, this)
  }
}

function bnpClamp() {
  var a = this.s & this.DM;
  while (this.t > 0 && this[this.t - 1] == a) {
    --this.t
  }
}

function bnToString(c) {
  if (this.s < 0) {
    return "-" + this.negate().toString(c)
  }
  var e;
  if (c == 16) {
    e = 4
  } else {
    if (c == 8) {
      e = 3
    } else {
      if (c == 2) {
        e = 1
      } else {
        if (c == 32) {
          e = 5
        } else {
          if (c == 4) {
            e = 2
          } else {
            return this.toRadix(c)
          }
        }
      }
    }
  }
  var g = (1 << e) - 1,
    l, a = false,
    h = "",
    f = this.t;
  var j = this.DB - (f * this.DB) % e;
  if (f-- > 0) {
    if (j < this.DB && (l = this[f] >> j) > 0) {
      a = true;
      h = int2char(l)
    }
    while (f >= 0) {
      if (j < e) {
        l = (this[f] & ((1 << j) - 1)) << (e - j);
        l |= this[--f] >> (j += this.DB - e)
      } else {
        l = (this[f] >> (j -= e)) & g;
        if (j <= 0) {
          j += this.DB;
          --f
        }
      }
      if (l > 0) {
        a = true
      }
      if (a) {
        h += int2char(l)
      }
    }
  }
  return a ? h : "0"
}

function bnNegate() {
  var a = nbi();
  BigInteger.ZERO.subTo(this, a);
  return a
}

function bnAbs() {
  return (this.s < 0) ? this.negate() : this
}

function bnCompareTo(b) {
  var d = this.s - b.s;
  if (d != 0) {
    return d
  }
  var c = this.t;
  d = c - b.t;
  if (d != 0) {
    return (this.s < 0) ? -d : d
  }
  while (--c >= 0) {
    if ((d = this[c] - b[c]) != 0) {
      return d
    }
  }
  return 0
}

function nbits(a) {
  var c = 1,
    b;
  if ((b = a >>> 16) != 0) {
    a = b;
    c += 16
  }
  if ((b = a >> 8) != 0) {
    a = b;
    c += 8
  }
  if ((b = a >> 4) != 0) {
    a = b;
    c += 4
  }
  if ((b = a >> 2) != 0) {
    a = b;
    c += 2
  }
  if ((b = a >> 1) != 0) {
    a = b;
    c += 1
  }
  return c
}

function bnBitLength() {
  if (this.t <= 0) {
    return 0
  }
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM))
}

function bnpDLShiftTo(c, b) {
  var a;
  for (a = this.t - 1; a >= 0; --a) {
    b[a + c] = this[a]
  }
  for (a = c - 1; a >= 0; --a) {
    b[a] = 0
  }
  b.t = this.t + c;
  b.s = this.s
}

function bnpDRShiftTo(c, b) {
  for (var a = c; a < this.t; ++a) {
    b[a - c] = this[a]
  }
  b.t = Math.max(this.t - c, 0);
  b.s = this.s
}

function bnpLShiftTo(j, e) {
  var b = j % this.DB;
  var a = this.DB - b;
  var g = (1 << a) - 1;
  var f = Math.floor(j / this.DB),
    h = (this.s << b) & this.DM,
    d;
  for (d = this.t - 1; d >= 0; --d) {
    e[d + f + 1] = (this[d] >> a) | h;
    h = (this[d] & g) << b
  }
  for (d = f - 1; d >= 0; --d) {
    e[d] = 0
  }
  e[f] = h;
  e.t = this.t + f + 1;
  e.s = this.s;
  e.clamp()
}

function bnpRShiftTo(g, d) {
  d.s = this.s;
  var e = Math.floor(g / this.DB);
  if (e >= this.t) {
    d.t = 0;
    return
  }
  var b = g % this.DB;
  var a = this.DB - b;
  var f = (1 << b) - 1;
  d[0] = this[e] >> b;
  for (var c = e + 1; c < this.t; ++c) {
    d[c - e - 1] |= (this[c] & f) << a;
    d[c - e] = this[c] >> b
  }
  if (b > 0) {
    d[this.t - e - 1] |= (this.s & f) << a
  }
  d.t = this.t - e;
  d.clamp()
}

function bnpSubTo(d, f) {
  var e = 0,
    g = 0,
    b = Math.min(d.t, this.t);
  while (e < b) {
    g += this[e] - d[e];
    f[e++] = g & this.DM;
    g >>= this.DB
  }
  if (d.t < this.t) {
    g -= d.s;
    while (e < this.t) {
      g += this[e];
      f[e++] = g & this.DM;
      g >>= this.DB
    }
    g += this.s
  } else {
    g += this.s;
    while (e < d.t) {
      g -= d[e];
      f[e++] = g & this.DM;
      g >>= this.DB
    }
    g -= d.s
  }
  f.s = (g < 0) ? -1 : 0;
  if (g < -1) {
    f[e++] = this.DV + g
  } else {
    if (g > 0) {
      f[e++] = g
    }
  }
  f.t = e;
  f.clamp()
}

function bnpMultiplyTo(c, e) {
  var b = this.abs(),
    f = c.abs();
  var d = b.t;
  e.t = d + f.t;
  while (--d >= 0) {
    e[d] = 0
  }
  for (d = 0; d < f.t; ++d) {
    e[d + b.t] = b.am(0, f[d], e, d, 0, b.t)
  }
  e.s = 0;
  e.clamp();
  if (this.s != c.s) {
    BigInteger.ZERO.subTo(e, e)
  }
}

function bnpSquareTo(d) {
  var a = this.abs();
  var b = d.t = 2 * a.t;
  while (--b >= 0) {
    d[b] = 0
  }
  for (b = 0; b < a.t - 1; ++b) {
    var e = a.am(b, a[b], d, 2 * b, 0, 1);
    if ((d[b + a.t] += a.am(b + 1, 2 * a[b], d, 2 * b + 1, e, a.t - b - 1)) >= a.DV) {
      d[b + a.t] -= a.DV;
      d[b + a.t + 1] = 1
    }
  }
  if (d.t > 0) {
    d[d.t - 1] += a.am(b, a[b], d, 2 * b, 0, 1)
  }
  d.s = 0;
  d.clamp()
}

function bnpDivRemTo(n, h, g) {
  var w = n.abs();
  if (w.t <= 0) {
    return
  }
  var k = this.abs();
  if (k.t < w.t) {
    if (h != null) {
      h.fromInt(0)
    }
    if (g != null) {
      this.copyTo(g)
    }
    return
  }
  if (g == null) {
    g = nbi()
  }
  var d = nbi(),
    a = this.s,
    l = n.s;
  var v = this.DB - nbits(w[w.t - 1]);
  if (v > 0) {
    w.lShiftTo(v, d);
    k.lShiftTo(v, g)
  } else {
    w.copyTo(d);
    k.copyTo(g)
  }
  var p = d.t;
  var b = d[p - 1];
  if (b == 0) {
    return
  }
  var o = b * (1 << this.F1) + ((p > 1) ? d[p - 2] >> this.F2 : 0);
  var A = this.FV / o,
    z = (1 << this.F1) / o,
    x = 1 << this.F2;
  var u = g.t,
    s = u - p,
    f = (h == null) ? nbi() : h;
  d.dlShiftTo(s, f);
  if (g.compareTo(f) >= 0) {
    g[g.t++] = 1;
    g.subTo(f, g)
  }
  BigInteger.ONE.dlShiftTo(p, f);
  f.subTo(d, d);
  while (d.t < p) {
    d[d.t++] = 0
  }
  while (--s >= 0) {
    var c = (g[--u] == b) ? this.DM : Math.floor(g[u] * A + (g[u - 1] + x) * z);
    if ((g[u] += d.am(0, c, g, s, 0, p)) < c) {
      d.dlShiftTo(s, f);
      g.subTo(f, g);
      while (g[u] < --c) {
        g.subTo(f, g)
      }
    }
  }
  if (h != null) {
    g.drShiftTo(p, h);
    if (a != l) {
      BigInteger.ZERO.subTo(h, h)
    }
  }
  g.t = p;
  g.clamp();
  if (v > 0) {
    g.rShiftTo(v, g)
  }
  if (a < 0) {
    BigInteger.ZERO.subTo(g, g)
  }
}

function bnMod(b) {
  var c = nbi();
  this.abs().divRemTo(b, null, c);
  if (this.s < 0 && c.compareTo(BigInteger.ZERO) > 0) {
    b.subTo(c, c)
  }
  return c
}

function Classic(a) {
  this.m = a
}

function cConvert(a) {
  if (a.s < 0 || a.compareTo(this.m) >= 0) {
    return a.mod(this.m)
  } else {
    return a
  }
}

function cRevert(a) {
  return a
}

function cReduce(a) {
  a.divRemTo(this.m, null, a)
}

function cMulTo(a, c, b) {
  a.multiplyTo(c, b);
  this.reduce(b)
}

function cSqrTo(a, b) {
  a.squareTo(b);
  this.reduce(b)
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

function bnpInvDigit() {
  if (this.t < 1) {
    return 0
  }
  var a = this[0];
  if ((a & 1) == 0) {
    return 0
  }
  var b = a & 3;
  b = (b * (2 - (a & 15) * b)) & 15;
  b = (b * (2 - (a & 255) * b)) & 255;
  b = (b * (2 - (((a & 65535) * b) & 65535))) & 65535;
  b = (b * (2 - a * b % this.DV)) % this.DV;
  return (b > 0) ? this.DV - b : -b
}

function Montgomery(a) {
  this.m = a;
  this.mp = a.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << (a.DB - 15)) - 1;
  this.mt2 = 2 * a.t
}

function montConvert(a) {
  var b = nbi();
  a.abs().dlShiftTo(this.m.t, b);
  b.divRemTo(this.m, null, b);
  if (a.s < 0 && b.compareTo(BigInteger.ZERO) > 0) {
    this.m.subTo(b, b)
  }
  return b
}

function montRevert(a) {
  var b = nbi();
  a.copyTo(b);
  this.reduce(b);
  return b
}

function montReduce(a) {
  while (a.t <= this.mt2) {
    a[a.t++] = 0
  }
  for (var c = 0; c < this.m.t; ++c) {
    var b = a[c] & 32767;
    var d = (b * this.mpl + (((b * this.mph + (a[c] >> 15) * this.mpl) & this.um) << 15)) & a.DM;
    b = c + this.m.t;
    a[b] += this.m.am(0, d, a, c, 0, this.m.t);
    while (a[b] >= a.DV) {
      a[b] -= a.DV;
      a[++b]++
    }
  }
  a.clamp();
  a.drShiftTo(this.m.t, a);
  if (a.compareTo(this.m) >= 0) {
    a.subTo(this.m, a)
  }
}

function montSqrTo(a, b) {
  a.squareTo(b);
  this.reduce(b)
}

function montMulTo(a, c, b) {
  a.multiplyTo(c, b);
  this.reduce(b)
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

function bnpIsEven() {
  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0
}

function bnpExp(h, j) {
  if (h > 4294967295 || h < 1) {
    return BigInteger.ONE
  }
  var f = nbi(),
    a = nbi(),
    d = j.convert(this),
    c = nbits(h) - 1;
  d.copyTo(f);
  while (--c >= 0) {
    j.sqrTo(f, a);
    if ((h & (1 << c)) > 0) {
      j.mulTo(a, d, f)
    } else {
      var b = f;
      f = a;
      a = b
    }
  }
  return j.revert(f)
}

function bnModPowInt(b, a) {
  var c;
  if (b < 256 || a.isEven()) {
    c = new Classic(a)
  } else {
    c = new Montgomery(a)
  }
  return this.exp(b, c)
}
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function bnClone() {
  var a = nbi();
  this.copyTo(a);
  return a
}

function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) {
      return this[0] - this.DV
    } else {
      if (this.t == 0) {
        return -1
      }
    }
  } else {
    if (this.t == 1) {
      return this[0]
    } else {
      if (this.t == 0) {
        return 0
      }
    }
  }
  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
}

function bnByteValue() {
  return (this.t == 0) ? this.s : (this[0] << 24) >> 24
}

function bnShortValue() {
  return (this.t == 0) ? this.s : (this[0] << 16) >> 16
}

function bnpChunkSize(a) {
  return Math.floor(Math.LN2 * this.DB / Math.log(a))
}

function bnSigNum() {
  if (this.s < 0) {
    return -1
  } else {
    if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {
      return 0
    } else {
      return 1
    }
  }
}

function bnpToRadix(c) {
  if (c == null) {
    c = 10
  }
  if (this.signum() == 0 || c < 2 || c > 36) {
    return "0"
  }
  var f = this.chunkSize(c);
  var e = Math.pow(c, f);
  var i = nbv(e),
    j = nbi(),
    h = nbi(),
    g = "";
  this.divRemTo(i, j, h);
  while (j.signum() > 0) {
    g = (e + h.intValue()).toString(c).substr(1) + g;
    j.divRemTo(i, j, h)
  }
  return h.intValue().toString(c) + g
}

function bnpFromRadix(m, h) {
  this.fromInt(0);
  if (h == null) {
    h = 10
  }
  var f = this.chunkSize(h);
  var g = Math.pow(h, f),
    e = false,
    a = 0,
    l = 0;
  for (var c = 0; c < m.length; ++c) {
    var k = intAt(m, c);
    if (k < 0) {
      if (m.charAt(c) == "-" && this.signum() == 0) {
        e = true
      }
      continue
    }
    l = h * l + k;
    if (++a >= f) {
      this.dMultiply(g);
      this.dAddOffset(l, 0);
      a = 0;
      l = 0
    }
  }
  if (a > 0) {
    this.dMultiply(Math.pow(h, a));
    this.dAddOffset(l, 0)
  }
  if (e) {
    BigInteger.ZERO.subTo(this, this)
  }
}

function bnpFromNumber(f, e, h) {
  if ("number" == typeof e) {
    if (f < 2) {
      this.fromInt(1)
    } else {
      this.fromNumber(f, h);
      if (!this.testBit(f - 1)) {
        this.bitwiseTo(BigInteger.ONE.shiftLeft(f - 1), op_or, this)
      }
      if (this.isEven()) {
        this.dAddOffset(1, 0)
      }
      while (!this.isProbablePrime(e)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > f) {
          this.subTo(BigInteger.ONE.shiftLeft(f - 1), this)
        }
      }
    }
  } else {
    var d = new Array(),
      g = f & 7;
    d.length = (f >> 3) + 1;
    e.nextBytes(d);
    if (g > 0) {
      d[0] &= ((1 << g) - 1)
    } else {
      d[0] = 0
    }
    this.fromString(d, 256)
  }
}

function bnToByteArray() {
  var b = this.t,
    c = new Array();
  c[0] = this.s;
  var e = this.DB - (b * this.DB) % 8,
    f, a = 0;
  if (b-- > 0) {
    if (e < this.DB && (f = this[b] >> e) != (this.s & this.DM) >> e) {
      c[a++] = f | (this.s << (this.DB - e))
    }
    while (b >= 0) {
      if (e < 8) {
        f = (this[b] & ((1 << e) - 1)) << (8 - e);
        f |= this[--b] >> (e += this.DB - 8)
      } else {
        f = (this[b] >> (e -= 8)) & 255;
        if (e <= 0) {
          e += this.DB;
          --b
        }
      }
      if ((f & 128) != 0) {
        f |= -256
      }
      if (a == 0 && (this.s & 128) != (f & 128)) {
        ++a
      }
      if (a > 0 || f != this.s) {
        c[a++] = f
      }
    }
  }
  return c
}

function bnEquals(b) {
  return (this.compareTo(b) == 0)
}

function bnMin(b) {
  return (this.compareTo(b) < 0) ? this : b
}

function bnMax(b) {
  return (this.compareTo(b) > 0) ? this : b
}

function bnpBitwiseTo(c, h, e) {
  var d, g, b = Math.min(c.t, this.t);
  for (d = 0; d < b; ++d) {
    e[d] = h(this[d], c[d])
  }
  if (c.t < this.t) {
    g = c.s & this.DM;
    for (d = b; d < this.t; ++d) {
      e[d] = h(this[d], g)
    }
    e.t = this.t
  } else {
    g = this.s & this.DM;
    for (d = b; d < c.t; ++d) {
      e[d] = h(g, c[d])
    }
    e.t = c.t
  }
  e.s = h(this.s, c.s);
  e.clamp()
}

function op_and(a, b) {
  return a & b
}

function bnAnd(b) {
  var c = nbi();
  this.bitwiseTo(b, op_and, c);
  return c
}

function op_or(a, b) {
  return a | b
}

function bnOr(b) {
  var c = nbi();
  this.bitwiseTo(b, op_or, c);
  return c
}

function op_xor(a, b) {
  return a ^ b
}

function bnXor(b) {
  var c = nbi();
  this.bitwiseTo(b, op_xor, c);
  return c
}

function op_andnot(a, b) {
  return a & ~b
}

function bnAndNot(b) {
  var c = nbi();
  this.bitwiseTo(b, op_andnot, c);
  return c
}

function bnNot() {
  var b = nbi();
  for (var a = 0; a < this.t; ++a) {
    b[a] = this.DM & ~this[a]
  }
  b.t = this.t;
  b.s = ~this.s;
  return b
}

function bnShiftLeft(b) {
  var a = nbi();
  if (b < 0) {
    this.rShiftTo(-b, a)
  } else {
    this.lShiftTo(b, a)
  }
  return a
}

function bnShiftRight(b) {
  var a = nbi();
  if (b < 0) {
    this.lShiftTo(-b, a)
  } else {
    this.rShiftTo(b, a)
  }
  return a
}

function lbit(a) {
  if (a == 0) {
    return -1
  }
  var b = 0;
  if ((a & 65535) == 0) {
    a >>= 16;
    b += 16
  }
  if ((a & 255) == 0) {
    a >>= 8;
    b += 8
  }
  if ((a & 15) == 0) {
    a >>= 4;
    b += 4
  }
  if ((a & 3) == 0) {
    a >>= 2;
    b += 2
  }
  if ((a & 1) == 0) {
    ++b
  }
  return b
}

function bnGetLowestSetBit() {
  for (var a = 0; a < this.t; ++a) {
    if (this[a] != 0) {
      return a * this.DB + lbit(this[a])
    }
  }
  if (this.s < 0) {
    return this.t * this.DB
  }
  return -1
}

function cbit(a) {
  var b = 0;
  while (a != 0) {
    a &= a - 1;
    ++b
  }
  return b
}

function bnBitCount() {
  var c = 0,
    a = this.s & this.DM;
  for (var b = 0; b < this.t; ++b) {
    c += cbit(this[b] ^ a)
  }
  return c
}

function bnTestBit(b) {
  var a = Math.floor(b / this.DB);
  if (a >= this.t) {
    return (this.s != 0)
  }
  return ((this[a] & (1 << (b % this.DB))) != 0)
}

function bnpChangeBit(c, b) {
  var a = BigInteger.ONE.shiftLeft(c);
  this.bitwiseTo(a, b, a);
  return a
}

function bnSetBit(a) {
  return this.changeBit(a, op_or)
}

function bnClearBit(a) {
  return this.changeBit(a, op_andnot)
}

function bnFlipBit(a) {
  return this.changeBit(a, op_xor)
}

function bnpAddTo(d, f) {
  var e = 0,
    g = 0,
    b = Math.min(d.t, this.t);
  while (e < b) {
    g += this[e] + d[e];
    f[e++] = g & this.DM;
    g >>= this.DB
  }
  if (d.t < this.t) {
    g += d.s;
    while (e < this.t) {
      g += this[e];
      f[e++] = g & this.DM;
      g >>= this.DB
    }
    g += this.s
  } else {
    g += this.s;
    while (e < d.t) {
      g += d[e];
      f[e++] = g & this.DM;
      g >>= this.DB
    }
    g += d.s
  }
  f.s = (g < 0) ? -1 : 0;
  if (g > 0) {
    f[e++] = g
  } else {
    if (g < -1) {
      f[e++] = this.DV + g
    }
  }
  f.t = e;
  f.clamp()
}

function bnAdd(b) {
  var c = nbi();
  this.addTo(b, c);
  return c
}

function bnSubtract(b) {
  var c = nbi();
  this.subTo(b, c);
  return c
}

function bnMultiply(b) {
  var c = nbi();
  this.multiplyTo(b, c);
  return c
}

function bnSquare() {
  var a = nbi();
  this.squareTo(a);
  return a
}

function bnDivide(b) {
  var c = nbi();
  this.divRemTo(b, c, null);
  return c
}

function bnRemainder(b) {
  var c = nbi();
  this.divRemTo(b, null, c);
  return c
}

function bnDivideAndRemainder(b) {
  var d = nbi(),
    c = nbi();
  this.divRemTo(b, d, c);
  return new Array(d, c)
}

function bnpDMultiply(a) {
  this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp()
}

function bnpDAddOffset(b, a) {
  if (b == 0) {
    return
  }
  while (this.t <= a) {
    this[this.t++] = 0
  }
  this[a] += b;
  while (this[a] >= this.DV) {
    this[a] -= this.DV;
    if (++a >= this.t) {
      this[this.t++] = 0
    }++this[a]
  }
}

function NullExp() {}

function nNop(a) {
  return a
}

function nMulTo(a, c, b) {
  a.multiplyTo(c, b)
}

function nSqrTo(a, b) {
  a.squareTo(b)
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

function bnPow(a) {
  return this.exp(a, new NullExp())
}

function bnpMultiplyLowerTo(b, f, e) {
  var d = Math.min(this.t + b.t, f);
  e.s = 0;
  e.t = d;
  while (d > 0) {
    e[--d] = 0
  }
  var c;
  for (c = e.t - this.t; d < c; ++d) {
    e[d + this.t] = this.am(0, b[d], e, d, 0, this.t)
  }
  for (c = Math.min(b.t, f); d < c; ++d) {
    this.am(0, b[d], e, d, 0, f - d)
  }
  e.clamp()
}

function bnpMultiplyUpperTo(b, e, d) {
  --e;
  var c = d.t = this.t + b.t - e;
  d.s = 0;
  while (--c >= 0) {
    d[c] = 0
  }
  for (c = Math.max(e - this.t, 0); c < b.t; ++c) {
    d[this.t + c - e] = this.am(e - c, b[c], d, 0, 0, this.t + c - e)
  }
  d.clamp();
  d.drShiftTo(1, d)
}

function Barrett(a) {
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2 * a.t, this.r2);
  this.mu = this.r2.divide(a);
  this.m = a
}

function barrettConvert(a) {
  if (a.s < 0 || a.t > 2 * this.m.t) {
    return a.mod(this.m)
  } else {
    if (a.compareTo(this.m) < 0) {
      return a
    } else {
      var b = nbi();
      a.copyTo(b);
      this.reduce(b);
      return b
    }
  }
}

function barrettRevert(a) {
  return a
}

function barrettReduce(a) {
  a.drShiftTo(this.m.t - 1, this.r2);
  if (a.t > this.m.t + 1) {
    a.t = this.m.t + 1;
    a.clamp()
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (a.compareTo(this.r2) < 0) {
    a.dAddOffset(1, this.m.t + 1)
  }
  a.subTo(this.r2, a);
  while (a.compareTo(this.m) >= 0) {
    a.subTo(this.m, a)
  }
}

function barrettSqrTo(a, b) {
  a.squareTo(b);
  this.reduce(b)
}

function barrettMulTo(a, c, b) {
  a.multiplyTo(c, b);
  this.reduce(b)
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

function bnModPow(q, f) {
  var o = q.bitLength(),
    h, b = nbv(1),
    v;
  if (o <= 0) {
    return b
  } else {
    if (o < 18) {
      h = 1
    } else {
      if (o < 48) {
        h = 3
      } else {
        if (o < 144) {
          h = 4
        } else {
          if (o < 768) {
            h = 5
          } else {
            h = 6
          }
        }
      }
    }
  }
  if (o < 8) {
    v = new Classic(f)
  } else {
    if (f.isEven()) {
      v = new Barrett(f)
    } else {
      v = new Montgomery(f)
    }
  }
  var p = new Array(),
    d = 3,
    s = h - 1,
    a = (1 << h) - 1;
  p[1] = v.convert(this);
  if (h > 1) {
    var A = nbi();
    v.sqrTo(p[1], A);
    while (d <= a) {
      p[d] = nbi();
      v.mulTo(A, p[d - 2], p[d]);
      d += 2
    }
  }
  var l = q.t - 1,
    x, u = true,
    c = nbi(),
    y;
  o = nbits(q[l]) - 1;
  while (l >= 0) {
    if (o >= s) {
      x = (q[l] >> (o - s)) & a
    } else {
      x = (q[l] & ((1 << (o + 1)) - 1)) << (s - o);
      if (l > 0) {
        x |= q[l - 1] >> (this.DB + o - s)
      }
    }
    d = h;
    while ((x & 1) == 0) {
      x >>= 1;
      --d
    }
    if ((o -= d) < 0) {
      o += this.DB;
      --l
    }
    if (u) {
      p[x].copyTo(b);
      u = false
    } else {
      while (d > 1) {
        v.sqrTo(b, c);
        v.sqrTo(c, b);
        d -= 2
      }
      if (d > 0) {
        v.sqrTo(b, c)
      } else {
        y = b;
        b = c;
        c = y
      }
      v.mulTo(c, p[x], b)
    }
    while (l >= 0 && (q[l] & (1 << o)) == 0) {
      v.sqrTo(b, c);
      y = b;
      b = c;
      c = y;
      if (--o < 0) {
        o = this.DB - 1;
        --l
      }
    }
  }
  return v.revert(b)
}

function bnGCD(c) {
  var b = (this.s < 0) ? this.negate() : this.clone();
  var h = (c.s < 0) ? c.negate() : c.clone();
  if (b.compareTo(h) < 0) {
    var e = b;
    b = h;
    h = e
  }
  var d = b.getLowestSetBit(),
    f = h.getLowestSetBit();
  if (f < 0) {
    return b
  }
  if (d < f) {
    f = d
  }
  if (f > 0) {
    b.rShiftTo(f, b);
    h.rShiftTo(f, h)
  }
  while (b.signum() > 0) {
    if ((d = b.getLowestSetBit()) > 0) {
      b.rShiftTo(d, b)
    }
    if ((d = h.getLowestSetBit()) > 0) {
      h.rShiftTo(d, h)
    }
    if (b.compareTo(h) >= 0) {
      b.subTo(h, b);
      b.rShiftTo(1, b)
    } else {
      h.subTo(b, h);
      h.rShiftTo(1, h)
    }
  }
  if (f > 0) {
    h.lShiftTo(f, h)
  }
  return h
}

function bnpModInt(e) {
  if (e <= 0) {
    return 0
  }
  var c = this.DV % e,
    b = (this.s < 0) ? e - 1 : 0;
  if (this.t > 0) {
    if (c == 0) {
      b = this[0] % e
    } else {
      for (var a = this.t - 1; a >= 0; --a) {
        b = (c * b + this[a]) % e
      }
    }
  }
  return b
}

function bnModInverse(f) {
  var j = f.isEven();
  if ((this.isEven() && j) || f.signum() == 0) {
    return BigInteger.ZERO
  }
  var i = f.clone(),
    h = this.clone();
  var g = nbv(1),
    e = nbv(0),
    l = nbv(0),
    k = nbv(1);
  while (i.signum() != 0) {
    while (i.isEven()) {
      i.rShiftTo(1, i);
      if (j) {
        if (!g.isEven() || !e.isEven()) {
          g.addTo(this, g);
          e.subTo(f, e)
        }
        g.rShiftTo(1, g)
      } else {
        if (!e.isEven()) {
          e.subTo(f, e)
        }
      }
      e.rShiftTo(1, e)
    }
    while (h.isEven()) {
      h.rShiftTo(1, h);
      if (j) {
        if (!l.isEven() || !k.isEven()) {
          l.addTo(this, l);
          k.subTo(f, k)
        }
        l.rShiftTo(1, l)
      } else {
        if (!k.isEven()) {
          k.subTo(f, k)
        }
      }
      k.rShiftTo(1, k)
    }
    if (i.compareTo(h) >= 0) {
      i.subTo(h, i);
      if (j) {
        g.subTo(l, g)
      }
      e.subTo(k, e)
    } else {
      h.subTo(i, h);
      if (j) {
        l.subTo(g, l)
      }
      k.subTo(e, k)
    }
  }
  if (h.compareTo(BigInteger.ONE) != 0) {
    return BigInteger.ZERO
  }
  if (k.compareTo(f) >= 0) {
    return k.subtract(f)
  }
  if (k.signum() < 0) {
    k.addTo(f, k)
  } else {
    return k
  }
  if (k.signum() < 0) {
    return k.add(f)
  } else {
    return k
  }
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];

function bnIsProbablePrime(e) {
  var d, b = this.abs();
  if (b.t == 1 && b[0] <= lowprimes[lowprimes.length - 1]) {
    for (d = 0; d < lowprimes.length; ++d) {
      if (b[0] == lowprimes[d]) {
        return true
      }
    }
    return false
  }
  if (b.isEven()) {
    return false
  }
  d = 1;
  while (d < lowprimes.length) {
    var a = lowprimes[d],
      c = d + 1;
    while (c < lowprimes.length && a < lplim) {
      a *= lowprimes[c++]
    }
    a = b.modInt(a);
    while (d < c) {
      if (a % lowprimes[d++] == 0) {
        return false
      }
    }
  }
  return b.millerRabin(e)
}

function bnpMillerRabin(f) {
  var g = this.subtract(BigInteger.ONE);
  var c = g.getLowestSetBit();
  if (c <= 0) {
    return false
  }
  var h = g.shiftRight(c);
  f = (f + 1) >> 1;
  if (f > lowprimes.length) {
    f = lowprimes.length
  }
  var b = nbi();
  for (var e = 0; e < f; ++e) {
    b.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
    var l = b.modPow(h, this);
    if (l.compareTo(BigInteger.ONE) != 0 && l.compareTo(g) != 0) {
      var d = 1;
      while (d++ < c && l.compareTo(g) != 0) {
        l = l.modPowInt(2, this);
        if (l.compareTo(BigInteger.ONE) == 0) {
          return false
        }
      }
      if (l.compareTo(g) != 0) {
        return false
      }
    }
  }
  return true
}
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
BigInteger.prototype.square = bnSquare;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function Arcfour() {
  this.i = 0;
  this.j = 0;
  this.S = new Array()
}

function ARC4init(d) {
  var c, a, b;
  for (c = 0; c < 256; ++c) {
    this.S[c] = c
  }
  a = 0;
  for (c = 0; c < 256; ++c) {
    a = (a + this.S[c] + d[c % d.length]) & 255;
    b = this.S[c];
    this.S[c] = this.S[a];
    this.S[a] = b
  }
  this.i = 0;
  this.j = 0
}

function ARC4next() {
  var a;
  this.i = (this.i + 1) & 255;
  this.j = (this.j + this.S[this.i]) & 255;
  a = this.S[this.i];
  this.S[this.i] = this.S[this.j];
  this.S[this.j] = a;
  return this.S[(a + this.S[this.i]) & 255]
}
Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;

function prng_newstate() {
  return new Arcfour()
}
var rng_psize = 256;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var rng_state;
var rng_pool;
var rng_pptr;

function rng_seed_int(a) {
  rng_pool[rng_pptr++] ^= a & 255;
  rng_pool[rng_pptr++] ^= (a >> 8) & 255;
  rng_pool[rng_pptr++] ^= (a >> 16) & 255;
  rng_pool[rng_pptr++] ^= (a >> 24) & 255;
  if (rng_pptr >= rng_psize) {
    rng_pptr -= rng_psize
  }
}

function rng_seed_time() {
  rng_seed_int(new Date().getTime())
}
if (rng_pool == null) {
  rng_pool = new Array();
  rng_pptr = 0;
  var t;
  if (window !== undefined && (window.crypto !== undefined || window.msCrypto !== undefined)) {
    var crypto = window.crypto || window.msCrypto;
    if (crypto.getRandomValues) {
      var ua = new Uint8Array(32);
      crypto.getRandomValues(ua);
      for (t = 0; t < 32; ++t) {
        rng_pool[rng_pptr++] = ua[t]
      }
    } else {
      if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
        var z = window.crypto.random(32);
        for (t = 0; t < z.length; ++t) {
          rng_pool[rng_pptr++] = z.charCodeAt(t) & 255
        }
      }
    }
  }
  while (rng_pptr < rng_psize) {
    t = Math.floor(65536 * Math.random());
    rng_pool[rng_pptr++] = t >>> 8;
    rng_pool[rng_pptr++] = t & 255
  }
  rng_pptr = 0;
  rng_seed_time()
}

function rng_get_byte() {
  if (rng_state == null) {
    rng_seed_time();
    rng_state = prng_newstate();
    rng_state.init(rng_pool);
    for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
      rng_pool[rng_pptr] = 0
    }
    rng_pptr = 0
  }
  return rng_state.next()
}

function rng_get_bytes(b) {
  var a;
  for (a = 0; a < b.length; ++a) {
    b[a] = rng_get_byte()
  }
}

function SecureRandom() {}
SecureRandom.prototype.nextBytes = rng_get_bytes;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function parseBigInt(b, a) {
  return new BigInteger(b, a)
}

function linebrk(c, d) {
  var a = "";
  var b = 0;
  while (b + d < c.length) {
    a += c.substring(b, b + d) + "\n";
    b += d
  }
  return a + c.substring(b, c.length)
}

function byte2Hex(a) {
  if (a < 16) {
    return "0" + a.toString(16)
  } else {
    return a.toString(16)
  }
}

function pkcs1pad2(e, h) {
  if (h < e.length + 11) {
    throw "Message too long for RSA";
    return null
  }
  var g = new Array();
  var d = e.length - 1;
  while (d >= 0 && h > 0) {
    var f = e.charCodeAt(d--);
    if (f < 128) {
      g[--h] = f
    } else {
      if ((f > 127) && (f < 2048)) {
        g[--h] = (f & 63) | 128;
        g[--h] = (f >> 6) | 192
      } else {
        g[--h] = (f & 63) | 128;
        g[--h] = ((f >> 6) & 63) | 128;
        g[--h] = (f >> 12) | 224
      }
    }
  }
  g[--h] = 0;
  var b = new SecureRandom();
  var a = new Array();
  while (h > 2) {
    a[0] = 0;
    while (a[0] == 0) {
      b.nextBytes(a)
    }
    g[--h] = a[0]
  }
  g[--h] = 2;
  g[--h] = 0;
  return new BigInteger(g)
}

function oaep_mgf1_arr(c, a, e) {
  var b = "",
    d = 0;
  while (b.length < a) {
    b += e(String.fromCharCode.apply(String, c.concat([(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255])));
    d += 1
  }
  return b
}

function oaep_pad(q, a, f, l) {
  var c = KJUR.crypto.MessageDigest;
  var o = KJUR.crypto.Util;
  var b = null;
  if (!f) {
    f = "sha1"
  }
  if (typeof f === "string") {
    b = c.getCanonicalAlgName(f);
    l = c.getHashLength(b);
    f = function (i) {
      return hextorstr(o.hashHex(rstrtohex(i), b))
    }
  }
  if (q.length + 2 * l + 2 > a) {
    throw "Message too long for RSA"
  }
  var k = "",
    e;
  for (e = 0; e < a - q.length - 2 * l - 2; e += 1) {
    k += "\x00"
  }
  var h = f("") + k + "\x01" + q;
  var g = new Array(l);
  new SecureRandom().nextBytes(g);
  var j = oaep_mgf1_arr(g, h.length, f);
  var p = [];
  for (e = 0; e < h.length; e += 1) {
    p[e] = h.charCodeAt(e) ^ j.charCodeAt(e)
  }
  var m = oaep_mgf1_arr(p, g.length, f);
  var d = [0];
  for (e = 0; e < g.length; e += 1) {
    d[e + 1] = g[e] ^ m.charCodeAt(e)
  }
  return new BigInteger(d.concat(p))
}

function RSAKey() {
  this.n = null;
  this.e = 0;
  this.d = null;
  this.p = null;
  this.q = null;
  this.dmp1 = null;
  this.dmq1 = null;
  this.coeff = null
}

function RSASetPublic(b, a) {
  this.isPublic = true;
  this.isPrivate = false;
  if (typeof b !== "string") {
    this.n = b;
    this.e = a
  } else {
    if (b != null && a != null && b.length > 0 && a.length > 0) {
      this.n = parseBigInt(b, 16);
      this.e = parseInt(a, 16)
    } else {
      throw "Invalid RSA public key"
    }
  }
}

function RSADoPublic(a) {
  return a.modPowInt(this.e, this.n)
}

function RSAEncrypt(d) {
  var a = pkcs1pad2(d, (this.n.bitLength() + 7) >> 3);
  if (a == null) {
    return null
  }
  var e = this.doPublic(a);
  if (e == null) {
    return null
  }
  var b = e.toString(16);
  if ((b.length & 1) == 0) {
    return b
  } else {
    return "0" + b
  }
}

function RSAEncryptOAEP(f, e, b) {
  var a = oaep_pad(f, (this.n.bitLength() + 7) >> 3, e, b);
  if (a == null) {
    return null
  }
  var g = this.doPublic(a);
  if (g == null) {
    return null
  }
  var d = g.toString(16);
  if ((d.length & 1) == 0) {
    return d
  } else {
    return "0" + d
  }
}
RSAKey.prototype.doPublic = RSADoPublic;
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
RSAKey.prototype.encryptOAEP = RSAEncryptOAEP;
RSAKey.prototype.type = "RSA";
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function pkcs1unpad2(g, j) {
  var a = g.toByteArray();
  var f = 0;
  while (f < a.length && a[f] == 0) {
    ++f
  }
  if (a.length - f != j - 1 || a[f] != 2) {
    return null
  }++f;
  while (a[f] != 0) {
    if (++f >= a.length) {
      return null
    }
  }
  var e = "";
  while (++f < a.length) {
    var h = a[f] & 255;
    if (h < 128) {
      e += String.fromCharCode(h)
    } else {
      if ((h > 191) && (h < 224)) {
        e += String.fromCharCode(((h & 31) << 6) | (a[f + 1] & 63));
        ++f
      } else {
        e += String.fromCharCode(((h & 15) << 12) | ((a[f + 1] & 63) << 6) | (a[f + 2] & 63));
        f += 2
      }
    }
  }
  return e
}

function oaep_mgf1_str(c, a, e) {
  var b = "",
    d = 0;
  while (b.length < a) {
    b += e(c + String.fromCharCode.apply(String, [(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255]));
    d += 1
  }
  return b
}

function oaep_unpad(o, b, g, p) {
  var e = KJUR.crypto.MessageDigest;
  var r = KJUR.crypto.Util;
  var c = null;
  if (!g) {
    g = "sha1"
  }
  if (typeof g === "string") {
    c = e.getCanonicalAlgName(g);
    p = e.getHashLength(c);
    g = function (d) {
      return hextorstr(r.hashHex(rstrtohex(d), c))
    }
  }
  o = o.toByteArray();
  var h;
  for (h = 0; h < o.length; h += 1) {
    o[h] &= 255
  }
  while (o.length < b) {
    o.unshift(0)
  }
  o = String.fromCharCode.apply(String, o);
  if (o.length < 2 * p + 2) {
    throw "Cipher too short"
  }
  var f = o.substr(1, p);
  var s = o.substr(p + 1);
  var q = oaep_mgf1_str(s, p, g);
  var k = [],
    h;
  for (h = 0; h < f.length; h += 1) {
    k[h] = f.charCodeAt(h) ^ q.charCodeAt(h)
  }
  var l = oaep_mgf1_str(String.fromCharCode.apply(String, k), o.length - p, g);
  var j = [];
  for (h = 0; h < s.length; h += 1) {
    j[h] = s.charCodeAt(h) ^ l.charCodeAt(h)
  }
  j = String.fromCharCode.apply(String, j);
  if (j.substr(0, p) !== g("")) {
    throw "Hash mismatch"
  }
  j = j.substr(p);
  var a = j.indexOf("\x01");
  var m = (a != -1) ? j.substr(0, a).lastIndexOf("\x00") : -1;
  if (m + 1 != a) {
    throw "Malformed data"
  }
  return j.substr(a + 1)
}

function RSASetPrivate(c, a, b) {
  this.isPrivate = true;
  if (typeof c !== "string") {
    this.n = c;
    this.e = a;
    this.d = b
  } else {
    if (c != null && a != null && c.length > 0 && a.length > 0) {
      this.n = parseBigInt(c, 16);
      this.e = parseInt(a, 16);
      this.d = parseBigInt(b, 16)
    } else {
      throw "Invalid RSA private key"
    }
  }
}

function RSASetPrivateEx(g, d, e, c, b, a, h, f) {
  this.isPrivate = true;
  this.isPublic = false;
  if (g == null) {
    throw "RSASetPrivateEx N == null"
  }
  if (d == null) {
    throw "RSASetPrivateEx E == null"
  }
  if (g.length == 0) {
    throw "RSASetPrivateEx N.length == 0"
  }
  if (d.length == 0) {
    throw "RSASetPrivateEx E.length == 0"
  }
  if (g != null && d != null && g.length > 0 && d.length > 0) {
    this.n = parseBigInt(g, 16);
    this.e = parseInt(d, 16);
    this.d = parseBigInt(e, 16);
    this.p = parseBigInt(c, 16);
    this.q = parseBigInt(b, 16);
    this.dmp1 = parseBigInt(a, 16);
    this.dmq1 = parseBigInt(h, 16);
    this.coeff = parseBigInt(f, 16)
  } else {
    throw "Invalid RSA private key in RSASetPrivateEx"
  }
}

function RSAGenerate(b, i) {
  var a = new SecureRandom();
  var f = b >> 1;
  this.e = parseInt(i, 16);
  var c = new BigInteger(i, 16);
  for (;;) {
    for (;;) {
      this.p = new BigInteger(b - f, 1, a);
      if (this.p.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
        break
      }
    }
    for (;;) {
      this.q = new BigInteger(f, 1, a);
      if (this.q.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
        break
      }
    }
    if (this.p.compareTo(this.q) <= 0) {
      var h = this.p;
      this.p = this.q;
      this.q = h
    }
    var g = this.p.subtract(BigInteger.ONE);
    var d = this.q.subtract(BigInteger.ONE);
    var e = g.multiply(d);
    if (e.gcd(c).compareTo(BigInteger.ONE) == 0) {
      this.n = this.p.multiply(this.q);
      if (this.n.bitLength() == b) {
        this.d = c.modInverse(e);
        this.dmp1 = this.d.mod(g);
        this.dmq1 = this.d.mod(d);
        this.coeff = this.q.modInverse(this.p);
        break
      }
    }
  }
  this.isPrivate = true
}

function RSADoPrivate(a) {
  if (this.p == null || this.q == null) {
    return a.modPow(this.d, this.n)
  }
  var c = a.mod(this.p).modPow(this.dmp1, this.p);
  var b = a.mod(this.q).modPow(this.dmq1, this.q);
  while (c.compareTo(b) < 0) {
    c = c.add(this.p)
  }
  return c.subtract(b).multiply(this.coeff).mod(this.p).multiply(this.q).add(b)
}

function RSADecrypt(b) {
  if (b.length != Math.ceil(this.n.bitLength() / 4)) {
    throw new Error("wrong ctext length")
  }
  var d = parseBigInt(b, 16);
  var a = this.doPrivate(d);
  if (a == null) {
    return null
  }
  return pkcs1unpad2(a, (this.n.bitLength() + 7) >> 3)
}

function RSADecryptOAEP(e, d, b) {
  if (e.length != Math.ceil(this.n.bitLength() / 4)) {
    throw new Error("wrong ctext length")
  }
  var f = parseBigInt(e, 16);
  var a = this.doPrivate(f);
  if (a == null) {
    return null
  }
  return oaep_unpad(a, (this.n.bitLength() + 7) >> 3, d, b)
}
RSAKey.prototype.doPrivate = RSADoPrivate;
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
RSAKey.prototype.decryptOAEP = RSADecryptOAEP;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function ECFieldElementFp(b, a) {
  this.x = a;
  this.q = b
}

function feFpEquals(a) {
  if (a == this) {
    return true
  }
  return (this.q.equals(a.q) && this.x.equals(a.x))
}

function feFpToBigInteger() {
  return this.x
}

function feFpNegate() {
  return new ECFieldElementFp(this.q, this.x.negate().mod(this.q))
}

function feFpAdd(a) {
  return new ECFieldElementFp(this.q, this.x.add(a.toBigInteger()).mod(this.q))
}

function feFpSubtract(a) {
  return new ECFieldElementFp(this.q, this.x.subtract(a.toBigInteger()).mod(this.q))
}

function feFpMultiply(a) {
  return new ECFieldElementFp(this.q, this.x.multiply(a.toBigInteger()).mod(this.q))
}

function feFpSquare() {
  return new ECFieldElementFp(this.q, this.x.square().mod(this.q))
}

function feFpDivide(a) {
  return new ECFieldElementFp(this.q, this.x.multiply(a.toBigInteger().modInverse(this.q)).mod(this.q))
}
ECFieldElementFp.prototype.equals = feFpEquals;
ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
ECFieldElementFp.prototype.negate = feFpNegate;
ECFieldElementFp.prototype.add = feFpAdd;
ECFieldElementFp.prototype.subtract = feFpSubtract;
ECFieldElementFp.prototype.multiply = feFpMultiply;
ECFieldElementFp.prototype.square = feFpSquare;
ECFieldElementFp.prototype.divide = feFpDivide;

function ECPointFp(c, a, d, b) {
  this.curve = c;
  this.x = a;
  this.y = d;
  if (b == null) {
    this.z = BigInteger.ONE
  } else {
    this.z = b
  }
  this.zinv = null
}

function pointFpGetX() {
  if (this.zinv == null) {
    this.zinv = this.z.modInverse(this.curve.q)
  }
  return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))
}

function pointFpGetY() {
  if (this.zinv == null) {
    this.zinv = this.z.modInverse(this.curve.q)
  }
  return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))
}

function pointFpEquals(a) {
  if (a == this) {
    return true
  }
  if (this.isInfinity()) {
    return a.isInfinity()
  }
  if (a.isInfinity()) {
    return this.isInfinity()
  }
  var c, b;
  c = a.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(a.z)).mod(this.curve.q);
  if (!c.equals(BigInteger.ZERO)) {
    return false
  }
  b = a.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(a.z)).mod(this.curve.q);
  return b.equals(BigInteger.ZERO)
}

function pointFpIsInfinity() {
  if ((this.x == null) && (this.y == null)) {
    return true
  }
  return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO)
}

function pointFpNegate() {
  return new ECPointFp(this.curve, this.x, this.y.negate(), this.z)
}

function pointFpAdd(l) {
  if (this.isInfinity()) {
    return l
  }
  if (l.isInfinity()) {
    return this
  }
  var p = l.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(l.z)).mod(this.curve.q);
  var o = l.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(l.z)).mod(this.curve.q);
  if (BigInteger.ZERO.equals(o)) {
    if (BigInteger.ZERO.equals(p)) {
      return this.twice()
    }
    return this.curve.getInfinity()
  }
  var j = new BigInteger("3");
  var e = this.x.toBigInteger();
  var n = this.y.toBigInteger();
  var c = l.x.toBigInteger();
  var k = l.y.toBigInteger();
  var m = o.square();
  var i = m.multiply(o);
  var d = e.multiply(m);
  var g = p.square().multiply(this.z);
  var a = g.subtract(d.shiftLeft(1)).multiply(l.z).subtract(i).multiply(o).mod(this.curve.q);
  var h = d.multiply(j).multiply(p).subtract(n.multiply(i)).subtract(g.multiply(p)).multiply(l.z).add(p.multiply(i)).mod(this.curve.q);
  var f = i.multiply(this.z).multiply(l.z).mod(this.curve.q);
  return new ECPointFp(this.curve, this.curve.fromBigInteger(a), this.curve.fromBigInteger(h), f)
}

function pointFpTwice() {
  if (this.isInfinity()) {
    return this
  }
  if (this.y.toBigInteger().signum() == 0) {
    return this.curve.getInfinity()
  }
  var g = new BigInteger("3");
  var c = this.x.toBigInteger();
  var h = this.y.toBigInteger();
  var e = h.multiply(this.z);
  var j = e.multiply(h).mod(this.curve.q);
  var i = this.curve.a.toBigInteger();
  var k = c.square().multiply(g);
  if (!BigInteger.ZERO.equals(i)) {
    k = k.add(this.z.square().multiply(i))
  }
  k = k.mod(this.curve.q);
  var b = k.square().subtract(c.shiftLeft(3).multiply(j)).shiftLeft(1).multiply(e).mod(this.curve.q);
  var f = k.multiply(g).multiply(c).subtract(j.shiftLeft(1)).shiftLeft(2).multiply(j).subtract(k.square().multiply(k)).mod(this.curve.q);
  var d = e.square().multiply(e).shiftLeft(3).mod(this.curve.q);
  return new ECPointFp(this.curve, this.curve.fromBigInteger(b), this.curve.fromBigInteger(f), d)
}

function pointFpMultiply(d) {
  if (this.isInfinity()) {
    return this
  }
  if (d.signum() == 0) {
    return this.curve.getInfinity()
  }
  var m = d;
  var l = m.multiply(new BigInteger("3"));
  var b = this.negate();
  var j = this;
  var q = this.curve.q.subtract(d);
  var o = q.multiply(new BigInteger("3"));
  var c = new ECPointFp(this.curve, this.x, this.y);
  var a = c.negate();
  var g;
  for (g = l.bitLength() - 2; g > 0; --g) {
    j = j.twice();
    var n = l.testBit(g);
    var f = m.testBit(g);
    if (n != f) {
      j = j.add(n ? this : b)
    }
  }
  for (g = o.bitLength() - 2; g > 0; --g) {
    c = c.twice();
    var p = o.testBit(g);
    var r = q.testBit(g);
    if (p != r) {
      c = c.add(p ? c : a)
    }
  }
  return j
}

function pointFpMultiplyTwo(c, a, b) {
  var d;
  if (c.bitLength() > b.bitLength()) {
    d = c.bitLength() - 1
  } else {
    d = b.bitLength() - 1
  }
  var f = this.curve.getInfinity();
  var e = this.add(a);
  while (d >= 0) {
    f = f.twice();
    if (c.testBit(d)) {
      if (b.testBit(d)) {
        f = f.add(e)
      } else {
        f = f.add(this)
      }
    } else {
      if (b.testBit(d)) {
        f = f.add(a)
      }
    }--d
  }
  return f
}
ECPointFp.prototype.getX = pointFpGetX;
ECPointFp.prototype.getY = pointFpGetY;
ECPointFp.prototype.equals = pointFpEquals;
ECPointFp.prototype.isInfinity = pointFpIsInfinity;
ECPointFp.prototype.negate = pointFpNegate;
ECPointFp.prototype.add = pointFpAdd;
ECPointFp.prototype.twice = pointFpTwice;
ECPointFp.prototype.multiply = pointFpMultiply;
ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;

function ECCurveFp(e, d, c) {
  this.q = e;
  this.a = this.fromBigInteger(d);
  this.b = this.fromBigInteger(c);
  this.infinity = new ECPointFp(this, null, null)
}

function curveFpGetQ() {
  return this.q
}

function curveFpGetA() {
  return this.a
}

function curveFpGetB() {
  return this.b
}

function curveFpEquals(a) {
  if (a == this) {
    return true
  }
  return (this.q.equals(a.q) && this.a.equals(a.a) && this.b.equals(a.b))
}

function curveFpGetInfinity() {
  return this.infinity
}

function curveFpFromBigInteger(a) {
  return new ECFieldElementFp(this.q, a)
}

function curveFpDecodePointHex(d) {
  switch (parseInt(d.substr(0, 2), 16)) {
    case 0:
      return this.infinity;
    case 2:
    case 3:
      return null;
    case 4:
    case 6:
    case 7:
      var a = (d.length - 2) / 2;
      var c = d.substr(2, a);
      var b = d.substr(a + 2, a);
      return new ECPointFp(this, this.fromBigInteger(new BigInteger(c, 16)), this.fromBigInteger(new BigInteger(b, 16)));
    default:
      return null
  }
}
ECCurveFp.prototype.getQ = curveFpGetQ;
ECCurveFp.prototype.getA = curveFpGetA;
ECCurveFp.prototype.getB = curveFpGetB;
ECCurveFp.prototype.equals = curveFpEquals;
ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
 */
ECFieldElementFp.prototype.getByteLength = function () {
  return Math.floor((this.toBigInteger().bitLength() + 7) / 8)
};
ECPointFp.prototype.getEncoded = function (c) {
  var d = function (h, f) {
    var g = h.toByteArrayUnsigned();
    if (f < g.length) {
      g = g.slice(g.length - f)
    } else {
      while (f > g.length) {
        g.unshift(0)
      }
    }
    return g
  };
  var a = this.getX().toBigInteger();
  var e = this.getY().toBigInteger();
  var b = d(a, 32);
  if (c) {
    if (e.isEven()) {
      b.unshift(2)
    } else {
      b.unshift(3)
    }
  } else {
    b.unshift(4);
    b = b.concat(d(e, 32))
  }
  return b
};
ECPointFp.decodeFrom = function (g, c) {
  var f = c[0];
  var e = c.length - 1;
  var d = c.slice(1, 1 + e / 2);
  var b = c.slice(1 + e / 2, 1 + e);
  d.unshift(0);
  b.unshift(0);
  var a = new BigInteger(d);
  var h = new BigInteger(b);
  return new ECPointFp(g, g.fromBigInteger(a), g.fromBigInteger(h))
};
ECPointFp.decodeFromHex = function (g, c) {
  var f = c.substr(0, 2);
  var e = c.length - 2;
  var d = c.substr(2, e / 2);
  var b = c.substr(2 + e / 2, e / 2);
  var a = new BigInteger(d, 16);
  var h = new BigInteger(b, 16);
  return new ECPointFp(g, g.fromBigInteger(a), g.fromBigInteger(h))
};
ECPointFp.prototype.add2D = function (c) {
  if (this.isInfinity()) {
    return c
  }
  if (c.isInfinity()) {
    return this
  }
  if (this.x.equals(c.x)) {
    if (this.y.equals(c.y)) {
      return this.twice()
    }
    return this.curve.getInfinity()
  }
  var g = c.x.subtract(this.x);
  var e = c.y.subtract(this.y);
  var a = e.divide(g);
  var d = a.square().subtract(this.x).subtract(c.x);
  var f = a.multiply(this.x.subtract(d)).subtract(this.y);
  return new ECPointFp(this.curve, d, f)
};
ECPointFp.prototype.twice2D = function () {
  if (this.isInfinity()) {
    return this
  }
  if (this.y.toBigInteger().signum() == 0) {
    return this.curve.getInfinity()
  }
  var b = this.curve.fromBigInteger(BigInteger.valueOf(2));
  var e = this.curve.fromBigInteger(BigInteger.valueOf(3));
  var a = this.x.square().multiply(e).add(this.curve.a).divide(this.y.multiply(b));
  var c = a.square().subtract(this.x.multiply(b));
  var d = a.multiply(this.x.subtract(c)).subtract(this.y);
  return new ECPointFp(this.curve, c, d)
};
ECPointFp.prototype.multiply2D = function (b) {
  if (this.isInfinity()) {
    return this
  }
  if (b.signum() == 0) {
    return this.curve.getInfinity()
  }
  var g = b;
  var f = g.multiply(new BigInteger("3"));
  var l = this.negate();
  var d = this;
  var c;
  for (c = f.bitLength() - 2; c > 0; --c) {
    d = d.twice();
    var a = f.testBit(c);
    var j = g.testBit(c);
    if (a != j) {
      d = d.add2D(a ? this : l)
    }
  }
  return d
};
ECPointFp.prototype.isOnCurve = function () {
  var d = this.getX().toBigInteger();
  var i = this.getY().toBigInteger();
  var f = this.curve.getA().toBigInteger();
  var c = this.curve.getB().toBigInteger();
  var h = this.curve.getQ();
  var e = i.multiply(i).mod(h);
  var g = d.multiply(d).multiply(d).add(f.multiply(d)).add(c).mod(h);
  return e.equals(g)
};
ECPointFp.prototype.toString = function () {
  return "(" + this.getX().toBigInteger().toString() + "," + this.getY().toBigInteger().toString() + ")"
};
ECPointFp.prototype.validate = function () {
  var c = this.curve.getQ();
  if (this.isInfinity()) {
    throw new Error("Point is at infinity.")
  }
  var a = this.getX().toBigInteger();
  var b = this.getY().toBigInteger();
  if (a.compareTo(BigInteger.ONE) < 0 || a.compareTo(c.subtract(BigInteger.ONE)) > 0) {
    throw new Error("x coordinate out of bounds")
  }
  if (b.compareTo(BigInteger.ONE) < 0 || b.compareTo(c.subtract(BigInteger.ONE)) > 0) {
    throw new Error("y coordinate out of bounds")
  }
  if (!this.isOnCurve()) {
    throw new Error("Point is not on the curve.")
  }
  if (this.multiply(c).isInfinity()) {
    throw new Error("Point is not a scalar multiple of G.")
  }
  return true
};
/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */
var jsonParse = (function () {
  var e = "(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)";
  var j = '(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
  var i = '(?:"' + j + '*")';
  var d = new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|" + e + "|" + i + ")", "g");
  var k = new RegExp("\\\\(?:([^u])|u(.{4}))", "g");
  var g = {
    '"': '"',
    "/": "/",
    "\\": "\\",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "\t"
  };

  function h(l, m, n) {
    return m ? g[m] : String.fromCharCode(parseInt(n, 16))
  }
  var c = new String("");
  var a = "\\";
  var f = {
    "{": Object,
    "[": Array
  };
  var b = Object.hasOwnProperty;
  return function (u, q) {
    var p = u.match(d);
    var x;
    var v = p[0];
    var l = false;
    if ("{" === v) {
      x = {}
    } else {
      if ("[" === v) {
        x = []
      } else {
        x = [];
        l = true
      }
    }
    var t;
    var r = [x];
    for (var o = 1 - l, m = p.length; o < m; ++o) {
      v = p[o];
      var w;
      switch (v.charCodeAt(0)) {
        default:
          w = r[0];
          w[t || w.length] = +(v);
          t = void 0;
          break;
        case 34:
          v = v.substring(1, v.length - 1);
          if (v.indexOf(a) !== -1) {
            v = v.replace(k, h)
          }
          w = r[0];
          if (!t) {
            if (w instanceof Array) {
              t = w.length
            } else {
              t = v || c;
              break
            }
          }
          w[t] = v;
          t = void 0;
          break;
        case 91:
          w = r[0];
          r.unshift(w[t || w.length] = []);
          t = void 0;
          break;
        case 93:
          r.shift();
          break;
        case 102:
          w = r[0];
          w[t || w.length] = false;
          t = void 0;
          break;
        case 110:
          w = r[0];
          w[t || w.length] = null;
          t = void 0;
          break;
        case 116:
          w = r[0];
          w[t || w.length] = true;
          t = void 0;
          break;
        case 123:
          w = r[0];
          r.unshift(w[t || w.length] = {});
          t = void 0;
          break;
        case 125:
          r.shift();
          break
      }
    }
    if (l) {
      if (r.length !== 1) {
        throw new Error()
      }
      x = x[0]
    } else {
      if (r.length) {
        throw new Error()
      }
    }
    if (q) {
      var s = function (C, B) {
        var D = C[B];
        if (D && typeof D === "object") {
          var n = null;
          for (var z in D) {
            if (b.call(D, z) && D !== C) {
              var y = s(D, z);
              if (y !== void 0) {
                D[z] = y
              } else {
                if (!n) {
                  n = []
                }
                n.push(z)
              }
            }
          }
          if (n) {
            for (var A = n.length; --A >= 0;) {
              delete D[n[A]]
            }
          }
        }
        return q.call(C, B, D)
      };
      x = s({
        "": x
      }, "")
    }
    return x
  }
})();
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
  KJUR.asn1 = {}
}
KJUR.asn1.ASN1Util = new function () {
  this.integerToByteHex = function (a) {
    var b = a.toString(16);
    if ((b.length % 2) == 1) {
      b = "0" + b
    }
    return b
  };
  this.bigIntToMinTwosComplementsHex = function (j) {
    var f = j.toString(16);
    if (f.substr(0, 1) != "-") {
      if (f.length % 2 == 1) {
        f = "0" + f
      } else {
        if (!f.match(/^[0-7]/)) {
          f = "00" + f
        }
      }
    } else {
      var a = f.substr(1);
      var e = a.length;
      if (e % 2 == 1) {
        e += 1
      } else {
        if (!f.match(/^[0-7]/)) {
          e += 2
        }
      }
      var g = "";
      for (var d = 0; d < e; d++) {
        g += "f"
      }
      var c = new BigInteger(g, 16);
      var b = c.xor(j).add(BigInteger.ONE);
      f = b.toString(16).replace(/^-/, "")
    }
    return f
  };
  this.getPEMStringFromHex = function (a, b) {
    return hextopem(a, b)
  };
  this.newObject = function (l) {
    var F = KJUR,
      p = F.asn1,
      B = p.DERBoolean,
      f = p.DERInteger,
      u = p.DERBitString,
      j = p.DEROctetString,
      x = p.DERNull,
      y = p.DERObjectIdentifier,
      n = p.DEREnumerated,
      h = p.DERUTF8String,
      g = p.DERNumericString,
      A = p.DERPrintableString,
      w = p.DERTeletexString,
      r = p.DERIA5String,
      E = p.DERUTCTime,
      k = p.DERGeneralizedTime,
      b = p.DERVisibleString,
      m = p.DERBMPString,
      o = p.DERSequence,
      d = p.DERSet,
      t = p.DERTaggedObject,
      q = p.ASN1Util.newObject;
    var v = Object.keys(l);
    if (v.length != 1) {
      throw "key of param shall be only one."
    }
    var H = v[0];
    if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":" + H + ":") == -1) {
      throw new Error("undefined key: " + H)
    }
    if (H == "bool") {
      return new B(l[H])
    }
    if (H == "int") {
      return new f(l[H])
    }
    if (H == "bitstr") {
      return new u(l[H])
    }
    if (H == "octstr") {
      return new j(l[H])
    }
    if (H == "null") {
      return new x(l[H])
    }
    if (H == "oid") {
      return new y(l[H])
    }
    if (H == "enum") {
      return new n(l[H])
    }
    if (H == "utf8str") {
      return new h(l[H])
    }
    if (H == "numstr") {
      return new g(l[H])
    }
    if (H == "prnstr") {
      return new A(l[H])
    }
    if (H == "telstr") {
      return new w(l[H])
    }
    if (H == "ia5str") {
      return new r(l[H])
    }
    if (H == "utctime") {
      return new E(l[H])
    }
    if (H == "gentime") {
      return new k(l[H])
    }
    if (H == "visstr") {
      return new b(l[H])
    }
    if (H == "bmpstr") {
      return new m(l[H])
    }
    if (H == "seq") {
      var e = l[H];
      var G = [];
      for (var z = 0; z < e.length; z++) {
        var D = q(e[z]);
        G.push(D)
      }
      return new o({
        array: G
      })
    }
    if (H == "set") {
      var e = l[H];
      var G = [];
      for (var z = 0; z < e.length; z++) {
        var D = q(e[z]);
        G.push(D)
      }
      return new d({
        array: G
      })
    }
    if (H == "tag") {
      var C = l[H];
      if (Object.prototype.toString.call(C) === "[object Array]" && C.length == 3) {
        var s = q(C[2]);
        return new t({
          tag: C[0],
          explicit: C[1],
          obj: s
        })
      } else {
        var c = {};
        if (C.explicit !== undefined) {
          c.explicit = C.explicit
        }
        if (C.tag !== undefined) {
          c.tag = C.tag
        }
        if (C.obj === undefined) {
          throw "obj shall be specified for 'tag'."
        }
        c.obj = q(C.obj);
        return new t(c)
      }
    }
  };
  this.jsonToASN1HEX = function (b) {
    var a = this.newObject(b);
    return a.getEncodedHex()
  }
};
KJUR.asn1.ASN1Util.oidHexToInt = function (a) {
  var j = "";
  var k = parseInt(a.substr(0, 2), 16);
  var d = Math.floor(k / 40);
  var c = k % 40;
  var j = d + "." + c;
  var e = "";
  for (var f = 2; f < a.length; f += 2) {
    var g = parseInt(a.substr(f, 2), 16);
    var h = ("00000000" + g.toString(2)).slice(-8);
    e = e + h.substr(1, 7);
    if (h.substr(0, 1) == "0") {
      var b = new BigInteger(e, 2);
      j = j + "." + b.toString(10);
      e = ""
    }
  }
  return j
};
KJUR.asn1.ASN1Util.oidIntToHex = function (f) {
  var e = function (a) {
    var k = a.toString(16);
    if (k.length == 1) {
      k = "0" + k
    }
    return k
  };
  var d = function (o) {
    var n = "";
    var k = new BigInteger(o, 10);
    var a = k.toString(2);
    var l = 7 - a.length % 7;
    if (l == 7) {
      l = 0
    }
    var q = "";
    for (var m = 0; m < l; m++) {
      q += "0"
    }
    a = q + a;
    for (var m = 0; m < a.length - 1; m += 7) {
      var p = a.substr(m, 7);
      if (m != a.length - 7) {
        p = "1" + p
      }
      n += e(parseInt(p, 2))
    }
    return n
  };
  if (!f.match(/^[0-9.]+$/)) {
    throw "malformed oid string: " + f
  }
  var g = "";
  var b = f.split(".");
  var j = parseInt(b[0]) * 40 + parseInt(b[1]);
  g += e(j);
  b.splice(0, 2);
  for (var c = 0; c < b.length; c++) {
    g += d(b[c])
  }
  return g
};
KJUR.asn1.ASN1Object = function () {
  var c = true;
  var b = null;
  var d = "00";
  var e = "00";
  var a = "";
  this.getLengthHexFromValue = function () {
    if (typeof this.hV == "undefined" || this.hV == null) {
      throw "this.hV is null or undefined."
    }
    if (this.hV.length % 2 == 1) {
      throw "value hex must be even length: n=" + a.length + ",v=" + this.hV
    }
    var i = this.hV.length / 2;
    var h = i.toString(16);
    if (h.length % 2 == 1) {
      h = "0" + h
    }
    if (i < 128) {
      return h
    } else {
      var g = h.length / 2;
      if (g > 15) {
        throw "ASN.1 length too long to represent by 8x: n = " + i.toString(16)
      }
      var f = 128 + g;
      return f.toString(16) + h
    }
  };
  this.getEncodedHex = function () {
    if (this.hTLV == null || this.isModified) {
      this.hV = this.getFreshValueHex();
      this.hL = this.getLengthHexFromValue();
      this.hTLV = this.hT + this.hL + this.hV;
      this.isModified = false
    }
    return this.hTLV
  };
  this.getValueHex = function () {
    this.getEncodedHex();
    return this.hV
  };
  this.getFreshValueHex = function () {
    return ""
  }
};
KJUR.asn1.DERAbstractString = function (c) {
  KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
  var b = null;
  var a = null;
  this.getString = function () {
    return this.s
  };
  this.setString = function (d) {
    this.hTLV = null;
    this.isModified = true;
    this.s = d;
    this.hV = utf8tohex(this.s).toLowerCase()
  };
  this.setStringHex = function (d) {
    this.hTLV = null;
    this.isModified = true;
    this.s = null;
    this.hV = d
  };
  this.getFreshValueHex = function () {
    return this.hV
  };
  if (typeof c != "undefined") {
    if (typeof c == "string") {
      this.setString(c)
    } else {
      if (typeof c.str != "undefined") {
        this.setString(c.str)
      } else {
        if (typeof c.hex != "undefined") {
          this.setStringHex(c.hex)
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
KJUR.asn1.DERAbstractTime = function (c) {
  KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
  var b = null;
  var a = null;
  this.localDateToUTC = function (g) {
    var e = g.getTime() + (g.getTimezoneOffset() * 60000);
    var f = new Date(e);
    return f
  };
  this.formatDate = function (m, o, e) {
    var g = this.zeroPadding;
    var n = this.localDateToUTC(m);
    var p = String(n.getFullYear());
    if (o == "utc") {
      p = p.substr(2, 2)
    }
    var l = g(String(n.getMonth() + 1), 2);
    var q = g(String(n.getDate()), 2);
    var h = g(String(n.getHours()), 2);
    var i = g(String(n.getMinutes()), 2);
    var j = g(String(n.getSeconds()), 2);
    var r = p + l + q + h + i + j;
    if (e === true) {
      var f = n.getMilliseconds();
      if (f != 0) {
        var k = g(String(f), 3);
        k = k.replace(/[0]+$/, "");
        r = r + "." + k
      }
    }
    return r + "Z"
  };
  this.zeroPadding = function (e, d) {
    if (e.length >= d) {
      return e
    }
    return new Array(d - e.length + 1).join("0") + e
  };
  this.getString = function () {
    return this.s
  };
  this.setString = function (d) {
    this.hTLV = null;
    this.isModified = true;
    this.s = d;
    this.hV = stohex(d)
  };
  this.setByDateValue = function (h, j, e, d, f, g) {
    var i = new Date(Date.UTC(h, j - 1, e, d, f, g, 0));
    this.setByDate(i)
  };
  this.getFreshValueHex = function () {
    return this.hV
  }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
KJUR.asn1.DERAbstractStructured = function (b) {
  KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
  var a = null;
  this.setByASN1ObjectArray = function (c) {
    this.hTLV = null;
    this.isModified = true;
    this.asn1Array = c
  };
  this.appendASN1Object = function (c) {
    this.hTLV = null;
    this.isModified = true;
    this.asn1Array.push(c)
  };
  this.asn1Array = new Array();
  if (typeof b != "undefined") {
    if (typeof b.array != "undefined") {
      this.asn1Array = b.array
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
KJUR.asn1.DERBoolean = function () {
  KJUR.asn1.DERBoolean.superclass.constructor.call(this);
  this.hT = "01";
  this.hTLV = "0101ff"
};
YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
KJUR.asn1.DERInteger = function (a) {
  KJUR.asn1.DERInteger.superclass.constructor.call(this);
  this.hT = "02";
  this.setByBigInteger = function (b) {
    this.hTLV = null;
    this.isModified = true;
    this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b)
  };
  this.setByInteger = function (c) {
    var b = new BigInteger(String(c), 10);
    this.setByBigInteger(b)
  };
  this.setValueHex = function (b) {
    this.hV = b
  };
  this.getFreshValueHex = function () {
    return this.hV
  };
  if (typeof a != "undefined") {
    if (typeof a.bigint != "undefined") {
      this.setByBigInteger(a.bigint)
    } else {
      if (typeof a["int"] != "undefined") {
        this.setByInteger(a["int"])
      } else {
        if (typeof a == "number") {
          this.setByInteger(a)
        } else {
          if (typeof a.hex != "undefined") {
            this.setValueHex(a.hex)
          }
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
KJUR.asn1.DERBitString = function (b) {
  if (b !== undefined && typeof b.obj !== "undefined") {
    var a = KJUR.asn1.ASN1Util.newObject(b.obj);
    b.hex = "00" + a.getEncodedHex()
  }
  KJUR.asn1.DERBitString.superclass.constructor.call(this);
  this.hT = "03";
  this.setHexValueIncludingUnusedBits = function (c) {
    this.hTLV = null;
    this.isModified = true;
    this.hV = c
  };
  this.setUnusedBitsAndHexValue = function (c, e) {
    if (c < 0 || 7 < c) {
      throw "unused bits shall be from 0 to 7: u = " + c
    }
    var d = "0" + c;
    this.hTLV = null;
    this.isModified = true;
    this.hV = d + e
  };
  this.setByBinaryString = function (e) {
    e = e.replace(/0+$/, "");
    var f = 8 - e.length % 8;
    if (f == 8) {
      f = 0
    }
    for (var g = 0; g <= f; g++) {
      e += "0"
    }
    var j = "";
    for (var g = 0; g < e.length - 1; g += 8) {
      var d = e.substr(g, 8);
      var c = parseInt(d, 2).toString(16);
      if (c.length == 1) {
        c = "0" + c
      }
      j += c
    }
    this.hTLV = null;
    this.isModified = true;
    this.hV = "0" + f + j
  };
  this.setByBooleanArray = function (e) {
    var d = "";
    for (var c = 0; c < e.length; c++) {
      if (e[c] == true) {
        d += "1"
      } else {
        d += "0"
      }
    }
    this.setByBinaryString(d)
  };
  this.newFalseArray = function (e) {
    var c = new Array(e);
    for (var d = 0; d < e; d++) {
      c[d] = false
    }
    return c
  };
  this.getFreshValueHex = function () {
    return this.hV
  };
  if (typeof b != "undefined") {
    if (typeof b == "string" && b.toLowerCase().match(/^[0-9a-f]+$/)) {
      this.setHexValueIncludingUnusedBits(b)
    } else {
      if (typeof b.hex != "undefined") {
        this.setHexValueIncludingUnusedBits(b.hex)
      } else {
        if (typeof b.bin != "undefined") {
          this.setByBinaryString(b.bin)
        } else {
          if (typeof b.array != "undefined") {
            this.setByBooleanArray(b.array)
          }
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
KJUR.asn1.DEROctetString = function (b) {
  if (b !== undefined && typeof b.obj !== "undefined") {
    var a = KJUR.asn1.ASN1Util.newObject(b.obj);
    b.hex = a.getEncodedHex()
  }
  KJUR.asn1.DEROctetString.superclass.constructor.call(this, b);
  this.hT = "04"
};
YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERNull = function () {
  KJUR.asn1.DERNull.superclass.constructor.call(this);
  this.hT = "05";
  this.hTLV = "0500"
};
YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
KJUR.asn1.DERObjectIdentifier = function (c) {
  var b = function (d) {
    var e = d.toString(16);
    if (e.length == 1) {
      e = "0" + e
    }
    return e
  };
  var a = function (k) {
    var j = "";
    var e = new BigInteger(k, 10);
    var d = e.toString(2);
    var f = 7 - d.length % 7;
    if (f == 7) {
      f = 0
    }
    var m = "";
    for (var g = 0; g < f; g++) {
      m += "0"
    }
    d = m + d;
    for (var g = 0; g < d.length - 1; g += 7) {
      var l = d.substr(g, 7);
      if (g != d.length - 7) {
        l = "1" + l
      }
      j += b(parseInt(l, 2))
    }
    return j
  };
  KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
  this.hT = "06";
  this.setValueHex = function (d) {
    this.hTLV = null;
    this.isModified = true;
    this.s = null;
    this.hV = d
  };
  this.setValueOidString = function (f) {
    if (!f.match(/^[0-9.]+$/)) {
      throw "malformed oid string: " + f
    }
    var g = "";
    var d = f.split(".");
    var j = parseInt(d[0]) * 40 + parseInt(d[1]);
    g += b(j);
    d.splice(0, 2);
    for (var e = 0; e < d.length; e++) {
      g += a(d[e])
    }
    this.hTLV = null;
    this.isModified = true;
    this.s = null;
    this.hV = g
  };
  this.setValueName = function (e) {
    var d = KJUR.asn1.x509.OID.name2oid(e);
    if (d !== "") {
      this.setValueOidString(d)
    } else {
      throw "DERObjectIdentifier oidName undefined: " + e
    }
  };
  this.getFreshValueHex = function () {
    return this.hV
  };
  if (c !== undefined) {
    if (typeof c === "string") {
      if (c.match(/^[0-2].[0-9.]+$/)) {
        this.setValueOidString(c)
      } else {
        this.setValueName(c)
      }
    } else {
      if (c.oid !== undefined) {
        this.setValueOidString(c.oid)
      } else {
        if (c.hex !== undefined) {
          this.setValueHex(c.hex)
        } else {
          if (c.name !== undefined) {
            this.setValueName(c.name)
          }
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
KJUR.asn1.DEREnumerated = function (a) {
  KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
  this.hT = "0a";
  this.setByBigInteger = function (b) {
    this.hTLV = null;
    this.isModified = true;
    this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b)
  };
  this.setByInteger = function (c) {
    var b = new BigInteger(String(c), 10);
    this.setByBigInteger(b)
  };
  this.setValueHex = function (b) {
    this.hV = b
  };
  this.getFreshValueHex = function () {
    return this.hV
  };
  if (typeof a != "undefined") {
    if (typeof a["int"] != "undefined") {
      this.setByInteger(a["int"])
    } else {
      if (typeof a == "number") {
        this.setByInteger(a)
      } else {
        if (typeof a.hex != "undefined") {
          this.setValueHex(a.hex)
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);
KJUR.asn1.DERUTF8String = function (a) {
  KJUR.asn1.DERUTF8String.superclass.constructor.call(this, a);
  this.hT = "0c"
};
YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERNumericString = function (a) {
  KJUR.asn1.DERNumericString.superclass.constructor.call(this, a);
  this.hT = "12"
};
YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERPrintableString = function (a) {
  KJUR.asn1.DERPrintableString.superclass.constructor.call(this, a);
  this.hT = "13"
};
YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERTeletexString = function (a) {
  KJUR.asn1.DERTeletexString.superclass.constructor.call(this, a);
  this.hT = "14"
};
YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERIA5String = function (a) {
  KJUR.asn1.DERIA5String.superclass.constructor.call(this, a);
  this.hT = "16"
};
YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERVisibleString = function (a) {
  KJUR.asn1.DERIA5String.superclass.constructor.call(this, a);
  this.hT = "1a"
};
YAHOO.lang.extend(KJUR.asn1.DERVisibleString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERBMPString = function (a) {
  KJUR.asn1.DERBMPString.superclass.constructor.call(this, a);
  this.hT = "1e"
};
YAHOO.lang.extend(KJUR.asn1.DERBMPString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERUTCTime = function (a) {
  KJUR.asn1.DERUTCTime.superclass.constructor.call(this, a);
  this.hT = "17";
  this.setByDate = function (b) {
    this.hTLV = null;
    this.isModified = true;
    this.date = b;
    this.s = this.formatDate(this.date, "utc");
    this.hV = stohex(this.s)
  };
  this.getFreshValueHex = function () {
    if (typeof this.date == "undefined" && typeof this.s == "undefined") {
      this.date = new Date();
      this.s = this.formatDate(this.date, "utc");
      this.hV = stohex(this.s)
    }
    return this.hV
  };
  if (a !== undefined) {
    if (a.str !== undefined) {
      this.setString(a.str)
    } else {
      if (typeof a == "string" && a.match(/^[0-9]{12}Z$/)) {
        this.setString(a)
      } else {
        if (a.hex !== undefined) {
          this.setStringHex(a.hex)
        } else {
          if (a.date !== undefined) {
            this.setByDate(a.date)
          }
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
KJUR.asn1.DERGeneralizedTime = function (a) {
  KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, a);
  this.hT = "18";
  this.withMillis = false;
  this.setByDate = function (b) {
    this.hTLV = null;
    this.isModified = true;
    this.date = b;
    this.s = this.formatDate(this.date, "gen", this.withMillis);
    this.hV = stohex(this.s)
  };
  this.getFreshValueHex = function () {
    if (this.date === undefined && this.s === undefined) {
      this.date = new Date();
      this.s = this.formatDate(this.date, "gen", this.withMillis);
      this.hV = stohex(this.s)
    }
    return this.hV
  };
  if (a !== undefined) {
    if (a.str !== undefined) {
      this.setString(a.str)
    } else {
      if (typeof a == "string" && a.match(/^[0-9]{14}Z$/)) {
        this.setString(a)
      } else {
        if (a.hex !== undefined) {
          this.setStringHex(a.hex)
        } else {
          if (a.date !== undefined) {
            this.setByDate(a.date)
          }
        }
      }
    }
    if (a.millis === true) {
      this.withMillis = true
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
KJUR.asn1.DERSequence = function (a) {
  KJUR.asn1.DERSequence.superclass.constructor.call(this, a);
  this.hT = "30";
  this.getFreshValueHex = function () {
    var c = "";
    for (var b = 0; b < this.asn1Array.length; b++) {
      var d = this.asn1Array[b];
      c += d.getEncodedHex()
    }
    this.hV = c;
    return this.hV
  }
};
YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
KJUR.asn1.DERSet = function (a) {
  KJUR.asn1.DERSet.superclass.constructor.call(this, a);
  this.hT = "31";
  this.sortFlag = true;
  this.getFreshValueHex = function () {
    var b = new Array();
    for (var c = 0; c < this.asn1Array.length; c++) {
      var d = this.asn1Array[c];
      b.push(d.getEncodedHex())
    }
    if (this.sortFlag == true) {
      b.sort()
    }
    this.hV = b.join("");
    return this.hV
  };
  if (typeof a != "undefined") {
    if (typeof a.sortflag != "undefined" && a.sortflag == false) {
      this.sortFlag = false
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
KJUR.asn1.DERTaggedObject = function (a) {
  KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
  this.hT = "a0";
  this.hV = "";
  this.isExplicit = true;
  this.asn1Object = null;
  this.setASN1Object = function (b, c, d) {
    this.hT = c;
    this.isExplicit = b;
    this.asn1Object = d;
    if (this.isExplicit) {
      this.hV = this.asn1Object.getEncodedHex();
      this.hTLV = null;
      this.isModified = true
    } else {
      this.hV = null;
      this.hTLV = d.getEncodedHex();
      this.hTLV = this.hTLV.replace(/^../, c);
      this.isModified = false
    }
  };
  this.getFreshValueHex = function () {
    return this.hV
  };
  if (typeof a != "undefined") {
    if (typeof a.tag != "undefined") {
      this.hT = a.tag
    }
    if (typeof a.explicit != "undefined") {
      this.isExplicit = a.explicit
    }
    if (typeof a.obj != "undefined") {
      this.asn1Object = a.obj;
      this.setASN1Object(this.isExplicit, this.hT, this.asn1Object)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);
var ASN1HEX = new function () {};
ASN1HEX.getLblen = function (c, a) {
  if (c.substr(a + 2, 1) != "8") {
    return 1
  }
  var b = parseInt(c.substr(a + 3, 1));
  if (b == 0) {
    return -1
  }
  if (0 < b && b < 10) {
    return b + 1
  }
  return -2
};
ASN1HEX.getL = function (c, b) {
  var a = ASN1HEX.getLblen(c, b);
  if (a < 1) {
    return ""
  }
  return c.substr(b + 2, a * 2)
};
ASN1HEX.getVblen = function (d, a) {
  var c, b;
  c = ASN1HEX.getL(d, a);
  if (c == "") {
    return -1
  }
  if (c.substr(0, 1) === "8") {
    b = new BigInteger(c.substr(2), 16)
  } else {
    b = new BigInteger(c, 16)
  }
  return b.intValue()
};
ASN1HEX.getVidx = function (c, b) {
  var a = ASN1HEX.getLblen(c, b);
  if (a < 0) {
    return a
  }
  return b + (a + 1) * 2
};
ASN1HEX.getV = function (d, a) {
  var c = ASN1HEX.getVidx(d, a);
  var b = ASN1HEX.getVblen(d, a);
  return d.substr(c, b * 2)
};
ASN1HEX.getTLV = function (b, a) {
  return b.substr(a, 2) + ASN1HEX.getL(b, a) + ASN1HEX.getV(b, a)
};
ASN1HEX.getNextSiblingIdx = function (d, a) {
  var c = ASN1HEX.getVidx(d, a);
  var b = ASN1HEX.getVblen(d, a);
  return c + b * 2
};
ASN1HEX.getChildIdx = function (e, f) {
  var j = ASN1HEX;
  var g = new Array();
  var i = j.getVidx(e, f);
  if (e.substr(f, 2) == "03") {
    g.push(i + 2)
  } else {
    g.push(i)
  }
  var l = j.getVblen(e, f);
  var c = i;
  var d = 0;
  while (1) {
    var b = j.getNextSiblingIdx(e, c);
    if (b == null || (b - i >= (l * 2))) {
      break
    }
    if (d >= 200) {
      break
    }
    g.push(b);
    c = b;
    d++
  }
  return g
};
ASN1HEX.getNthChildIdx = function (d, b, e) {
  var c = ASN1HEX.getChildIdx(d, b);
  return c[e]
};
ASN1HEX.getIdxbyList = function (e, d, c, i) {
  var g = ASN1HEX;
  var f, b;
  if (c.length == 0) {
    if (i !== undefined) {
      if (e.substr(d, 2) !== i) {
        throw Error("checking tag doesn't match: " + e.substr(d, 2) + "!=" + i)
      }
    }
    return d
  }
  f = c.shift();
  b = g.getChildIdx(e, d);
  return g.getIdxbyList(e, b[f], c, i)
};
ASN1HEX.getIdxbyListEx = function (f, k, b, g) {
  var m = ASN1HEX;
  var d, l;
  if (b.length == 0) {
    if (g !== undefined) {
      if (f.substr(k, 2) !== g) {
        return -1
      }
    }
    return k
  }
  d = b.shift();
  l = m.getChildIdx(f, k);
  var j = 0;
  for (var e = 0; e < l.length; e++) {
    var c = f.substr(l[e], 2);
    if ((typeof d == "number" && (!m.isContextTag(c)) && j == d) || (typeof d == "string" && m.isContextTag(c, d))) {
      return m.getIdxbyListEx(f, l[e], b, g)
    }
    if (!m.isContextTag(c)) {
      j++
    }
  }
  return -1
};
ASN1HEX.getTLVbyList = function (d, c, b, f) {
  var e = ASN1HEX;
  var a = e.getIdxbyList(d, c, b);
  if (a === undefined) {
    throw new Error("can't find nthList object")
  }
  if (f !== undefined) {
    if (d.substr(a, 2) != f) {
      throw new Error("checking tag doesn't match: " + d.substr(a, 2) + "!=" + f)
    }
  }
  return e.getTLV(d, a)
};
ASN1HEX.getTLVbyListEx = function (d, c, b, f) {
  var e = ASN1HEX;
  var a = e.getIdxbyListEx(d, c, b, f);
  if (a == -1) {
    return null
  }
  return e.getTLV(d, a)
};
ASN1HEX.getVbyList = function (e, c, b, g, i) {
  var f = ASN1HEX;
  var a, d;
  a = f.getIdxbyList(e, c, b, g);
  if (a === undefined) {
    throw "can't find nthList object"
  }
  d = f.getV(e, a);
  if (i === true) {
    d = d.substr(2)
  }
  return d
};
ASN1HEX.getVbyListEx = function (b, e, a, d, f) {
  var j = ASN1HEX;
  var g, c, i;
  g = j.getIdxbyListEx(b, e, a, d);
  if (g == -1) {
    return null
  }
  i = j.getV(b, g);
  if (b.substr(g, 2) == "03" && f !== false) {
    i = i.substr(2)
  }
  return i
};
ASN1HEX.hextooidstr = function (e) {
  var h = function (b, a) {
    if (b.length >= a) {
      return b
    }
    return new Array(a - b.length + 1).join("0") + b
  };
  var l = [];
  var o = e.substr(0, 2);
  var f = parseInt(o, 16);
  l[0] = new String(Math.floor(f / 40));
  l[1] = new String(f % 40);
  var m = e.substr(2);
  var k = [];
  for (var g = 0; g < m.length / 2; g++) {
    k.push(parseInt(m.substr(g * 2, 2), 16))
  }
  var j = [];
  var d = "";
  for (var g = 0; g < k.length; g++) {
    if (k[g] & 128) {
      d = d + h((k[g] & 127).toString(2), 7)
    } else {
      d = d + h((k[g] & 127).toString(2), 7);
      j.push(new String(parseInt(d, 2)));
      d = ""
    }
  }
  var n = l.join(".");
  if (j.length > 0) {
    n = n + "." + j.join(".")
  }
  return n
};
ASN1HEX.dump = function (t, c, l, g) {
  var p = ASN1HEX;
  var j = p.getV;
  var y = p.dump;
  var w = p.getChildIdx;
  var e = t;
  if (t instanceof KJUR.asn1.ASN1Object) {
    e = t.getEncodedHex()
  }
  var q = function (A, i) {
    if (A.length <= i * 2) {
      return A
    } else {
      var v = A.substr(0, i) + "..(total " + A.length / 2 + "bytes).." + A.substr(A.length - i, i);
      return v
    }
  };
  if (c === undefined) {
    c = {
      ommit_long_octet: 32
    }
  }
  if (l === undefined) {
    l = 0
  }
  if (g === undefined) {
    g = ""
  }
  var x = c.ommit_long_octet;
  var z = e.substr(l, 2);
  if (z == "01") {
    var h = j(e, l);
    if (h == "00") {
      return g + "BOOLEAN FALSE\n"
    } else {
      return g + "BOOLEAN TRUE\n"
    }
  }
  if (z == "02") {
    var h = j(e, l);
    return g + "INTEGER " + q(h, x) + "\n"
  }
  if (z == "03") {
    var h = j(e, l);
    if (p.isASN1HEX(h.substr(2))) {
      var k = g + "BITSTRING, encapsulates\n";
      k = k + y(h.substr(2), c, 0, g + "  ");
      return k
    } else {
      return g + "BITSTRING " + q(h, x) + "\n"
    }
  }
  if (z == "04") {
    var h = j(e, l);
    if (p.isASN1HEX(h)) {
      var k = g + "OCTETSTRING, encapsulates\n";
      k = k + y(h, c, 0, g + "  ");
      return k
    } else {
      return g + "OCTETSTRING " + q(h, x) + "\n"
    }
  }
  if (z == "05") {
    return g + "NULL\n"
  }
  if (z == "06") {
    var m = j(e, l);
    var b = KJUR.asn1.ASN1Util.oidHexToInt(m);
    var o = KJUR.asn1.x509.OID.oid2name(b);
    var a = b.replace(/\./g, " ");
    if (o != "") {
      return g + "ObjectIdentifier " + o + " (" + a + ")\n"
    } else {
      return g + "ObjectIdentifier (" + a + ")\n"
    }
  }
  if (z == "0c") {
    return g + "UTF8String '" + hextoutf8(j(e, l)) + "'\n"
  }
  if (z == "13") {
    return g + "PrintableString '" + hextoutf8(j(e, l)) + "'\n"
  }
  if (z == "14") {
    return g + "TeletexString '" + hextoutf8(j(e, l)) + "'\n"
  }
  if (z == "16") {
    return g + "IA5String '" + hextoutf8(j(e, l)) + "'\n"
  }
  if (z == "17") {
    return g + "UTCTime " + hextoutf8(j(e, l)) + "\n"
  }
  if (z == "18") {
    return g + "GeneralizedTime " + hextoutf8(j(e, l)) + "\n"
  }
  if (z == "1a") {
    return g + "VisualString '" + hextoutf8(j(e, l)) + "'\n"
  }
  if (z == "1e") {
    return g + "BMPString '" + hextoutf8(j(e, l)) + "'\n"
  }
  if (z == "30") {
    if (e.substr(l, 4) == "3000") {
      return g + "SEQUENCE {}\n"
    }
    var k = g + "SEQUENCE\n";
    var d = w(e, l);
    var f = c;
    if ((d.length == 2 || d.length == 3) && e.substr(d[0], 2) == "06" && e.substr(d[d.length - 1], 2) == "04") {
      var o = p.oidname(j(e, d[0]));
      var r = JSON.parse(JSON.stringify(c));
      r.x509ExtName = o;
      f = r
    }
    for (var u = 0; u < d.length; u++) {
      k = k + y(e, f, d[u], g + "  ")
    }
    return k
  }
  if (z == "31") {
    var k = g + "SET\n";
    var d = w(e, l);
    for (var u = 0; u < d.length; u++) {
      k = k + y(e, c, d[u], g + "  ")
    }
    return k
  }
  var z = parseInt(z, 16);
  if ((z & 128) != 0) {
    var n = z & 31;
    if ((z & 32) != 0) {
      var k = g + "[" + n + "]\n";
      var d = w(e, l);
      for (var u = 0; u < d.length; u++) {
        k = k + y(e, c, d[u], g + "  ")
      }
      return k
    } else {
      var h = j(e, l);
      if (h.substr(0, 8) == "68747470") {
        h = hextoutf8(h)
      }
      if (c.x509ExtName === "subjectAltName" && n == 2) {
        h = hextoutf8(h)
      }
      var k = g + "[" + n + "] " + h + "\n";
      return k
    }
  }
  return g + "UNKNOWN(" + z + ") " + j(e, l) + "\n"
};
ASN1HEX.isContextTag = function (c, b) {
  c = c.toLowerCase();
  var f, e;
  try {
    f = parseInt(c, 16)
  } catch (d) {
    return -1
  }
  if (b === undefined) {
    if ((f & 192) == 128) {
      return true
    } else {
      return false
    }
  }
  try {
    var a = b.match(/^\[[0-9]+\]$/);
    if (a == null) {
      return false
    }
    e = parseInt(b.substr(1, b.length - 1), 10);
    if (e > 31) {
      return false
    }
    if (((f & 192) == 128) && ((f & 31) == e)) {
      return true
    }
    return false
  } catch (d) {
    return false
  }
};
ASN1HEX.isASN1HEX = function (e) {
  var d = ASN1HEX;
  if (e.length % 2 == 1) {
    return false
  }
  var c = d.getVblen(e, 0);
  var b = e.substr(0, 2);
  var f = d.getL(e, 0);
  var a = e.length - b.length - f.length;
  if (a == c * 2) {
    return true
  }
  return false
};
ASN1HEX.checkStrictDER = function (g, o, d, c, r) {
  var s = ASN1HEX;
  if (d === undefined) {
    if (typeof g != "string") {
      throw new Error("not hex string")
    }
    g = g.toLowerCase();
    if (!KJUR.lang.String.isHex(g)) {
      throw new Error("not hex string")
    }
    d = g.length;
    c = g.length / 2;
    if (c < 128) {
      r = 1
    } else {
      r = Math.ceil(c.toString(16)) + 1
    }
  }
  var k = s.getL(g, o);
  if (k.length > r * 2) {
    throw new Error("L of TLV too long: idx=" + o)
  }
  var n = s.getVblen(g, o);
  if (n > c) {
    throw new Error("value of L too long than hex: idx=" + o)
  }
  var q = s.getTLV(g, o);
  var f = q.length - 2 - s.getL(g, o).length;
  if (f !== (n * 2)) {
    throw new Error("V string length and L's value not the same:" + f + "/" + (n * 2))
  }
  if (o === 0) {
    if (g.length != q.length) {
      throw new Error("total length and TLV length unmatch:" + g.length + "!=" + q.length)
    }
  }
  var b = g.substr(o, 2);
  if (b === "02") {
    var a = s.getVidx(g, o);
    if (g.substr(a, 2) == "00" && g.charCodeAt(a + 2) < 56) {
      throw new Error("not least zeros for DER INTEGER")
    }
  }
  if (parseInt(b, 16) & 32) {
    var p = s.getVblen(g, o);
    var m = 0;
    var l = s.getChildIdx(g, o);
    for (var e = 0; e < l.length; e++) {
      var j = s.getTLV(g, l[e]);
      m += j.length;
      s.checkStrictDER(g, l[e], d, c, r)
    }
    if ((p * 2) != m) {
      throw new Error("sum of children's TLV length and L unmatch: " + (p * 2) + "!=" + m)
    }
  }
};
ASN1HEX.oidname = function (a) {
  var c = KJUR.asn1;
  if (KJUR.lang.String.isHex(a)) {
    a = c.ASN1Util.oidHexToInt(a)
  }
  var b = c.x509.OID.oid2name(a);
  if (b === "") {
    b = a
  }
  return b
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
  KJUR.asn1 = {}
}
if (typeof KJUR.asn1.x509 == "undefined" || !KJUR.asn1.x509) {
  KJUR.asn1.x509 = {}
}
KJUR.asn1.x509.Certificate = function (e) {
  KJUR.asn1.x509.Certificate.superclass.constructor.call(this);
  var a = null,
    j = null,
    h = null,
    k = null,
    i = null,
    b = KJUR,
    f = b.crypto,
    g = b.asn1,
    d = g.DERSequence,
    c = g.DERBitString;
  this.sign = function () {
    this.asn1SignatureAlg = this.asn1TBSCert.asn1SignatureAlg;
    var m = new KJUR.crypto.Signature({
      alg: this.asn1SignatureAlg.nameAlg
    });
    m.init(this.prvKey);
    m.updateHex(this.asn1TBSCert.getEncodedHex());
    this.hexSig = m.sign();
    this.asn1Sig = new c({
      hex: "00" + this.hexSig
    });
    var l = new d({
      array: [this.asn1TBSCert, this.asn1SignatureAlg, this.asn1Sig]
    });
    this.hTLV = l.getEncodedHex();
    this.isModified = false
  };
  this.setSignatureHex = function (l) {
    this.asn1SignatureAlg = this.asn1TBSCert.asn1SignatureAlg;
    this.hexSig = l;
    this.asn1Sig = new c({
      hex: "00" + this.hexSig
    });
    var m = new d({
      array: [this.asn1TBSCert, this.asn1SignatureAlg, this.asn1Sig]
    });
    this.hTLV = m.getEncodedHex();
    this.isModified = false
  };
  this.getEncodedHex = function () {
    if (this.isModified == false && this.hTLV != null) {
      return this.hTLV
    }
    throw "not signed yet"
  };
  this.getPEMString = function () {
    var l = hextob64nl(this.getEncodedHex());
    return "-----BEGIN CERTIFICATE-----\r\n" + l + "\r\n-----END CERTIFICATE-----\r\n"
  };
  if (e !== undefined) {
    if (e.tbscertobj !== undefined) {
      this.asn1TBSCert = e.tbscertobj
    }
    if (e.prvkeyobj !== undefined) {
      this.prvKey = e.prvkeyobj
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.Certificate, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.TBSCertificate = function (e) {
  KJUR.asn1.x509.TBSCertificate.superclass.constructor.call(this);
  var b = KJUR,
    i = b.asn1,
    f = i.DERSequence,
    h = i.DERInteger,
    c = i.DERTaggedObject,
    d = i.x509,
    g = d.Time,
    a = d.X500Name,
    j = d.SubjectPublicKeyInfo;
  this._initialize = function () {
    this.asn1Array = new Array();
    this.asn1Version = new c({
      obj: new h({
        "int": 2
      })
    });
    this.asn1SerialNumber = null;
    this.asn1SignatureAlg = null;
    this.asn1Issuer = null;
    this.asn1NotBefore = null;
    this.asn1NotAfter = null;
    this.asn1Subject = null;
    this.asn1SubjPKey = null;
    this.extensionsArray = new Array()
  };
  this.setSerialNumberByParam = function (k) {
    this.asn1SerialNumber = new h(k)
  };
  this.setSignatureAlgByParam = function (k) {
    this.asn1SignatureAlg = new d.AlgorithmIdentifier(k)
  };
  this.setIssuerByParam = function (k) {
    this.asn1Issuer = new a(k)
  };
  this.setNotBeforeByParam = function (k) {
    this.asn1NotBefore = new g(k)
  };
  this.setNotAfterByParam = function (k) {
    this.asn1NotAfter = new g(k)
  };
  this.setSubjectByParam = function (k) {
    this.asn1Subject = new a(k)
  };
  this.setSubjectPublicKey = function (k) {
    this.asn1SubjPKey = new j(k)
  };
  this.setSubjectPublicKeyByGetKey = function (l) {
    var k = KEYUTIL.getKey(l);
    this.asn1SubjPKey = new j(k)
  };
  this.appendExtension = function (k) {
    this.extensionsArray.push(k)
  };
  this.appendExtensionByName = function (l, k) {
    KJUR.asn1.x509.Extension.appendByNameToArray(l, k, this.extensionsArray)
  };
  this.getEncodedHex = function () {
    if (this.asn1NotBefore == null || this.asn1NotAfter == null) {
      throw "notBefore and/or notAfter not set"
    }
    var l = new f({
      array: [this.asn1NotBefore, this.asn1NotAfter]
    });
    this.asn1Array = new Array();
    this.asn1Array.push(this.asn1Version);
    this.asn1Array.push(this.asn1SerialNumber);
    this.asn1Array.push(this.asn1SignatureAlg);
    this.asn1Array.push(this.asn1Issuer);
    this.asn1Array.push(l);
    this.asn1Array.push(this.asn1Subject);
    this.asn1Array.push(this.asn1SubjPKey);
    if (this.extensionsArray.length > 0) {
      var m = new f({
        array: this.extensionsArray
      });
      var k = new c({
        explicit: true,
        tag: "a3",
        obj: m
      });
      this.asn1Array.push(k)
    }
    var n = new f({
      array: this.asn1Array
    });
    this.hTLV = n.getEncodedHex();
    this.isModified = false;
    return this.hTLV
  };
  this._initialize()
};
YAHOO.lang.extend(KJUR.asn1.x509.TBSCertificate, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.Extension = function (d) {
  KJUR.asn1.x509.Extension.superclass.constructor.call(this);
  var f = null,
    a = KJUR,
    e = a.asn1,
    h = e.DERObjectIdentifier,
    i = e.DEROctetString,
    b = e.DERBitString,
    g = e.DERBoolean,
    c = e.DERSequence;
  this.getEncodedHex = function () {
    var m = new h({
      oid: this.oid
    });
    var l = new i({
      hex: this.getExtnValueHex()
    });
    var k = new Array();
    k.push(m);
    if (this.critical) {
      k.push(new g())
    }
    k.push(l);
    var j = new c({
      array: k
    });
    return j.getEncodedHex()
  };
  this.critical = false;
  if (d !== undefined) {
    if (d.critical !== undefined) {
      this.critical = d.critical
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.Extension, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.Extension.appendByNameToArray = function (e, c, b) {
  var g = e.toLowerCase(),
    f = KJUR.asn1.x509;
  if (g == "basicconstraints") {
    var d = new f.BasicConstraints(c);
    b.push(d)
  } else {
    if (g == "keyusage") {
      var d = new f.KeyUsage(c);
      b.push(d)
    } else {
      if (g == "crldistributionpoints") {
        var d = new f.CRLDistributionPoints(c);
        b.push(d)
      } else {
        if (g == "extkeyusage") {
          var d = new f.ExtKeyUsage(c);
          b.push(d)
        } else {
          if (g == "authoritykeyidentifier") {
            var d = new f.AuthorityKeyIdentifier(c);
            b.push(d)
          } else {
            if (g == "subjectkeyidentifier") {
              var d = new f.SubjectKeyIdentifier(c);
              b.push(d)
            } else {
              if (g == "authorityinfoaccess") {
                var d = new f.AuthorityInfoAccess(c);
                b.push(d)
              } else {
                if (g == "subjectaltname") {
                  var d = new f.SubjectAltName(c);
                  b.push(d)
                } else {
                  if (g == "issueraltname") {
                    var d = new f.IssuerAltName(c);
                    b.push(d)
                  } else {
                    if (g == "certificatepolicies") {
                      var d = new f.CertificatePolicies(c);
                      b.push(d)
                    } else {
                      throw new Error("unsupported extension name: " + e)
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
KJUR.asn1.x509.KeyUsage = function (f) {
  KJUR.asn1.x509.KeyUsage.superclass.constructor.call(this, f);
  var a = X509.KEYUSAGE_NAME;
  this.getExtnValueHex = function () {
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.oid = "2.5.29.15";
  if (f !== undefined) {
    if (f.bin !== undefined) {
      this.asn1ExtnValue = new KJUR.asn1.DERBitString(f)
    }
    if (f.names !== undefined && f.names.length !== undefined) {
      var e = f.names;
      var d = "000000000";
      for (var c = 0; c < e.length; c++) {
        for (var b = 0; b < a.length; b++) {
          if (e[c] === a[b]) {
            d = d.substring(0, b) + "1" + d.substring(b + 1, d.length)
          }
        }
      }
      this.asn1ExtnValue = new KJUR.asn1.DERBitString({
        bin: d
      })
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.KeyUsage, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.BasicConstraints = function (c) {
  KJUR.asn1.x509.BasicConstraints.superclass.constructor.call(this, c);
  var a = false;
  var b = -1;
  this.getExtnValueHex = function () {
    var e = new Array();
    if (this.cA) {
      e.push(new KJUR.asn1.DERBoolean())
    }
    if (this.pathLen > -1) {
      e.push(new KJUR.asn1.DERInteger({
        "int": this.pathLen
      }))
    }
    var d = new KJUR.asn1.DERSequence({
      array: e
    });
    this.asn1ExtnValue = d;
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.oid = "2.5.29.19";
  this.cA = false;
  this.pathLen = -1;
  if (c !== undefined) {
    if (c.cA !== undefined) {
      this.cA = c.cA
    }
    if (c.pathLen !== undefined) {
      this.pathLen = c.pathLen
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.BasicConstraints, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.CRLDistributionPoints = function (d) {
  KJUR.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this, d);
  var b = KJUR,
    a = b.asn1,
    c = a.x509;
  this.getExtnValueHex = function () {
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.setByDPArray = function (e) {
    this.asn1ExtnValue = new a.DERSequence({
      array: e
    })
  };
  this.setByOneURI = function (h) {
    var e = new c.GeneralNames([{
      uri: h
    }]);
    var g = new c.DistributionPointName(e);
    var f = new c.DistributionPoint({
      dpobj: g
    });
    this.setByDPArray([f])
  };
  this.oid = "2.5.29.31";
  if (d !== undefined) {
    if (d.array !== undefined) {
      this.setByDPArray(d.array)
    } else {
      if (d.uri !== undefined) {
        this.setByOneURI(d.uri)
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.CRLDistributionPoints, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.CertificatePolicies = function (f) {
  KJUR.asn1.x509.CertificatePolicies.superclass.constructor.call(this, f);
  var c = KJUR,
    b = c.asn1,
    e = b.x509,
    a = b.DERSequence,
    d = e.PolicyInformation;
  this.params = null;
  this.getExtnValueHex = function () {
    var j = [];
    for (var h = 0; h < this.params.array.length; h++) {
      j.push(new d(this.params.array[h]))
    }
    var g = new a({
      array: j
    });
    this.asn1ExtnValue = g;
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.oid = "2.5.29.32";
  if (f !== undefined) {
    this.params = f
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.CertificatePolicies, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.PolicyInformation = function (d) {
  KJUR.asn1.x509.PolicyInformation.superclass.constructor.call(this, d);
  var c = KJUR.asn1,
    b = c.DERSequence,
    e = c.DERObjectIdentifier,
    a = c.x509.PolicyQualifierInfo;
  this.params = null;
  this.getEncodedHex = function () {
    if (this.params.policyoid === undefined && this.params.array === undefined) {
      throw new Error("parameter oid and array missing")
    }
    var f = [new e({
      oid: this.params.policyoid
    })];
    if (this.params.array !== undefined) {
      var j = [];
      for (var h = 0; h < this.params.array.length; h++) {
        j.push(new a(this.params.array[h]))
      }
      if (j.length > 0) {
        f.push(new b({
          array: j
        }))
      }
    }
    var g = new b({
      array: f
    });
    return g.getEncodedHex()
  };
  if (d !== undefined) {
    this.params = d
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.PolicyInformation, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.PolicyQualifierInfo = function (e) {
  KJUR.asn1.x509.PolicyQualifierInfo.superclass.constructor.call(this, e);
  var c = KJUR.asn1,
    b = c.DERSequence,
    d = c.DERIA5String,
    f = c.DERObjectIdentifier,
    a = c.x509.UserNotice;
  this.params = null;
  this.getEncodedHex = function () {
    if (this.params.cps !== undefined) {
      var g = new b({
        array: [new f({
          oid: "1.3.6.1.5.5.7.2.1"
        }), new d({
          str: this.params.cps
        })]
      });
      return g.getEncodedHex()
    }
    if (this.params.unotice != undefined) {
      var g = new b({
        array: [new f({
          oid: "1.3.6.1.5.5.7.2.2"
        }), new a(this.params.unotice)]
      });
      return g.getEncodedHex()
    }
  };
  if (e !== undefined) {
    this.params = e
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.PolicyQualifierInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.UserNotice = function (e) {
  KJUR.asn1.x509.UserNotice.superclass.constructor.call(this, e);
  var a = KJUR.asn1.DERSequence,
    d = KJUR.asn1.DERInteger,
    c = KJUR.asn1.x509.DisplayText,
    b = KJUR.asn1.x509.NoticeReference;
  this.params = null;
  this.getEncodedHex = function () {
    var f = [];
    if (this.params.noticeref !== undefined) {
      f.push(new b(this.params.noticeref))
    }
    if (this.params.exptext !== undefined) {
      f.push(new c(this.params.exptext))
    }
    var g = new a({
      array: f
    });
    return g.getEncodedHex()
  };
  if (e !== undefined) {
    this.params = e
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.UserNotice, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.NoticeReference = function (d) {
  KJUR.asn1.x509.NoticeReference.superclass.constructor.call(this, d);
  var a = KJUR.asn1.DERSequence,
    c = KJUR.asn1.DERInteger,
    b = KJUR.asn1.x509.DisplayText;
  this.params = null;
  this.getEncodedHex = function () {
    var f = [];
    if (this.params.org !== undefined) {
      f.push(new b(this.params.org))
    }
    if (this.params.noticenum !== undefined) {
      var h = [];
      var e = this.params.noticenum;
      for (var j = 0; j < e.length; j++) {
        h.push(new c(e[j]))
      }
      f.push(new a({
        array: h
      }))
    }
    if (f.length == 0) {
      throw new Error("parameter is empty")
    }
    var g = new a({
      array: f
    });
    return g.getEncodedHex()
  };
  if (d !== undefined) {
    this.params = d
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.NoticeReference, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.DisplayText = function (a) {
  KJUR.asn1.x509.DisplayText.superclass.constructor.call(this, a);
  this.hT = "0c";
  if (a !== undefined) {
    if (a.type === "ia5") {
      this.hT = "16"
    } else {
      if (a.type === "vis") {
        this.hT = "1a"
      } else {
        if (a.type === "bmp") {
          this.hT = "1e"
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.DisplayText, KJUR.asn1.DERAbstractString);
KJUR.asn1.x509.ExtKeyUsage = function (c) {
  KJUR.asn1.x509.ExtKeyUsage.superclass.constructor.call(this, c);
  var b = KJUR,
    a = b.asn1;
  this.setPurposeArray = function (d) {
    this.asn1ExtnValue = new a.DERSequence();
    for (var e = 0; e < d.length; e++) {
      var f = new a.DERObjectIdentifier(d[e]);
      this.asn1ExtnValue.appendASN1Object(f)
    }
  };
  this.getExtnValueHex = function () {
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.oid = "2.5.29.37";
  if (c !== undefined) {
    if (c.array !== undefined) {
      this.setPurposeArray(c.array)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.ExtKeyUsage, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.AuthorityKeyIdentifier = function (f) {
  KJUR.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this, f);
  var b = KJUR,
    a = b.asn1,
    d = a.DERTaggedObject,
    e = a.x509.GeneralNames,
    c = b.crypto.Util.isKey;
  this.asn1KID = null;
  this.asn1CertIssuer = null;
  this.asn1CertSN = null;
  this.getExtnValueHex = function () {
    var h = new Array();
    if (this.asn1KID) {
      h.push(new d({
        explicit: false,
        tag: "80",
        obj: this.asn1KID
      }))
    }
    if (this.asn1CertIssuer) {
      h.push(new d({
        explicit: false,
        tag: "a1",
        obj: new e([{
          dn: this.asn1CertIssuer
        }])
      }))
    }
    if (this.asn1CertSN) {
      h.push(new d({
        explicit: false,
        tag: "82",
        obj: this.asn1CertSN
      }))
    }
    var g = new a.DERSequence({
      array: h
    });
    this.asn1ExtnValue = g;
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.setKIDByParam = function (i) {
    if (i.str !== undefined || i.hex !== undefined) {
      this.asn1KID = new KJUR.asn1.DEROctetString(i)
    } else {
      if ((typeof i === "object" && KJUR.crypto.Util.isKey(i)) || (typeof i === "string" && i.indexOf("BEGIN ") != -1)) {
        var h = i;
        if (typeof i === "string") {
          h = KEYUTIL.getKey(i)
        }
        var g = KEYUTIL.getKeyID(h);
        this.asn1KID = new KJUR.asn1.DEROctetString({
          hex: g
        })
      }
    }
  };
  this.setCertIssuerByParam = function (g) {
    if (g.str !== undefined || g.ldapstr !== undefined || g.hex !== undefined || g.certsubject !== undefined || g.certissuer !== undefined) {
      this.asn1CertIssuer = new KJUR.asn1.x509.X500Name(g)
    } else {
      if (typeof g === "string" && g.indexOf("BEGIN ") != -1 && g.indexOf("CERTIFICATE") != -1) {
        this.asn1CertIssuer = new KJUR.asn1.x509.X500Name({
          certissuer: g
        })
      }
    }
  };
  this.setCertSNByParam = function (i) {
    if (i.str !== undefined || i.bigint !== undefined || i.hex !== undefined) {
      this.asn1CertSN = new KJUR.asn1.DERInteger(i)
    } else {
      if (typeof i === "string" && i.indexOf("BEGIN ") != -1 && i.indexOf("CERTIFICATE")) {
        var g = new X509();
        g.readCertPEM(i);
        var h = g.getSerialNumberHex();
        this.asn1CertSN = new KJUR.asn1.DERInteger({
          hex: h
        })
      }
    }
  };
  this.oid = "2.5.29.35";
  if (f !== undefined) {
    if (f.kid !== undefined) {
      this.setKIDByParam(f.kid)
    }
    if (f.issuer !== undefined) {
      this.setCertIssuerByParam(f.issuer)
    }
    if (f.sn !== undefined) {
      this.setCertSNByParam(f.sn)
    }
    if (f.issuersn !== undefined && typeof f.issuersn === "string" && f.issuersn.indexOf("BEGIN ") != -1 && f.issuersn.indexOf("CERTIFICATE")) {
      this.setCertSNByParam(f.issuersn);
      this.setCertIssuerByParam(f.issuersn)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.AuthorityKeyIdentifier, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.SubjectKeyIdentifier = function (d) {
  KJUR.asn1.x509.SubjectKeyIdentifier.superclass.constructor.call(this, d);
  var b = KJUR,
    a = b.asn1,
    c = a.DEROctetString;
  this.asn1KID = null;
  this.getExtnValueHex = function () {
    this.asn1ExtnValue = this.asn1KID;
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.setKIDByParam = function (g) {
    if (g.str !== undefined || g.hex !== undefined) {
      this.asn1KID = new c(g)
    } else {
      if ((typeof g === "object" && KJUR.crypto.Util.isKey(g)) || (typeof g === "string" && g.indexOf("BEGIN") != -1)) {
        var f = g;
        if (typeof g === "string") {
          f = KEYUTIL.getKey(g)
        }
        var e = KEYUTIL.getKeyID(f);
        this.asn1KID = new KJUR.asn1.DEROctetString({
          hex: e
        })
      }
    }
  };
  this.oid = "2.5.29.14";
  if (d !== undefined) {
    if (d.kid !== undefined) {
      this.setKIDByParam(d.kid)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.SubjectKeyIdentifier, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.AuthorityInfoAccess = function (a) {
  KJUR.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this, a);
  this.setAccessDescriptionArray = function (k) {
    var j = new Array(),
      b = KJUR,
      g = b.asn1,
      d = g.DERSequence;
    for (var f = 0; f < k.length; f++) {
      var c = new g.DERObjectIdentifier(k[f].accessMethod);
      var e = new g.x509.GeneralName(k[f].accessLocation);
      var h = new d({
        array: [c, e]
      });
      j.push(h)
    }
    this.asn1ExtnValue = new d({
      array: j
    })
  };
  this.getExtnValueHex = function () {
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.oid = "1.3.6.1.5.5.7.1.1";
  if (a !== undefined) {
    if (a.array !== undefined) {
      this.setAccessDescriptionArray(a.array)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.AuthorityInfoAccess, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.SubjectAltName = function (a) {
  KJUR.asn1.x509.SubjectAltName.superclass.constructor.call(this, a);
  this.setNameArray = function (b) {
    this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(b)
  };
  this.getExtnValueHex = function () {
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.oid = "2.5.29.17";
  if (a !== undefined) {
    if (a.array !== undefined) {
      this.setNameArray(a.array)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.SubjectAltName, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.IssuerAltName = function (a) {
  KJUR.asn1.x509.IssuerAltName.superclass.constructor.call(this, a);
  this.setNameArray = function (b) {
    this.asn1ExtnValue = new KJUR.asn1.x509.GeneralNames(b)
  };
  this.getExtnValueHex = function () {
    return this.asn1ExtnValue.getEncodedHex()
  };
  this.oid = "2.5.29.18";
  if (a !== undefined) {
    if (a.array !== undefined) {
      this.setNameArray(a.array)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.IssuerAltName, KJUR.asn1.x509.Extension);
KJUR.asn1.x509.CRL = function (f) {
  KJUR.asn1.x509.CRL.superclass.constructor.call(this);
  var b = null,
    d = null,
    e = null,
    c = null,
    a = null;
  this.sign = function () {
    this.asn1SignatureAlg = this.asn1TBSCertList.asn1SignatureAlg;
    sig = new KJUR.crypto.Signature({
      alg: this.asn1SignatureAlg.nameAlg,
      prov: "cryptojs/jsrsa"
    });
    sig.init(this.prvKey);
    sig.updateHex(this.asn1TBSCertList.getEncodedHex());
    this.hexSig = sig.sign();
    this.asn1Sig = new KJUR.asn1.DERBitString({
      hex: "00" + this.hexSig
    });
    var g = new KJUR.asn1.DERSequence({
      array: [this.asn1TBSCertList, this.asn1SignatureAlg, this.asn1Sig]
    });
    this.hTLV = g.getEncodedHex();
    this.isModified = false
  };
  this.getEncodedHex = function () {
    if (this.isModified == false && this.hTLV != null) {
      return this.hTLV
    }
    throw "not signed yet"
  };
  this.getPEMString = function () {
    var g = hextob64nl(this.getEncodedHex());
    return "-----BEGIN X509 CRL-----\r\n" + g + "\r\n-----END X509 CRL-----\r\n"
  };
  if (f !== undefined) {
    if (f.tbsobj !== undefined) {
      this.asn1TBSCertList = f.tbsobj
    }
    if (f.prvkeyobj !== undefined) {
      this.prvKey = f.prvkeyobj
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.CRL, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.TBSCertList = function (g) {
  KJUR.asn1.x509.TBSCertList.superclass.constructor.call(this);
  var e = null,
    d = KJUR,
    c = d.asn1,
    b = c.DERSequence,
    f = c.x509,
    a = f.Time;
  this.setSignatureAlgByParam = function (h) {
    this.asn1SignatureAlg = new f.AlgorithmIdentifier(h)
  };
  this.setIssuerByParam = function (h) {
    this.asn1Issuer = new f.X500Name(h)
  };
  this.setThisUpdateByParam = function (h) {
    this.asn1ThisUpdate = new a(h)
  };
  this.setNextUpdateByParam = function (h) {
    this.asn1NextUpdate = new a(h)
  };
  this.addRevokedCert = function (h, i) {
    var k = {};
    if (h != undefined && h != null) {
      k.sn = h
    }
    if (i != undefined && i != null) {
      k.time = i
    }
    var j = new f.CRLEntry(k);
    this.aRevokedCert.push(j)
  };
  this.getEncodedHex = function () {
    this.asn1Array = new Array();
    if (this.asn1Version != null) {
      this.asn1Array.push(this.asn1Version)
    }
    this.asn1Array.push(this.asn1SignatureAlg);
    this.asn1Array.push(this.asn1Issuer);
    this.asn1Array.push(this.asn1ThisUpdate);
    if (this.asn1NextUpdate != null) {
      this.asn1Array.push(this.asn1NextUpdate)
    }
    if (this.aRevokedCert.length > 0) {
      var h = new b({
        array: this.aRevokedCert
      });
      this.asn1Array.push(h)
    }
    var i = new b({
      array: this.asn1Array
    });
    this.hTLV = i.getEncodedHex();
    this.isModified = false;
    return this.hTLV
  };
  this._initialize = function () {
    this.asn1Version = null;
    this.asn1SignatureAlg = null;
    this.asn1Issuer = null;
    this.asn1ThisUpdate = null;
    this.asn1NextUpdate = null;
    this.aRevokedCert = new Array()
  };
  this._initialize()
};
YAHOO.lang.extend(KJUR.asn1.x509.TBSCertList, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.CRLEntry = function (e) {
  KJUR.asn1.x509.CRLEntry.superclass.constructor.call(this);
  var d = null,
    c = null,
    b = KJUR,
    a = b.asn1;
  this.setCertSerial = function (f) {
    this.sn = new a.DERInteger(f)
  };
  this.setRevocationDate = function (f) {
    this.time = new a.x509.Time(f)
  };
  this.getEncodedHex = function () {
    var f = new a.DERSequence({
      array: [this.sn, this.time]
    });
    this.TLV = f.getEncodedHex();
    return this.TLV
  };
  if (e !== undefined) {
    if (e.time !== undefined) {
      this.setRevocationDate(e.time)
    }
    if (e.sn !== undefined) {
      this.setCertSerial(e.sn)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.CRLEntry, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.X500Name = function (f) {
  KJUR.asn1.x509.X500Name.superclass.constructor.call(this);
  this.asn1Array = new Array();
  var d = KJUR,
    c = d.asn1,
    e = c.x509,
    b = pemtohex;
  this.setByString = function (g) {
    var k = g.split("/");
    k.shift();
    var j = [];
    for (var l = 0; l < k.length; l++) {
      if (k[l].match(/^[^=]+=.+$/)) {
        j.push(k[l])
      } else {
        var h = j.length - 1;
        j[h] = j[h] + "/" + k[l]
      }
    }
    for (var l = 0; l < j.length; l++) {
      this.asn1Array.push(new e.RDN({
        str: j[l]
      }))
    }
  };
  this.setByLdapString = function (g) {
    var h = e.X500Name.ldapToCompat(g);
    this.setByString(h)
  };
  this.setByObject = function (i) {
    for (var g in i) {
      if (i.hasOwnProperty(g)) {
        var h = new KJUR.asn1.x509.RDN({
          str: g + "=" + i[g]
        });
        this.asn1Array ? this.asn1Array.push(h) : this.asn1Array = [h]
      }
    }
  };
  this.getEncodedHex = function () {
    if (typeof this.hTLV == "string") {
      return this.hTLV
    }
    var g = new c.DERSequence({
      array: this.asn1Array
    });
    this.hTLV = g.getEncodedHex();
    return this.hTLV
  };
  if (f !== undefined) {
    if (f.str !== undefined) {
      this.setByString(f.str)
    } else {
      if (f.ldapstr !== undefined) {
        this.setByLdapString(f.ldapstr)
      } else {
        if (f.hex !== undefined) {
          this.hTLV = f.hex
        } else {
          if (f.certissuer !== undefined) {
            var a = new X509();
            a.readCertPEM(f.certissuer);
            this.hTLV = a.getIssuerHex()
          } else {
            if (f.certsubject !== undefined) {
              var a = new X509();
              a.readCertPEM(f.certsubject);
              this.hTLV = a.getSubjectHex()
            } else {
              if (typeof f === "object" && f.certsubject === undefined && f.certissuer === undefined) {
                this.setByObject(f)
              }
            }
          }
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.X500Name, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.X500Name.compatToLDAP = function (d) {
  if (d.substr(0, 1) !== "/") {
    throw "malformed input"
  }
  var b = "";
  d = d.substr(1);
  var c = d.split("/");
  c.reverse();
  c = c.map(function (a) {
    return a.replace(/,/, "\\,")
  });
  return c.join(",")
};
KJUR.asn1.x509.X500Name.onelineToLDAP = function (a) {
  return KJUR.asn1.x509.X500Name.compatToLDAP(a)
};
KJUR.asn1.x509.X500Name.ldapToCompat = function (g) {
  var c = g.split(",");
  var e = false;
  var b = [];
  for (var f = 0; c.length > 0; f++) {
    var h = c.shift();
    if (e === true) {
      var d = b.pop();
      var j = (d + "," + h).replace(/\\,/g, ",");
      b.push(j);
      e = false
    } else {
      b.push(h)
    }
    if (h.substr(-1, 1) === "\\") {
      e = true
    }
  }
  b = b.map(function (a) {
    return a.replace("/", "\\/")
  });
  b.reverse();
  return "/" + b.join("/")
};
KJUR.asn1.x509.X500Name.ldapToOneline = function (a) {
  return KJUR.asn1.x509.X500Name.ldapToCompat(a)
};
KJUR.asn1.x509.RDN = function (a) {
  KJUR.asn1.x509.RDN.superclass.constructor.call(this);
  this.asn1Array = new Array();
  this.addByString = function (b) {
    this.asn1Array.push(new KJUR.asn1.x509.AttributeTypeAndValue({
      str: b
    }))
  };
  this.addByMultiValuedString = function (d) {
    var b = KJUR.asn1.x509.RDN.parseString(d);
    for (var c = 0; c < b.length; c++) {
      this.addByString(b[c])
    }
  };
  this.getEncodedHex = function () {
    var b = new KJUR.asn1.DERSet({
      array: this.asn1Array
    });
    this.TLV = b.getEncodedHex();
    return this.TLV
  };
  if (a !== undefined) {
    if (a.str !== undefined) {
      this.addByMultiValuedString(a.str)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.RDN, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.RDN.parseString = function (m) {
  var j = m.split(/\+/);
  var h = false;
  var c = [];
  for (var g = 0; j.length > 0; g++) {
    var k = j.shift();
    if (h === true) {
      var f = c.pop();
      var d = (f + "+" + k).replace(/\\\+/g, "+");
      c.push(d);
      h = false
    } else {
      c.push(k)
    }
    if (k.substr(-1, 1) === "\\") {
      h = true
    }
  }
  var l = false;
  var b = [];
  for (var g = 0; c.length > 0; g++) {
    var k = c.shift();
    if (l === true) {
      var e = b.pop();
      if (k.match(/"$/)) {
        var d = (e + "+" + k).replace(/^([^=]+)="(.*)"$/, "$1=$2");
        b.push(d);
        l = false
      } else {
        b.push(e + "+" + k)
      }
    } else {
      b.push(k)
    }
    if (k.match(/^[^=]+="/)) {
      l = true
    }
  }
  return b
};
KJUR.asn1.x509.AttributeTypeAndValue = function (d) {
  KJUR.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this);
  var f = null,
    e = null,
    a = "utf8",
    c = KJUR,
    b = c.asn1;
  this.setByString = function (h) {
    var g = h.match(/^([^=]+)=(.+)$/);
    if (g) {
      this.setByAttrTypeAndValueStr(g[1], g[2])
    } else {
      throw "malformed attrTypeAndValueStr: " + h
    }
  };
  this.setByAttrTypeAndValueStr = function (i, h) {
    this.typeObj = KJUR.asn1.x509.OID.atype2obj(i);
    var g = a;
    if (i == "C") {
      g = "prn"
    }
    this.valueObj = this.getValueObj(g, h)
  };
  this.getValueObj = function (h, g) {
    if (h == "utf8") {
      return new b.DERUTF8String({
        str: g
      })
    }
    if (h == "prn") {
      return new b.DERPrintableString({
        str: g
      })
    }
    if (h == "tel") {
      return new b.DERTeletexString({
        str: g
      })
    }
    if (h == "ia5") {
      return new b.DERIA5String({
        str: g
      })
    }
    throw "unsupported directory string type: type=" + h + " value=" + g
  };
  this.getEncodedHex = function () {
    var g = new b.DERSequence({
      array: [this.typeObj, this.valueObj]
    });
    this.TLV = g.getEncodedHex();
    return this.TLV
  };
  if (d !== undefined) {
    if (d.str !== undefined) {
      this.setByString(d.str)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.AttributeTypeAndValue, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.SubjectPublicKeyInfo = function (f) {
  KJUR.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);
  var l = null,
    k = null,
    a = KJUR,
    j = a.asn1,
    i = j.DERInteger,
    b = j.DERBitString,
    m = j.DERObjectIdentifier,
    e = j.DERSequence,
    h = j.ASN1Util.newObject,
    d = j.x509,
    o = d.AlgorithmIdentifier,
    g = a.crypto,
    n = g.ECDSA,
    c = g.DSA;
  this.getASN1Object = function () {
    if (this.asn1AlgId == null || this.asn1SubjPKey == null) {
      throw "algId and/or subjPubKey not set"
    }
    var p = new e({
      array: [this.asn1AlgId, this.asn1SubjPKey]
    });
    return p
  };
  this.getEncodedHex = function () {
    var p = this.getASN1Object();
    this.hTLV = p.getEncodedHex();
    return this.hTLV
  };
  this.setPubKey = function (q) {
    try {
      if (q instanceof RSAKey) {
        var u = h({
          seq: [{
            "int": {
              bigint: q.n
            }
          }, {
            "int": {
              "int": q.e
            }
          }]
        });
        var s = u.getEncodedHex();
        this.asn1AlgId = new o({
          name: "rsaEncryption"
        });
        this.asn1SubjPKey = new b({
          hex: "00" + s
        })
      }
    } catch (p) {}
    try {
      if (q instanceof KJUR.crypto.ECDSA) {
        var r = new m({
          name: q.curveName
        });
        this.asn1AlgId = new o({
          name: "ecPublicKey",
          asn1params: r
        });
        this.asn1SubjPKey = new b({
          hex: "00" + q.pubKeyHex
        })
      }
    } catch (p) {}
    try {
      if (q instanceof KJUR.crypto.DSA) {
        var r = new h({
          seq: [{
            "int": {
              bigint: q.p
            }
          }, {
            "int": {
              bigint: q.q
            }
          }, {
            "int": {
              bigint: q.g
            }
          }]
        });
        this.asn1AlgId = new o({
          name: "dsa",
          asn1params: r
        });
        var t = new i({
          bigint: q.y
        });
        this.asn1SubjPKey = new b({
          hex: "00" + t.getEncodedHex()
        })
      }
    } catch (p) {}
  };
  if (f !== undefined) {
    this.setPubKey(f)
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.SubjectPublicKeyInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.Time = function (f) {
  KJUR.asn1.x509.Time.superclass.constructor.call(this);
  var e = null,
    a = null,
    d = KJUR,
    c = d.asn1,
    b = c.DERUTCTime,
    g = c.DERGeneralizedTime;
  this.setTimeParams = function (h) {
    this.timeParams = h
  };
  this.getEncodedHex = function () {
    var h = null;
    if (this.timeParams != null) {
      if (this.type == "utc") {
        h = new b(this.timeParams)
      } else {
        h = new g(this.timeParams)
      }
    } else {
      if (this.type == "utc") {
        h = new b()
      } else {
        h = new g()
      }
    }
    this.TLV = h.getEncodedHex();
    return this.TLV
  };
  this.type = "utc";
  if (f !== undefined) {
    if (f.type !== undefined) {
      this.type = f.type
    } else {
      if (f.str !== undefined) {
        if (f.str.match(/^[0-9]{12}Z$/)) {
          this.type = "utc"
        }
        if (f.str.match(/^[0-9]{14}Z$/)) {
          this.type = "gen"
        }
      }
    }
    this.timeParams = f
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.Time, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.AlgorithmIdentifier = function (e) {
  KJUR.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this);
  this.nameAlg = null;
  this.asn1Alg = null;
  this.asn1Params = null;
  this.paramEmpty = false;
  var b = KJUR,
    a = b.asn1,
    c = a.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;
  this.getEncodedHex = function () {
    if (this.nameAlg === null && this.asn1Alg === null) {
      throw new Error("algorithm not specified")
    }
    if (this.nameAlg !== null) {
      var f = null;
      for (var h in c) {
        if (h === this.nameAlg) {
          f = c[h]
        }
      }
      if (f !== null) {
        this.hTLV = f;
        return this.hTLV
      }
    }
    if (this.nameAlg !== null && this.asn1Alg === null) {
      this.asn1Alg = a.x509.OID.name2obj(this.nameAlg)
    }
    var g = [this.asn1Alg];
    if (this.asn1Params !== null) {
      g.push(this.asn1Params)
    }
    var i = new a.DERSequence({
      array: g
    });
    this.hTLV = i.getEncodedHex();
    return this.hTLV
  };
  if (e !== undefined) {
    if (e.name !== undefined) {
      this.nameAlg = e.name
    }
    if (e.asn1params !== undefined) {
      this.asn1Params = e.asn1params
    }
    if (e.paramempty !== undefined) {
      this.paramEmpty = e.paramempty
    }
  }
  if (this.asn1Params === null && this.paramEmpty === false && this.nameAlg !== null) {
    var d = this.nameAlg.toLowerCase();
    if (d.substr(-7, 7) !== "withdsa" && d.substr(-9, 9) !== "withecdsa") {
      this.asn1Params = new a.DERNull()
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.AlgorithmIdentifier, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV = {
  SHAwithRSAandMGF1: "300d06092a864886f70d01010a3000",
  SHA256withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040201a11a301806092a864886f70d010108300b0609608648016503040201a203020120",
  SHA384withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040202a11a301806092a864886f70d010108300b0609608648016503040202a203020130",
  SHA512withRSAandMGF1: "303d06092a864886f70d01010a3030a00d300b0609608648016503040203a11a301806092a864886f70d010108300b0609608648016503040203a203020140"
};
KJUR.asn1.x509.GeneralName = function (e) {
  KJUR.asn1.x509.GeneralName.superclass.constructor.call(this);
  var m = null,
    i = null,
    k = {
      rfc822: "81",
      dns: "82",
      dn: "a4",
      uri: "86",
      ip: "87"
    },
    b = KJUR,
    g = b.asn1,
    f = g.DERSequence,
    j = g.DEROctetString,
    d = g.DERIA5String,
    c = g.DERTaggedObject,
    l = g.ASN1Object,
    a = g.x509.X500Name,
    h = pemtohex;
  this.explicit = false;
  this.setByParam = function (p) {
    var r = null;
    var u = null;
    if (p === undefined) {
      return
    }
    if (p.rfc822 !== undefined) {
      this.type = "rfc822";
      u = new d({
        str: p[this.type]
      })
    }
    if (p.dns !== undefined) {
      this.type = "dns";
      u = new d({
        str: p[this.type]
      })
    }
    if (p.uri !== undefined) {
      this.type = "uri";
      u = new d({
        str: p[this.type]
      })
    }
    if (p.dn !== undefined) {
      this.type = "dn";
      this.explicit = true;
      if (typeof p.dn === "string") {
        u = new a({
          str: p.dn
        })
      } else {
        if (p.dn instanceof KJUR.asn1.x509.X500Name) {
          u = p.dn
        } else {
          u = new a(p.dn)
        }
      }
    }
    if (p.ldapdn !== undefined) {
      this.type = "dn";
      this.explicit = true;
      u = new a({
        ldapstr: p.ldapdn
      })
    }
    if (p.certissuer !== undefined) {
      this.type = "dn";
      this.explicit = true;
      var o = p.certissuer;
      var w = null;
      if (o.match(/^[0-9A-Fa-f]+$/)) {
        w == o
      }
      if (o.indexOf("-----BEGIN ") != -1) {
        w = h(o)
      }
      if (w == null) {
        throw "certissuer param not cert"
      }
      var t = new X509();
      t.hex = w;
      var y = t.getIssuerHex();
      u = new l();
      u.hTLV = y
    }
    if (p.certsubj !== undefined) {
      this.type = "dn";
      this.explicit = true;
      var o = p.certsubj;
      var w = null;
      if (o.match(/^[0-9A-Fa-f]+$/)) {
        w == o
      }
      if (o.indexOf("-----BEGIN ") != -1) {
        w = h(o)
      }
      if (w == null) {
        throw "certsubj param not cert"
      }
      var t = new X509();
      t.hex = w;
      var y = t.getSubjectHex();
      u = new l();
      u.hTLV = y
    }
    if (p.ip !== undefined) {
      this.type = "ip";
      this.explicit = false;
      var q = p.ip;
      var s;
      var n = "malformed IP address";
      if (q.match(/^[0-9.]+[.][0-9.]+$/)) {
        s = intarystrtohex("[" + q.split(".").join(",") + "]");
        if (s.length !== 8) {
          throw n
        }
      } else {
        if (q.match(/^[0-9A-Fa-f:]+:[0-9A-Fa-f:]+$/)) {
          s = ipv6tohex(q)
        } else {
          if (q.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) {
            s = q
          } else {
            throw n
          }
        }
      }
      u = new j({
        hex: s
      })
    }
    if (this.type == null) {
      throw "unsupported type in params=" + p
    }
    this.asn1Obj = new c({
      explicit: this.explicit,
      tag: k[this.type],
      obj: u
    })
  };
  this.getEncodedHex = function () {
    return this.asn1Obj.getEncodedHex()
  };
  if (e !== undefined) {
    this.setByParam(e)
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.GeneralName, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.GeneralNames = function (d) {
  KJUR.asn1.x509.GeneralNames.superclass.constructor.call(this);
  var a = null,
    c = KJUR,
    b = c.asn1;
  this.setByParamArray = function (g) {
    for (var e = 0; e < g.length; e++) {
      var f = new b.x509.GeneralName(g[e]);
      this.asn1Array.push(f)
    }
  };
  this.getEncodedHex = function () {
    var e = new b.DERSequence({
      array: this.asn1Array
    });
    return e.getEncodedHex()
  };
  this.asn1Array = new Array();
  if (typeof d != "undefined") {
    this.setByParamArray(d)
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.GeneralNames, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.DistributionPointName = function (b) {
  KJUR.asn1.x509.DistributionPointName.superclass.constructor.call(this);
  var h = null,
    e = null,
    a = null,
    g = null,
    d = KJUR,
    c = d.asn1,
    f = c.DERTaggedObject;
  this.getEncodedHex = function () {
    if (this.type != "full") {
      throw "currently type shall be 'full': " + this.type
    }
    this.asn1Obj = new f({
      explicit: false,
      tag: this.tag,
      obj: this.asn1V
    });
    this.hTLV = this.asn1Obj.getEncodedHex();
    return this.hTLV
  };
  if (b !== undefined) {
    if (c.x509.GeneralNames.prototype.isPrototypeOf(b)) {
      this.type = "full";
      this.tag = "a0";
      this.asn1V = b
    } else {
      throw "This class supports GeneralNames only as argument"
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.DistributionPointName, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.DistributionPoint = function (d) {
  KJUR.asn1.x509.DistributionPoint.superclass.constructor.call(this);
  var a = null,
    c = KJUR,
    b = c.asn1;
  this.getEncodedHex = function () {
    var e = new b.DERSequence();
    if (this.asn1DP != null) {
      var f = new b.DERTaggedObject({
        explicit: true,
        tag: "a0",
        obj: this.asn1DP
      });
      e.appendASN1Object(f)
    }
    this.hTLV = e.getEncodedHex();
    return this.hTLV
  };
  if (d !== undefined) {
    if (d.dpobj !== undefined) {
      this.asn1DP = d.dpobj
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.x509.DistributionPoint, KJUR.asn1.ASN1Object);
KJUR.asn1.x509.OID = new function (a) {
  this.atype2oidList = {
    CN: "2.5.4.3",
    L: "2.5.4.7",
    ST: "2.5.4.8",
    O: "2.5.4.10",
    OU: "2.5.4.11",
    C: "2.5.4.6",
    STREET: "2.5.4.9",
    DC: "0.9.2342.19200300.100.1.25",
    UID: "0.9.2342.19200300.100.1.1",
    SN: "2.5.4.4",
    T: "2.5.4.12",
    DN: "2.5.4.49",
    E: "1.2.840.113549.1.9.1",
    description: "2.5.4.13",
    businessCategory: "2.5.4.15",
    postalCode: "2.5.4.17",
    serialNumber: "2.5.4.5",
    uniqueIdentifier: "2.5.4.45",
    organizationIdentifier: "2.5.4.97",
    jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1",
    jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2",
    jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3"
  };
  this.name2oidList = {
    sha1: "1.3.14.3.2.26",
    sha256: "2.16.840.1.101.3.4.2.1",
    sha384: "2.16.840.1.101.3.4.2.2",
    sha512: "2.16.840.1.101.3.4.2.3",
    sha224: "2.16.840.1.101.3.4.2.4",
    md5: "1.2.840.113549.2.5",
    md2: "1.3.14.7.2.2.1",
    ripemd160: "1.3.36.3.2.1",
    MD2withRSA: "1.2.840.113549.1.1.2",
    MD4withRSA: "1.2.840.113549.1.1.3",
    MD5withRSA: "1.2.840.113549.1.1.4",
    SHA1withRSA: "1.2.840.113549.1.1.5",
    SHA224withRSA: "1.2.840.113549.1.1.14",
    SHA256withRSA: "1.2.840.113549.1.1.11",
    SHA384withRSA: "1.2.840.113549.1.1.12",
    SHA512withRSA: "1.2.840.113549.1.1.13",
    SHA1withECDSA: "1.2.840.10045.4.1",
    SHA224withECDSA: "1.2.840.10045.4.3.1",
    SHA256withECDSA: "1.2.840.10045.4.3.2",
    SHA384withECDSA: "1.2.840.10045.4.3.3",
    SHA512withECDSA: "1.2.840.10045.4.3.4",
    dsa: "1.2.840.10040.4.1",
    SHA1withDSA: "1.2.840.10040.4.3",
    SHA224withDSA: "2.16.840.1.101.3.4.3.1",
    SHA256withDSA: "2.16.840.1.101.3.4.3.2",
    rsaEncryption: "1.2.840.113549.1.1.1",
    commonName: "2.5.4.3",
    countryName: "2.5.4.6",
    localityName: "2.5.4.7",
    stateOrProvinceName: "2.5.4.8",
    streetAddress: "2.5.4.9",
    organizationName: "2.5.4.10",
    organizationalUnitName: "2.5.4.11",
    domainComponent: "0.9.2342.19200300.100.1.25",
    userId: "0.9.2342.19200300.100.1.1",
    surname: "2.5.4.4",
    title: "2.5.4.12",
    distinguishedName: "2.5.4.49",
    emailAddress: "1.2.840.113549.1.9.1",
    description: "2.5.4.13",
    businessCategory: "2.5.4.15",
    postalCode: "2.5.4.17",
    uniqueIdentifier: "2.5.4.45",
    organizationIdentifier: "2.5.4.97",
    jurisdictionOfIncorporationL: "1.3.6.1.4.1.311.60.2.1.1",
    jurisdictionOfIncorporationSP: "1.3.6.1.4.1.311.60.2.1.2",
    jurisdictionOfIncorporationC: "1.3.6.1.4.1.311.60.2.1.3",
    subjectKeyIdentifier: "2.5.29.14",
    keyUsage: "2.5.29.15",
    subjectAltName: "2.5.29.17",
    issuerAltName: "2.5.29.18",
    basicConstraints: "2.5.29.19",
    nameConstraints: "2.5.29.30",
    cRLDistributionPoints: "2.5.29.31",
    certificatePolicies: "2.5.29.32",
    authorityKeyIdentifier: "2.5.29.35",
    policyConstraints: "2.5.29.36",
    extKeyUsage: "2.5.29.37",
    authorityInfoAccess: "1.3.6.1.5.5.7.1.1",
    ocsp: "1.3.6.1.5.5.7.48.1",
    caIssuers: "1.3.6.1.5.5.7.48.2",
    anyExtendedKeyUsage: "2.5.29.37.0",
    serverAuth: "1.3.6.1.5.5.7.3.1",
    clientAuth: "1.3.6.1.5.5.7.3.2",
    codeSigning: "1.3.6.1.5.5.7.3.3",
    emailProtection: "1.3.6.1.5.5.7.3.4",
    timeStamping: "1.3.6.1.5.5.7.3.8",
    ocspSigning: "1.3.6.1.5.5.7.3.9",
    ecPublicKey: "1.2.840.10045.2.1",
    secp256r1: "1.2.840.10045.3.1.7",
    secp256k1: "1.3.132.0.10",
    secp384r1: "1.3.132.0.34",
    pkcs5PBES2: "1.2.840.113549.1.5.13",
    pkcs5PBKDF2: "1.2.840.113549.1.5.12",
    "des-EDE3-CBC": "1.2.840.113549.3.7",
    data: "1.2.840.113549.1.7.1",
    "signed-data": "1.2.840.113549.1.7.2",
    "enveloped-data": "1.2.840.113549.1.7.3",
    "digested-data": "1.2.840.113549.1.7.5",
    "encrypted-data": "1.2.840.113549.1.7.6",
    "authenticated-data": "1.2.840.113549.1.9.16.1.2",
    tstinfo: "1.2.840.113549.1.9.16.1.4",
    extensionRequest: "1.2.840.113549.1.9.14",
  };
  this.objCache = {};
  this.name2obj = function (b) {
    if (typeof this.objCache[b] != "undefined") {
      return this.objCache[b]
    }
    if (typeof this.name2oidList[b] == "undefined") {
      throw "Name of ObjectIdentifier not defined: " + b
    }
    var c = this.name2oidList[b];
    var d = new KJUR.asn1.DERObjectIdentifier({
      oid: c
    });
    this.objCache[b] = d;
    return d
  };
  this.atype2obj = function (b) {
    if (typeof this.objCache[b] != "undefined") {
      return this.objCache[b]
    }
    if (typeof this.atype2oidList[b] == "undefined") {
      throw "AttributeType name undefined: " + b
    }
    var c = this.atype2oidList[b];
    var d = new KJUR.asn1.DERObjectIdentifier({
      oid: c
    });
    this.objCache[b] = d;
    return d
  }
};
KJUR.asn1.x509.OID.oid2name = function (b) {
  var c = KJUR.asn1.x509.OID.name2oidList;
  for (var a in c) {
    if (c[a] == b) {
      return a
    }
  }
  return ""
};
KJUR.asn1.x509.OID.oid2atype = function (b) {
  var c = KJUR.asn1.x509.OID.atype2oidList;
  for (var a in c) {
    if (c[a] == b) {
      return a
    }
  }
  return b
};
KJUR.asn1.x509.OID.name2oid = function (a) {
  var b = KJUR.asn1.x509.OID.name2oidList;
  if (b[a] === undefined) {
    return ""
  }
  return b[a]
};
KJUR.asn1.x509.X509Util = {};
KJUR.asn1.x509.X509Util.newCertPEM = function (h) {
  var g = KJUR.asn1.x509,
    b = g.TBSCertificate,
    a = g.Certificate;
  var f = new b();
  if (h.serial !== undefined) {
    f.setSerialNumberByParam(h.serial)
  } else {
    throw "serial number undefined."
  }
  if (typeof h.sigalg.name === "string") {
    f.setSignatureAlgByParam(h.sigalg)
  } else {
    throw "unproper signature algorithm name"
  }
  if (h.issuer !== undefined) {
    f.setIssuerByParam(h.issuer)
  } else {
    throw "issuer name undefined."
  }
  if (h.notbefore !== undefined) {
    f.setNotBeforeByParam(h.notbefore)
  } else {
    throw "notbefore undefined."
  }
  if (h.notafter !== undefined) {
    f.setNotAfterByParam(h.notafter)
  } else {
    throw "notafter undefined."
  }
  if (h.subject !== undefined) {
    f.setSubjectByParam(h.subject)
  } else {
    throw "subject name undefined."
  }
  if (h.sbjpubkey !== undefined) {
    f.setSubjectPublicKeyByGetKey(h.sbjpubkey)
  } else {
    throw "subject public key undefined."
  }
  if (h.ext !== undefined && h.ext.length !== undefined) {
    for (var d = 0; d < h.ext.length; d++) {
      for (key in h.ext[d]) {
        f.appendExtensionByName(key, h.ext[d][key])
      }
    }
  }
  if (h.cakey === undefined && h.sighex === undefined) {
    throw "param cakey and sighex undefined."
  }
  var e = null;
  var c = null;
  if (h.cakey) {
    if (h.cakey.isPrivate === true) {
      e = h.cakey
    } else {
      e = KEYUTIL.getKey.apply(null, h.cakey)
    }
    c = new a({
      tbscertobj: f,
      prvkeyobj: e
    });
    c.sign()
  }
  if (h.sighex) {
    c = new a({
      tbscertobj: f
    });
    c.setSignatureHex(h.sighex)
  }
  return c.getPEMString()
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
  KJUR.asn1 = {}
}
if (typeof KJUR.asn1.cms == "undefined" || !KJUR.asn1.cms) {
  KJUR.asn1.cms = {}
}
KJUR.asn1.cms.Attribute = function (d) {
  var a = [],
    c = KJUR,
    b = c.asn1;
  b.cms.Attribute.superclass.constructor.call(this);
  this.getEncodedHex = function () {
    var h, g, e;
    h = new b.DERObjectIdentifier({
      oid: this.attrTypeOid
    });
    g = new b.DERSet({
      array: this.valueList
    });
    try {
      g.getEncodedHex()
    } catch (f) {
      throw "fail valueSet.getEncodedHex in Attribute(1)/" + f
    }
    e = new b.DERSequence({
      array: [h, g]
    });
    try {
      this.hTLV = e.getEncodedHex()
    } catch (f) {
      throw "failed seq.getEncodedHex in Attribute(2)/" + f
    }
    return this.hTLV
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.Attribute, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.ContentType = function (d) {
  var c = KJUR,
    b = c.asn1;
  b.cms.ContentType.superclass.constructor.call(this);
  this.attrTypeOid = "1.2.840.113549.1.9.3";
  var a = null;
  if (typeof d != "undefined") {
    var a = new b.DERObjectIdentifier(d);
    this.valueList = [a]
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.ContentType, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.MessageDigest = function (d) {
  var b = KJUR,
    e = b.asn1,
    g = e.DEROctetString,
    i = e.cms;
  i.MessageDigest.superclass.constructor.call(this);
  this.attrTypeOid = "1.2.840.113549.1.9.4";
  if (d !== undefined) {
    if (d.eciObj instanceof i.EncapsulatedContentInfo && typeof d.hashAlg === "string") {
      var h = d.eciObj.eContentValueHex;
      var c = d.hashAlg;
      var a = b.crypto.Util.hashHex(h, c);
      var f = new g({
        hex: a
      });
      f.getEncodedHex();
      this.valueList = [f]
    } else {
      var f = new g(d);
      f.getEncodedHex();
      this.valueList = [f]
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.MessageDigest, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.SigningTime = function (e) {
  var d = KJUR,
    c = d.asn1;
  c.cms.SigningTime.superclass.constructor.call(this);
  this.attrTypeOid = "1.2.840.113549.1.9.5";
  if (e !== undefined) {
    var a = new c.x509.Time(e);
    try {
      a.getEncodedHex()
    } catch (b) {
      throw "SigningTime.getEncodedHex() failed/" + b
    }
    this.valueList = [a]
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.SigningTime, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.SigningCertificate = function (f) {
  var c = KJUR,
    b = c.asn1,
    a = b.DERSequence,
    e = b.cms,
    d = c.crypto;
  e.SigningCertificate.superclass.constructor.call(this);
  this.attrTypeOid = "1.2.840.113549.1.9.16.2.12";
  this.setCerts = function (n) {
    var l = [];
    for (var k = 0; k < n.length; k++) {
      var h = pemtohex(n[k]);
      var g = c.crypto.Util.hashHex(h, "sha1");
      var o = new b.DEROctetString({
        hex: g
      });
      o.getEncodedHex();
      var m = new e.IssuerSerial({
        cert: n[k]
      });
      m.getEncodedHex();
      var p = new a({
        array: [o, m]
      });
      p.getEncodedHex();
      l.push(p)
    }
    var j = new a({
      array: l
    });
    j.getEncodedHex();
    this.valueList = [j]
  };
  if (f !== undefined) {
    if (typeof f.array == "object") {
      this.setCerts(f.array)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.SigningCertificate, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.SigningCertificateV2 = function (h) {
  var d = KJUR,
    c = d.asn1,
    b = c.DERSequence,
    g = c.x509,
    f = c.cms,
    e = d.crypto;
  f.SigningCertificateV2.superclass.constructor.call(this);
  this.attrTypeOid = "1.2.840.113549.1.9.16.2.47";
  this.setCerts = function (r, k) {
    var p = [];
    for (var n = 0; n < r.length; n++) {
      var l = pemtohex(r[n]);
      var t = [];
      if (k !== "sha256") {
        t.push(new g.AlgorithmIdentifier({
          name: k
        }))
      }
      var j = e.Util.hashHex(l, k);
      var s = new c.DEROctetString({
        hex: j
      });
      s.getEncodedHex();
      t.push(s);
      var o = new f.IssuerSerial({
        cert: r[n]
      });
      o.getEncodedHex();
      t.push(o);
      var q = new b({
        array: t
      });
      q.getEncodedHex();
      p.push(q)
    }
    var m = new b({
      array: p
    });
    m.getEncodedHex();
    this.valueList = [m]
  };
  if (h !== undefined) {
    if (typeof h.array == "object") {
      var a = "sha256";
      if (typeof h.hashAlg == "string") {
        a = h.hashAlg
      }
      this.setCerts(h.array, a)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.SigningCertificateV2, KJUR.asn1.cms.Attribute);
KJUR.asn1.cms.IssuerSerial = function (f) {
  var d = KJUR,
    h = d.asn1,
    g = h.DERInteger,
    j = h.cms,
    e = h.x509,
    b = e.X500Name,
    a = e.GeneralNames,
    c = X509;
  j.IssuerSerial.superclass.constructor.call(this);
  var k = null;
  var i = null;
  this.setByCertPEM = function (o) {
    var m = pemtohex(o);
    var l = new c();
    l.hex = m;
    var p = l.getIssuerHex();
    this.dIssuer = new b();
    this.dIssuer.hTLV = p;
    var n = l.getSerialNumberHex();
    this.dSerial = new g({
      hex: n
    })
  };
  this.getEncodedHex = function () {
    var l = new a([{
      dn: this.dIssuer
    }]);
    var m = new h.DERSequence({
      array: [l, this.dSerial]
    });
    this.hTLV = m.getEncodedHex();
    return this.hTLV
  };
  if (f !== undefined) {
    if (typeof f == "string" && f.indexOf("-----BEGIN ") != -1) {
      this.setByCertPEM(f)
    }
    if (f.issuer && f.serial) {
      if (f.issuer instanceof b) {
        this.dIssuer = f.issuer
      } else {
        this.dIssuer = new b(f.issuer)
      }
      if (f.serial instanceof g) {
        this.dSerial = f.serial
      } else {
        this.dSerial = new g(f.serial)
      }
    }
    if (typeof f.cert == "string") {
      this.setByCertPEM(f.cert)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.IssuerSerial, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.IssuerAndSerialNumber = function (e) {
  var b = KJUR,
    g = b.asn1,
    f = g.DERInteger,
    i = g.cms,
    d = g.x509,
    a = d.X500Name,
    c = X509;
  i.IssuerAndSerialNumber.superclass.constructor.call(this);
  var j = null;
  var h = null;
  this.setByCertPEM = function (n) {
    var l = pemtohex(n);
    var k = new c();
    k.hex = l;
    var o = k.getIssuerHex();
    this.dIssuer = new a();
    this.dIssuer.hTLV = o;
    var m = k.getSerialNumberHex();
    this.dSerial = new f({
      hex: m
    })
  };
  this.getEncodedHex = function () {
    var k = new g.DERSequence({
      array: [this.dIssuer, this.dSerial]
    });
    this.hTLV = k.getEncodedHex();
    return this.hTLV
  };
  if (e !== undefined) {
    if (typeof e == "string" && e.indexOf("-----BEGIN ") != -1) {
      this.setByCertPEM(e)
    }
    if (e.issuer && e.serial) {
      if (e.issuer instanceof a) {
        this.dIssuer = e.issuer
      } else {
        this.dIssuer = new a(e.issuer)
      }
      if (e.serial instanceof f) {
        this.dSerial = e.serial
      } else {
        this.dSerial = new f(e.serial)
      }
    }
    if (typeof e.cert == "string") {
      this.setByCertPEM(e.cert)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.IssuerAndSerialNumber, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.AttributeList = function (d) {
  var b = KJUR,
    a = b.asn1,
    c = a.cms;
  c.AttributeList.superclass.constructor.call(this);
  this.list = new Array();
  this.sortFlag = true;
  this.add = function (e) {
    if (e instanceof c.Attribute) {
      this.list.push(e)
    }
  };
  this.length = function () {
    return this.list.length
  };
  this.clear = function () {
    this.list = new Array();
    this.hTLV = null;
    this.hV = null
  };
  this.getEncodedHex = function () {
    if (typeof this.hTLV == "string") {
      return this.hTLV
    }
    var e = new a.DERSet({
      array: this.list,
      sortflag: this.sortFlag
    });
    this.hTLV = e.getEncodedHex();
    return this.hTLV
  };
  if (d !== undefined) {
    if (typeof d.sortflag != "undefined" && d.sortflag == false) {
      this.sortFlag = false
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.AttributeList, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.SignerInfo = function (e) {
  var a = KJUR,
    h = a.asn1,
    b = h.DERTaggedObject,
    n = h.cms,
    j = n.AttributeList,
    g = n.ContentType,
    k = n.EncapsulatedContentInfo,
    c = n.MessageDigest,
    l = n.SignedData,
    d = h.x509,
    m = d.AlgorithmIdentifier,
    f = a.crypto,
    i = KEYUTIL;
  n.SignerInfo.superclass.constructor.call(this);
  this.dCMSVersion = new h.DERInteger({
    "int": 1
  });
  this.dSignerIdentifier = null;
  this.dDigestAlgorithm = null;
  this.dSignedAttrs = new j();
  this.dSigAlg = null;
  this.dSig = null;
  this.dUnsignedAttrs = new j();
  this.setSignerIdentifier = function (p) {
    if (typeof p == "string" && p.indexOf("CERTIFICATE") != -1 && p.indexOf("BEGIN") != -1 && p.indexOf("END") != -1) {
      var o = p;
      this.dSignerIdentifier = new n.IssuerAndSerialNumber({
        cert: p
      })
    }
  };
  this.setForContentAndHash = function (o) {
    if (o !== undefined) {
      if (o.eciObj instanceof k) {
        this.dSignedAttrs.add(new g({
          oid: "1.2.840.113549.1.7.1"
        }));
        this.dSignedAttrs.add(new c({
          eciObj: o.eciObj,
          hashAlg: o.hashAlg
        }))
      }
      if (o.sdObj !== undefined && o.sdObj instanceof l) {
        if (o.sdObj.digestAlgNameList.join(":").indexOf(o.hashAlg) == -1) {
          o.sdObj.digestAlgNameList.push(o.hashAlg)
        }
      }
      if (typeof o.hashAlg == "string") {
        this.dDigestAlgorithm = new m({
          name: o.hashAlg
        })
      }
    }
  };
  this.sign = function (t, p) {
    this.dSigAlg = new m({
      name: p
    });
    var q = this.dSignedAttrs.getEncodedHex();
    var o = i.getKey(t);
    var s = new f.Signature({
      alg: p
    });
    s.init(o);
    s.updateHex(q);
    var r = s.sign();
    this.dSig = new h.DEROctetString({
      hex: r
    })
  };
  this.addUnsigned = function (o) {
    this.hTLV = null;
    this.dUnsignedAttrs.hTLV = null;
    this.dUnsignedAttrs.add(o)
  };
  this.getEncodedHex = function () {
    if (this.dSignedAttrs instanceof j && this.dSignedAttrs.length() == 0) {
      throw "SignedAttrs length = 0 (empty)"
    }
    var o = new b({
      obj: this.dSignedAttrs,
      tag: "a0",
      explicit: false
    });
    var r = null;
    if (this.dUnsignedAttrs.length() > 0) {
      r = new b({
        obj: this.dUnsignedAttrs,
        tag: "a1",
        explicit: false
      })
    }
    var q = [this.dCMSVersion, this.dSignerIdentifier, this.dDigestAlgorithm, o, this.dSigAlg, this.dSig, ];
    if (r != null) {
      q.push(r)
    }
    var p = new h.DERSequence({
      array: q
    });
    this.hTLV = p.getEncodedHex();
    return this.hTLV
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.SignerInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.EncapsulatedContentInfo = function (g) {
  var c = KJUR,
    b = c.asn1,
    e = b.DERTaggedObject,
    a = b.DERSequence,
    h = b.DERObjectIdentifier,
    d = b.DEROctetString,
    f = b.cms;
  f.EncapsulatedContentInfo.superclass.constructor.call(this);
  this.dEContentType = new h({
    name: "data"
  });
  this.dEContent = null;
  this.isDetached = false;
  this.eContentValueHex = null;
  this.setContentType = function (i) {
    if (i.match(/^[0-2][.][0-9.]+$/)) {
      this.dEContentType = new h({
        oid: i
      })
    } else {
      this.dEContentType = new h({
        name: i
      })
    }
  };
  this.setContentValue = function (i) {
    if (i !== undefined) {
      if (typeof i.hex == "string") {
        this.eContentValueHex = i.hex
      } else {
        if (typeof i.str == "string") {
          this.eContentValueHex = utf8tohex(i.str)
        }
      }
    }
  };
  this.setContentValueHex = function (i) {
    this.eContentValueHex = i
  };
  this.setContentValueStr = function (i) {
    this.eContentValueHex = utf8tohex(i)
  };
  this.getEncodedHex = function () {
    if (typeof this.eContentValueHex != "string") {
      throw "eContentValue not yet set"
    }
    var k = new d({
      hex: this.eContentValueHex
    });
    this.dEContent = new e({
      obj: k,
      tag: "a0",
      explicit: true
    });
    var i = [this.dEContentType];
    if (!this.isDetached) {
      i.push(this.dEContent)
    }
    var j = new a({
      array: i
    });
    this.hTLV = j.getEncodedHex();
    return this.hTLV
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.EncapsulatedContentInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.ContentInfo = function (f) {
  var c = KJUR,
    b = c.asn1,
    d = b.DERTaggedObject,
    a = b.DERSequence,
    e = b.x509;
  KJUR.asn1.cms.ContentInfo.superclass.constructor.call(this);
  this.dContentType = null;
  this.dContent = null;
  this.setContentType = function (g) {
    if (typeof g == "string") {
      this.dContentType = e.OID.name2obj(g)
    }
  };
  this.getEncodedHex = function () {
    var h = new d({
      obj: this.dContent,
      tag: "a0",
      explicit: true
    });
    var g = new a({
      array: [this.dContentType, h]
    });
    this.hTLV = g.getEncodedHex();
    return this.hTLV
  };
  if (f !== undefined) {
    if (f.type) {
      this.setContentType(f.type)
    }
    if (f.obj && f.obj instanceof b.ASN1Object) {
      this.dContent = f.obj
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.ContentInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.SignedData = function (e) {
  var a = KJUR,
    h = a.asn1,
    j = h.ASN1Object,
    g = h.DERInteger,
    m = h.DERSet,
    f = h.DERSequence,
    b = h.DERTaggedObject,
    l = h.cms,
    i = l.EncapsulatedContentInfo,
    d = l.SignerInfo,
    n = l.ContentInfo,
    c = h.x509,
    k = c.AlgorithmIdentifier;
  KJUR.asn1.cms.SignedData.superclass.constructor.call(this);
  this.dCMSVersion = new g({
    "int": 1
  });
  this.dDigestAlgs = null;
  this.digestAlgNameList = [];
  this.dEncapContentInfo = new i();
  this.dCerts = null;
  this.certificateList = [];
  this.crlList = [];
  this.signerInfoList = [new d()];
  this.addCertificatesByPEM = function (p) {
    var q = pemtohex(p);
    var r = new j();
    r.hTLV = q;
    this.certificateList.push(r)
  };
  this.getEncodedHex = function () {
    if (typeof this.hTLV == "string") {
      return this.hTLV
    }
    if (this.dDigestAlgs == null) {
      var u = [];
      for (var t = 0; t < this.digestAlgNameList.length; t++) {
        var s = this.digestAlgNameList[t];
        var w = new k({
          name: s
        });
        u.push(w)
      }
      this.dDigestAlgs = new m({
        array: u
      })
    }
    var p = [this.dCMSVersion, this.dDigestAlgs, this.dEncapContentInfo];
    if (this.dCerts == null) {
      if (this.certificateList.length > 0) {
        var v = new m({
          array: this.certificateList
        });
        this.dCerts = new b({
          obj: v,
          tag: "a0",
          explicit: false
        })
      }
    }
    if (this.dCerts != null) {
      p.push(this.dCerts)
    }
    var r = new m({
      array: this.signerInfoList
    });
    p.push(r);
    var q = new f({
      array: p
    });
    this.hTLV = q.getEncodedHex();
    return this.hTLV
  };
  this.getContentInfo = function () {
    this.getEncodedHex();
    var o = new n({
      type: "signed-data",
      obj: this
    });
    return o
  };
  this.getContentInfoEncodedHex = function () {
    var o = this.getContentInfo();
    var p = o.getEncodedHex();
    return p
  };
  this.getPEM = function () {
    return hextopem(this.getContentInfoEncodedHex(), "CMS")
  }
};
YAHOO.lang.extend(KJUR.asn1.cms.SignedData, KJUR.asn1.ASN1Object);
KJUR.asn1.cms.CMSUtil = new function () {};
KJUR.asn1.cms.CMSUtil.newSignedData = function (d) {
  var b = KJUR,
    j = b.asn1,
    q = j.cms,
    f = q.SignerInfo,
    n = q.SignedData,
    o = q.SigningTime,
    a = q.SigningCertificate,
    p = q.SigningCertificateV2,
    c = j.cades,
    e = c.SignaturePolicyIdentifier;
  var m = new n();
  m.dEncapContentInfo.setContentValue(d.content);
  if (typeof d.detached == "boolean") {
    m.dEncapContentInfo.isDetached = d.detached
  }
  if (typeof d.certs == "object") {
    for (var h = 0; h < d.certs.length; h++) {
      m.addCertificatesByPEM(d.certs[h])
    }
  }
  m.signerInfoList = [];
  for (var h = 0; h < d.signerInfos.length; h++) {
    var k = d.signerInfos[h];
    var g = new f();
    g.setSignerIdentifier(k.signerCert);
    g.setForContentAndHash({
      sdObj: m,
      eciObj: m.dEncapContentInfo,
      hashAlg: k.hashAlg
    });
    for (attrName in k.sAttr) {
      var r = k.sAttr[attrName];
      if (attrName == "SigningTime") {
        var l = new o(r);
        g.dSignedAttrs.add(l)
      }
      if (attrName == "SigningCertificate") {
        var l = new a(r);
        g.dSignedAttrs.add(l)
      }
      if (attrName == "SigningCertificateV2") {
        var l = new p(r);
        g.dSignedAttrs.add(l)
      }
      if (attrName == "SignaturePolicyIdentifier") {
        var l = new e(r);
        g.dSignedAttrs.add(l)
      }
    }
    g.sign(k.signerPrvKey, k.sigAlg);
    m.signerInfoList.push(g)
  }
  return m
};
KJUR.asn1.cms.CMSUtil.verifySignedData = function (n) {
  var C = KJUR,
    p = C.asn1,
    s = p.cms,
    D = s.SignerInfo,
    q = s.SignedData,
    y = s.SigningTime,
    b = s.SigningCertificate,
    d = s.SigningCertificateV2,
    A = p.cades,
    u = A.SignaturePolicyIdentifier,
    i = C.lang.String.isHex,
    v = ASN1HEX,
    h = v.getVbyList,
    a = v.getTLVbyList,
    t = v.getIdxbyList,
    z = v.getChildIdx,
    c = v.getTLV,
    B = v.oidname,
    j = C.crypto.Util.hashHex;
  if (n.cms === undefined && !i(n.cms)) {}
  var E = n.cms;
  var g = function (J, H) {
    var G;
    for (var I = 3; I < 6; I++) {
      G = t(J, 0, [1, 0, I]);
      if (G !== undefined) {
        var F = J.substr(G, 2);
        if (F === "a0") {
          H.certsIdx = G
        }
        if (F === "a1") {
          H.revinfosIdx = G
        }
        if (F === "31") {
          H.signerinfosIdx = G
        }
      }
    }
  };
  var l = function (I, F) {
    var H = F.signerinfosIdx;
    if (H === undefined) {
      return
    }
    var L = z(I, H);
    F.signerInfoIdxList = L;
    for (var G = 0; G < L.length; G++) {
      var K = L[G];
      var J = {
        idx: K
      };
      k(I, J);
      F.signerInfos.push(J)
    }
  };
  var k = function (I, J) {
    var F = J.idx;
    J.signerid_issuer1 = a(I, F, [1, 0], "30");
    J.signerid_serial1 = h(I, F, [1, 1], "02");
    J.hashalg = B(h(I, F, [2, 0], "06"));
    var H = t(I, F, [3], "a0");
    J.idxSignedAttrs = H;
    f(I, J, H);
    var G = z(I, F);
    var K = G.length;
    if (K < 6) {
      throw "malformed SignerInfo"
    }
    J.sigalg = B(h(I, F, [K - 2, 0], "06"));
    J.sigval = h(I, F, [K - 1], "04")
  };
  var f = function (L, M, F) {
    var J = z(L, F);
    M.signedAttrIdxList = J;
    for (var K = 0; K < J.length; K++) {
      var I = J[K];
      var G = h(L, I, [0], "06");
      var H;
      if (G === "2a864886f70d010905") {
        H = hextoutf8(h(L, I, [1, 0]));
        M.saSigningTime = H
      } else {
        if (G === "2a864886f70d010904") {
          H = h(L, I, [1, 0], "04");
          M.saMessageDigest = H
        }
      }
    }
  };
  var w = function (G, F) {
    if (h(G, 0, [0], "06") !== "2a864886f70d010702") {
      return F
    }
    F.cmsType = "signedData";
    F.econtent = h(G, 0, [1, 0, 2, 1, 0]);
    g(G, F);
    F.signerInfos = [];
    l(G, F)
  };
  var o = function (J, F) {
    var G = F.parse.signerInfos;
    var L = G.length;
    var K = true;
    for (var I = 0; I < L; I++) {
      var H = G[I];
      e(J, F, H, I);
      if (!H.isValid) {
        K = false
      }
    }
    F.isValid = K
  };
  var x = function (F, Q, J, P) {
    var N = Q.parse.certsIdx;
    var H;
    if (Q.certs === undefined) {
      H = [];
      Q.certkeys = [];
      var K = z(F, N);
      for (var I = 0; I < K.length; I++) {
        var M = c(F, K[I]);
        var O = new X509();
        O.readCertHex(M);
        H[I] = O;
        Q.certkeys[I] = O.getPublicKey()
      }
      Q.certs = H
    } else {
      H = Q.certs
    }
    Q.cccc = H.length;
    Q.cccci = K.length;
    for (var I = 0; I < H.length; I++) {
      var L = O.getIssuerHex();
      var G = O.getSerialNumberHex();
      if (J.signerid_issuer1 === L && J.signerid_serial1 === G) {
        J.certkey_idx = I
      }
    }
  };
  var e = function (F, R, I, N) {
    I.verifyDetail = {};
    var Q = I.verifyDetail;
    var K = R.parse.econtent;
    var G = I.hashalg;
    var L = I.saMessageDigest;
    Q.validMessageDigest = false;
    if (j(K, G) === L) {
      Q.validMessageDigest = true
    }
    x(F, R, I, N);
    Q.validSignatureValue = false;
    var H = I.sigalg;
    var M = "31" + c(F, I.idxSignedAttrs).substr(2);
    I.signedattrshex = M;
    var J = R.certs[I.certkey_idx].getPublicKey();
    var P = new KJUR.crypto.Signature({
      alg: H
    });
    P.init(J);
    P.updateHex(M);
    var O = P.verify(I.sigval);
    Q.validSignatureValue_isValid = O;
    if (O === true) {
      Q.validSignatureValue = true
    }
    I.isValid = false;
    if (Q.validMessageDigest && Q.validSignatureValue) {
      I.isValid = true
    }
  };
  var m = function () {};
  var r = {
    isValid: false,
    parse: {}
  };
  w(E, r.parse);
  o(E, r);
  return r
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
  KJUR.asn1 = {}
}
if (typeof KJUR.asn1.tsp == "undefined" || !KJUR.asn1.tsp) {
  KJUR.asn1.tsp = {}
}
KJUR.asn1.tsp.Accuracy = function (f) {
  var c = KJUR,
    b = c.asn1,
    e = b.DERInteger,
    a = b.DERSequence,
    d = b.DERTaggedObject;
  b.tsp.Accuracy.superclass.constructor.call(this);
  this.seconds = null;
  this.millis = null;
  this.micros = null;
  this.getEncodedHex = function () {
    var i = null;
    var k = null;
    var m = null;
    var g = [];
    if (this.seconds != null) {
      i = new e({
        "int": this.seconds
      });
      g.push(i)
    }
    if (this.millis != null) {
      var l = new e({
        "int": this.millis
      });
      k = new d({
        obj: l,
        tag: "80",
        explicit: false
      });
      g.push(k)
    }
    if (this.micros != null) {
      var j = new e({
        "int": this.micros
      });
      m = new d({
        obj: j,
        tag: "81",
        explicit: false
      });
      g.push(m)
    }
    var h = new a({
      array: g
    });
    this.hTLV = h.getEncodedHex();
    return this.hTLV
  };
  if (f !== undefined) {
    if (typeof f.seconds == "number") {
      this.seconds = f.seconds
    }
    if (typeof f.millis == "number") {
      this.millis = f.millis
    }
    if (typeof f.micros == "number") {
      this.micros = f.micros
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.Accuracy, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.MessageImprint = function (g) {
  var c = KJUR,
    b = c.asn1,
    a = b.DERSequence,
    d = b.DEROctetString,
    f = b.x509,
    e = f.AlgorithmIdentifier;
  b.tsp.MessageImprint.superclass.constructor.call(this);
  this.dHashAlg = null;
  this.dHashValue = null;
  this.getEncodedHex = function () {
    if (typeof this.hTLV == "string") {
      return this.hTLV
    }
    var h = new a({
      array: [this.dHashAlg, this.dHashValue]
    });
    return h.getEncodedHex()
  };
  if (g !== undefined) {
    if (typeof g.hashAlg == "string") {
      this.dHashAlg = new e({
        name: g.hashAlg
      })
    }
    if (typeof g.hashValue == "string") {
      this.dHashValue = new d({
        hex: g.hashValue
      })
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.MessageImprint, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.TimeStampReq = function (c) {
  var a = KJUR,
    f = a.asn1,
    d = f.DERSequence,
    e = f.DERInteger,
    g = f.DERBoolean,
    i = f.DERObjectIdentifier,
    h = f.tsp,
    b = h.MessageImprint;
  h.TimeStampReq.superclass.constructor.call(this);
  this.dVersion = new e({
    "int": 1
  });
  this.dMessageImprint = null;
  this.dPolicy = null;
  this.dNonce = null;
  this.certReq = true;
  this.setMessageImprint = function (j) {
    if (j instanceof b) {
      this.dMessageImprint = j;
      return
    }
    if (typeof j == "object") {
      this.dMessageImprint = new b(j)
    }
  };
  this.getEncodedHex = function () {
    if (this.dMessageImprint == null) {
      throw "messageImprint shall be specified"
    }
    var j = [this.dVersion, this.dMessageImprint];
    if (this.dPolicy != null) {
      j.push(this.dPolicy)
    }
    if (this.dNonce != null) {
      j.push(this.dNonce)
    }
    if (this.certReq) {
      j.push(new g())
    }
    var k = new d({
      array: j
    });
    this.hTLV = k.getEncodedHex();
    return this.hTLV
  };
  if (c !== undefined) {
    if (typeof c.mi == "object") {
      this.setMessageImprint(c.mi)
    }
    if (typeof c.policy == "object") {
      this.dPolicy = new i(c.policy)
    }
    if (typeof c.nonce == "object") {
      this.dNonce = new e(c.nonce)
    }
    if (typeof c.certreq == "boolean") {
      this.certReq = c.certreq
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.TimeStampReq, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.TSTInfo = function (e) {
  var c = KJUR,
    i = c.asn1,
    f = i.DERSequence,
    h = i.DERInteger,
    k = i.DERBoolean,
    g = i.DERGeneralizedTime,
    l = i.DERObjectIdentifier,
    j = i.tsp,
    d = j.MessageImprint,
    b = j.Accuracy,
    a = i.x509.X500Name;
  j.TSTInfo.superclass.constructor.call(this);
  this.dVersion = new h({
    "int": 1
  });
  this.dPolicy = null;
  this.dMessageImprint = null;
  this.dSerialNumber = null;
  this.dGenTime = null;
  this.dAccuracy = null;
  this.dOrdering = null;
  this.dNonce = null;
  this.dTsa = null;
  this.getEncodedHex = function () {
    var m = [this.dVersion];
    if (this.dPolicy == null) {
      throw "policy shall be specified."
    }
    m.push(this.dPolicy);
    if (this.dMessageImprint == null) {
      throw "messageImprint shall be specified."
    }
    m.push(this.dMessageImprint);
    if (this.dSerialNumber == null) {
      throw "serialNumber shall be specified."
    }
    m.push(this.dSerialNumber);
    if (this.dGenTime == null) {
      throw "genTime shall be specified."
    }
    m.push(this.dGenTime);
    if (this.dAccuracy != null) {
      m.push(this.dAccuracy)
    }
    if (this.dOrdering != null) {
      m.push(this.dOrdering)
    }
    if (this.dNonce != null) {
      m.push(this.dNonce)
    }
    if (this.dTsa != null) {
      m.push(this.dTsa)
    }
    var n = new f({
      array: m
    });
    this.hTLV = n.getEncodedHex();
    return this.hTLV
  };
  if (e !== undefined) {
    if (typeof e.policy == "string") {
      if (!e.policy.match(/^[0-9.]+$/)) {
        throw "policy shall be oid like 0.1.4.134"
      }
      this.dPolicy = new l({
        oid: e.policy
      })
    }
    if (e.messageImprint !== undefined) {
      this.dMessageImprint = new d(e.messageImprint)
    }
    if (e.serialNumber !== undefined) {
      this.dSerialNumber = new h(e.serialNumber)
    }
    if (e.genTime !== undefined) {
      this.dGenTime = new g(e.genTime)
    }
    if (e.accuracy !== undefined) {
      this.dAccuracy = new b(e.accuracy)
    }
    if (e.ordering !== undefined && e.ordering == true) {
      this.dOrdering = new k()
    }
    if (e.nonce !== undefined) {
      this.dNonce = new h(e.nonce)
    }
    if (e.tsa !== undefined) {
      this.dTsa = new a(e.tsa)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.TSTInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.TimeStampResp = function (g) {
  var e = KJUR,
    d = e.asn1,
    c = d.DERSequence,
    f = d.ASN1Object,
    a = d.tsp,
    b = a.PKIStatusInfo;
  a.TimeStampResp.superclass.constructor.call(this);
  this.dStatus = null;
  this.dTST = null;
  this.getEncodedHex = function () {
    if (this.dStatus == null) {
      throw "status shall be specified"
    }
    var h = [this.dStatus];
    if (this.dTST != null) {
      h.push(this.dTST)
    }
    var i = new c({
      array: h
    });
    this.hTLV = i.getEncodedHex();
    return this.hTLV
  };
  if (g !== undefined) {
    if (typeof g.status == "object") {
      this.dStatus = new b(g.status)
    }
    if (g.tst !== undefined && g.tst instanceof f) {
      this.dTST = g.tst.getContentInfo()
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.TimeStampResp, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIStatusInfo = function (h) {
  var g = KJUR,
    f = g.asn1,
    e = f.DERSequence,
    a = f.tsp,
    d = a.PKIStatus,
    c = a.PKIFreeText,
    b = a.PKIFailureInfo;
  a.PKIStatusInfo.superclass.constructor.call(this);
  this.dStatus = null;
  this.dStatusString = null;
  this.dFailureInfo = null;
  this.getEncodedHex = function () {
    if (this.dStatus == null) {
      throw "status shall be specified"
    }
    var i = [this.dStatus];
    if (this.dStatusString != null) {
      i.push(this.dStatusString)
    }
    if (this.dFailureInfo != null) {
      i.push(this.dFailureInfo)
    }
    var j = new e({
      array: i
    });
    this.hTLV = j.getEncodedHex();
    return this.hTLV
  };
  if (h !== undefined) {
    if (typeof h.status == "object") {
      this.dStatus = new d(h.status)
    }
    if (typeof h.statstr == "object") {
      this.dStatusString = new c({
        array: h.statstr
      })
    }
    if (typeof h.failinfo == "object") {
      this.dFailureInfo = new b(h.failinfo)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.PKIStatusInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIStatus = function (h) {
  var d = KJUR,
    c = d.asn1,
    g = c.DERInteger,
    a = c.tsp,
    b = a.PKIStatus;
  a.PKIStatus.superclass.constructor.call(this);
  var f = null;
  this.getEncodedHex = function () {
    this.hTLV = this.dStatus.getEncodedHex();
    return this.hTLV
  };
  if (h !== undefined) {
    if (h.name !== undefined) {
      var e = b.valueList;
      if (e[h.name] === undefined) {
        throw "name undefined: " + h.name
      }
      this.dStatus = new g({
        "int": e[h.name]
      })
    } else {
      this.dStatus = new g(h)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.PKIStatus, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIStatus.valueList = {
  granted: 0,
  grantedWithMods: 1,
  rejection: 2,
  waiting: 3,
  revocationWarning: 4,
  revocationNotification: 5
};
KJUR.asn1.tsp.PKIFreeText = function (f) {
  var e = KJUR,
    d = e.asn1,
    b = d.DERSequence,
    c = d.DERUTF8String,
    a = d.tsp;
  a.PKIFreeText.superclass.constructor.call(this);
  this.textList = [];
  this.getEncodedHex = function () {
    var g = [];
    for (var j = 0; j < this.textList.length; j++) {
      g.push(new c({
        str: this.textList[j]
      }))
    }
    var h = new b({
      array: g
    });
    this.hTLV = h.getEncodedHex();
    return this.hTLV
  };
  if (f !== undefined) {
    if (typeof f.array == "object") {
      this.textList = f.array
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.PKIFreeText, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIFailureInfo = function (g) {
  var d = KJUR,
    c = d.asn1,
    f = c.DERBitString,
    a = c.tsp,
    b = a.PKIFailureInfo;
  b.superclass.constructor.call(this);
  this.value = null;
  this.getEncodedHex = function () {
    if (this.value == null) {
      throw "value shall be specified"
    }
    var h = new Number(this.value).toString(2);
    var i = new f();
    i.setByBinaryString(h);
    this.hTLV = i.getEncodedHex();
    return this.hTLV
  };
  if (g !== undefined) {
    if (typeof g.name == "string") {
      var e = b.valueList;
      if (e[g.name] === undefined) {
        throw "name undefined: " + g.name
      }
      this.value = e[g.name]
    } else {
      if (typeof g["int"] == "number") {
        this.value = g["int"]
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.PKIFailureInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.tsp.PKIFailureInfo.valueList = {
  badAlg: 0,
  badRequest: 2,
  badDataFormat: 5,
  timeNotAvailable: 14,
  unacceptedPolicy: 15,
  unacceptedExtension: 16,
  addInfoNotAvailable: 17,
  systemFailure: 25
};
KJUR.asn1.tsp.AbstractTSAAdapter = function (a) {
  this.getTSTHex = function (c, b) {
    throw "not implemented yet"
  }
};
KJUR.asn1.tsp.SimpleTSAAdapter = function (e) {
  var d = KJUR,
    c = d.asn1,
    a = c.tsp,
    b = d.crypto.Util.hashHex;
  a.SimpleTSAAdapter.superclass.constructor.call(this);
  this.params = null;
  this.serial = 0;
  this.getTSTHex = function (g, f) {
    var i = b(g, f);
    this.params.tstInfo.messageImprint = {
      hashAlg: f,
      hashValue: i
    };
    this.params.tstInfo.serialNumber = {
      "int": this.serial++
    };
    var h = Math.floor(Math.random() * 1000000000);
    this.params.tstInfo.nonce = {
      "int": h
    };
    var j = a.TSPUtil.newTimeStampToken(this.params);
    return j.getContentInfoEncodedHex()
  };
  if (e !== undefined) {
    this.params = e
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.SimpleTSAAdapter, KJUR.asn1.tsp.AbstractTSAAdapter);
KJUR.asn1.tsp.FixedTSAAdapter = function (e) {
  var d = KJUR,
    c = d.asn1,
    a = c.tsp,
    b = d.crypto.Util.hashHex;
  a.FixedTSAAdapter.superclass.constructor.call(this);
  this.params = null;
  this.getTSTHex = function (g, f) {
    var h = b(g, f);
    this.params.tstInfo.messageImprint = {
      hashAlg: f,
      hashValue: h
    };
    var i = a.TSPUtil.newTimeStampToken(this.params);
    return i.getContentInfoEncodedHex()
  };
  if (e !== undefined) {
    this.params = e
  }
};
YAHOO.lang.extend(KJUR.asn1.tsp.FixedTSAAdapter, KJUR.asn1.tsp.AbstractTSAAdapter);
KJUR.asn1.tsp.TSPUtil = new function () {};
KJUR.asn1.tsp.TSPUtil.newTimeStampToken = function (c) {
  var b = KJUR,
    h = b.asn1,
    m = h.cms,
    k = h.tsp,
    a = h.tsp.TSTInfo;
  var j = new m.SignedData();
  var g = new a(c.tstInfo);
  var f = g.getEncodedHex();
  j.dEncapContentInfo.setContentValue({
    hex: f
  });
  j.dEncapContentInfo.setContentType("tstinfo");
  if (typeof c.certs == "object") {
    for (var e = 0; e < c.certs.length; e++) {
      j.addCertificatesByPEM(c.certs[e])
    }
  }
  var d = j.signerInfoList[0];
  d.setSignerIdentifier(c.signerCert);
  d.setForContentAndHash({
    sdObj: j,
    eciObj: j.dEncapContentInfo,
    hashAlg: c.hashAlg
  });
  var l = new m.SigningCertificate({
    array: [c.signerCert]
  });
  d.dSignedAttrs.add(l);
  d.sign(c.signerPrvKey, c.sigAlg);
  return j
};
KJUR.asn1.tsp.TSPUtil.parseTimeStampReq = function (m) {
  var l = ASN1HEX;
  var h = l.getChildIdx;
  var f = l.getV;
  var b = l.getTLV;
  var j = {};
  j.certreq = false;
  var a = h(m, 0);
  if (a.length < 2) {
    throw "TimeStampReq must have at least 2 items"
  }
  var e = b(m, a[1]);
  j.mi = KJUR.asn1.tsp.TSPUtil.parseMessageImprint(e);
  for (var d = 2; d < a.length; d++) {
    var g = a[d];
    var k = m.substr(g, 2);
    if (k == "06") {
      var c = f(m, g);
      j.policy = l.hextooidstr(c)
    }
    if (k == "02") {
      j.nonce = f(m, g)
    }
    if (k == "01") {
      j.certreq = true
    }
  }
  return j
};
KJUR.asn1.tsp.TSPUtil.parseMessageImprint = function (c) {
  var m = ASN1HEX;
  var j = m.getChildIdx;
  var i = m.getV;
  var g = m.getIdxbyList;
  var k = {};
  if (c.substr(0, 2) != "30") {
    throw "head of messageImprint hex shall be '30'"
  }
  var a = j(c, 0);
  var l = g(c, 0, [0, 0]);
  var e = i(c, l);
  var d = m.hextooidstr(e);
  var h = KJUR.asn1.x509.OID.oid2name(d);
  if (h == "") {
    throw "hashAlg name undefined: " + d
  }
  var b = h;
  var f = g(c, 0, [1]);
  k.hashAlg = b;
  k.hashValue = i(c, f);
  return k
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
  KJUR.asn1 = {}
}
if (typeof KJUR.asn1.cades == "undefined" || !KJUR.asn1.cades) {
  KJUR.asn1.cades = {}
}
KJUR.asn1.cades.SignaturePolicyIdentifier = function (f) {
  var b = KJUR,
    h = b.asn1,
    i = h.DERObjectIdentifier,
    g = h.DERSequence,
    e = h.cades,
    c = e.OtherHashAlgAndValue;
  e.SignaturePolicyIdentifier.superclass.constructor.call(this);
  this.attrTypeOid = "1.2.840.113549.1.9.16.2.15";
  if (f !== undefined) {
    if (typeof f.oid == "string" && typeof f.hash == "object") {
      var d = new i({
        oid: f.oid
      });
      var a = new c(f.hash);
      var j = new g({
        array: [d, a]
      });
      this.valueList = [j]
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cades.SignaturePolicyIdentifier, KJUR.asn1.cms.Attribute);
KJUR.asn1.cades.OtherHashAlgAndValue = function (e) {
  var a = KJUR,
    g = a.asn1,
    f = g.DERSequence,
    h = g.DEROctetString,
    d = g.x509,
    i = d.AlgorithmIdentifier,
    c = g.cades,
    b = c.OtherHashAlgAndValue;
  b.superclass.constructor.call(this);
  this.dAlg = null;
  this.dHash = null;
  this.getEncodedHex = function () {
    var j = new f({
      array: [this.dAlg, this.dHash]
    });
    this.hTLV = j.getEncodedHex();
    return this.hTLV
  };
  if (e !== undefined) {
    if (typeof e.alg == "string" && typeof e.hash == "string") {
      this.dAlg = new i({
        name: e.alg
      });
      this.dHash = new h({
        hex: e.hash
      })
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cades.OtherHashAlgAndValue, KJUR.asn1.ASN1Object);
KJUR.asn1.cades.SignatureTimeStamp = function (h) {
  var c = KJUR,
    b = c.asn1,
    e = b.ASN1Object,
    g = b.x509,
    a = b.cades;
  a.SignatureTimeStamp.superclass.constructor.call(this);
  this.attrTypeOid = "1.2.840.113549.1.9.16.2.14";
  this.tstHex = null;
  if (h !== undefined) {
    if (h.res !== undefined) {
      if (typeof h.res == "string" && h.res.match(/^[0-9A-Fa-f]+$/)) {} else {
        if (h.res instanceof e) {} else {
          throw "res param shall be ASN1Object or hex string"
        }
      }
    }
    if (h.tst !== undefined) {
      if (typeof h.tst == "string" && h.tst.match(/^[0-9A-Fa-f]+$/)) {
        var f = new e();
        this.tstHex = h.tst;
        f.hTLV = this.tstHex;
        f.getEncodedHex();
        this.valueList = [f]
      } else {
        if (h.tst instanceof e) {} else {
          throw "tst param shall be ASN1Object or hex string"
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cades.SignatureTimeStamp, KJUR.asn1.cms.Attribute);
KJUR.asn1.cades.CompleteCertificateRefs = function (d) {
  var c = KJUR,
    b = c.asn1,
    a = b.cades;
  a.CompleteCertificateRefs.superclass.constructor.call(this);
  this.attrTypeOid = "1.2.840.113549.1.9.16.2.21";
  this.setByArray = function (e) {
    this.valueList = [];
    for (var f = 0; f < e.length; f++) {
      var g = new a.OtherCertID(e[f]);
      this.valueList.push(g)
    }
  };
  if (d !== undefined) {
    if (typeof d == "object" && typeof d.length == "number") {
      this.setByArray(d)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cades.CompleteCertificateRefs, KJUR.asn1.cms.Attribute);
KJUR.asn1.cades.OtherCertID = function (e) {
  var c = KJUR,
    b = c.asn1,
    d = b.cms,
    a = b.cades;
  a.OtherCertID.superclass.constructor.call(this);
  this.hasIssuerSerial = true;
  this.dOtherCertHash = null;
  this.dIssuerSerial = null;
  this.setByCertPEM = function (f) {
    this.dOtherCertHash = new a.OtherHash(f);
    if (this.hasIssuerSerial) {
      this.dIssuerSerial = new d.IssuerAndSerialNumber(f)
    }
  };
  this.getEncodedHex = function () {
    if (this.hTLV != null) {
      return this.hTLV
    }
    if (this.dOtherCertHash == null) {
      throw "otherCertHash not set"
    }
    var f = [this.dOtherCertHash];
    if (this.dIssuerSerial != null) {
      f.push(this.dIssuerSerial)
    }
    var g = new b.DERSequence({
      array: f
    });
    this.hTLV = g.getEncodedHex();
    return this.hTLV
  };
  if (e !== undefined) {
    if (typeof e == "string" && e.indexOf("-----BEGIN ") != -1) {
      this.setByCertPEM(e)
    }
    if (typeof e == "object") {
      if (e.hasis === false) {
        this.hasIssuerSerial = false
      }
      if (typeof e.cert == "string") {
        this.setByCertPEM(e.cert)
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cades.OtherCertID, KJUR.asn1.ASN1Object);
KJUR.asn1.cades.OtherHash = function (f) {
  var d = KJUR,
    c = d.asn1,
    e = c.cms,
    b = c.cades,
    g = b.OtherHashAlgAndValue,
    a = d.crypto.Util.hashHex;
  b.OtherHash.superclass.constructor.call(this);
  this.alg = "sha256";
  this.dOtherHash = null;
  this.setByCertPEM = function (h) {
    if (h.indexOf("-----BEGIN ") == -1) {
      throw "certPEM not to seem PEM format"
    }
    var i = pemtohex(h);
    var j = a(i, this.alg);
    this.dOtherHash = new g({
      alg: this.alg,
      hash: j
    })
  };
  this.getEncodedHex = function () {
    if (this.dOtherHash == null) {
      throw "OtherHash not set"
    }
    return this.dOtherHash.getEncodedHex()
  };
  if (f !== undefined) {
    if (typeof f == "string") {
      if (f.indexOf("-----BEGIN ") != -1) {
        this.setByCertPEM(f)
      } else {
        if (f.match(/^[0-9A-Fa-f]+$/)) {
          this.dOtherHash = new c.DEROctetString({
            hex: f
          })
        } else {
          throw "unsupported string value for params"
        }
      }
    } else {
      if (typeof f == "object") {
        if (typeof f.cert == "string") {
          if (typeof f.alg == "string") {
            this.alg = f.alg
          }
          this.setByCertPEM(f.cert)
        } else {
          this.dOtherHash = new g(f)
        }
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.cades.OtherHash, KJUR.asn1.ASN1Object);
KJUR.asn1.cades.CAdESUtil = new function () {};
KJUR.asn1.cades.CAdESUtil.addSigTS = function (c, b, a) {};
KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned = function (f) {
  var q = ASN1HEX,
    w = q.getChildIdx,
    b = q.getTLV,
    a = q.getTLVbyList,
    s = q.getTLVbyListEx,
    l = q.getIdxbyList,
    e = q.getIdxbyListEx,
    D = KJUR,
    h = D.asn1,
    m = h.ASN1Object,
    k = h.cms,
    j = k.SignedData,
    x = h.cades,
    B = x.CAdESUtil;
  var n = {};
  if (a(f, 0, [0]) != "06092a864886f70d010702") {
    throw "hex is not CMS SignedData"
  }
  var A = l(f, 0, [1, 0]);
  var C = w(f, A);
  if (C.length < 4) {
    throw "num of SignedData elem shall be 4 at least"
  }
  var d = C.shift();
  n.version = b(f, d);
  var y = C.shift();
  n.algs = b(f, y);
  var c = C.shift();
  n.encapcontent = b(f, c);
  n.certs = null;
  n.revs = null;
  n.si = [];
  var p = C.shift();
  if (f.substr(p, 2) == "a0") {
    n.certs = b(f, p);
    p = C.shift()
  }
  if (f.substr(p, 2) == "a1") {
    n.revs = b(f, p);
    p = C.shift()
  }
  var v = p;
  if (f.substr(v, 2) != "31") {
    throw "Can't find signerInfos"
  }
  var g = w(f, v);
  for (var t = 0; t < g.length; t++) {
    var u = g[t];
    var o = B.parseSignerInfoForAddingUnsigned(f, u, t);
    n.si[t] = o
  }
  var z = null;
  n.obj = new j();
  z = new m();
  z.hTLV = n.version;
  n.obj.dCMSVersion = z;
  z = new m();
  z.hTLV = n.algs;
  n.obj.dDigestAlgs = z;
  z = new m();
  z.hTLV = n.encapcontent;
  n.obj.dEncapContentInfo = z;
  z = new m();
  z.hTLV = n.certs;
  n.obj.dCerts = z;
  n.obj.signerInfoList = [];
  for (var t = 0; t < n.si.length; t++) {
    n.obj.signerInfoList.push(n.si[t].obj)
  }
  return n
};
KJUR.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned = function (g, q, c) {
  var p = ASN1HEX,
    s = p.getChildIdx,
    a = p.getTLV,
    l = p.getV,
    v = KJUR,
    h = v.asn1,
    n = h.ASN1Object,
    j = h.cms,
    k = j.AttributeList,
    w = j.SignerInfo;
  var o = {};
  var t = s(g, q);
  if (t.length != 6) {
    throw "not supported items for SignerInfo (!=6)"
  }
  var d = t.shift();
  o.version = a(g, d);
  var e = t.shift();
  o.si = a(g, e);
  var m = t.shift();
  o.digalg = a(g, m);
  var f = t.shift();
  o.sattrs = a(g, f);
  var i = t.shift();
  o.sigalg = a(g, i);
  var b = t.shift();
  o.sig = a(g, b);
  o.sigval = l(g, b);
  var u = null;
  o.obj = new w();
  u = new n();
  u.hTLV = o.version;
  o.obj.dCMSVersion = u;
  u = new n();
  u.hTLV = o.si;
  o.obj.dSignerIdentifier = u;
  u = new n();
  u.hTLV = o.digalg;
  o.obj.dDigestAlgorithm = u;
  u = new n();
  u.hTLV = o.sattrs;
  o.obj.dSignedAttrs = u;
  u = new n();
  u.hTLV = o.sigalg;
  o.obj.dSigAlg = u;
  u = new n();
  u.hTLV = o.sig;
  o.obj.dSig = u;
  o.obj.dUnsignedAttrs = new k();
  return o
};
if (typeof KJUR.asn1.csr == "undefined" || !KJUR.asn1.csr) {
  KJUR.asn1.csr = {}
}
KJUR.asn1.csr.CertificationRequest = function (d) {
  var a = KJUR,
    f = a.asn1,
    b = f.DERBitString,
    e = f.DERSequence,
    k = f.csr,
    c = f.x509;
  k.CertificationRequest.superclass.constructor.call(this);
  var l = null;
  var j = null;
  var h = null;
  var i = null;
  var g = null;
  this.sign = function (p, n) {
    if (this.prvKey == null) {
      this.prvKey = n
    }
    this.asn1SignatureAlg = new c.AlgorithmIdentifier({
      name: p
    });
    var o = new a.crypto.Signature({
      alg: p
    });
    o.init(this.prvKey);
    o.updateHex(this.asn1CSRInfo.getEncodedHex());
    this.hexSig = o.sign();
    this.asn1Sig = new b({
      hex: "00" + this.hexSig
    });
    var m = new e({
      array: [this.asn1CSRInfo, this.asn1SignatureAlg, this.asn1Sig]
    });
    this.hTLV = m.getEncodedHex();
    this.isModified = false
  };
  this.getPEMString = function () {
    return hextopem(this.getEncodedHex(), "CERTIFICATE REQUEST")
  };
  this.getEncodedHex = function () {
    if (this.isModified == false && this.hTLV != null) {
      return this.hTLV
    }
    throw "not signed yet"
  };
  if (d !== undefined && d.csrinfo !== undefined) {
    this.asn1CSRInfo = d.csrinfo
  }
};
YAHOO.lang.extend(KJUR.asn1.csr.CertificationRequest, KJUR.asn1.ASN1Object);
KJUR.asn1.csr.CertificationRequestInfo = function (e) {
  var b = KJUR,
    h = b.asn1,
    g = h.DERInteger,
    f = h.DERSequence,
    m = h.DERSet,
    j = h.DERNull,
    c = h.DERTaggedObject,
    k = h.DERObjectIdentifier,
    l = h.csr,
    d = h.x509,
    a = d.X500Name,
    n = d.Extension,
    i = KEYUTIL;
  l.CertificationRequestInfo.superclass.constructor.call(this);
  this._initialize = function () {
    this.asn1Array = new Array();
    this.asn1Version = new g({
      "int": 0
    });
    this.asn1Subject = null;
    this.asn1SubjPKey = null;
    this.extensionsArray = new Array()
  };
  this.setSubjectByParam = function (o) {
    this.asn1Subject = new a(o)
  };
  this.setSubjectPublicKeyByGetKey = function (p) {
    var o = i.getKey(p);
    this.asn1SubjPKey = new d.SubjectPublicKeyInfo(o)
  };
  this.appendExtensionByName = function (p, o) {
    n.appendByNameToArray(p, o, this.extensionsArray)
  };
  this.getEncodedHex = function () {
    this.asn1Array = new Array();
    this.asn1Array.push(this.asn1Version);
    this.asn1Array.push(this.asn1Subject);
    this.asn1Array.push(this.asn1SubjPKey);
    if (this.extensionsArray.length > 0) {
      var s = new f({
        array: this.extensionsArray
      });
      var r = new m({
        array: [s]
      });
      var q = new f({
        array: [new k({
          oid: "1.2.840.113549.1.9.14"
        }), r]
      });
      var p = new c({
        explicit: true,
        tag: "a0",
        obj: q
      });
      this.asn1Array.push(p)
    } else {
      var p = new c({
        explicit: false,
        tag: "a0",
        obj: new j()
      });
      this.asn1Array.push(p)
    }
    var t = new f({
      array: this.asn1Array
    });
    this.hTLV = t.getEncodedHex();
    this.isModified = false;
    return this.hTLV
  };
  this._initialize()
};
YAHOO.lang.extend(KJUR.asn1.csr.CertificationRequestInfo, KJUR.asn1.ASN1Object);
KJUR.asn1.csr.CSRUtil = new function () {};
KJUR.asn1.csr.CSRUtil.newCSRPEM = function (h) {
  var c = KEYUTIL,
    b = KJUR.asn1.csr;
  if (h.subject === undefined) {
    throw "parameter subject undefined"
  }
  if (h.sbjpubkey === undefined) {
    throw "parameter sbjpubkey undefined"
  }
  if (h.sigalg === undefined) {
    throw "parameter sigalg undefined"
  }
  if (h.sbjprvkey === undefined) {
    throw "parameter sbjpubkey undefined"
  }
  var d = new b.CertificationRequestInfo();
  d.setSubjectByParam(h.subject);
  d.setSubjectPublicKeyByGetKey(h.sbjpubkey);
  if (h.ext !== undefined && h.ext.length !== undefined) {
    for (var e = 0; e < h.ext.length; e++) {
      for (key in h.ext[e]) {
        d.appendExtensionByName(key, h.ext[e][key])
      }
    }
  }
  var f = new b.CertificationRequest({
    csrinfo: d
  });
  var a = c.getKey(h.sbjprvkey);
  f.sign(h.sigalg, a);
  var g = f.getPEMString();
  return g
};
KJUR.asn1.csr.CSRUtil.getInfo = function (c) {
  var f = ASN1HEX;
  var g = f.getTLVbyListEx;
  var b = {};
  b.subject = {};
  b.pubkey = {};
  if (c.indexOf("-----BEGIN CERTIFICATE REQUEST") == -1) {
    throw "argument is not PEM file"
  }
  var e = pemtohex(c, "CERTIFICATE REQUEST");
  try {
    b.subject.hex = g(e, 0, [0, 1])
  } catch (d) {}
  try {
    b.subject.name = X509.hex2dn(b.subject.hex)
  } catch (d) {}
  b.pubkey.hex = g(e, 0, [0, 2]);
  b.pubkey.obj = KEYUTIL.getKey(b.pubkey.hex, null, "pkcs8pub");
  try {
    b.ext = [];
    var a = new X509();
    a.parseExt(c);
    b.ext.push({
      subjectAltName: {
        array: a.getExtSubjectAltName2()
      }
    })
  } catch (d) {}
  return b
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) {
  KJUR.asn1 = {}
}
if (typeof KJUR.asn1.ocsp == "undefined" || !KJUR.asn1.ocsp) {
  KJUR.asn1.ocsp = {}
}
KJUR.asn1.ocsp.DEFAULT_HASH = "sha1";
KJUR.asn1.ocsp.CertID = function (g) {
  var d = KJUR,
    k = d.asn1,
    m = k.DEROctetString,
    j = k.DERInteger,
    h = k.DERSequence,
    f = k.x509,
    n = f.AlgorithmIdentifier,
    o = k.ocsp,
    l = o.DEFAULT_HASH,
    i = d.crypto,
    e = i.Util.hashHex,
    c = X509,
    q = ASN1HEX;
  o.CertID.superclass.constructor.call(this);
  this.dHashAlg = null;
  this.dIssuerNameHash = null;
  this.dIssuerKeyHash = null;
  this.dSerialNumber = null;
  this.setByValue = function (t, s, p, r) {
    if (r === undefined) {
      r = l
    }
    this.dHashAlg = new n({
      name: r
    });
    this.dIssuerNameHash = new m({
      hex: t
    });
    this.dIssuerKeyHash = new m({
      hex: s
    });
    this.dSerialNumber = new j({
      hex: p
    })
  };
  this.setByCert = function (x, t, v) {
    if (v === undefined) {
      v = l
    }
    var p = new c();
    p.readCertPEM(t);
    var y = new c();
    y.readCertPEM(x);
    var z = y.getPublicKeyHex();
    var w = q.getTLVbyList(z, 0, [1, 0], "30");
    var r = p.getSerialNumberHex();
    var s = e(y.getSubjectHex(), v);
    var u = e(w, v);
    this.setByValue(s, u, r, v);
    this.hoge = p.getSerialNumberHex()
  };
  this.getEncodedHex = function () {
    if (this.dHashAlg === null && this.dIssuerNameHash === null && this.dIssuerKeyHash === null && this.dSerialNumber === null) {
      throw "not yet set values"
    }
    var p = [this.dHashAlg, this.dIssuerNameHash, this.dIssuerKeyHash, this.dSerialNumber];
    var r = new h({
      array: p
    });
    this.hTLV = r.getEncodedHex();
    return this.hTLV
  };
  if (g !== undefined) {
    var b = g;
    if (b.issuerCert !== undefined && b.subjectCert !== undefined) {
      var a = l;
      if (b.alg === undefined) {
        a = undefined
      }
      this.setByCert(b.issuerCert, b.subjectCert, a)
    } else {
      if (b.namehash !== undefined && b.keyhash !== undefined && b.serial !== undefined) {
        var a = l;
        if (b.alg === undefined) {
          a = undefined
        }
        this.setByValue(b.namehash, b.keyhash, b.serial, a)
      } else {
        throw "invalid constructor arguments"
      }
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.ocsp.CertID, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.Request = function (f) {
  var c = KJUR,
    b = c.asn1,
    a = b.DERSequence,
    d = b.ocsp;
  d.Request.superclass.constructor.call(this);
  this.dReqCert = null;
  this.dExt = null;
  this.getEncodedHex = function () {
    var g = [];
    if (this.dReqCert === null) {
      throw "reqCert not set"
    }
    g.push(this.dReqCert);
    var h = new a({
      array: g
    });
    this.hTLV = h.getEncodedHex();
    return this.hTLV
  };
  if (typeof f !== "undefined") {
    var e = new d.CertID(f);
    this.dReqCert = e
  }
};
YAHOO.lang.extend(KJUR.asn1.ocsp.Request, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.TBSRequest = function (e) {
  var c = KJUR,
    b = c.asn1,
    a = b.DERSequence,
    d = b.ocsp;
  d.TBSRequest.superclass.constructor.call(this);
  this.version = 0;
  this.dRequestorName = null;
  this.dRequestList = [];
  this.dRequestExt = null;
  this.setRequestListByParam = function (h) {
    var f = [];
    for (var g = 0; g < h.length; g++) {
      var j = new d.Request(h[0]);
      f.push(j)
    }
    this.dRequestList = f
  };
  this.getEncodedHex = function () {
    var f = [];
    if (this.version !== 0) {
      throw "not supported version: " + this.version
    }
    if (this.dRequestorName !== null) {
      throw "requestorName not supported"
    }
    var h = new a({
      array: this.dRequestList
    });
    f.push(h);
    if (this.dRequestExt !== null) {
      throw "requestExtensions not supported"
    }
    var g = new a({
      array: f
    });
    this.hTLV = g.getEncodedHex();
    return this.hTLV
  };
  if (e !== undefined) {
    if (e.reqList !== undefined) {
      this.setRequestListByParam(e.reqList)
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.ocsp.TBSRequest, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.OCSPRequest = function (f) {
  var c = KJUR,
    b = c.asn1,
    a = b.DERSequence,
    d = b.ocsp;
  d.OCSPRequest.superclass.constructor.call(this);
  this.dTbsRequest = null;
  this.dOptionalSignature = null;
  this.getEncodedHex = function () {
    var g = [];
    if (this.dTbsRequest !== null) {
      g.push(this.dTbsRequest)
    } else {
      throw "tbsRequest not set"
    }
    if (this.dOptionalSignature !== null) {
      throw "optionalSignature not supported"
    }
    var h = new a({
      array: g
    });
    this.hTLV = h.getEncodedHex();
    return this.hTLV
  };
  if (f !== undefined) {
    if (f.reqList !== undefined) {
      var e = new d.TBSRequest(f);
      this.dTbsRequest = e
    }
  }
};
YAHOO.lang.extend(KJUR.asn1.ocsp.OCSPRequest, KJUR.asn1.ASN1Object);
KJUR.asn1.ocsp.OCSPUtil = {};
KJUR.asn1.ocsp.OCSPUtil.getRequestHex = function (a, b, h) {
  var d = KJUR,
    c = d.asn1,
    e = c.ocsp;
  if (h === undefined) {
    h = e.DEFAULT_HASH
  }
  var g = {
    alg: h,
    issuerCert: a,
    subjectCert: b
  };
  var f = new e.OCSPRequest({
    reqList: [g]
  });
  return f.getEncodedHex()
};
KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo = function (b) {
  var m = ASN1HEX,
    c = m.getVbyList,
    k = m.getVbyListEx,
    e = m.getIdxbyList,
    d = m.getIdxbyListEx,
    g = m.getV;
  var n = {};
  try {
    var j = k(b, 0, [0], "0a");
    n.responseStatus = parseInt(j, 16)
  } catch (f) {}
  if (n.responseStatus !== 0) {
    return n
  }
  try {
    var i = e(b, 0, [1, 0, 1, 0, 0, 2, 0, 1]);
    if (b.substr(i, 2) === "80") {
      n.certStatus = "good"
    } else {
      if (b.substr(i, 2) === "a1") {
        n.certStatus = "revoked";
        n.revocationTime = hextoutf8(c(b, i, [0]))
      } else {
        if (b.substr(i, 2) === "82") {
          n.certStatus = "unknown"
        }
      }
    }
  } catch (f) {}
  try {
    var a = e(b, 0, [1, 0, 1, 0, 0, 2, 0, 2]);
    n.thisUpdate = hextoutf8(g(b, a))
  } catch (f) {}
  try {
    var l = e(b, 0, [1, 0, 1, 0, 0, 2, 0, 3]);
    if (b.substr(l, 2) === "a0") {
      n.nextUpdate = hextoutf8(c(b, l, [0]))
    }
  } catch (f) {}
  return n
};
var KJUR;
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.lang == "undefined" || !KJUR.lang) {
  KJUR.lang = {}
}
KJUR.lang.String = function () {};

function Base64x() {}

function stoBA(d) {
  var b = new Array();
  for (var c = 0; c < d.length; c++) {
    b[c] = d.charCodeAt(c)
  }
  return b
}

function BAtos(b) {
  var d = "";
  for (var c = 0; c < b.length; c++) {
    d = d + String.fromCharCode(b[c])
  }
  return d
}

function BAtohex(b) {
  var e = "";
  for (var d = 0; d < b.length; d++) {
    var c = b[d].toString(16);
    if (c.length == 1) {
      c = "0" + c
    }
    e = e + c
  }
  return e
}

function stohex(a) {
  return BAtohex(stoBA(a))
}

function stob64(a) {
  return hex2b64(stohex(a))
}

function stob64u(a) {
  return b64tob64u(hex2b64(stohex(a)))
}

function b64utos(a) {
  return BAtos(b64toBA(b64utob64(a)))
}

function b64tob64u(a) {
  a = a.replace(/\=/g, "");
  a = a.replace(/\+/g, "-");
  a = a.replace(/\//g, "_");
  return a
}

function b64utob64(a) {
  if (a.length % 4 == 2) {
    a = a + "=="
  } else {
    if (a.length % 4 == 3) {
      a = a + "="
    }
  }
  a = a.replace(/-/g, "+");
  a = a.replace(/_/g, "/");
  return a
}

function hextob64u(a) {
  if (a.length % 2 == 1) {
    a = "0" + a
  }
  return b64tob64u(hex2b64(a))
}

function b64utohex(a) {
  return b64tohex(b64utob64(a))
}
var utf8tob64u, b64utoutf8;
if (typeof Buffer === "function") {
  utf8tob64u = function (a) {
    return b64tob64u(new Buffer(a, "utf8").toString("base64"))
  };
  b64utoutf8 = function (a) {
    return new Buffer(b64utob64(a), "base64").toString("utf8")
  }
} else {
  utf8tob64u = function (a) {
    return hextob64u(uricmptohex(encodeURIComponentAll(a)))
  };
  b64utoutf8 = function (a) {
    return decodeURIComponent(hextouricmp(b64utohex(a)))
  }
}

function utf8tob64(a) {
  return hex2b64(uricmptohex(encodeURIComponentAll(a)))
}

function b64toutf8(a) {
  return decodeURIComponent(hextouricmp(b64tohex(a)))
}

function utf8tohex(a) {
  return uricmptohex(encodeURIComponentAll(a))
}

function hextoutf8(a) {
  return decodeURIComponent(hextouricmp(a))
}

function hextorstr(c) {
  var b = "";
  for (var a = 0; a < c.length - 1; a += 2) {
    b += String.fromCharCode(parseInt(c.substr(a, 2), 16))
  }
  return b
}

function rstrtohex(c) {
  var a = "";
  for (var b = 0; b < c.length; b++) {
    a += ("0" + c.charCodeAt(b).toString(16)).slice(-2)
  }
  return a
}

function hextob64(a) {
  return hex2b64(a)
}

function hextob64nl(b) {
  var a = hextob64(b);
  var c = a.replace(/(.{64})/g, "$1\r\n");
  c = c.replace(/\r\n$/, "");
  return c
}

function b64nltohex(b) {
  var a = b.replace(/[^0-9A-Za-z\/+=]*/g, "");
  var c = b64tohex(a);
  return c
}

function hextopem(a, b) {
  var c = hextob64nl(a);
  return "-----BEGIN " + b + "-----\r\n" + c + "\r\n-----END " + b + "-----\r\n"
}

function pemtohex(a, b) {
  if (a.indexOf("-----BEGIN ") == -1) {
    throw "can't find PEM header: " + b
  }
  if (b !== undefined) {
    a = a.replace(new RegExp("^[^]*-----BEGIN " + b + "-----"), "");
    a = a.replace(new RegExp("-----END " + b + "-----[^]*$"), "")
  } else {
    a = a.replace(/^[^]*-----BEGIN [^-]+-----/, "");
    a = a.replace(/-----END [^-]+-----[^]*$/, "")
  }
  return b64nltohex(a)
}

function hextoArrayBuffer(d) {
  if (d.length % 2 != 0) {
    throw "input is not even length"
  }
  if (d.match(/^[0-9A-Fa-f]+$/) == null) {
    throw "input is not hexadecimal"
  }
  var b = new ArrayBuffer(d.length / 2);
  var a = new DataView(b);
  for (var c = 0; c < d.length / 2; c++) {
    a.setUint8(c, parseInt(d.substr(c * 2, 2), 16))
  }
  return b
}

function ArrayBuffertohex(b) {
  var d = "";
  var a = new DataView(b);
  for (var c = 0; c < b.byteLength; c++) {
    d += ("00" + a.getUint8(c).toString(16)).slice(-2)
  }
  return d
}

function zulutomsec(n) {
  var l, j, m, e, f, i, b, k;
  var a, h, g, c;
  c = n.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/);
  if (c) {
    a = c[1];
    l = parseInt(a);
    if (a.length === 2) {
      if (50 <= l && l < 100) {
        l = 1900 + l
      } else {
        if (0 <= l && l < 50) {
          l = 2000 + l
        }
      }
    }
    j = parseInt(c[2]) - 1;
    m = parseInt(c[3]);
    e = parseInt(c[4]);
    f = parseInt(c[5]);
    i = parseInt(c[6]);
    b = 0;
    h = c[7];
    if (h !== "") {
      g = (h.substr(1) + "00").substr(0, 3);
      b = parseInt(g)
    }
    return Date.UTC(l, j, m, e, f, i, b)
  }
  throw "unsupported zulu format: " + n
}

function zulutosec(a) {
  var b = zulutomsec(a);
  return ~~(b / 1000)
}

function zulutodate(a) {
  return new Date(zulutomsec(a))
}

function datetozulu(g, e, f) {
  var b;
  var a = g.getUTCFullYear();
  if (e) {
    if (a < 1950 || 2049 < a) {
      throw "not proper year for UTCTime: " + a
    }
    b = ("" + a).slice(-2)
  } else {
    b = ("000" + a).slice(-4)
  }
  b += ("0" + (g.getUTCMonth() + 1)).slice(-2);
  b += ("0" + g.getUTCDate()).slice(-2);
  b += ("0" + g.getUTCHours()).slice(-2);
  b += ("0" + g.getUTCMinutes()).slice(-2);
  b += ("0" + g.getUTCSeconds()).slice(-2);
  if (f) {
    var c = g.getUTCMilliseconds();
    if (c !== 0) {
      c = ("00" + c).slice(-3);
      c = c.replace(/0+$/g, "");
      b += "." + c
    }
  }
  b += "Z";
  return b
}

function uricmptohex(a) {
  return a.replace(/%/g, "")
}

function hextouricmp(a) {
  return a.replace(/(..)/g, "%$1")
}

function ipv6tohex(g) {
  var b = "malformed IPv6 address";
  if (!g.match(/^[0-9A-Fa-f:]+$/)) {
    throw b
  }
  g = g.toLowerCase();
  var d = g.split(":").length - 1;
  if (d < 2) {
    throw b
  }
  var e = ":".repeat(7 - d + 2);
  g = g.replace("::", e);
  var c = g.split(":");
  if (c.length != 8) {
    throw b
  }
  for (var f = 0; f < 8; f++) {
    c[f] = ("0000" + c[f]).slice(-4)
  }
  return c.join("")
}

function hextoipv6(e) {
  if (!e.match(/^[0-9A-Fa-f]{32}$/)) {
    throw "malformed IPv6 address octet"
  }
  e = e.toLowerCase();
  var b = e.match(/.{1,4}/g);
  for (var d = 0; d < 8; d++) {
    b[d] = b[d].replace(/^0+/, "");
    if (b[d] == "") {
      b[d] = "0"
    }
  }
  e = ":" + b.join(":") + ":";
  var c = e.match(/:(0:){2,}/g);
  if (c === null) {
    return e.slice(1, -1)
  }
  var f = "";
  for (var d = 0; d < c.length; d++) {
    if (c[d].length > f.length) {
      f = c[d]
    }
  }
  e = e.replace(f, "::");
  return e.slice(1, -1)
}

function hextoip(b) {
  var d = "malformed hex value";
  if (!b.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)) {
    throw d
  }
  if (b.length == 8) {
    var c;
    try {
      c = parseInt(b.substr(0, 2), 16) + "." + parseInt(b.substr(2, 2), 16) + "." + parseInt(b.substr(4, 2), 16) + "." + parseInt(b.substr(6, 2), 16);
      return c
    } catch (a) {
      throw d
    }
  } else {
    if (b.length == 32) {
      return hextoipv6(b)
    } else {
      return b
    }
  }
}

function iptohex(f) {
  var j = "malformed IP address";
  f = f.toLowerCase(f);
  if (f.match(/^[0-9.]+$/)) {
    var b = f.split(".");
    if (b.length !== 4) {
      throw j
    }
    var g = "";
    try {
      for (var e = 0; e < 4; e++) {
        var h = parseInt(b[e]);
        g += ("0" + h.toString(16)).slice(-2)
      }
      return g
    } catch (c) {
      throw j
    }
  } else {
    if (f.match(/^[0-9a-f:]+$/) && f.indexOf(":") !== -1) {
      return ipv6tohex(f)
    } else {
      throw j
    }
  }
}

function encodeURIComponentAll(a) {
  var d = encodeURIComponent(a);
  var b = "";
  for (var c = 0; c < d.length; c++) {
    if (d[c] == "%") {
      b = b + d.substr(c, 3);
      c = c + 2
    } else {
      b = b + "%" + stohex(d[c])
    }
  }
  return b
}

function newline_toUnix(a) {
  a = a.replace(/\r\n/mg, "\n");
  return a
}

function newline_toDos(a) {
  a = a.replace(/\r\n/mg, "\n");
  a = a.replace(/\n/mg, "\r\n");
  return a
}
KJUR.lang.String.isInteger = function (a) {
  if (a.match(/^[0-9]+$/)) {
    return true
  } else {
    if (a.match(/^-[0-9]+$/)) {
      return true
    } else {
      return false
    }
  }
};
KJUR.lang.String.isHex = function (a) {
  if (a.length % 2 == 0 && (a.match(/^[0-9a-f]+$/) || a.match(/^[0-9A-F]+$/))) {
    return true
  } else {
    return false
  }
};
KJUR.lang.String.isBase64 = function (a) {
  a = a.replace(/\s+/g, "");
  if (a.match(/^[0-9A-Za-z+\/]+={0,3}$/) && a.length % 4 == 0) {
    return true
  } else {
    return false
  }
};
KJUR.lang.String.isBase64URL = function (a) {
  if (a.match(/[+/=]/)) {
    return false
  }
  a = b64utob64(a);
  return KJUR.lang.String.isBase64(a)
};
KJUR.lang.String.isIntegerArray = function (a) {
  a = a.replace(/\s+/g, "");
  if (a.match(/^\[[0-9,]+\]$/)) {
    return true
  } else {
    return false
  }
};

function hextoposhex(a) {
  if (a.length % 2 == 1) {
    return "0" + a
  }
  if (a.substr(0, 1) > "7") {
    return "00" + a
  }
  return a
}

function intarystrtohex(b) {
  b = b.replace(/^\s*\[\s*/, "");
  b = b.replace(/\s*\]\s*$/, "");
  b = b.replace(/\s*/g, "");
  try {
    var c = b.split(/,/).map(function (g, e, h) {
      var f = parseInt(g);
      if (f < 0 || 255 < f) {
        throw "integer not in range 0-255"
      }
      var d = ("00" + f.toString(16)).slice(-2);
      return d
    }).join("");
    return c
  } catch (a) {
    throw "malformed integer array string: " + a
  }
}
var strdiffidx = function (c, a) {
  var d = c.length;
  if (c.length > a.length) {
    d = a.length
  }
  for (var b = 0; b < d; b++) {
    if (c.charCodeAt(b) != a.charCodeAt(b)) {
      return b
    }
  }
  if (c.length != a.length) {
    return d
  }
  return -1
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
  KJUR.crypto = {}
}
KJUR.crypto.Util = new function () {
  this.DIGESTINFOHEAD = {
    sha1: "3021300906052b0e03021a05000414",
    sha224: "302d300d06096086480165030402040500041c",
    sha256: "3031300d060960864801650304020105000420",
    sha384: "3041300d060960864801650304020205000430",
    sha512: "3051300d060960864801650304020305000440",
    md2: "3020300c06082a864886f70d020205000410",
    md5: "3020300c06082a864886f70d020505000410",
    ripemd160: "3021300906052b2403020105000414",
  };
  this.DEFAULTPROVIDER = {
    md5: "cryptojs",
    sha1: "cryptojs",
    sha224: "cryptojs",
    sha256: "cryptojs",
    sha384: "cryptojs",
    sha512: "cryptojs",
    ripemd160: "cryptojs",
    hmacmd5: "cryptojs",
    hmacsha1: "cryptojs",
    hmacsha224: "cryptojs",
    hmacsha256: "cryptojs",
    hmacsha384: "cryptojs",
    hmacsha512: "cryptojs",
    hmacripemd160: "cryptojs",
    MD5withRSA: "cryptojs/jsrsa",
    SHA1withRSA: "cryptojs/jsrsa",
    SHA224withRSA: "cryptojs/jsrsa",
    SHA256withRSA: "cryptojs/jsrsa",
    SHA384withRSA: "cryptojs/jsrsa",
    SHA512withRSA: "cryptojs/jsrsa",
    RIPEMD160withRSA: "cryptojs/jsrsa",
    MD5withECDSA: "cryptojs/jsrsa",
    SHA1withECDSA: "cryptojs/jsrsa",
    SHA224withECDSA: "cryptojs/jsrsa",
    SHA256withECDSA: "cryptojs/jsrsa",
    SHA384withECDSA: "cryptojs/jsrsa",
    SHA512withECDSA: "cryptojs/jsrsa",
    RIPEMD160withECDSA: "cryptojs/jsrsa",
    SHA1withDSA: "cryptojs/jsrsa",
    SHA224withDSA: "cryptojs/jsrsa",
    SHA256withDSA: "cryptojs/jsrsa",
    MD5withRSAandMGF1: "cryptojs/jsrsa",
    SHAwithRSAandMGF1: "cryptojs/jsrsa",
    SHA1withRSAandMGF1: "cryptojs/jsrsa",
    SHA224withRSAandMGF1: "cryptojs/jsrsa",
    SHA256withRSAandMGF1: "cryptojs/jsrsa",
    SHA384withRSAandMGF1: "cryptojs/jsrsa",
    SHA512withRSAandMGF1: "cryptojs/jsrsa",
    RIPEMD160withRSAandMGF1: "cryptojs/jsrsa",
  };
  this.CRYPTOJSMESSAGEDIGESTNAME = {
    md5: CryptoJS.algo.MD5,
    sha1: CryptoJS.algo.SHA1,
    sha224: CryptoJS.algo.SHA224,
    sha256: CryptoJS.algo.SHA256,
    sha384: CryptoJS.algo.SHA384,
    sha512: CryptoJS.algo.SHA512,
    ripemd160: CryptoJS.algo.RIPEMD160
  };
  this.getDigestInfoHex = function (a, b) {
    if (typeof this.DIGESTINFOHEAD[b] == "undefined") {
      throw "alg not supported in Util.DIGESTINFOHEAD: " + b
    }
    return this.DIGESTINFOHEAD[b] + a
  };
  this.getPaddedDigestInfoHex = function (h, a, j) {
    var c = this.getDigestInfoHex(h, a);
    var d = j / 4;
    if (c.length + 22 > d) {
      throw "key is too short for SigAlg: keylen=" + j + "," + a
    }
    var b = "0001";
    var k = "00" + c;
    var g = "";
    var l = d - b.length - k.length;
    for (var f = 0; f < l; f += 2) {
      g += "ff"
    }
    var e = b + g + k;
    return e
  };
  this.hashString = function (a, c) {
    var b = new KJUR.crypto.MessageDigest({
      alg: c
    });
    return b.digestString(a)
  };
  this.hashHex = function (b, c) {
    var a = new KJUR.crypto.MessageDigest({
      alg: c
    });
    return a.digestHex(b)
  };
  this.sha1 = function (a) {
    return this.hashString(a, "sha1")
  };
  this.sha256 = function (a) {
    return this.hashString(a, "sha256")
  };
  this.sha256Hex = function (a) {
    return this.hashHex(a, "sha256")
  };
  this.sha512 = function (a) {
    return this.hashString(a, "sha512")
  };
  this.sha512Hex = function (a) {
    return this.hashHex(a, "sha512")
  };
  this.isKey = function (a) {
    if (a instanceof RSAKey || a instanceof KJUR.crypto.DSA || a instanceof KJUR.crypto.ECDSA) {
      return true
    } else {
      return false
    }
  }
};
KJUR.crypto.Util.md5 = function (a) {
  var b = new KJUR.crypto.MessageDigest({
    alg: "md5",
    prov: "cryptojs"
  });
  return b.digestString(a)
};
KJUR.crypto.Util.ripemd160 = function (a) {
  var b = new KJUR.crypto.MessageDigest({
    alg: "ripemd160",
    prov: "cryptojs"
  });
  return b.digestString(a)
};
KJUR.crypto.Util.SECURERANDOMGEN = new SecureRandom();
KJUR.crypto.Util.getRandomHexOfNbytes = function (b) {
  var a = new Array(b);
  KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(a);
  return BAtohex(a)
};
KJUR.crypto.Util.getRandomBigIntegerOfNbytes = function (a) {
  return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbytes(a), 16)
};
KJUR.crypto.Util.getRandomHexOfNbits = function (d) {
  var c = d % 8;
  var a = (d - c) / 8;
  var b = new Array(a + 1);
  KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(b);
  b[0] = (((255 << c) & 255) ^ 255) & b[0];
  return BAtohex(b)
};
KJUR.crypto.Util.getRandomBigIntegerOfNbits = function (a) {
  return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbits(a), 16)
};
KJUR.crypto.Util.getRandomBigIntegerZeroToMax = function (b) {
  var a = b.bitLength();
  while (1) {
    var c = KJUR.crypto.Util.getRandomBigIntegerOfNbits(a);
    if (b.compareTo(c) != -1) {
      return c
    }
  }
};
KJUR.crypto.Util.getRandomBigIntegerMinToMax = function (e, b) {
  var c = e.compareTo(b);
  if (c == 1) {
    throw "biMin is greater than biMax"
  }
  if (c == 0) {
    return e
  }
  var a = b.subtract(e);
  var d = KJUR.crypto.Util.getRandomBigIntegerZeroToMax(a);
  return d.add(e)
};
KJUR.crypto.MessageDigest = function (c) {
  var b = null;
  var a = null;
  var d = null;
  this.setAlgAndProvider = function (g, f) {
    g = KJUR.crypto.MessageDigest.getCanonicalAlgName(g);
    if (g !== null && f === undefined) {
      f = KJUR.crypto.Util.DEFAULTPROVIDER[g]
    }
    if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && f == "cryptojs") {
      try {
        this.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create()
      } catch (e) {
        throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e
      }
      this.updateString = function (h) {
        this.md.update(h)
      };
      this.updateHex = function (h) {
        var i = CryptoJS.enc.Hex.parse(h);
        this.md.update(i)
      };
      this.digest = function () {
        var h = this.md.finalize();
        return h.toString(CryptoJS.enc.Hex)
      };
      this.digestString = function (h) {
        this.updateString(h);
        return this.digest()
      };
      this.digestHex = function (h) {
        this.updateHex(h);
        return this.digest()
      }
    }
    if (":sha256:".indexOf(g) != -1 && f == "sjcl") {
      try {
        this.md = new sjcl.hash.sha256()
      } catch (e) {
        throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e
      }
      this.updateString = function (h) {
        this.md.update(h)
      };
      this.updateHex = function (i) {
        var h = sjcl.codec.hex.toBits(i);
        this.md.update(h)
      };
      this.digest = function () {
        var h = this.md.finalize();
        return sjcl.codec.hex.fromBits(h)
      };
      this.digestString = function (h) {
        this.updateString(h);
        return this.digest()
      };
      this.digestHex = function (h) {
        this.updateHex(h);
        return this.digest()
      }
    }
  };
  this.updateString = function (e) {
    throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName
  };
  this.updateHex = function (e) {
    throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName
  };
  this.digest = function () {
    throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName
  };
  this.digestString = function (e) {
    throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName
  };
  this.digestHex = function (e) {
    throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName
  };
  if (c !== undefined) {
    if (c.alg !== undefined) {
      this.algName = c.alg;
      if (c.prov === undefined) {
        this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]
      }
      this.setAlgAndProvider(this.algName, this.provName)
    }
  }
};
KJUR.crypto.MessageDigest.getCanonicalAlgName = function (a) {
  if (typeof a === "string") {
    a = a.toLowerCase();
    a = a.replace(/-/, "")
  }
  return a
};
KJUR.crypto.MessageDigest.getHashLength = function (c) {
  var b = KJUR.crypto.MessageDigest;
  var a = b.getCanonicalAlgName(c);
  if (b.HASHLENGTH[a] === undefined) {
    throw "not supported algorithm: " + c
  }
  return b.HASHLENGTH[a]
};
KJUR.crypto.MessageDigest.HASHLENGTH = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  ripemd160: 20
};
KJUR.crypto.Mac = function (d) {
  var f = null;
  var c = null;
  var a = null;
  var e = null;
  var b = null;
  this.setAlgAndProvider = function (k, i) {
    k = k.toLowerCase();
    if (k == null) {
      k = "hmacsha1"
    }
    k = k.toLowerCase();
    if (k.substr(0, 4) != "hmac") {
      throw "setAlgAndProvider unsupported HMAC alg: " + k
    }
    if (i === undefined) {
      i = KJUR.crypto.Util.DEFAULTPROVIDER[k]
    }
    this.algProv = k + "/" + i;
    var g = k.substr(4);
    if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && i == "cryptojs") {
      try {
        var j = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g];
        this.mac = CryptoJS.algo.HMAC.create(j, this.pass)
      } catch (h) {
        throw "setAlgAndProvider hash alg set fail hashAlg=" + g + "/" + h
      }
      this.updateString = function (l) {
        this.mac.update(l)
      };
      this.updateHex = function (l) {
        var m = CryptoJS.enc.Hex.parse(l);
        this.mac.update(m)
      };
      this.doFinal = function () {
        var l = this.mac.finalize();
        return l.toString(CryptoJS.enc.Hex)
      };
      this.doFinalString = function (l) {
        this.updateString(l);
        return this.doFinal()
      };
      this.doFinalHex = function (l) {
        this.updateHex(l);
        return this.doFinal()
      }
    }
  };
  this.updateString = function (g) {
    throw "updateString(str) not supported for this alg/prov: " + this.algProv
  };
  this.updateHex = function (g) {
    throw "updateHex(hex) not supported for this alg/prov: " + this.algProv
  };
  this.doFinal = function () {
    throw "digest() not supported for this alg/prov: " + this.algProv
  };
  this.doFinalString = function (g) {
    throw "digestString(str) not supported for this alg/prov: " + this.algProv
  };
  this.doFinalHex = function (g) {
    throw "digestHex(hex) not supported for this alg/prov: " + this.algProv
  };
  this.setPassword = function (h) {
    if (typeof h == "string") {
      var g = h;
      if (h.length % 2 == 1 || !h.match(/^[0-9A-Fa-f]+$/)) {
        g = rstrtohex(h)
      }
      this.pass = CryptoJS.enc.Hex.parse(g);
      return
    }
    if (typeof h != "object") {
      throw "KJUR.crypto.Mac unsupported password type: " + h
    }
    var g = null;
    if (h.hex !== undefined) {
      if (h.hex.length % 2 != 0 || !h.hex.match(/^[0-9A-Fa-f]+$/)) {
        throw "Mac: wrong hex password: " + h.hex
      }
      g = h.hex
    }
    if (h.utf8 !== undefined) {
      g = utf8tohex(h.utf8)
    }
    if (h.rstr !== undefined) {
      g = rstrtohex(h.rstr)
    }
    if (h.b64 !== undefined) {
      g = b64tohex(h.b64)
    }
    if (h.b64u !== undefined) {
      g = b64utohex(h.b64u)
    }
    if (g == null) {
      throw "KJUR.crypto.Mac unsupported password type: " + h
    }
    this.pass = CryptoJS.enc.Hex.parse(g)
  };
  if (d !== undefined) {
    if (d.pass !== undefined) {
      this.setPassword(d.pass)
    }
    if (d.alg !== undefined) {
      this.algName = d.alg;
      if (d.prov === undefined) {
        this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]
      }
      this.setAlgAndProvider(this.algName, this.provName)
    }
  }
};
KJUR.crypto.Signature = function (o) {
  var q = null;
  var n = null;
  var r = null;
  var c = null;
  var l = null;
  var d = null;
  var k = null;
  var h = null;
  var p = null;
  var e = null;
  var b = -1;
  var g = null;
  var j = null;
  var a = null;
  var i = null;
  var f = null;
  this._setAlgNames = function () {
    var s = this.algName.match(/^(.+)with(.+)$/);
    if (s) {
      this.mdAlgName = s[1].toLowerCase();
      this.pubkeyAlgName = s[2].toLowerCase();
      if (this.pubkeyAlgName == "rsaandmgf1" && this.mdAlgName == "sha") {
        this.mdAlgName = "sha1"
      }
    }
  };
  this._zeroPaddingOfSignature = function (x, w) {
    var v = "";
    var t = w / 4 - x.length;
    for (var u = 0; u < t; u++) {
      v = v + "0"
    }
    return v + x
  };
  this.setAlgAndProvider = function (u, t) {
    this._setAlgNames();
    if (t != "cryptojs/jsrsa") {
      throw new Error("provider not supported: " + t)
    }
    if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName) != -1) {
      try {
        this.md = new KJUR.crypto.MessageDigest({
          alg: this.mdAlgName
        })
      } catch (s) {
        throw new Error("setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + s)
      }
      this.init = function (w, x) {
        var y = null;
        try {
          if (x === undefined) {
            y = KEYUTIL.getKey(w)
          } else {
            y = KEYUTIL.getKey(w, x)
          }
        } catch (v) {
          throw "init failed:" + v
        }
        if (y.isPrivate === true) {
          this.prvKey = y;
          this.state = "SIGN"
        } else {
          if (y.isPublic === true) {
            this.pubKey = y;
            this.state = "VERIFY"
          } else {
            throw "init failed.:" + y
          }
        }
      };
      this.updateString = function (v) {
        this.md.updateString(v)
      };
      this.updateHex = function (v) {
        this.md.updateHex(v)
      };
      this.sign = function () {
        this.sHashHex = this.md.digest();
        if (this.prvKey === undefined && this.ecprvhex !== undefined && this.eccurvename !== undefined && KJUR.crypto.ECDSA !== undefined) {
          this.prvKey = new KJUR.crypto.ECDSA({
            curve: this.eccurvename,
            prv: this.ecprvhex
          })
        }
        if (this.prvKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1") {
          this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex, this.mdAlgName, this.pssSaltLen)
        } else {
          if (this.prvKey instanceof RSAKey && this.pubkeyAlgName === "rsa") {
            this.hSign = this.prvKey.signWithMessageHash(this.sHashHex, this.mdAlgName)
          } else {
            if (this.prvKey instanceof KJUR.crypto.ECDSA) {
              this.hSign = this.prvKey.signWithMessageHash(this.sHashHex)
            } else {
              if (this.prvKey instanceof KJUR.crypto.DSA) {
                this.hSign = this.prvKey.signWithMessageHash(this.sHashHex)
              } else {
                throw "Signature: unsupported private key alg: " + this.pubkeyAlgName
              }
            }
          }
        }
        return this.hSign
      };
      this.signString = function (v) {
        this.updateString(v);
        return this.sign()
      };
      this.signHex = function (v) {
        this.updateHex(v);
        return this.sign()
      };
      this.verify = function (v) {
        this.sHashHex = this.md.digest();
        if (this.pubKey === undefined && this.ecpubhex !== undefined && this.eccurvename !== undefined && KJUR.crypto.ECDSA !== undefined) {
          this.pubKey = new KJUR.crypto.ECDSA({
            curve: this.eccurvename,
            pub: this.ecpubhex
          })
        }
        if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsaandmgf1") {
          return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, v, this.mdAlgName, this.pssSaltLen)
        } else {
          if (this.pubKey instanceof RSAKey && this.pubkeyAlgName === "rsa") {
            return this.pubKey.verifyWithMessageHash(this.sHashHex, v)
          } else {
            if (KJUR.crypto.ECDSA !== undefined && this.pubKey instanceof KJUR.crypto.ECDSA) {
              return this.pubKey.verifyWithMessageHash(this.sHashHex, v)
            } else {
              if (KJUR.crypto.DSA !== undefined && this.pubKey instanceof KJUR.crypto.DSA) {
                return this.pubKey.verifyWithMessageHash(this.sHashHex, v)
              } else {
                throw "Signature: unsupported public key alg: " + this.pubkeyAlgName
              }
            }
          }
        }
      }
    }
  };
  this.init = function (s, t) {
    throw "init(key, pass) not supported for this alg:prov=" + this.algProvName
  };
  this.updateString = function (s) {
    throw "updateString(str) not supported for this alg:prov=" + this.algProvName
  };
  this.updateHex = function (s) {
    throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName
  };
  this.sign = function () {
    throw "sign() not supported for this alg:prov=" + this.algProvName
  };
  this.signString = function (s) {
    throw "digestString(str) not supported for this alg:prov=" + this.algProvName
  };
  this.signHex = function (s) {
    throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName
  };
  this.verify = function (s) {
    throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName
  };
  this.initParams = o;
  if (o !== undefined) {
    if (o.alg !== undefined) {
      this.algName = o.alg;
      if (o.prov === undefined) {
        this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]
      } else {
        this.provName = o.prov
      }
      this.algProvName = this.algName + ":" + this.provName;
      this.setAlgAndProvider(this.algName, this.provName);
      this._setAlgNames()
    }
    if (o.psssaltlen !== undefined) {
      this.pssSaltLen = o.psssaltlen
    }
    if (o.prvkeypem !== undefined) {
      if (o.prvkeypas !== undefined) {
        throw "both prvkeypem and prvkeypas parameters not supported"
      } else {
        try {
          var q = KEYUTIL.getKey(o.prvkeypem);
          this.init(q)
        } catch (m) {
          throw "fatal error to load pem private key: " + m
        }
      }
    }
  }
};
KJUR.crypto.Cipher = function (a) {};
KJUR.crypto.Cipher.encrypt = function (e, f, d) {
  if (f instanceof RSAKey && f.isPublic) {
    var c = KJUR.crypto.Cipher.getAlgByKeyAndName(f, d);
    if (c === "RSA") {
      return f.encrypt(e)
    }
    if (c === "RSAOAEP") {
      return f.encryptOAEP(e, "sha1")
    }
    var b = c.match(/^RSAOAEP(\d+)$/);
    if (b !== null) {
      return f.encryptOAEP(e, "sha" + b[1])
    }
    throw "Cipher.encrypt: unsupported algorithm for RSAKey: " + d
  } else {
    throw "Cipher.encrypt: unsupported key or algorithm"
  }
};
KJUR.crypto.Cipher.decrypt = function (e, f, d) {
  if (f instanceof RSAKey && f.isPrivate) {
    var c = KJUR.crypto.Cipher.getAlgByKeyAndName(f, d);
    if (c === "RSA") {
      return f.decrypt(e)
    }
    if (c === "RSAOAEP") {
      return f.decryptOAEP(e, "sha1")
    }
    var b = c.match(/^RSAOAEP(\d+)$/);
    if (b !== null) {
      return f.decryptOAEP(e, "sha" + b[1])
    }
    throw "Cipher.decrypt: unsupported algorithm for RSAKey: " + d
  } else {
    throw "Cipher.decrypt: unsupported key or algorithm"
  }
};
KJUR.crypto.Cipher.getAlgByKeyAndName = function (b, a) {
  if (b instanceof RSAKey) {
    if (":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(a) != -1) {
      return a
    }
    if (a === null || a === undefined) {
      return "RSA"
    }
    throw "getAlgByKeyAndName: not supported algorithm name for RSAKey: " + a
  }
  throw "getAlgByKeyAndName: not supported algorithm name: " + a
};
KJUR.crypto.OID = new function () {
  this.oidhex2name = {
    "2a864886f70d010101": "rsaEncryption",
    "2a8648ce3d0201": "ecPublicKey",
    "2a8648ce380401": "dsa",
    "2a8648ce3d030107": "secp256r1",
    "2b8104001f": "secp192k1",
    "2b81040021": "secp224r1",
    "2b8104000a": "secp256k1",
    "2b81040023": "secp521r1",
    "2b81040022": "secp384r1",
    "2a8648ce380403": "SHA1withDSA",
    "608648016503040301": "SHA224withDSA",
    "608648016503040302": "SHA256withDSA",
  }
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
  KJUR.crypto = {}
}
KJUR.crypto.ECDSA = function (e) {
  var g = "secp256r1";
  var p = null;
  var b = null;
  var i = null;
  var j = Error,
    f = BigInteger,
    h = ECPointFp,
    m = KJUR.crypto.ECDSA,
    c = KJUR.crypto.ECParameterDB,
    d = m.getName,
    q = ASN1HEX,
    n = q.getVbyListEx,
    k = q.isASN1HEX;
  var a = new SecureRandom();
  var o = null;
  this.type = "EC";
  this.isPrivate = false;
  this.isPublic = false;

  function l(x, t, w, s) {
    var r = Math.max(t.bitLength(), s.bitLength());
    var y = x.add2D(w);
    var v = x.curve.getInfinity();
    for (var u = r - 1; u >= 0; --u) {
      v = v.twice2D();
      v.z = f.ONE;
      if (t.testBit(u)) {
        if (s.testBit(u)) {
          v = v.add2D(y)
        } else {
          v = v.add2D(x)
        }
      } else {
        if (s.testBit(u)) {
          v = v.add2D(w)
        }
      }
    }
    return v
  }
  this.getBigRandom = function (r) {
    return new f(r.bitLength(), a).mod(r.subtract(f.ONE)).add(f.ONE)
  };
  this.setNamedCurve = function (r) {
    this.ecparams = c.getByName(r);
    this.prvKeyHex = null;
    this.pubKeyHex = null;
    this.curveName = r
  };
  this.setPrivateKeyHex = function (r) {
    this.isPrivate = true;
    this.prvKeyHex = r
  };
  this.setPublicKeyHex = function (r) {
    this.isPublic = true;
    this.pubKeyHex = r
  };
  this.getPublicKeyXYHex = function () {
    var t = this.pubKeyHex;
    if (t.substr(0, 2) !== "04") {
      throw "this method supports uncompressed format(04) only"
    }
    var s = this.ecparams.keylen / 4;
    if (t.length !== 2 + s * 2) {
      throw "malformed public key hex length"
    }
    var r = {};
    r.x = t.substr(2, s);
    r.y = t.substr(2 + s);
    return r
  };
  this.getShortNISTPCurveName = function () {
    var r = this.curveName;
    if (r === "secp256r1" || r === "NIST P-256" || r === "P-256" || r === "prime256v1") {
      return "P-256"
    }
    if (r === "secp384r1" || r === "NIST P-384" || r === "P-384") {
      return "P-384"
    }
    return null
  };
  this.generateKeyPairHex = function () {
    var t = this.ecparams.n;
    var w = this.getBigRandom(t);
    var u = this.ecparams.G.multiply(w);
    var z = u.getX().toBigInteger();
    var x = u.getY().toBigInteger();
    var r = this.ecparams.keylen / 4;
    var v = ("0000000000" + w.toString(16)).slice(-r);
    var A = ("0000000000" + z.toString(16)).slice(-r);
    var y = ("0000000000" + x.toString(16)).slice(-r);
    var s = "04" + A + y;
    this.setPrivateKeyHex(v);
    this.setPublicKeyHex(s);
    return {
      ecprvhex: v,
      ecpubhex: s
    }
  };
  this.signWithMessageHash = function (r) {
    return this.signHex(r, this.prvKeyHex)
  };
  this.signHex = function (x, u) {
    var A = new f(u, 16);
    var v = this.ecparams.n;
    var z = new f(x.substring(0, this.ecparams.keylen / 4), 16);
    do {
      var w = this.getBigRandom(v);
      var B = this.ecparams.G;
      var y = B.multiply(w);
      var t = y.getX().toBigInteger().mod(v)
    } while (t.compareTo(f.ZERO) <= 0);
    var C = w.modInverse(v).multiply(z.add(A.multiply(t))).mod(v);
    return m.biRSSigToASN1Sig(t, C)
  };
  this.sign = function (w, B) {
    var z = B;
    var u = this.ecparams.n;
    var y = f.fromByteArrayUnsigned(w);
    do {
      var v = this.getBigRandom(u);
      var A = this.ecparams.G;
      var x = A.multiply(v);
      var t = x.getX().toBigInteger().mod(u)
    } while (t.compareTo(BigInteger.ZERO) <= 0);
    var C = v.modInverse(u).multiply(y.add(z.multiply(t))).mod(u);
    return this.serializeSig(t, C)
  };
  this.verifyWithMessageHash = function (s, r) {
    return this.verifyHex(s, r, this.pubKeyHex)
  };
  this.verifyHex = function (v, y, u) {
    try {
      var t, B;
      var w = m.parseSigHex(y);
      t = w.r;
      B = w.s;
      var x = h.decodeFromHex(this.ecparams.curve, u);
      var z = new f(v.substring(0, this.ecparams.keylen / 4), 16);
      return this.verifyRaw(z, t, B, x)
    } catch (A) {
      return false
    }
  };
  this.verify = function (z, A, u) {
    var w, t;
    if (Bitcoin.Util.isArray(A)) {
      var y = this.parseSig(A);
      w = y.r;
      t = y.s
    } else {
      if ("object" === typeof A && A.r && A.s) {
        w = A.r;
        t = A.s
      } else {
        throw "Invalid value for signature"
      }
    }
    var v;
    if (u instanceof ECPointFp) {
      v = u
    } else {
      if (Bitcoin.Util.isArray(u)) {
        v = h.decodeFrom(this.ecparams.curve, u)
      } else {
        throw "Invalid format for pubkey value, must be byte array or ECPointFp"
      }
    }
    var x = f.fromByteArrayUnsigned(z);
    return this.verifyRaw(x, w, t, v)
  };
  this.verifyRaw = function (z, t, E, y) {
    var x = this.ecparams.n;
    var D = this.ecparams.G;
    if (t.compareTo(f.ONE) < 0 || t.compareTo(x) >= 0) {
      return false
    }
    if (E.compareTo(f.ONE) < 0 || E.compareTo(x) >= 0) {
      return false
    }
    var A = E.modInverse(x);
    var w = z.multiply(A).mod(x);
    var u = t.multiply(A).mod(x);
    var B = D.multiply(w).add(y.multiply(u));
    var C = B.getX().toBigInteger().mod(x);
    return C.equals(t)
  };
  this.serializeSig = function (v, u) {
    var w = v.toByteArraySigned();
    var t = u.toByteArraySigned();
    var x = [];
    x.push(2);
    x.push(w.length);
    x = x.concat(w);
    x.push(2);
    x.push(t.length);
    x = x.concat(t);
    x.unshift(x.length);
    x.unshift(48);
    return x
  };
  this.parseSig = function (y) {
    var x;
    if (y[0] != 48) {
      throw new Error("Signature not a valid DERSequence")
    }
    x = 2;
    if (y[x] != 2) {
      throw new Error("First element in signature must be a DERInteger")
    }
    var w = y.slice(x + 2, x + 2 + y[x + 1]);
    x += 2 + y[x + 1];
    if (y[x] != 2) {
      throw new Error("Second element in signature must be a DERInteger")
    }
    var t = y.slice(x + 2, x + 2 + y[x + 1]);
    x += 2 + y[x + 1];
    var v = f.fromByteArrayUnsigned(w);
    var u = f.fromByteArrayUnsigned(t);
    return {
      r: v,
      s: u
    }
  };
  this.parseSigCompact = function (w) {
    if (w.length !== 65) {
      throw "Signature has the wrong length"
    }
    var t = w[0] - 27;
    if (t < 0 || t > 7) {
      throw "Invalid signature type"
    }
    var x = this.ecparams.n;
    var v = f.fromByteArrayUnsigned(w.slice(1, 33)).mod(x);
    var u = f.fromByteArrayUnsigned(w.slice(33, 65)).mod(x);
    return {
      r: v,
      s: u,
      i: t
    }
  };
  this.readPKCS5PrvKeyHex = function (u) {
    if (k(u) === false) {
      throw new Error("not ASN.1 hex string")
    }
    var r, t, v;
    try {
      r = n(u, 0, ["[0]", 0], "06");
      t = n(u, 0, [1], "04");
      try {
        v = n(u, 0, ["[1]", 0], "03")
      } catch (s) {}
    } catch (s) {
      throw new Error("malformed PKCS#1/5 plain ECC private key")
    }
    this.curveName = d(r);
    if (this.curveName === undefined) {
      throw "unsupported curve name"
    }
    this.setNamedCurve(this.curveName);
    this.setPublicKeyHex(v);
    this.setPrivateKeyHex(t);
    this.isPublic = false
  };
  this.readPKCS8PrvKeyHex = function (v) {
    if (k(v) === false) {
      throw new j("not ASN.1 hex string")
    }
    var t, r, u, w;
    try {
      t = n(v, 0, [1, 0], "06");
      r = n(v, 0, [1, 1], "06");
      u = n(v, 0, [2, 0, 1], "04");
      try {
        w = n(v, 0, [2, 0, "[1]", 0], "03")
      } catch (s) {}
    } catch (s) {
      throw new j("malformed PKCS#8 plain ECC private key")
    }
    this.curveName = d(r);
    if (this.curveName === undefined) {
      throw new j("unsupported curve name")
    }
    this.setNamedCurve(this.curveName);
    this.setPublicKeyHex(w);
    this.setPrivateKeyHex(u);
    this.isPublic = false
  };
  this.readPKCS8PubKeyHex = function (u) {
    if (k(u) === false) {
      throw new j("not ASN.1 hex string")
    }
    var t, r, v;
    try {
      t = n(u, 0, [0, 0], "06");
      r = n(u, 0, [0, 1], "06");
      v = n(u, 0, [1], "03")
    } catch (s) {
      throw new j("malformed PKCS#8 ECC public key")
    }
    this.curveName = d(r);
    if (this.curveName === null) {
      throw new j("unsupported curve name")
    }
    this.setNamedCurve(this.curveName);
    this.setPublicKeyHex(v)
  };
  this.readCertPubKeyHex = function (t, v) {
    if (k(t) === false) {
      throw new j("not ASN.1 hex string")
    }
    var r, u;
    try {
      r = n(t, 0, [0, 5, 0, 1], "06");
      u = n(t, 0, [0, 5, 1], "03")
    } catch (s) {
      throw new j("malformed X.509 certificate ECC public key")
    }
    this.curveName = d(r);
    if (this.curveName === null) {
      throw new j("unsupported curve name")
    }
    this.setNamedCurve(this.curveName);
    this.setPublicKeyHex(u)
  };
  if (e !== undefined) {
    if (e.curve !== undefined) {
      this.curveName = e.curve
    }
  }
  if (this.curveName === undefined) {
    this.curveName = g
  }
  this.setNamedCurve(this.curveName);
  if (e !== undefined) {
    if (e.prv !== undefined) {
      this.setPrivateKeyHex(e.prv)
    }
    if (e.pub !== undefined) {
      this.setPublicKeyHex(e.pub)
    }
  }
};
KJUR.crypto.ECDSA.parseSigHex = function (a) {
  var b = KJUR.crypto.ECDSA.parseSigHexInHexRS(a);
  var d = new BigInteger(b.r, 16);
  var c = new BigInteger(b.s, 16);
  return {
    r: d,
    s: c
  }
};
KJUR.crypto.ECDSA.parseSigHexInHexRS = function (f) {
  var j = ASN1HEX,
    i = j.getChildIdx,
    g = j.getV;
  j.checkStrictDER(f, 0);
  if (f.substr(0, 2) != "30") {
    throw new Error("signature is not a ASN.1 sequence")
  }
  var h = i(f, 0);
  if (h.length != 2) {
    throw new Error("signature shall have two elements")
  }
  var e = h[0];
  var d = h[1];
  if (f.substr(e, 2) != "02") {
    throw new Error("1st item not ASN.1 integer")
  }
  if (f.substr(d, 2) != "02") {
    throw new Error("2nd item not ASN.1 integer")
  }
  var c = g(f, e);
  var b = g(f, d);
  return {
    r: c,
    s: b
  }
};
KJUR.crypto.ECDSA.asn1SigToConcatSig = function (c) {
  var d = KJUR.crypto.ECDSA.parseSigHexInHexRS(c);
  var b = d.r;
  var a = d.s;
  if (b.substr(0, 2) == "00" && (b.length % 32) == 2) {
    b = b.substr(2)
  }
  if (a.substr(0, 2) == "00" && (a.length % 32) == 2) {
    a = a.substr(2)
  }
  if ((b.length % 32) == 30) {
    b = "00" + b
  }
  if ((a.length % 32) == 30) {
    a = "00" + a
  }
  if (b.length % 32 != 0) {
    throw "unknown ECDSA sig r length error"
  }
  if (a.length % 32 != 0) {
    throw "unknown ECDSA sig s length error"
  }
  return b + a
};
KJUR.crypto.ECDSA.concatSigToASN1Sig = function (a) {
  if ((((a.length / 2) * 8) % (16 * 8)) != 0) {
    throw "unknown ECDSA concatinated r-s sig  length error"
  }
  var c = a.substr(0, a.length / 2);
  var b = a.substr(a.length / 2);
  return KJUR.crypto.ECDSA.hexRSSigToASN1Sig(c, b)
};
KJUR.crypto.ECDSA.hexRSSigToASN1Sig = function (b, a) {
  var d = new BigInteger(b, 16);
  var c = new BigInteger(a, 16);
  return KJUR.crypto.ECDSA.biRSSigToASN1Sig(d, c)
};
KJUR.crypto.ECDSA.biRSSigToASN1Sig = function (f, d) {
  var c = KJUR.asn1;
  var b = new c.DERInteger({
    bigint: f
  });
  var a = new c.DERInteger({
    bigint: d
  });
  var e = new c.DERSequence({
    array: [b, a]
  });
  return e.getEncodedHex()
};
KJUR.crypto.ECDSA.getName = function (a) {
  if (a === "2b8104001f") {
    return "secp192k1"
  }
  if (a === "2a8648ce3d030107") {
    return "secp256r1"
  }
  if (a === "2b8104000a") {
    return "secp256k1"
  }
  if (a === "2b81040021") {
    return "secp224r1"
  }
  if (a === "2b81040022") {
    return "secp384r1"
  }
  if ("|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(a) !== -1) {
    return "secp256r1"
  }
  if ("|secp256k1|".indexOf(a) !== -1) {
    return "secp256k1"
  }
  if ("|secp224r1|NIST P-224|P-224|".indexOf(a) !== -1) {
    return "secp224r1"
  }
  if ("|secp384r1|NIST P-384|P-384|".indexOf(a) !== -1) {
    return "secp384r1"
  }
  return null
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
  KJUR.crypto = {}
}
KJUR.crypto.ECParameterDB = new function () {
  var b = {};
  var c = {};

  function a(d) {
    return new BigInteger(d, 16)
  }
  this.getByName = function (e) {
    var d = e;
    if (typeof c[d] != "undefined") {
      d = c[e]
    }
    if (typeof b[d] != "undefined") {
      return b[d]
    }
    throw "unregistered EC curve name: " + d
  };
  this.regist = function (A, l, o, g, m, e, j, f, k, u, d, x) {
    b[A] = {};
    var s = a(o);
    var z = a(g);
    var y = a(m);
    var t = a(e);
    var w = a(j);
    var r = new ECCurveFp(s, z, y);
    var q = r.decodePointHex("04" + f + k);
    b[A]["name"] = A;
    b[A]["keylen"] = l;
    b[A]["curve"] = r;
    b[A]["G"] = q;
    b[A]["n"] = t;
    b[A]["h"] = w;
    b[A]["oid"] = d;
    b[A]["info"] = x;
    for (var v = 0; v < u.length; v++) {
      c[u[v]] = A
    }
  }
};
KJUR.crypto.ECParameterDB.regist("secp128r1", 128, "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC", "E87579C11079F43DD824993C2CEE5ED3", "FFFFFFFE0000000075A30D1B9038A115", "1", "161FF7528B899B2D0C28607CA52C5B86", "CF5AC8395BAFEB13C02DA292DDED7A83", [], "", "secp128r1 : SECG curve over a 128 bit prime field");
KJUR.crypto.ECParameterDB.regist("secp160k1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73", "0", "7", "0100000000000000000001B8FA16DFAB9ACA16B6B3", "1", "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB", "938CF935318FDCED6BC28286531733C3F03C4FEE", [], "", "secp160k1 : SECG curve over a 160 bit prime field");
KJUR.crypto.ECParameterDB.regist("secp160r1", 160, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC", "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45", "0100000000000000000001F4C8F927AED3CA752257", "1", "4A96B5688EF573284664698968C38BB913CBFC82", "23A628553168947D59DCC912042351377AC5FB32", [], "", "secp160r1 : SECG curve over a 160 bit prime field");
KJUR.crypto.ECParameterDB.regist("secp192k1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37", "0", "3", "FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D", "1", "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D", "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D", []);
KJUR.crypto.ECParameterDB.regist("secp192r1", 192, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC", "64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", "1", "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811", []);
KJUR.crypto.ECParameterDB.regist("secp224r1", 224, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE", "B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4", "FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D", "1", "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21", "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34", []);
KJUR.crypto.ECParameterDB.regist("secp256k1", 256, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", "0", "7", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "1", "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798", "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8", []);
KJUR.crypto.ECParameterDB.regist("secp256r1", 256, "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", "FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", "5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", "FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", "1", "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296", "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5", ["NIST P-256", "P-256", "prime256v1"]);
KJUR.crypto.ECParameterDB.regist("secp384r1", 384, "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC", "B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973", "1", "AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7", "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", ["NIST P-384", "P-384"]);
KJUR.crypto.ECParameterDB.regist("secp521r1", 521, "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC", "051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00", "1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409", "1", "C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66", "011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650", ["NIST P-521", "P-521"]);
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) {
  KJUR.crypto = {}
}
KJUR.crypto.DSA = function () {
  var b = ASN1HEX,
    e = b.getVbyList,
    d = b.getVbyListEx,
    a = b.isASN1HEX,
    c = BigInteger;
  this.p = null;
  this.q = null;
  this.g = null;
  this.y = null;
  this.x = null;
  this.type = "DSA";
  this.isPrivate = false;
  this.isPublic = false;
  this.setPrivate = function (j, i, h, k, f) {
    this.isPrivate = true;
    this.p = j;
    this.q = i;
    this.g = h;
    this.y = k;
    this.x = f
  };
  this.setPrivateHex = function (i, g, k, n, o) {
    var h, f, j, l, m;
    h = new BigInteger(i, 16);
    f = new BigInteger(g, 16);
    j = new BigInteger(k, 16);
    if (typeof n === "string" && n.length > 1) {
      l = new BigInteger(n, 16)
    } else {
      l = null
    }
    m = new BigInteger(o, 16);
    this.setPrivate(h, f, j, l, m)
  };
  this.setPublic = function (i, h, f, j) {
    this.isPublic = true;
    this.p = i;
    this.q = h;
    this.g = f;
    this.y = j;
    this.x = null
  };
  this.setPublicHex = function (k, j, i, l) {
    var g, f, m, h;
    g = new BigInteger(k, 16);
    f = new BigInteger(j, 16);
    m = new BigInteger(i, 16);
    h = new BigInteger(l, 16);
    this.setPublic(g, f, m, h)
  };
  this.signWithMessageHash = function (j) {
    var i = this.p;
    var h = this.q;
    var m = this.g;
    var o = this.y;
    var t = this.x;
    var l = KJUR.crypto.Util.getRandomBigIntegerMinToMax(BigInteger.ONE.add(BigInteger.ONE), h.subtract(BigInteger.ONE));
    var u = j.substr(0, h.bitLength() / 4);
    var n = new BigInteger(u, 16);
    var f = (m.modPow(l, i)).mod(h);
    var w = (l.modInverse(h).multiply(n.add(t.multiply(f)))).mod(h);
    var v = KJUR.asn1.ASN1Util.jsonToASN1HEX({
      seq: [{
        "int": {
          bigint: f
        }
      }, {
        "int": {
          bigint: w
        }
      }]
    });
    return v
  };
  this.verifyWithMessageHash = function (m, l) {
    var j = this.p;
    var h = this.q;
    var o = this.g;
    var u = this.y;
    var n = this.parseASN1Signature(l);
    var f = n[0];
    var C = n[1];
    var B = m.substr(0, h.bitLength() / 4);
    var t = new BigInteger(B, 16);
    if (BigInteger.ZERO.compareTo(f) > 0 || f.compareTo(h) > 0) {
      throw "invalid DSA signature"
    }
    if (BigInteger.ZERO.compareTo(C) >= 0 || C.compareTo(h) > 0) {
      throw "invalid DSA signature"
    }
    var x = C.modInverse(h);
    var k = t.multiply(x).mod(h);
    var i = f.multiply(x).mod(h);
    var A = o.modPow(k, j).multiply(u.modPow(i, j)).mod(j).mod(h);
    return A.compareTo(f) == 0
  };
  this.parseASN1Signature = function (f) {
    try {
      var i = new c(d(f, 0, [0], "02"), 16);
      var h = new c(d(f, 0, [1], "02"), 16);
      return [i, h]
    } catch (g) {
      throw new Error("malformed ASN.1 DSA signature")
    }
  };
  this.readPKCS5PrvKeyHex = function (j) {
    var k, i, g, l, m;
    if (a(j) === false) {
      throw new Error("not ASN.1 hex string")
    }
    try {
      k = d(j, 0, [1], "02");
      i = d(j, 0, [2], "02");
      g = d(j, 0, [3], "02");
      l = d(j, 0, [4], "02");
      m = d(j, 0, [5], "02")
    } catch (f) {
      throw new Error("malformed PKCS#1/5 plain DSA private key")
    }
    this.setPrivateHex(k, i, g, l, m)
  };
  this.readPKCS8PrvKeyHex = function (j) {
    var k, i, g, l;
    if (a(j) === false) {
      throw new Error("not ASN.1 hex string")
    }
    try {
      k = d(j, 0, [1, 1, 0], "02");
      i = d(j, 0, [1, 1, 1], "02");
      g = d(j, 0, [1, 1, 2], "02");
      l = d(j, 0, [2, 0], "02")
    } catch (f) {
      throw new Error("malformed PKCS#8 plain DSA private key")
    }
    this.setPrivateHex(k, i, g, null, l)
  };
  this.readPKCS8PubKeyHex = function (j) {
    var k, i, g, l;
    if (a(j) === false) {
      throw new Error("not ASN.1 hex string")
    }
    try {
      k = d(j, 0, [0, 1, 0], "02");
      i = d(j, 0, [0, 1, 1], "02");
      g = d(j, 0, [0, 1, 2], "02");
      l = d(j, 0, [1, 0], "02")
    } catch (f) {
      throw new Error("malformed PKCS#8 DSA public key")
    }
    this.setPublicHex(k, i, g, l)
  };
  this.readCertPubKeyHex = function (j, m) {
    var k, i, g, l;
    if (a(j) === false) {
      throw new Error("not ASN.1 hex string")
    }
    try {
      k = d(j, 0, [0, 5, 0, 1, 0], "02");
      i = d(j, 0, [0, 5, 0, 1, 1], "02");
      g = d(j, 0, [0, 5, 0, 1, 2], "02");
      l = d(j, 0, [0, 5, 1, 0], "02")
    } catch (f) {
      throw new Error("malformed X.509 certificate DSA public key")
    }
    this.setPublicHex(k, i, g, l)
  }
};
var KEYUTIL = function () {
  var d = function (p, r, q) {
    return k(CryptoJS.AES, p, r, q)
  };
  var e = function (p, r, q) {
    return k(CryptoJS.TripleDES, p, r, q)
  };
  var a = function (p, r, q) {
    return k(CryptoJS.DES, p, r, q)
  };
  var k = function (s, x, u, q) {
    var r = CryptoJS.enc.Hex.parse(x);
    var w = CryptoJS.enc.Hex.parse(u);
    var p = CryptoJS.enc.Hex.parse(q);
    var t = {};
    t.key = w;
    t.iv = p;
    t.ciphertext = r;
    var v = s.decrypt(t, w, {
      iv: p
    });
    return CryptoJS.enc.Hex.stringify(v)
  };
  var l = function (p, r, q) {
    return g(CryptoJS.AES, p, r, q)
  };
  var o = function (p, r, q) {
    return g(CryptoJS.TripleDES, p, r, q)
  };
  var f = function (p, r, q) {
    return g(CryptoJS.DES, p, r, q)
  };
  var g = function (t, y, v, q) {
    var s = CryptoJS.enc.Hex.parse(y);
    var x = CryptoJS.enc.Hex.parse(v);
    var p = CryptoJS.enc.Hex.parse(q);
    var w = t.encrypt(s, x, {
      iv: p
    });
    var r = CryptoJS.enc.Hex.parse(w.toString());
    var u = CryptoJS.enc.Base64.stringify(r);
    return u
  };
  var i = {
    "AES-256-CBC": {
      proc: d,
      eproc: l,
      keylen: 32,
      ivlen: 16
    },
    "AES-192-CBC": {
      proc: d,
      eproc: l,
      keylen: 24,
      ivlen: 16
    },
    "AES-128-CBC": {
      proc: d,
      eproc: l,
      keylen: 16,
      ivlen: 16
    },
    "DES-EDE3-CBC": {
      proc: e,
      eproc: o,
      keylen: 24,
      ivlen: 8
    },
    "DES-CBC": {
      proc: a,
      eproc: f,
      keylen: 8,
      ivlen: 8
    }
  };
  var c = function (p) {
    return i[p]["proc"]
  };
  var m = function (p) {
    var r = CryptoJS.lib.WordArray.random(p);
    var q = CryptoJS.enc.Hex.stringify(r);
    return q
  };
  var n = function (v) {
    var w = {};
    var q = v.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)", "m"));
    if (q) {
      w.cipher = q[1];
      w.ivsalt = q[2]
    }
    var p = v.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));
    if (p) {
      w.type = p[1]
    }
    var u = -1;
    var x = 0;
    if (v.indexOf("\r\n\r\n") != -1) {
      u = v.indexOf("\r\n\r\n");
      x = 2
    }
    if (v.indexOf("\n\n") != -1) {
      u = v.indexOf("\n\n");
      x = 1
    }
    var t = v.indexOf("-----END");
    if (u != -1 && t != -1) {
      var r = v.substring(u + x * 2, t - x);
      r = r.replace(/\s+/g, "");
      w.data = r
    }
    return w
  };
  var j = function (q, y, p) {
    var v = p.substring(0, 16);
    var t = CryptoJS.enc.Hex.parse(v);
    var r = CryptoJS.enc.Utf8.parse(y);
    var u = i[q]["keylen"] + i[q]["ivlen"];
    var x = "";
    var w = null;
    for (;;) {
      var s = CryptoJS.algo.MD5.create();
      if (w != null) {
        s.update(w)
      }
      s.update(r);
      s.update(t);
      w = s.finalize();
      x = x + CryptoJS.enc.Hex.stringify(w);
      if (x.length >= u * 2) {
        break
      }
    }
    var z = {};
    z.keyhex = x.substr(0, i[q]["keylen"] * 2);
    z.ivhex = x.substr(i[q]["keylen"] * 2, i[q]["ivlen"] * 2);
    return z
  };
  var b = function (p, v, r, w) {
    var s = CryptoJS.enc.Base64.parse(p);
    var q = CryptoJS.enc.Hex.stringify(s);
    var u = i[v]["proc"];
    var t = u(q, r, w);
    return t
  };
  var h = function (p, s, q, u) {
    var r = i[s]["eproc"];
    var t = r(p, q, u);
    return t
  };
  return {
    version: "1.0.0",
    parsePKCS5PEM: function (p) {
      return n(p)
    },
    getKeyAndUnusedIvByPasscodeAndIvsalt: function (q, p, r) {
      return j(q, p, r)
    },
    decryptKeyB64: function (p, r, q, s) {
      return b(p, r, q, s)
    },
    getDecryptedKeyHex: function (y, x) {
      var q = n(y);
      var t = q.type;
      var r = q.cipher;
      var p = q.ivsalt;
      var s = q.data;
      var w = j(r, x, p);
      var v = w.keyhex;
      var u = b(s, r, v, p);
      return u
    },
    getEncryptedPKCS5PEMFromPrvKeyHex: function (x, s, A, t, r) {
      var p = "";
      if (typeof t == "undefined" || t == null) {
        t = "AES-256-CBC"
      }
      if (typeof i[t] == "undefined") {
        throw "KEYUTIL unsupported algorithm: " + t
      }
      if (typeof r == "undefined" || r == null) {
        var v = i[t]["ivlen"];
        var u = m(v);
        r = u.toUpperCase()
      }
      var z = j(t, A, r);
      var y = z.keyhex;
      var w = h(s, t, y, r);
      var q = w.replace(/(.{64})/g, "$1\r\n");
      var p = "-----BEGIN " + x + " PRIVATE KEY-----\r\n";
      p += "Proc-Type: 4,ENCRYPTED\r\n";
      p += "DEK-Info: " + t + "," + r + "\r\n";
      p += "\r\n";
      p += q;
      p += "\r\n-----END " + x + " PRIVATE KEY-----\r\n";
      return p
    },
    parseHexOfEncryptedPKCS8: function (y) {
      var B = ASN1HEX;
      var z = B.getChildIdx;
      var w = B.getV;
      var t = {};
      var r = z(y, 0);
      if (r.length != 2) {
        throw "malformed format: SEQUENCE(0).items != 2: " + r.length
      }
      t.ciphertext = w(y, r[1]);
      var A = z(y, r[0]);
      if (A.length != 2) {
        throw "malformed format: SEQUENCE(0.0).items != 2: " + A.length
      }
      if (w(y, A[0]) != "2a864886f70d01050d") {
        throw "this only supports pkcs5PBES2"
      }
      var p = z(y, A[1]);
      if (A.length != 2) {
        throw "malformed format: SEQUENCE(0.0.1).items != 2: " + p.length
      }
      var q = z(y, p[1]);
      if (q.length != 2) {
        throw "malformed format: SEQUENCE(0.0.1.1).items != 2: " + q.length
      }
      if (w(y, q[0]) != "2a864886f70d0307") {
        throw "this only supports TripleDES"
      }
      t.encryptionSchemeAlg = "TripleDES";
      t.encryptionSchemeIV = w(y, q[1]);
      var s = z(y, p[0]);
      if (s.length != 2) {
        throw "malformed format: SEQUENCE(0.0.1.0).items != 2: " + s.length
      }
      if (w(y, s[0]) != "2a864886f70d01050c") {
        throw "this only supports pkcs5PBKDF2"
      }
      var x = z(y, s[1]);
      if (x.length < 2) {
        throw "malformed format: SEQUENCE(0.0.1.0.1).items < 2: " + x.length
      }
      t.pbkdf2Salt = w(y, x[0]);
      var u = w(y, x[1]);
      try {
        t.pbkdf2Iter = parseInt(u, 16)
      } catch (v) {
        throw "malformed format pbkdf2Iter: " + u
      }
      return t
    },
    getPBKDF2KeyHexFromParam: function (u, p) {
      var t = CryptoJS.enc.Hex.parse(u.pbkdf2Salt);
      var q = u.pbkdf2Iter;
      var s = CryptoJS.PBKDF2(p, t, {
        keySize: 192 / 32,
        iterations: q
      });
      var r = CryptoJS.enc.Hex.stringify(s);
      return r
    },
    _getPlainPKCS8HexFromEncryptedPKCS8PEM: function (x, y) {
      var r = pemtohex(x, "ENCRYPTED PRIVATE KEY");
      var p = this.parseHexOfEncryptedPKCS8(r);
      var u = KEYUTIL.getPBKDF2KeyHexFromParam(p, y);
      var v = {};
      v.ciphertext = CryptoJS.enc.Hex.parse(p.ciphertext);
      var t = CryptoJS.enc.Hex.parse(u);
      var s = CryptoJS.enc.Hex.parse(p.encryptionSchemeIV);
      var w = CryptoJS.TripleDES.decrypt(v, t, {
        iv: s
      });
      var q = CryptoJS.enc.Hex.stringify(w);
      return q
    },
    getKeyFromEncryptedPKCS8PEM: function (s, q) {
      var p = this._getPlainPKCS8HexFromEncryptedPKCS8PEM(s, q);
      var r = this.getKeyFromPlainPrivatePKCS8Hex(p);
      return r
    },
    parsePlainPrivatePKCS8Hex: function (s) {
      var v = ASN1HEX;
      var u = v.getChildIdx;
      var t = v.getV;
      var q = {};
      q.algparam = null;
      if (s.substr(0, 2) != "30") {
        throw "malformed plain PKCS8 private key(code:001)"
      }
      var r = u(s, 0);
      if (r.length != 3) {
        throw "malformed plain PKCS8 private key(code:002)"
      }
      if (s.substr(r[1], 2) != "30") {
        throw "malformed PKCS8 private key(code:003)"
      }
      var p = u(s, r[1]);
      if (p.length != 2) {
        throw "malformed PKCS8 private key(code:004)"
      }
      if (s.substr(p[0], 2) != "06") {
        throw "malformed PKCS8 private key(code:005)"
      }
      q.algoid = t(s, p[0]);
      if (s.substr(p[1], 2) == "06") {
        q.algparam = t(s, p[1])
      }
      if (s.substr(r[2], 2) != "04") {
        throw "malformed PKCS8 private key(code:006)"
      }
      q.keyidx = v.getVidx(s, r[2]);
      return q
    },
    getKeyFromPlainPrivatePKCS8PEM: function (q) {
      var p = pemtohex(q, "PRIVATE KEY");
      var r = this.getKeyFromPlainPrivatePKCS8Hex(p);
      return r
    },
    getKeyFromPlainPrivatePKCS8Hex: function (p) {
      var q = this.parsePlainPrivatePKCS8Hex(p);
      var r;
      if (q.algoid == "2a864886f70d010101") {
        r = new RSAKey()
      } else {
        if (q.algoid == "2a8648ce380401") {
          r = new KJUR.crypto.DSA()
        } else {
          if (q.algoid == "2a8648ce3d0201") {
            r = new KJUR.crypto.ECDSA()
          } else {
            throw "unsupported private key algorithm"
          }
        }
      }
      r.readPKCS8PrvKeyHex(p);
      return r
    },
    _getKeyFromPublicPKCS8Hex: function (q) {
      var p;
      var r = ASN1HEX.getVbyList(q, 0, [0, 0], "06");
      if (r === "2a864886f70d010101") {
        p = new RSAKey()
      } else {
        if (r === "2a8648ce380401") {
          p = new KJUR.crypto.DSA()
        } else {
          if (r === "2a8648ce3d0201") {
            p = new KJUR.crypto.ECDSA()
          } else {
            throw "unsupported PKCS#8 public key hex"
          }
        }
      }
      p.readPKCS8PubKeyHex(q);
      return p
    },
    parsePublicRawRSAKeyHex: function (r) {
      var u = ASN1HEX;
      var t = u.getChildIdx;
      var s = u.getV;
      var p = {};
      if (r.substr(0, 2) != "30") {
        throw "malformed RSA key(code:001)"
      }
      var q = t(r, 0);
      if (q.length != 2) {
        throw "malformed RSA key(code:002)"
      }
      if (r.substr(q[0], 2) != "02") {
        throw "malformed RSA key(code:003)"
      }
      p.n = s(r, q[0]);
      if (r.substr(q[1], 2) != "02") {
        throw "malformed RSA key(code:004)"
      }
      p.e = s(r, q[1]);
      return p
    },
    parsePublicPKCS8Hex: function (t) {
      var v = ASN1HEX;
      var u = v.getChildIdx;
      var s = v.getV;
      var q = {};
      q.algparam = null;
      var r = u(t, 0);
      if (r.length != 2) {
        throw "outer DERSequence shall have 2 elements: " + r.length
      }
      var w = r[0];
      if (t.substr(w, 2) != "30") {
        throw "malformed PKCS8 public key(code:001)"
      }
      var p = u(t, w);
      if (p.length != 2) {
        throw "malformed PKCS8 public key(code:002)"
      }
      if (t.substr(p[0], 2) != "06") {
        throw "malformed PKCS8 public key(code:003)"
      }
      q.algoid = s(t, p[0]);
      if (t.substr(p[1], 2) == "06") {
        q.algparam = s(t, p[1])
      } else {
        if (t.substr(p[1], 2) == "30") {
          q.algparam = {};
          q.algparam.p = v.getVbyList(t, p[1], [0], "02");
          q.algparam.q = v.getVbyList(t, p[1], [1], "02");
          q.algparam.g = v.getVbyList(t, p[1], [2], "02")
        }
      }
      if (t.substr(r[1], 2) != "03") {
        throw "malformed PKCS8 public key(code:004)"
      }
      q.key = s(t, r[1]).substr(2);
      return q
    },
  }
}();
KEYUTIL.getKey = function (l, k, n) {
  var G = ASN1HEX,
    L = G.getChildIdx,
    v = G.getV,
    d = G.getVbyList,
    c = KJUR.crypto,
    i = c.ECDSA,
    C = c.DSA,
    w = RSAKey,
    M = pemtohex,
    F = KEYUTIL;
  if (typeof w != "undefined" && l instanceof w) {
    return l
  }
  if (typeof i != "undefined" && l instanceof i) {
    return l
  }
  if (typeof C != "undefined" && l instanceof C) {
    return l
  }
  if (l.curve !== undefined && l.xy !== undefined && l.d === undefined) {
    return new i({
      pub: l.xy,
      curve: l.curve
    })
  }
  if (l.curve !== undefined && l.d !== undefined) {
    return new i({
      prv: l.d,
      curve: l.curve
    })
  }
  if (l.kty === undefined && l.n !== undefined && l.e !== undefined && l.d === undefined) {
    var P = new w();
    P.setPublic(l.n, l.e);
    return P
  }
  if (l.kty === undefined && l.n !== undefined && l.e !== undefined && l.d !== undefined && l.p !== undefined && l.q !== undefined && l.dp !== undefined && l.dq !== undefined && l.co !== undefined && l.qi === undefined) {
    var P = new w();
    P.setPrivateEx(l.n, l.e, l.d, l.p, l.q, l.dp, l.dq, l.co);
    return P
  }
  if (l.kty === undefined && l.n !== undefined && l.e !== undefined && l.d !== undefined && l.p === undefined) {
    var P = new w();
    P.setPrivate(l.n, l.e, l.d);
    return P
  }
  if (l.p !== undefined && l.q !== undefined && l.g !== undefined && l.y !== undefined && l.x === undefined) {
    var P = new C();
    P.setPublic(l.p, l.q, l.g, l.y);
    return P
  }
  if (l.p !== undefined && l.q !== undefined && l.g !== undefined && l.y !== undefined && l.x !== undefined) {
    var P = new C();
    P.setPrivate(l.p, l.q, l.g, l.y, l.x);
    return P
  }
  if (l.kty === "RSA" && l.n !== undefined && l.e !== undefined && l.d === undefined) {
    var P = new w();
    P.setPublic(b64utohex(l.n), b64utohex(l.e));
    return P
  }
  if (l.kty === "RSA" && l.n !== undefined && l.e !== undefined && l.d !== undefined && l.p !== undefined && l.q !== undefined && l.dp !== undefined && l.dq !== undefined && l.qi !== undefined) {
    var P = new w();
    P.setPrivateEx(b64utohex(l.n), b64utohex(l.e), b64utohex(l.d), b64utohex(l.p), b64utohex(l.q), b64utohex(l.dp), b64utohex(l.dq), b64utohex(l.qi));
    return P
  }
  if (l.kty === "RSA" && l.n !== undefined && l.e !== undefined && l.d !== undefined) {
    var P = new w();
    P.setPrivate(b64utohex(l.n), b64utohex(l.e), b64utohex(l.d));
    return P
  }
  if (l.kty === "EC" && l.crv !== undefined && l.x !== undefined && l.y !== undefined && l.d === undefined) {
    var j = new i({
      curve: l.crv
    });
    var t = j.ecparams.keylen / 4;
    var B = ("0000000000" + b64utohex(l.x)).slice(-t);
    var z = ("0000000000" + b64utohex(l.y)).slice(-t);
    var u = "04" + B + z;
    j.setPublicKeyHex(u);
    return j
  }
  if (l.kty === "EC" && l.crv !== undefined && l.x !== undefined && l.y !== undefined && l.d !== undefined) {
    var j = new i({
      curve: l.crv
    });
    var t = j.ecparams.keylen / 4;
    var B = ("0000000000" + b64utohex(l.x)).slice(-t);
    var z = ("0000000000" + b64utohex(l.y)).slice(-t);
    var u = "04" + B + z;
    var b = ("0000000000" + b64utohex(l.d)).slice(-t);
    j.setPublicKeyHex(u);
    j.setPrivateKeyHex(b);
    return j
  }
  if (n === "pkcs5prv") {
    var J = l,
      G = ASN1HEX,
      N, P;
    N = L(J, 0);
    if (N.length === 9) {
      P = new w();
      P.readPKCS5PrvKeyHex(J)
    } else {
      if (N.length === 6) {
        P = new C();
        P.readPKCS5PrvKeyHex(J)
      } else {
        if (N.length > 2 && J.substr(N[1], 2) === "04") {
          P = new i();
          P.readPKCS5PrvKeyHex(J)
        } else {
          throw "unsupported PKCS#1/5 hexadecimal key"
        }
      }
    }
    return P
  }
  if (n === "pkcs8prv") {
    var P = F.getKeyFromPlainPrivatePKCS8Hex(l);
    return P
  }
  if (n === "pkcs8pub") {
    return F._getKeyFromPublicPKCS8Hex(l)
  }
  if (n === "x509pub") {
    return X509.getPublicKeyFromCertHex(l)
  }
  if (l.indexOf("-END CERTIFICATE-", 0) != -1 || l.indexOf("-END X509 CERTIFICATE-", 0) != -1 || l.indexOf("-END TRUSTED CERTIFICATE-", 0) != -1) {
    return X509.getPublicKeyFromCertPEM(l)
  }
  if (l.indexOf("-END PUBLIC KEY-") != -1) {
    var O = pemtohex(l, "PUBLIC KEY");
    return F._getKeyFromPublicPKCS8Hex(O)
  }
  if (l.indexOf("-END RSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
    var m = M(l, "RSA PRIVATE KEY");
    return F.getKey(m, null, "pkcs5prv")
  }
  if (l.indexOf("-END DSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
    var I = M(l, "DSA PRIVATE KEY");
    var E = d(I, 0, [1], "02");
    var D = d(I, 0, [2], "02");
    var K = d(I, 0, [3], "02");
    var r = d(I, 0, [4], "02");
    var s = d(I, 0, [5], "02");
    var P = new C();
    P.setPrivate(new BigInteger(E, 16), new BigInteger(D, 16), new BigInteger(K, 16), new BigInteger(r, 16), new BigInteger(s, 16));
    return P
  }
  if (l.indexOf("-END EC PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") == -1) {
    var m = M(l, "EC PRIVATE KEY");
    return F.getKey(m, null, "pkcs5prv")
  }
  if (l.indexOf("-END PRIVATE KEY-") != -1) {
    return F.getKeyFromPlainPrivatePKCS8PEM(l)
  }
  if (l.indexOf("-END RSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
    var o = F.getDecryptedKeyHex(l, k);
    var H = new RSAKey();
    H.readPKCS5PrvKeyHex(o);
    return H
  }
  if (l.indexOf("-END EC PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
    var I = F.getDecryptedKeyHex(l, k);
    var P = d(I, 0, [1], "04");
    var f = d(I, 0, [2, 0], "06");
    var A = d(I, 0, [3, 0], "03").substr(2);
    var e = "";
    if (KJUR.crypto.OID.oidhex2name[f] !== undefined) {
      e = KJUR.crypto.OID.oidhex2name[f]
    } else {
      throw "undefined OID(hex) in KJUR.crypto.OID: " + f
    }
    var j = new i({
      curve: e
    });
    j.setPublicKeyHex(A);
    j.setPrivateKeyHex(P);
    j.isPublic = false;
    return j
  }
  if (l.indexOf("-END DSA PRIVATE KEY-") != -1 && l.indexOf("4,ENCRYPTED") != -1) {
    var I = F.getDecryptedKeyHex(l, k);
    var E = d(I, 0, [1], "02");
    var D = d(I, 0, [2], "02");
    var K = d(I, 0, [3], "02");
    var r = d(I, 0, [4], "02");
    var s = d(I, 0, [5], "02");
    var P = new C();
    P.setPrivate(new BigInteger(E, 16), new BigInteger(D, 16), new BigInteger(K, 16), new BigInteger(r, 16), new BigInteger(s, 16));
    return P
  }
  if (l.indexOf("-END ENCRYPTED PRIVATE KEY-") != -1) {
    return F.getKeyFromEncryptedPKCS8PEM(l, k)
  }
  throw new Error("not supported argument")
};
KEYUTIL.generateKeypair = function (a, c) {
  if (a == "RSA") {
    var b = c;
    var h = new RSAKey();
    h.generate(b, "10001");
    h.isPrivate = true;
    h.isPublic = true;
    var f = new RSAKey();
    var e = h.n.toString(16);
    var i = h.e.toString(16);
    f.setPublic(e, i);
    f.isPrivate = false;
    f.isPublic = true;
    var k = {};
    k.prvKeyObj = h;
    k.pubKeyObj = f;
    return k
  } else {
    if (a == "EC") {
      var d = c;
      var g = new KJUR.crypto.ECDSA({
        curve: d
      });
      var j = g.generateKeyPairHex();
      var h = new KJUR.crypto.ECDSA({
        curve: d
      });
      h.setPublicKeyHex(j.ecpubhex);
      h.setPrivateKeyHex(j.ecprvhex);
      h.isPrivate = true;
      h.isPublic = false;
      var f = new KJUR.crypto.ECDSA({
        curve: d
      });
      f.setPublicKeyHex(j.ecpubhex);
      f.isPrivate = false;
      f.isPublic = true;
      var k = {};
      k.prvKeyObj = h;
      k.pubKeyObj = f;
      return k
    } else {
      throw "unknown algorithm: " + a
    }
  }
};
KEYUTIL.getPEM = function (b, D, y, m, q, j) {
  var F = KJUR,
    k = F.asn1,
    z = k.DERObjectIdentifier,
    f = k.DERInteger,
    l = k.ASN1Util.newObject,
    a = k.x509,
    C = a.SubjectPublicKeyInfo,
    e = F.crypto,
    u = e.DSA,
    r = e.ECDSA,
    n = RSAKey;

  function A(s) {
    var G = l({
      seq: [{
        "int": 0
      }, {
        "int": {
          bigint: s.n
        }
      }, {
        "int": s.e
      }, {
        "int": {
          bigint: s.d
        }
      }, {
        "int": {
          bigint: s.p
        }
      }, {
        "int": {
          bigint: s.q
        }
      }, {
        "int": {
          bigint: s.dmp1
        }
      }, {
        "int": {
          bigint: s.dmq1
        }
      }, {
        "int": {
          bigint: s.coeff
        }
      }]
    });
    return G
  }

  function B(G) {
    var s = l({
      seq: [{
        "int": 1
      }, {
        octstr: {
          hex: G.prvKeyHex
        }
      }, {
        tag: ["a0", true, {
          oid: {
            name: G.curveName
          }
        }]
      }, {
        tag: ["a1", true, {
          bitstr: {
            hex: "00" + G.pubKeyHex
          }
        }]
      }]
    });
    return s
  }

  function x(s) {
    var G = l({
      seq: [{
        "int": 0
      }, {
        "int": {
          bigint: s.p
        }
      }, {
        "int": {
          bigint: s.q
        }
      }, {
        "int": {
          bigint: s.g
        }
      }, {
        "int": {
          bigint: s.y
        }
      }, {
        "int": {
          bigint: s.x
        }
      }]
    });
    return G
  }
  if (((n !== undefined && b instanceof n) || (u !== undefined && b instanceof u) || (r !== undefined && b instanceof r)) && b.isPublic == true && (D === undefined || D == "PKCS8PUB")) {
    var E = new C(b);
    var w = E.getEncodedHex();
    return hextopem(w, "PUBLIC KEY")
  }
  if (D == "PKCS1PRV" && n !== undefined && b instanceof n && (y === undefined || y == null) && b.isPrivate == true) {
    var E = A(b);
    var w = E.getEncodedHex();
    return hextopem(w, "RSA PRIVATE KEY")
  }
  if (D == "PKCS1PRV" && r !== undefined && b instanceof r && (y === undefined || y == null) && b.isPrivate == true) {
    var i = new z({
      name: b.curveName
    });
    var v = i.getEncodedHex();
    var h = B(b);
    var t = h.getEncodedHex();
    var p = "";
    p += hextopem(v, "EC PARAMETERS");
    p += hextopem(t, "EC PRIVATE KEY");
    return p
  }
  if (D == "PKCS1PRV" && u !== undefined && b instanceof u && (y === undefined || y == null) && b.isPrivate == true) {
    var E = x(b);
    var w = E.getEncodedHex();
    return hextopem(w, "DSA PRIVATE KEY")
  }
  if (D == "PKCS5PRV" && n !== undefined && b instanceof n && (y !== undefined && y != null) && b.isPrivate == true) {
    var E = A(b);
    var w = E.getEncodedHex();
    if (m === undefined) {
      m = "DES-EDE3-CBC"
    }
    return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA", w, y, m, j)
  }
  if (D == "PKCS5PRV" && r !== undefined && b instanceof r && (y !== undefined && y != null) && b.isPrivate == true) {
    var E = B(b);
    var w = E.getEncodedHex();
    if (m === undefined) {
      m = "DES-EDE3-CBC"
    }
    return this.getEncryptedPKCS5PEMFromPrvKeyHex("EC", w, y, m, j)
  }
  if (D == "PKCS5PRV" && u !== undefined && b instanceof u && (y !== undefined && y != null) && b.isPrivate == true) {
    var E = x(b);
    var w = E.getEncodedHex();
    if (m === undefined) {
      m = "DES-EDE3-CBC"
    }
    return this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA", w, y, m, j)
  }
  var o = function (G, s) {
    var I = c(G, s);
    var H = new l({
      seq: [{
        seq: [{
          oid: {
            name: "pkcs5PBES2"
          }
        }, {
          seq: [{
            seq: [{
              oid: {
                name: "pkcs5PBKDF2"
              }
            }, {
              seq: [{
                octstr: {
                  hex: I.pbkdf2Salt
                }
              }, {
                "int": I.pbkdf2Iter
              }]
            }]
          }, {
            seq: [{
              oid: {
                name: "des-EDE3-CBC"
              }
            }, {
              octstr: {
                hex: I.encryptionSchemeIV
              }
            }]
          }]
        }]
      }, {
        octstr: {
          hex: I.ciphertext
        }
      }]
    });
    return H.getEncodedHex()
  };
  var c = function (N, O) {
    var H = 100;
    var M = CryptoJS.lib.WordArray.random(8);
    var L = "DES-EDE3-CBC";
    var s = CryptoJS.lib.WordArray.random(8);
    var I = CryptoJS.PBKDF2(O, M, {
      keySize: 192 / 32,
      iterations: H
    });
    var J = CryptoJS.enc.Hex.parse(N);
    var K = CryptoJS.TripleDES.encrypt(J, I, {
      iv: s
    }) + "";
    var G = {};
    G.ciphertext = K;
    G.pbkdf2Salt = CryptoJS.enc.Hex.stringify(M);
    G.pbkdf2Iter = H;
    G.encryptionSchemeAlg = L;
    G.encryptionSchemeIV = CryptoJS.enc.Hex.stringify(s);
    return G
  };
  if (D == "PKCS8PRV" && n != undefined && b instanceof n && b.isPrivate == true) {
    var g = A(b);
    var d = g.getEncodedHex();
    var E = l({
      seq: [{
        "int": 0
      }, {
        seq: [{
          oid: {
            name: "rsaEncryption"
          }
        }, {
          "null": true
        }]
      }, {
        octstr: {
          hex: d
        }
      }]
    });
    var w = E.getEncodedHex();
    if (y === undefined || y == null) {
      return hextopem(w, "PRIVATE KEY")
    } else {
      var t = o(w, y);
      return hextopem(t, "ENCRYPTED PRIVATE KEY")
    }
  }
  if (D == "PKCS8PRV" && r !== undefined && b instanceof r && b.isPrivate == true) {
    var g = new l({
      seq: [{
        "int": 1
      }, {
        octstr: {
          hex: b.prvKeyHex
        }
      }, {
        tag: ["a1", true, {
          bitstr: {
            hex: "00" + b.pubKeyHex
          }
        }]
      }]
    });
    var d = g.getEncodedHex();
    var E = l({
      seq: [{
        "int": 0
      }, {
        seq: [{
          oid: {
            name: "ecPublicKey"
          }
        }, {
          oid: {
            name: b.curveName
          }
        }]
      }, {
        octstr: {
          hex: d
        }
      }]
    });
    var w = E.getEncodedHex();
    if (y === undefined || y == null) {
      return hextopem(w, "PRIVATE KEY")
    } else {
      var t = o(w, y);
      return hextopem(t, "ENCRYPTED PRIVATE KEY")
    }
  }
  if (D == "PKCS8PRV" && u !== undefined && b instanceof u && b.isPrivate == true) {
    var g = new f({
      bigint: b.x
    });
    var d = g.getEncodedHex();
    var E = l({
      seq: [{
        "int": 0
      }, {
        seq: [{
          oid: {
            name: "dsa"
          }
        }, {
          seq: [{
            "int": {
              bigint: b.p
            }
          }, {
            "int": {
              bigint: b.q
            }
          }, {
            "int": {
              bigint: b.g
            }
          }]
        }]
      }, {
        octstr: {
          hex: d
        }
      }]
    });
    var w = E.getEncodedHex();
    if (y === undefined || y == null) {
      return hextopem(w, "PRIVATE KEY")
    } else {
      var t = o(w, y);
      return hextopem(t, "ENCRYPTED PRIVATE KEY")
    }
  }
  throw "unsupported object nor format"
};
KEYUTIL.getKeyFromCSRPEM = function (b) {
  var a = pemtohex(b, "CERTIFICATE REQUEST");
  var c = KEYUTIL.getKeyFromCSRHex(a);
  return c
};
KEYUTIL.getKeyFromCSRHex = function (a) {
  var c = KEYUTIL.parseCSRHex(a);
  var b = KEYUTIL.getKey(c.p8pubkeyhex, null, "pkcs8pub");
  return b
};
KEYUTIL.parseCSRHex = function (d) {
  var i = ASN1HEX;
  var f = i.getChildIdx;
  var c = i.getTLV;
  var b = {};
  var g = d;
  if (g.substr(0, 2) != "30") {
    throw "malformed CSR(code:001)"
  }
  var e = f(g, 0);
  if (e.length < 1) {
    throw "malformed CSR(code:002)"
  }
  if (g.substr(e[0], 2) != "30") {
    throw "malformed CSR(code:003)"
  }
  var a = f(g, e[0]);
  if (a.length < 3) {
    throw "malformed CSR(code:004)"
  }
  b.p8pubkeyhex = c(g, a[2]);
  return b
};
KEYUTIL.getKeyID = function (f) {
  var c = KEYUTIL;
  var e = ASN1HEX;
  if (typeof f === "string" && f.indexOf("BEGIN ") != -1) {
    f = c.getKey(f)
  }
  var d = pemtohex(c.getPEM(f));
  var b = e.getIdxbyList(d, 0, [1]);
  var a = e.getV(d, b).substring(2);
  return KJUR.crypto.Util.hashHex(a, "sha1")
};
KEYUTIL.getJWKFromKey = function (d) {
  var b = {};
  if (d instanceof RSAKey && d.isPrivate) {
    b.kty = "RSA";
    b.n = hextob64u(d.n.toString(16));
    b.e = hextob64u(d.e.toString(16));
    b.d = hextob64u(d.d.toString(16));
    b.p = hextob64u(d.p.toString(16));
    b.q = hextob64u(d.q.toString(16));
    b.dp = hextob64u(d.dmp1.toString(16));
    b.dq = hextob64u(d.dmq1.toString(16));
    b.qi = hextob64u(d.coeff.toString(16));
    return b
  } else {
    if (d instanceof RSAKey && d.isPublic) {
      b.kty = "RSA";
      b.n = hextob64u(d.n.toString(16));
      b.e = hextob64u(d.e.toString(16));
      return b
    } else {
      if (d instanceof KJUR.crypto.ECDSA && d.isPrivate) {
        var a = d.getShortNISTPCurveName();
        if (a !== "P-256" && a !== "P-384") {
          throw "unsupported curve name for JWT: " + a
        }
        var c = d.getPublicKeyXYHex();
        b.kty = "EC";
        b.crv = a;
        b.x = hextob64u(c.x);
        b.y = hextob64u(c.y);
        b.d = hextob64u(d.prvKeyHex);
        return b
      } else {
        if (d instanceof KJUR.crypto.ECDSA && d.isPublic) {
          var a = d.getShortNISTPCurveName();
          if (a !== "P-256" && a !== "P-384") {
            throw "unsupported curve name for JWT: " + a
          }
          var c = d.getPublicKeyXYHex();
          b.kty = "EC";
          b.crv = a;
          b.x = hextob64u(c.x);
          b.y = hextob64u(c.y);
          return b
        }
      }
    }
  }
  throw "not supported key object"
};
RSAKey.getPosArrayOfChildrenFromHex = function (a) {
  return ASN1HEX.getChildIdx(a, 0)
};
RSAKey.getHexValueArrayOfChildrenFromHex = function (f) {
  var n = ASN1HEX;
  var i = n.getV;
  var k = RSAKey.getPosArrayOfChildrenFromHex(f);
  var e = i(f, k[0]);
  var j = i(f, k[1]);
  var b = i(f, k[2]);
  var c = i(f, k[3]);
  var h = i(f, k[4]);
  var g = i(f, k[5]);
  var m = i(f, k[6]);
  var l = i(f, k[7]);
  var d = i(f, k[8]);
  var k = new Array();
  k.push(e, j, b, c, h, g, m, l, d);
  return k
};
RSAKey.prototype.readPrivateKeyFromPEMString = function (d) {
  var c = pemtohex(d);
  var b = RSAKey.getHexValueArrayOfChildrenFromHex(c);
  this.setPrivateEx(b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8])
};
RSAKey.prototype.readPKCS5PrvKeyHex = function (c) {
  var b = RSAKey.getHexValueArrayOfChildrenFromHex(c);
  this.setPrivateEx(b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8])
};
RSAKey.prototype.readPKCS8PrvKeyHex = function (e) {
  var c, i, k, b, a, f, d, j;
  var m = ASN1HEX;
  var l = m.getVbyListEx;
  if (m.isASN1HEX(e) === false) {
    throw new Error("not ASN.1 hex string")
  }
  try {
    c = l(e, 0, [2, 0, 1], "02");
    i = l(e, 0, [2, 0, 2], "02");
    k = l(e, 0, [2, 0, 3], "02");
    b = l(e, 0, [2, 0, 4], "02");
    a = l(e, 0, [2, 0, 5], "02");
    f = l(e, 0, [2, 0, 6], "02");
    d = l(e, 0, [2, 0, 7], "02");
    j = l(e, 0, [2, 0, 8], "02")
  } catch (g) {
    throw new Error("malformed PKCS#8 plain RSA private key")
  }
  this.setPrivateEx(c, i, k, b, a, f, d, j)
};
RSAKey.prototype.readPKCS5PubKeyHex = function (c) {
  var e = ASN1HEX;
  var b = e.getV;
  if (e.isASN1HEX(c) === false) {
    throw "keyHex is not ASN.1 hex string"
  }
  var a = e.getChildIdx(c, 0);
  if (a.length !== 2 || c.substr(a[0], 2) !== "02" || c.substr(a[1], 2) !== "02") {
    throw "wrong hex for PKCS#5 public key"
  }
  var f = b(c, a[0]);
  var d = b(c, a[1]);
  this.setPublic(f, d)
};
RSAKey.prototype.readPKCS8PubKeyHex = function (b) {
  var c = ASN1HEX;
  if (c.isASN1HEX(b) === false) {
    throw new Error("not ASN.1 hex string")
  }
  if (c.getTLVbyListEx(b, 0, [0, 0]) !== "06092a864886f70d010101") {
    throw new Error("not PKCS8 RSA public key")
  }
  var a = c.getTLVbyListEx(b, 0, [1, 0]);
  this.readPKCS5PubKeyHex(a)
};
RSAKey.prototype.readCertPubKeyHex = function (b, d) {
  var a, c;
  a = new X509();
  a.readCertHex(b);
  c = a.getPublicKeyHex();
  this.readPKCS8PubKeyHex(c)
};
var _RE_HEXDECONLY = new RegExp("[^0-9a-f]", "gi");

function _rsasign_getHexPaddedDigestInfoForString(d, e, a) {
  var b = function (f) {
    return KJUR.crypto.Util.hashString(f, a)
  };
  var c = b(d);
  return KJUR.crypto.Util.getPaddedDigestInfoHex(c, a, e)
}

function _zeroPaddingOfSignature(e, d) {
  var c = "";
  var a = d / 4 - e.length;
  for (var b = 0; b < a; b++) {
    c = c + "0"
  }
  return c + e
}
RSAKey.prototype.sign = function (d, a) {
  var b = function (e) {
    return KJUR.crypto.Util.hashString(e, a)
  };
  var c = b(d);
  return this.signWithMessageHash(c, a)
};
RSAKey.prototype.signWithMessageHash = function (e, c) {
  var f = KJUR.crypto.Util.getPaddedDigestInfoHex(e, c, this.n.bitLength());
  var b = parseBigInt(f, 16);
  var d = this.doPrivate(b);
  var a = d.toString(16);
  return _zeroPaddingOfSignature(a, this.n.bitLength())
};

function pss_mgf1_str(c, a, e) {
  var b = "",
    d = 0;
  while (b.length < a) {
    b += hextorstr(e(rstrtohex(c + String.fromCharCode.apply(String, [(d & 4278190080) >> 24, (d & 16711680) >> 16, (d & 65280) >> 8, d & 255]))));
    d += 1
  }
  return b
}
RSAKey.prototype.signPSS = function (e, a, d) {
  var c = function (f) {
    return KJUR.crypto.Util.hashHex(f, a)
  };
  var b = c(rstrtohex(e));
  if (d === undefined) {
    d = -1
  }
  return this.signWithMessageHashPSS(b, a, d)
};
RSAKey.prototype.signWithMessageHashPSS = function (l, a, k) {
  var b = hextorstr(l);
  var g = b.length;
  var m = this.n.bitLength() - 1;
  var c = Math.ceil(m / 8);
  var d;
  var o = function (i) {
    return KJUR.crypto.Util.hashHex(i, a)
  };
  if (k === -1 || k === undefined) {
    k = g
  } else {
    if (k === -2) {
      k = c - g - 2
    } else {
      if (k < -2) {
        throw "invalid salt length"
      }
    }
  }
  if (c < (g + k + 2)) {
    throw "data too long"
  }
  var f = "";
  if (k > 0) {
    f = new Array(k);
    new SecureRandom().nextBytes(f);
    f = String.fromCharCode.apply(String, f)
  }
  var n = hextorstr(o(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00" + b + f)));
  var j = [];
  for (d = 0; d < c - k - g - 2; d += 1) {
    j[d] = 0
  }
  var e = String.fromCharCode.apply(String, j) + "\x01" + f;
  var h = pss_mgf1_str(n, e.length, o);
  var q = [];
  for (d = 0; d < e.length; d += 1) {
    q[d] = e.charCodeAt(d) ^ h.charCodeAt(d)
  }
  var p = (65280 >> (8 * c - m)) & 255;
  q[0] &= ~p;
  for (d = 0; d < g; d++) {
    q.push(n.charCodeAt(d))
  }
  q.push(188);
  return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16), this.n.bitLength())
};

function _rsasign_getDecryptSignatureBI(a, d, c) {
  var b = new RSAKey();
  b.setPublic(d, c);
  var e = b.doPublic(a);
  return e
}

function _rsasign_getHexDigestInfoFromSig(a, c, b) {
  var e = _rsasign_getDecryptSignatureBI(a, c, b);
  var d = e.toString(16).replace(/^1f+00/, "");
  return d
}

function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f) {
  for (var e in KJUR.crypto.Util.DIGESTINFOHEAD) {
    var d = KJUR.crypto.Util.DIGESTINFOHEAD[e];
    var b = d.length;
    if (f.substring(0, b) == d) {
      var c = [e, f.substring(b)];
      return c
    }
  }
  return []
}
RSAKey.prototype.verify = function (f, j) {
  j = j.replace(_RE_HEXDECONLY, "");
  j = j.replace(/[ \n]+/g, "");
  var b = parseBigInt(j, 16);
  if (b.bitLength() > this.n.bitLength()) {
    return 0
  }
  var i = this.doPublic(b);
  var e = i.toString(16).replace(/^1f+00/, "");
  var g = _rsasign_getAlgNameAndHashFromHexDisgestInfo(e);
  if (g.length == 0) {
    return false
  }
  var d = g[0];
  var h = g[1];
  var a = function (k) {
    return KJUR.crypto.Util.hashString(k, d)
  };
  var c = a(f);
  return (h == c)
};
RSAKey.prototype.verifyWithMessageHash = function (e, a) {
  if (a.length != Math.ceil(this.n.bitLength() / 4)) {
    return false
  }
  var b = parseBigInt(a, 16);
  if (b.bitLength() > this.n.bitLength()) {
    return 0
  }
  var h = this.doPublic(b);
  var g = h.toString(16).replace(/^1f+00/, "");
  var c = _rsasign_getAlgNameAndHashFromHexDisgestInfo(g);
  if (c.length == 0) {
    return false
  }
  var d = c[0];
  var f = c[1];
  return (f == e)
};
RSAKey.prototype.verifyPSS = function (c, b, a, f) {
  var e = function (g) {
    return KJUR.crypto.Util.hashHex(g, a)
  };
  var d = e(rstrtohex(c));
  if (f === undefined) {
    f = -1
  }
  return this.verifyWithMessageHashPSS(d, b, a, f)
};
RSAKey.prototype.verifyWithMessageHashPSS = function (f, s, l, c) {
  if (s.length != Math.ceil(this.n.bitLength() / 4)) {
    return false
  }
  var k = new BigInteger(s, 16);
  var r = function (i) {
    return KJUR.crypto.Util.hashHex(i, l)
  };
  var j = hextorstr(f);
  var h = j.length;
  var g = this.n.bitLength() - 1;
  var m = Math.ceil(g / 8);
  var q;
  if (c === -1 || c === undefined) {
    c = h
  } else {
    if (c === -2) {
      c = m - h - 2
    } else {
      if (c < -2) {
        throw "invalid salt length"
      }
    }
  }
  if (m < (h + c + 2)) {
    throw "data too long"
  }
  var a = this.doPublic(k).toByteArray();
  for (q = 0; q < a.length; q += 1) {
    a[q] &= 255
  }
  while (a.length < m) {
    a.unshift(0)
  }
  if (a[m - 1] !== 188) {
    throw "encoded message does not end in 0xbc"
  }
  a = String.fromCharCode.apply(String, a);
  var d = a.substr(0, m - h - 1);
  var e = a.substr(d.length, h);
  var p = (65280 >> (8 * m - g)) & 255;
  if ((d.charCodeAt(0) & p) !== 0) {
    throw "bits beyond keysize not zero"
  }
  var n = pss_mgf1_str(e, d.length, r);
  var o = [];
  for (q = 0; q < d.length; q += 1) {
    o[q] = d.charCodeAt(q) ^ n.charCodeAt(q)
  }
  o[0] &= ~p;
  var b = m - h - c - 2;
  for (q = 0; q < b; q += 1) {
    if (o[q] !== 0) {
      throw "leftmost octets not zero"
    }
  }
  if (o[b] !== 1) {
    throw "0x01 marker not found"
  }
  return e === hextorstr(r(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00" + j + String.fromCharCode.apply(String, o.slice(-c)))))
};
RSAKey.SALT_LEN_HLEN = -1;
RSAKey.SALT_LEN_MAX = -2;
RSAKey.SALT_LEN_RECOVER = -2;

function X509() {
  var o = ASN1HEX,
    m = o.getChildIdx,
    k = o.getV,
    b = o.getTLV,
    h = o.getVbyList,
    n = o.getVbyListEx,
    c = o.getTLVbyList,
    e = o.getTLVbyListEx,
    i = o.getIdxbyList,
    d = o.getVidx,
    l = o.oidname,
    a = X509,
    g = pemtohex,
    f;
  try {
    f = KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV
  } catch (j) {}
  this.hex = null;
  this.version = 0;
  this.foffset = 0;
  this.aExtInfo = null;
  this.getVersion = function () {
    if (this.hex === null || this.version !== 0) {
      return this.version
    }
    if (c(this.hex, 0, [0, 0]) !== "a003020102") {
      this.version = 1;
      this.foffset = -1;
      return 1
    }
    this.version = 3;
    return 3
  };
  this.getSerialNumberHex = function () {
    return h(this.hex, 0, [0, 1 + this.foffset], "02")
  };
  this.getSignatureAlgorithmField = function () {
    var q = null;
    var p = e(this.hex, 0, [0, 1]);
    for (var r in f) {
      if (p === f[r]) {
        return r
      }
    }
    return l(n(this.hex, 0, [0, 1, 0], "06"))
  };
  this.getIssuerHex = function () {
    return c(this.hex, 0, [0, 3 + this.foffset], "30")
  };
  this.getIssuerString = function () {
    return a.hex2dn(this.getIssuerHex())
  };
  this.getSubjectHex = function () {
    return c(this.hex, 0, [0, 5 + this.foffset], "30")
  };
  this.getSubjectString = function () {
    return a.hex2dn(this.getSubjectHex())
  };
  this.getNotBefore = function () {
    var p = h(this.hex, 0, [0, 4 + this.foffset, 0]);
    p = p.replace(/(..)/g, "%$1");
    p = decodeURIComponent(p);
    return p
  };
  this.getNotAfter = function () {
    var p = h(this.hex, 0, [0, 4 + this.foffset, 1]);
    p = p.replace(/(..)/g, "%$1");
    p = decodeURIComponent(p);
    return p
  };
  this.getPublicKeyHex = function () {
    return o.getTLVbyList(this.hex, 0, [0, 6 + this.foffset], "30")
  };
  this.getPublicKeyIdx = function () {
    return i(this.hex, 0, [0, 6 + this.foffset], "30")
  };
  this.getPublicKeyContentIdx = function () {
    var p = this.getPublicKeyIdx();
    return i(this.hex, p, [1, 0], "30")
  };
  this.getPublicKey = function () {
    return KEYUTIL.getKey(this.getPublicKeyHex(), null, "pkcs8pub")
  };
  this.getSignatureAlgorithmName = function () {
    return l(h(this.hex, 0, [1, 0], "06"))
  };
  this.getSignatureValueHex = function () {
    return h(this.hex, 0, [2], "03", true)
  };
  this.verifySignature = function (r) {
    var s = this.getSignatureAlgorithmField();
    var p = this.getSignatureValueHex();
    var q = c(this.hex, 0, [0], "30");
    var t = new KJUR.crypto.Signature({
      alg: s
    });
    t.init(r);
    t.updateHex(q);
    return t.verify(p)
  };
  this.parseExt = function (y) {
    var r, p, t;
    if (y === undefined) {
      t = this.hex;
      if (this.version !== 3) {
        return -1
      }
      r = i(t, 0, [0, 7, 0], "30");
      p = m(t, r)
    } else {
      t = pemtohex(y);
      var u = i(t, 0, [0, 3, 0, 0], "06");
      if (k(t, u) != "2a864886f70d01090e") {
        this.aExtInfo = new Array();
        return
      }
      r = i(t, 0, [0, 3, 0, 1, 0], "30");
      p = m(t, r);
      this.hex = t
    }
    this.aExtInfo = new Array();
    for (var s = 0; s < p.length; s++) {
      var w = {};
      w.critical = false;
      var v = m(t, p[s]);
      var q = 0;
      if (v.length === 3) {
        w.critical = true;
        q = 1
      }
      w.oid = o.hextooidstr(h(t, p[s], [0], "06"));
      var x = i(t, p[s], [1 + q]);
      w.vidx = d(t, x);
      this.aExtInfo.push(w)
    }
  };
  this.getExtInfo = function (r) {
    var p = this.aExtInfo;
    var s = r;
    if (!r.match(/^[0-9.]+$/)) {
      s = KJUR.asn1.x509.OID.name2oid(r)
    }
    if (s === "") {
      return undefined
    }
    for (var q = 0; q < p.length; q++) {
      if (p[q].oid === s) {
        return p[q]
      }
    }
    return undefined
  };
  this.getExtBasicConstraints = function () {
    var r = this.getExtInfo("basicConstraints");
    if (r === undefined) {
      return r
    }
    var p = k(this.hex, r.vidx);
    if (p === "") {
      return {}
    }
    if (p === "0101ff") {
      return {
        cA: true
      }
    }
    if (p.substr(0, 8) === "0101ff02") {
      var s = k(p, 6);
      var q = parseInt(s, 16);
      return {
        cA: true,
        pathLen: q
      }
    }
    throw "basicConstraints parse error"
  };
  this.getExtKeyUsageBin = function () {
    var s = this.getExtInfo("keyUsage");
    if (s === undefined) {
      return ""
    }
    var q = k(this.hex, s.vidx);
    if (q.length % 2 != 0 || q.length <= 2) {
      throw new Error("malformed key usage value")
    }
    var p = parseInt(q.substr(0, 2));
    var r = parseInt(q.substr(2), 16).toString(2);
    r = ("0000000" + r).slice(-8);
    return r.substr(0, r.length - p)
  };
  this.getExtKeyUsageString = function () {
    var r = this.getExtKeyUsageBin();
    var p = new Array();
    for (var q = 0; q < r.length; q++) {
      if (r.substr(q, 1) == "1") {
        p.push(X509.KEYUSAGE_NAME[q])
      }
    }
    return p.join(",")
  };
  this.getExtSubjectKeyIdentifier = function () {
    var p = this.getExtInfo("subjectKeyIdentifier");
    if (p === undefined) {
      return p
    }
    return k(this.hex, p.vidx)
  };
  this.getExtAuthorityKeyIdentifier = function () {
    var t = this.getExtInfo("authorityKeyIdentifier");
    if (t === undefined) {
      return t
    }
    var p = {};
    var s = b(this.hex, t.vidx);
    var q = m(s, 0);
    for (var r = 0; r < q.length; r++) {
      if (s.substr(q[r], 2) === "80") {
        p.kid = k(s, q[r])
      }
    }
    return p
  };
  this.getExtExtKeyUsageName = function () {
    var t = this.getExtInfo("extKeyUsage");
    if (t === undefined) {
      return t
    }
    var p = new Array();
    var s = b(this.hex, t.vidx);
    if (s === "") {
      return p
    }
    var q = m(s, 0);
    for (var r = 0; r < q.length; r++) {
      p.push(l(k(s, q[r])))
    }
    return p
  };
  this.getExtSubjectAltName = function () {
    var q = this.getExtSubjectAltName2();
    var p = new Array();
    for (var r = 0; r < q.length; r++) {
      if (q[r][0] === "DNS") {
        p.push(q[r][1])
      }
    }
    return p
  };
  this.getExtSubjectAltName2 = function () {
    var t, w, v;
    var u = this.getExtInfo("subjectAltName");
    if (u === undefined) {
      return u
    }
    var p = new Array();
    var s = b(this.hex, u.vidx);
    var q = m(s, 0);
    for (var r = 0; r < q.length; r++) {
      v = s.substr(q[r], 2);
      t = k(s, q[r]);
      if (v === "81") {
        w = hextoutf8(t);
        p.push(["MAIL", w])
      }
      if (v === "82") {
        w = hextoutf8(t);
        p.push(["DNS", w])
      }
      if (v === "84") {
        w = X509.hex2dn(t, 0);
        p.push(["DN", w])
      }
      if (v === "86") {
        w = hextoutf8(t);
        p.push(["URI", w])
      }
      if (v === "87") {
        w = hextoip(t);
        p.push(["IP", w])
      }
    }
    return p
  };
  this.getExtCRLDistributionPointsURI = function () {
    var u = this.getExtInfo("cRLDistributionPoints");
    if (u === undefined) {
      return u
    }
    var p = new Array();
    var q = m(this.hex, u.vidx);
    for (var s = 0; s < q.length; s++) {
      try {
        var v = h(this.hex, q[s], [0, 0, 0], "86");
        var t = hextoutf8(v);
        p.push(t)
      } catch (r) {}
    }
    return p
  };
  this.getExtAIAInfo = function () {
    var t = this.getExtInfo("authorityInfoAccess");
    if (t === undefined) {
      return t
    }
    var p = {
      ocsp: [],
      caissuer: []
    };
    var q = m(this.hex, t.vidx);
    for (var r = 0; r < q.length; r++) {
      var u = h(this.hex, q[r], [0], "06");
      var s = h(this.hex, q[r], [1], "86");
      if (u === "2b06010505073001") {
        p.ocsp.push(hextoutf8(s))
      }
      if (u === "2b06010505073002") {
        p.caissuer.push(hextoutf8(s))
      }
    }
    return p
  };
  this.getExtCertificatePolicies = function () {
    var s = this.getExtInfo("certificatePolicies");
    if (s === undefined) {
      return s
    }
    var p = b(this.hex, s.vidx);
    var y = [];
    var w = m(p, 0);
    for (var v = 0; v < w.length; v++) {
      var x = {};
      var r = m(p, w[v]);
      x.id = l(k(p, r[0]));
      if (r.length === 2) {
        var q = m(p, r[1]);
        for (var u = 0; u < q.length; u++) {
          var t = h(p, q[u], [0], "06");
          if (t === "2b06010505070201") {
            x.cps = hextoutf8(h(p, q[u], [1]))
          } else {
            if (t === "2b06010505070202") {
              x.unotice = hextoutf8(h(p, q[u], [1, 0]))
            }
          }
        }
      }
      y.push(x)
    }
    return y
  };
  this.readCertPEM = function (p) {
    this.readCertHex(g(p))
  };
  this.readCertHex = function (p) {
    this.hex = p;
    this.getVersion();
    try {
      i(this.hex, 0, [0, 7], "a3");
      this.parseExt()
    } catch (q) {}
  };
  this.getInfo = function () {
    var q = X509;
    var F, y, D;
    F = "Basic Fields\n";
    F += "  serial number: " + this.getSerialNumberHex() + "\n";
    F += "  signature algorithm: " + this.getSignatureAlgorithmField() + "\n";
    F += "  issuer: " + this.getIssuerString() + "\n";
    F += "  notBefore: " + this.getNotBefore() + "\n";
    F += "  notAfter: " + this.getNotAfter() + "\n";
    F += "  subject: " + this.getSubjectString() + "\n";
    F += "  subject public key info: \n";
    y = this.getPublicKey();
    F += "    key algorithm: " + y.type + "\n";
    if (y.type === "RSA") {
      F += "    n=" + hextoposhex(y.n.toString(16)).substr(0, 16) + "...\n";
      F += "    e=" + hextoposhex(y.e.toString(16)) + "\n"
    }
    D = this.aExtInfo;
    if (D !== undefined && D !== null) {
      F += "X509v3 Extensions:\n";
      for (var w = 0; w < D.length; w++) {
        var r = D[w];
        var E = KJUR.asn1.x509.OID.oid2name(r.oid);
        if (E === "") {
          E = r.oid
        }
        var B = "";
        if (r.critical === true) {
          B = "CRITICAL"
        }
        F += "  " + E + " " + B + ":\n";
        if (E === "basicConstraints") {
          var z = this.getExtBasicConstraints();
          if (z.cA === undefined) {
            F += "    {}\n"
          } else {
            F += "    cA=true";
            if (z.pathLen !== undefined) {
              F += ", pathLen=" + z.pathLen
            }
            F += "\n"
          }
        } else {
          if (E === "keyUsage") {
            F += "    " + this.getExtKeyUsageString() + "\n"
          } else {
            if (E === "subjectKeyIdentifier") {
              F += "    " + this.getExtSubjectKeyIdentifier() + "\n"
            } else {
              if (E === "authorityKeyIdentifier") {
                var p = this.getExtAuthorityKeyIdentifier();
                if (p.kid !== undefined) {
                  F += "    kid=" + p.kid + "\n"
                }
              } else {
                if (E === "extKeyUsage") {
                  var A = this.getExtExtKeyUsageName();
                  F += "    " + A.join(", ") + "\n"
                } else {
                  if (E === "subjectAltName") {
                    var x = this.getExtSubjectAltName2();
                    F += "    " + x + "\n"
                  } else {
                    if (E === "cRLDistributionPoints") {
                      var C = this.getExtCRLDistributionPointsURI();
                      F += "    " + C + "\n"
                    } else {
                      if (E === "authorityInfoAccess") {
                        var u = this.getExtAIAInfo();
                        if (u.ocsp !== undefined) {
                          F += "    ocsp: " + u.ocsp.join(",") + "\n"
                        }
                        if (u.caissuer !== undefined) {
                          F += "    caissuer: " + u.caissuer.join(",") + "\n"
                        }
                      } else {
                        if (E === "certificatePolicies") {
                          var t = this.getExtCertificatePolicies();
                          for (var v = 0; v < t.length; v++) {
                            if (t[v].id !== undefined) {
                              F += "    policy oid: " + t[v].id + "\n"
                            }
                            if (t[v].cps !== undefined) {
                              F += "    cps: " + t[v].cps + "\n"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    F += "signature algorithm: " + this.getSignatureAlgorithmName() + "\n";
    F += "signature: " + this.getSignatureValueHex().substr(0, 16) + "...\n";
    return F
  }
}
X509.hex2dn = function (f, b) {
  if (b === undefined) {
    b = 0
  }
  if (f.substr(b, 2) !== "30") {
    throw "malformed DN"
  }
  var c = new Array();
  var d = ASN1HEX.getChildIdx(f, b);
  for (var e = 0; e < d.length; e++) {
    c.push(X509.hex2rdn(f, d[e]))
  }
  c = c.map(function (a) {
    return a.replace("/", "\\/")
  });
  return "/" + c.join("/")
};
X509.hex2rdn = function (f, b) {
  if (b === undefined) {
    b = 0
  }
  if (f.substr(b, 2) !== "31") {
    throw "malformed RDN"
  }
  var c = new Array();
  var d = ASN1HEX.getChildIdx(f, b);
  for (var e = 0; e < d.length; e++) {
    c.push(X509.hex2attrTypeValue(f, d[e]))
  }
  c = c.map(function (a) {
    return a.replace("+", "\\+")
  });
  return c.join("+")
};
X509.hex2attrTypeValue = function (d, i) {
  var j = ASN1HEX;
  var h = j.getV;
  if (i === undefined) {
    i = 0
  }
  if (d.substr(i, 2) !== "30") {
    throw "malformed attribute type and value"
  }
  var g = j.getChildIdx(d, i);
  if (g.length !== 2 || d.substr(g[0], 2) !== "06") {
    "malformed attribute type and value"
  }
  var b = h(d, g[0]);
  var f = KJUR.asn1.ASN1Util.oidHexToInt(b);
  var e = KJUR.asn1.x509.OID.oid2atype(f);
  var a = h(d, g[1]);
  var c = hextorstr(a);
  return e + "=" + c
};
X509.getPublicKeyFromCertHex = function (b) {
  var a = new X509();
  a.readCertHex(b);
  return a.getPublicKey()
};
X509.getPublicKeyFromCertPEM = function (b) {
  var a = new X509();
  a.readCertPEM(b);
  return a.getPublicKey()
};
X509.getPublicKeyInfoPropOfCertPEM = function (c) {
  var e = ASN1HEX;
  var g = e.getVbyList;
  var b = {};
  var a, f, d;
  b.algparam = null;
  a = new X509();
  a.readCertPEM(c);
  f = a.getPublicKeyHex();
  b.keyhex = g(f, 0, [1], "03").substr(2);
  b.algoid = g(f, 0, [0, 0], "06");
  if (b.algoid === "2a8648ce3d0201") {
    b.algparam = g(f, 0, [0, 1], "06")
  }
  return b
};
X509.KEYUSAGE_NAME = ["digitalSignature", "nonRepudiation", "keyEncipherment", "dataEncipherment", "keyAgreement", "keyCertSign", "cRLSign", "encipherOnly", "decipherOnly"];
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.jws == "undefined" || !KJUR.jws) {
  KJUR.jws = {}
}
KJUR.jws.JWS = function () {
  var b = KJUR,
    a = b.jws.JWS,
    c = a.isSafeJSONString;
  this.parseJWS = function (g, j) {
    if ((this.parsedJWS !== undefined) && (j || (this.parsedJWS.sigvalH !== undefined))) {
      return
    }
    var i = g.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);
    if (i == null) {
      throw "JWS signature is not a form of 'Head.Payload.SigValue'."
    }
    var k = i[1];
    var e = i[2];
    var l = i[3];
    var n = k + "." + e;
    this.parsedJWS = {};
    this.parsedJWS.headB64U = k;
    this.parsedJWS.payloadB64U = e;
    this.parsedJWS.sigvalB64U = l;
    this.parsedJWS.si = n;
    if (!j) {
      var h = b64utohex(l);
      var f = parseBigInt(h, 16);
      this.parsedJWS.sigvalH = h;
      this.parsedJWS.sigvalBI = f
    }
    var d = b64utoutf8(k);
    var m = b64utoutf8(e);
    this.parsedJWS.headS = d;
    this.parsedJWS.payloadS = m;
    if (!c(d, this.parsedJWS, "headP")) {
      throw "malformed JSON string for JWS Head: " + d
    }
  }
};
KJUR.jws.JWS.sign = function (j, w, z, A, a) {
  var x = KJUR,
    n = x.jws,
    r = n.JWS,
    h = r.readSafeJSONString,
    q = r.isSafeJSONString,
    d = x.crypto,
    l = d.ECDSA,
    p = d.Mac,
    c = d.Signature,
    u = JSON;
  var t, k, o;
  if (typeof w != "string" && typeof w != "object") {
    throw "spHeader must be JSON string or object: " + w
  }
  if (typeof w == "object") {
    k = w;
    t = u.stringify(k)
  }
  if (typeof w == "string") {
    t = w;
    if (!q(t)) {
      throw "JWS Head is not safe JSON string: " + t
    }
    k = h(t)
  }
  o = z;
  if (typeof z == "object") {
    o = u.stringify(z)
  }
  if ((j == "" || j == null) && k.alg !== undefined) {
    j = k.alg
  }
  if ((j != "" && j != null) && k.alg === undefined) {
    k.alg = j;
    t = u.stringify(k)
  }
  if (j !== k.alg) {
    throw "alg and sHeader.alg doesn't match: " + j + "!=" + k.alg
  }
  var s = null;
  if (r.jwsalg2sigalg[j] === undefined) {
    throw "unsupported alg name: " + j
  } else {
    s = r.jwsalg2sigalg[j]
  }
  var e = utf8tob64u(t);
  var m = utf8tob64u(o);
  var b = e + "." + m;
  var y = "";
  if (s.substr(0, 4) == "Hmac") {
    if (A === undefined) {
      throw "mac key shall be specified for HS* alg"
    }
    var i = new p({
      alg: s,
      prov: "cryptojs",
      pass: A
    });
    i.updateString(b);
    y = i.doFinal()
  } else {
    if (s.indexOf("withECDSA") != -1) {
      var f = new c({
        alg: s
      });
      f.init(A, a);
      f.updateString(b);
      var g = f.sign();
      y = KJUR.crypto.ECDSA.asn1SigToConcatSig(g)
    } else {
      if (s != "none") {
        var f = new c({
          alg: s
        });
        f.init(A, a);
        f.updateString(b);
        y = f.sign()
      }
    }
  }
  var v = hextob64u(y);
  return b + "." + v
};
KJUR.jws.JWS.verify = function (w, B, n) {
  var x = KJUR,
    q = x.jws,
    t = q.JWS,
    i = t.readSafeJSONString,
    e = x.crypto,
    p = e.ECDSA,
    s = e.Mac,
    d = e.Signature,
    m;
  if (typeof RSAKey !== undefined) {
    m = RSAKey
  }
  var y = w.split(".");
  if (y.length !== 3) {
    return false
  }
  var f = y[0];
  var r = y[1];
  var c = f + "." + r;
  var A = b64utohex(y[2]);
  var l = i(b64utoutf8(y[0]));
  var k = null;
  var z = null;
  if (l.alg === undefined) {
    throw "algorithm not specified in header"
  } else {
    k = l.alg;
    z = k.substr(0, 2)
  }
  if (n != null && Object.prototype.toString.call(n) === "[object Array]" && n.length > 0) {
    var b = ":" + n.join(":") + ":";
    if (b.indexOf(":" + k + ":") == -1) {
      throw "algorithm '" + k + "' not accepted in the list"
    }
  }
  if (k != "none" && B === null) {
    throw "key shall be specified to verify."
  }
  if (typeof B == "string" && B.indexOf("-----BEGIN ") != -1) {
    B = KEYUTIL.getKey(B)
  }
  if (z == "RS" || z == "PS") {
    if (!(B instanceof m)) {
      throw "key shall be a RSAKey obj for RS* and PS* algs"
    }
  }
  if (z == "ES") {
    if (!(B instanceof p)) {
      throw "key shall be a ECDSA obj for ES* algs"
    }
  }
  if (k == "none") {}
  var u = null;
  if (t.jwsalg2sigalg[l.alg] === undefined) {
    throw "unsupported alg name: " + k
  } else {
    u = t.jwsalg2sigalg[k]
  }
  if (u == "none") {
    throw "not supported"
  } else {
    if (u.substr(0, 4) == "Hmac") {
      var o = null;
      if (B === undefined) {
        throw "hexadecimal key shall be specified for HMAC"
      }
      var j = new s({
        alg: u,
        pass: B
      });
      j.updateString(c);
      o = j.doFinal();
      return A == o
    } else {
      if (u.indexOf("withECDSA") != -1) {
        var h = null;
        try {
          h = p.concatSigToASN1Sig(A)
        } catch (v) {
          return false
        }
        var g = new d({
          alg: u
        });
        g.init(B);
        g.updateString(c);
        return g.verify(h)
      } else {
        var g = new d({
          alg: u
        });
        g.init(B);
        g.updateString(c);
        return g.verify(A)
      }
    }
  }
};
KJUR.jws.JWS.parse = function (g) {
  var c = g.split(".");
  var b = {};
  var f, e, d;
  if (c.length != 2 && c.length != 3) {
    throw "malformed sJWS: wrong number of '.' splitted elements"
  }
  f = c[0];
  e = c[1];
  if (c.length == 3) {
    d = c[2]
  }
  b.headerObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(f));
  b.payloadObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(e));
  b.headerPP = JSON.stringify(b.headerObj, null, "  ");
  if (b.payloadObj == null) {
    b.payloadPP = b64utoutf8(e)
  } else {
    b.payloadPP = JSON.stringify(b.payloadObj, null, "  ")
  }
  if (d !== undefined) {
    b.sigHex = b64utohex(d)
  }
  return b
};
KJUR.jws.JWS.verifyJWT = function (e, l, r) {
  var d = KJUR,
    j = d.jws,
    o = j.JWS,
    n = o.readSafeJSONString,
    p = o.inArray,
    f = o.includedArray;
  var k = e.split(".");
  var c = k[0];
  var i = k[1];
  var q = c + "." + i;
  var m = b64utohex(k[2]);
  var h = n(b64utoutf8(c));
  var g = n(b64utoutf8(i));
  if (h.alg === undefined) {
    return false
  }
  if (r.alg === undefined) {
    throw "acceptField.alg shall be specified"
  }
  if (!p(h.alg, r.alg)) {
    return false
  }
  if (g.iss !== undefined && typeof r.iss === "object") {
    if (!p(g.iss, r.iss)) {
      return false
    }
  }
  if (g.sub !== undefined && typeof r.sub === "object") {
    if (!p(g.sub, r.sub)) {
      return false
    }
  }
  if (g.aud !== undefined && typeof r.aud === "object") {
    if (typeof g.aud == "string") {
      if (!p(g.aud, r.aud)) {
        return false
      }
    } else {
      if (typeof g.aud == "object") {
        if (!f(g.aud, r.aud)) {
          return false
        }
      }
    }
  }
  var b = j.IntDate.getNow();
  if (r.verifyAt !== undefined && typeof r.verifyAt === "number") {
    b = r.verifyAt
  }
  if (r.gracePeriod === undefined || typeof r.gracePeriod !== "number") {
    r.gracePeriod = 0
  }
  if (g.exp !== undefined && typeof g.exp == "number") {
    if (g.exp + r.gracePeriod < b) {
      return false
    }
  }
  if (g.nbf !== undefined && typeof g.nbf == "number") {
    if (b < g.nbf - r.gracePeriod) {
      return false
    }
  }
  if (g.iat !== undefined && typeof g.iat == "number") {
    if (b < g.iat - r.gracePeriod) {
      return false
    }
  }
  if (g.jti !== undefined && r.jti !== undefined) {
    if (g.jti !== r.jti) {
      return false
    }
  }
  if (!o.verify(e, l, r.alg)) {
    return false
  }
  return true
};
KJUR.jws.JWS.includedArray = function (b, a) {
  var c = KJUR.jws.JWS.inArray;
  if (b === null) {
    return false
  }
  if (typeof b !== "object") {
    return false
  }
  if (typeof b.length !== "number") {
    return false
  }
  for (var d = 0; d < b.length; d++) {
    if (!c(b[d], a)) {
      return false
    }
  }
  return true
};
KJUR.jws.JWS.inArray = function (d, b) {
  if (b === null) {
    return false
  }
  if (typeof b !== "object") {
    return false
  }
  if (typeof b.length !== "number") {
    return false
  }
  for (var c = 0; c < b.length; c++) {
    if (b[c] == d) {
      return true
    }
  }
  return false
};
KJUR.jws.JWS.jwsalg2sigalg = {
  HS256: "HmacSHA256",
  HS384: "HmacSHA384",
  HS512: "HmacSHA512",
  RS256: "SHA256withRSA",
  RS384: "SHA384withRSA",
  RS512: "SHA512withRSA",
  ES256: "SHA256withECDSA",
  ES384: "SHA384withECDSA",
  PS256: "SHA256withRSAandMGF1",
  PS384: "SHA384withRSAandMGF1",
  PS512: "SHA512withRSAandMGF1",
  none: "none",
};
KJUR.jws.JWS.isSafeJSONString = function (c, b, d) {
  var e = null;
  try {
    e = jsonParse(c);
    if (typeof e != "object") {
      return 0
    }
    if (e.constructor === Array) {
      return 0
    }
    if (b) {
      b[d] = e
    }
    return 1
  } catch (a) {
    return 0
  }
};
KJUR.jws.JWS.readSafeJSONString = function (b) {
  var c = null;
  try {
    c = jsonParse(b);
    if (typeof c != "object") {
      return null
    }
    if (c.constructor === Array) {
      return null
    }
    return c
  } catch (a) {
    return null
  }
};
KJUR.jws.JWS.getEncodedSignatureValueFromJWS = function (b) {
  var a = b.match(/^[^.]+\.[^.]+\.([^.]+)$/);
  if (a == null) {
    throw "JWS signature is not a form of 'Head.Payload.SigValue'."
  }
  return a[1]
};
KJUR.jws.JWS.getJWKthumbprint = function (d) {
  if (d.kty !== "RSA" && d.kty !== "EC" && d.kty !== "oct") {
    throw "unsupported algorithm for JWK Thumprint"
  }
  var a = "{";
  if (d.kty === "RSA") {
    if (typeof d.n != "string" || typeof d.e != "string") {
      throw "wrong n and e value for RSA key"
    }
    a += '"e":"' + d.e + '",';
    a += '"kty":"' + d.kty + '",';
    a += '"n":"' + d.n + '"}'
  } else {
    if (d.kty === "EC") {
      if (typeof d.crv != "string" || typeof d.x != "string" || typeof d.y != "string") {
        throw "wrong crv, x and y value for EC key"
      }
      a += '"crv":"' + d.crv + '",';
      a += '"kty":"' + d.kty + '",';
      a += '"x":"' + d.x + '",';
      a += '"y":"' + d.y + '"}'
    } else {
      if (d.kty === "oct") {
        if (typeof d.k != "string") {
          throw "wrong k value for oct(symmetric) key"
        }
        a += '"kty":"' + d.kty + '",';
        a += '"k":"' + d.k + '"}'
      }
    }
  }
  var b = rstrtohex(a);
  var c = KJUR.crypto.Util.hashHex(b, "sha256");
  var e = hextob64u(c);
  return e
};
KJUR.jws.IntDate = {};
KJUR.jws.IntDate.get = function (c) {
  var b = KJUR.jws.IntDate,
    d = b.getNow,
    a = b.getZulu;
  if (c == "now") {
    return d()
  } else {
    if (c == "now + 1hour") {
      return d() + 60 * 60
    } else {
      if (c == "now + 1day") {
        return d() + 60 * 60 * 24
      } else {
        if (c == "now + 1month") {
          return d() + 60 * 60 * 24 * 30
        } else {
          if (c == "now + 1year") {
            return d() + 60 * 60 * 24 * 365
          } else {
            if (c.match(/Z$/)) {
              return a(c)
            } else {
              if (c.match(/^[0-9]+$/)) {
                return parseInt(c)
              }
            }
          }
        }
      }
    }
  }
  throw "unsupported format: " + c
};
KJUR.jws.IntDate.getZulu = function (a) {
  return zulutosec(a)
};
KJUR.jws.IntDate.getNow = function () {
  var a = ~~(new Date() / 1000);
  return a
};
KJUR.jws.IntDate.intDate2UTCString = function (a) {
  var b = new Date(a * 1000);
  return b.toUTCString()
};
KJUR.jws.IntDate.intDate2Zulu = function (e) {
  var i = new Date(e * 1000),
    h = ("0000" + i.getUTCFullYear()).slice(-4),
    g = ("00" + (i.getUTCMonth() + 1)).slice(-2),
    b = ("00" + i.getUTCDate()).slice(-2),
    a = ("00" + i.getUTCHours()).slice(-2),
    c = ("00" + i.getUTCMinutes()).slice(-2),
    f = ("00" + i.getUTCSeconds()).slice(-2);
  return h + g + b + a + c + f + "Z"
};
if (typeof KJUR == "undefined" || !KJUR) {
  KJUR = {}
}
if (typeof KJUR.jws == "undefined" || !KJUR.jws) {
  KJUR.jws = {}
}
KJUR.jws.JWSJS = function () {
  var c = KJUR,
    b = c.jws,
    a = b.JWS,
    d = a.readSafeJSONString;
  this.aHeader = [];
  this.sPayload = "";
  this.aSignature = [];
  this.init = function () {
    this.aHeader = [];
    this.sPayload = undefined;
    this.aSignature = []
  };
  this.initWithJWS = function (f) {
    this.init();
    var e = f.split(".");
    if (e.length != 3) {
      throw "malformed input JWS"
    }
    this.aHeader.push(e[0]);
    this.sPayload = e[1];
    this.aSignature.push(e[2])
  };
  this.addSignature = function (e, h, m, k) {
    if (this.sPayload === undefined || this.sPayload === null) {
      throw "there's no JSON-JS signature to add."
    }
    var l = this.aHeader.length;
    if (this.aHeader.length != this.aSignature.length) {
      throw "aHeader.length != aSignature.length"
    }
    try {
      var f = KJUR.jws.JWS.sign(e, h, this.sPayload, m, k);
      var j = f.split(".");
      var n = j[0];
      var g = j[2];
      this.aHeader.push(j[0]);
      this.aSignature.push(j[2])
    } catch (i) {
      if (this.aHeader.length > l) {
        this.aHeader.pop()
      }
      if (this.aSignature.length > l) {
        this.aSignature.pop()
      }
      throw "addSignature failed: " + i
    }
  };
  this.verifyAll = function (h) {
    if (this.aHeader.length !== h.length || this.aSignature.length !== h.length) {
      return false
    }
    for (var g = 0; g < h.length; g++) {
      var f = h[g];
      if (f.length !== 2) {
        return false
      }
      var e = this.verifyNth(g, f[0], f[1]);
      if (e === false) {
        return false
      }
    }
    return true
  };
  this.verifyNth = function (f, j, g) {
    if (this.aHeader.length <= f || this.aSignature.length <= f) {
      return false
    }
    var h = this.aHeader[f];
    var k = this.aSignature[f];
    var l = h + "." + this.sPayload + "." + k;
    var e = false;
    try {
      e = a.verify(l, j, g)
    } catch (i) {
      return false
    }
    return e
  };
  this.readJWSJS = function (g) {
    if (typeof g === "string") {
      var f = d(g);
      if (f == null) {
        throw "argument is not safe JSON object string"
      }
      this.aHeader = f.headers;
      this.sPayload = f.payload;
      this.aSignature = f.signatures
    } else {
      try {
        if (g.headers.length > 0) {
          this.aHeader = g.headers
        } else {
          throw "malformed header"
        }
        if (typeof g.payload === "string") {
          this.sPayload = g.payload
        } else {
          throw "malformed signatures"
        }
        if (g.signatures.length > 0) {
          this.aSignature = g.signatures
        } else {
          throw "malformed signatures"
        }
      } catch (e) {
        throw "malformed JWS-JS JSON object: " + e
      }
    }
  };
  this.getJSON = function () {
    return {
      headers: this.aHeader,
      payload: this.sPayload,
      signatures: this.aSignature
    }
  };
  this.isEmpty = function () {
    if (this.aHeader.length == 0) {
      return 1
    }
    return 0
  }
};